<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>Golang中的interface</title>
    <meta name="description" content="Keep coding, Keep curiosity" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="https://smartkeyerror.com//Golang-interface" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/page2/" />

    <meta property="og:site_name" content="知其然, 知其所以然" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Golang中的interface" />
    <meta property="og:description" content="Keep coding, Keep curiosity" />
    <meta property="og:url" content="https://smartkeyerror.com//Golang-interface" />
    <meta property="og:image" content="/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Golang中的interface" />
    <meta name="twitter:description" content="Keep coding, Keep curiosity" />
    <meta name="twitter:url" content="https://smartkeyerror.com//Golang-interface" />
    <meta name="twitter:image:src" content="/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "知其然, 知其所以然",
    "name": "Golang中的interface",
    "url": "https://smartkeyerror.com//Golang-interface",
    "image": "/assets/images/cover1.jpg",
    "description": "Keep coding, Keep curiosity"
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="知其然, 知其所以然" href="/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/">Home</a></li>
        <li class="nav-archives " role="presentation"><a href="/archives">Archives</a></li>
        <li class="nav-about " role="presentation"><a href="/about">About</a></li>
    </ul>
<!--    <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>-->
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">Golang中的interface</h1>
            <section class="post-meta">
            <!-- <a href='/'></a> -->

            
                
                    <a href='/author/smartkeyerror'>smartkeyerror</a>
                
            
            <time class="post-date" datetime="2019-12-25">25 Dec 2019</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/tag/Golang'>Golang</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <p>Golang除了方便使用的协程以外，最令我感到惊讶的就是<code class="highlighter-rouge">interface</code>，接口。在其它语言中，接口承担的主要作用为解耦和协议，但是在Golang中，<code class="highlighter-rouge">interface</code>还作为一种”通用”类型广泛使用于标准库和第三方库中。</p>

<!---more--->

<h4 id="1-面向接口编程">1. 面向接口编程</h4>

<p>面向接口编程的核心就在于将接口和实现分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口编程而非面向实现编程，不依赖不稳定的实现细节，当实现发生变化时，上游系统可不做或者只需进行少量的修改，从而降低耦合性，提高拓展性。 换句话说，面向接口编程是一种可随时拔插替换的编程方法。</p>

<p>以图片存储服务为例，图片经过一系列的处理之后上传至阿里云OSS中保存。 以Java代码为例，为了代码复用，将其封装成一个类对外使用:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AliyunOssImageStore</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createBucketIfNotExist</span><span class="o">(</span><span class="n">string</span> <span class="n">bucketName</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="c1">// OSS通过bucket来划分整块OSS存储空间</span>
        <span class="c1">// 当所需要的bucket不存在时，进行创建，创建失败则抛出异常</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="n">String</span> <span class="nf">generateAccessToken</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 通过appKey以及appSecret生成access_token, 内部方法</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">uploadToOss</span><span class="o">(</span><span class="n">Image</span> <span class="n">image</span><span class="o">,</span> <span class="n">string</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 将图片上传至oss，返回图片URL地址</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 使用</span>
<span class="kd">class</span> <span class="nc">OssProcess</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">bucketName</span> <span class="o">=</span> <span class="s">"user_thumbnail_image"</span><span class="o">;</span>
        <span class="n">AliyunOssImageStore</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AliyunOssImageStore</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">createBucketIfNotExist</span><span class="o">(</span><span class="n">bucketName</span><span class="o">);</span>
        <span class="n">Image</span> <span class="n">image</span> <span class="o">=</span> <span class="o">...</span> <span class="c1">// 生成图片</span>
        <span class="n">store</span><span class="o">.</span><span class="na">uploadToOss</span><span class="o">(</span><span class="n">image</span><span class="o">,</span> <span class="n">bucketName</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">AliyunOssImageStore</code>就是一个具体的实现类，实现了将图片上传至阿里云OSS的功能，在绝大多数时候，代码都能完好的工作。现在由于采购部门不满阿里云的价格，想要更换图片存储供应商，比如七牛。现在开发人员需要添加<code class="highlighter-rouge">QiniuImageStore</code>，并替换掉原有的实现方式，如此一来，必将会涉及到大面积的代码改动，包括业务代码以及重新编写测试用例。</p>

<p>更换一个OSS服务就需要大面积的更改业务代码，违反了开放-封闭原则，从而引入了额外的工作量以及风险，上游系统直接依赖具体的实现是不妥当的，因为具体的实现很有可能发生变化，一旦发生变化，波及的范围可能是整个系统。</p>

<p>解决该问题的一种方式是添加代理类，即在业务代码和具体实现之间额外添加一层抽象，或者说函数，假设叫<code class="highlighter-rouge">imageStoreProxy</code>。业务代码调用<code class="highlighter-rouge">imageStoreProxy</code>方法，而该方法调用具体的OSS实现，当OSS实现发生变动时，只需修改<code class="highlighter-rouge">imageStoreProxy</code>一处即可。但是这么做的后果就是降低了系统的灵活性并增加了系统的复杂度，<code class="highlighter-rouge">imageStoreProxy</code>需要满足上游系统所有的需求，该方法到后期将会变得非常臃肿而难以维护，最可能出现的情况就是该方法存在乱七八糟的<code class="highlighter-rouge">if-else</code>。</p>

<p>一个更好的方式就是使用接口，上游系统依赖接口，具体实现根据接口定义的方法进行实现，并在运行时选择具体的实现。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ImageStore</span> <span class="o">{</span>
    <span class="n">String</span> <span class="nf">upload</span><span class="o">(</span><span class="n">Image</span> <span class="n">image</span><span class="o">,</span> <span class="n">String</span> <span class="n">bucket</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AliyunOssImageStore</span> <span class="kd">implements</span> <span class="n">ImageStore</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">upload</span><span class="o">(</span><span class="n">Image</span> <span class="n">image</span><span class="o">,</span> <span class="n">String</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 阿里云OSS的具体实现</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">QiniuImageStore</span> <span class="kd">implements</span> <span class="n">ImageStore</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">upload</span><span class="o">(</span><span class="n">Image</span> <span class="n">image</span><span class="o">,</span> <span class="n">String</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 七牛云的具体实现</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 使用</span>
<span class="kd">class</span> <span class="nc">OssProcess</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ImageStore</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AliyunOssImageStore</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">upload</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span> <span class="c1">// 使用阿里云OSS</span>
        
        <span class="n">ImageStore</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QiniuImageStore</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">upload</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span> <span class="c1">// 使用七牛云</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>合理的使用接口可以完全屏蔽具体的实现细节，当具体实现发生变化时，上游系统只需改动少量的代码即可适应该变化。 例如底层数据存储，MySQL与MongoDB在实现上完全不同，数据的CRUD有着非常大的区别，但是通过定义合理的接口，再根据接口封装MySQL与MongoDB的具体实现，上游系统则可以完全忽略其细节的区别，只关注自身的业务逻辑，从而实现耦合的解除。</p>

<p>常见ORM就是做的，例如Python中的<code class="highlighter-rouge">SQLAlchemy</code>，只需在配置文件或者是定义文件中进行少量的修改，即可实现底层数据存储应用的替换。</p>

<h4 id="2-作为接口定义的interface">2. 作为接口定义的interface</h4>

<p>Golang中的<code class="highlighter-rouge">interface</code>承担的主要作用之一就是解耦与多态，与Java中的接口没有什么区别，只是在语法格式上不同而已。Golang中的接口实现不需要显式地使用<code class="highlighter-rouge">implements</code>关键字，某个类型只需要实现了接口中的所有方法，就说该类型实现了该接口。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">OperationLog</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Timestamp</span><span class="x"> </span><span class="kt">int32</span><span class="x">    </span><span class="c">// 时间戳</span><span class="x">
	</span><span class="n">Operation</span><span class="x"> </span><span class="kt">string</span><span class="x">   </span><span class="c">// 操作类型, create/update/delete</span><span class="x">
	</span><span class="c">// Other need fields</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">OperationLogService</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">InsertOne</span><span class="p">(</span><span class="n">log</span><span class="x"> </span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x">      </span><span class="c">// 单个日志记录</span><span class="x">
	</span><span class="n">InsertMany</span><span class="p">(</span><span class="n">logs</span><span class="x"> </span><span class="p">[]</span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x">  </span><span class="c">// 批量日志记录</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">ElasticLogService</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">EsClient</span><span class="x"> </span><span class="o">*</span><span class="n">ElasticClient</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">svc</span><span class="x"> </span><span class="o">*</span><span class="n">ElasticLogService</span><span class="p">)</span><span class="x"> </span><span class="n">InsertOne</span><span class="p">(</span><span class="n">log</span><span class="x"> </span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">svc</span><span class="o">.</span><span class="n">EsClient</span><span class="o">.</span><span class="n">PostOne</span><span class="p">(</span><span class="c">/*参数省略*/</span><span class="p">)</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">svc</span><span class="x"> </span><span class="o">*</span><span class="n">ElasticLogService</span><span class="p">)</span><span class="x"> </span><span class="n">InsertMany</span><span class="p">(</span><span class="n">logs</span><span class="x"> </span><span class="p">[]</span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">svc</span><span class="o">.</span><span class="n">EsClient</span><span class="o">.</span><span class="n">PostMany</span><span class="p">(</span><span class="c">/*参数省略*/</span><span class="p">)</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">MySQLLogService</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Db</span><span class="x"> </span><span class="o">*</span><span class="n">MySQLClient</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">svc</span><span class="x"> </span><span class="o">*</span><span class="n">MySQLLogService</span><span class="p">)</span><span class="x"> </span><span class="n">InsertOne</span><span class="p">(</span><span class="n">log</span><span class="x"> </span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">svc</span><span class="o">.</span><span class="n">Db</span><span class="o">.</span><span class="n">InsertToLogTable</span><span class="p">(</span><span class="c">/*参数省略*/</span><span class="p">)</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">svc</span><span class="x"> </span><span class="o">*</span><span class="n">MySQLLogService</span><span class="p">)</span><span class="x"> </span><span class="n">InsertMany</span><span class="p">(</span><span class="n">logs</span><span class="x"> </span><span class="p">[]</span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">svc</span><span class="o">.</span><span class="n">Db</span><span class="o">.</span><span class="n">InsertManyToLogTable</span><span class="p">(</span><span class="c">/*参数省略*/</span><span class="p">)</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">var</span><span class="x"> </span><span class="n">logService</span><span class="x"> </span><span class="n">OperationLogService</span><span class="x">
	</span><span class="c">// 使用MySQL作为data storage</span><span class="x">
	</span><span class="n">logService</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">ElasticLogService</span><span class="p">{</span><span class="c">/*...*/</span><span class="p">}</span><span class="x">
	</span><span class="n">logService</span><span class="o">.</span><span class="n">InsertOne</span><span class="p">(</span><span class="c">/*...*/</span><span class="p">)</span><span class="x">

	</span><span class="c">// 使用ES作为data storage</span><span class="x">
	</span><span class="n">logService</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">MySQLLogService</span><span class="p">{</span><span class="c">/*...*/</span><span class="p">}</span><span class="x">
	</span><span class="n">logService</span><span class="o">.</span><span class="n">InsertOne</span><span class="p">(</span><span class="c">/*...*/</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>这是一个简单的操作日志服务demo，可以看到，操作日志具体的实现有Elasticsearch以及MySQL两种方式，而这两种DB对数据的CURD有着非常大的差异，前者使用http API，而后者则采用SQL语句。由于系统本身的复杂性既需要存储容量大、支持全局搜索但数据易失的ES，又需要存储容量有限、不支持全局搜索但数据持久化要求程度高的MySQL。</p>

<p>在有了接口对相关方法进行强约束以后，<code class="highlighter-rouge">ElasticLogService</code>以及<code class="highlighter-rouge">MySQLLogService</code>可以无差别的对外提供服务，需要切换服务时，只需进行非常小的改动即可满足需求。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/golang/interface/log_service.png" alt="" /></p>

<h4 id="3-作为类型的interface">3. 作为类型的interface</h4>

<p>当使用</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">MyInterface</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{}</span><span class="x">
</span></code></pre></div></div>

<p>时，我们定义了一个接口，当接口中不存在任何方法时，称之为empty interface，通常写做<code class="highlighter-rouge">interface{}</code>。由于Golang并没有显式的<code class="highlighter-rouge">implements</code>关键字，而所有的类型至少包含零个个方法，所以Golang中所有的类型都隐式地实现了<code class="highlighter-rouge">interface{}</code>，也就意味着，当我们定义如下方法时:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">DoSomething</span><span class="p">(</span><span class="n">v</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>函数将能够接收任意的数据类型，不管是<code class="highlighter-rouge">int</code>还是<code class="highlighter-rouge">int64</code>，或者是自定义的结构体。以內建函数<code class="highlighter-rouge">Printf</code>为例，其原型为:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">Printf</span><span class="p">(</span><span class="n">format</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">a</span><span class="x"> </span><span class="o">...</span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">(</span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>其中的<code class="highlighter-rouge">a</code>即为任意类型的任意数量的参数，如</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"human eat %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">food</span><span class="p">)</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"The T-shirt price is %.2f, %s"</span><span class="p">,</span><span class="x"> </span><span class="m">9.15</span><span class="p">,</span><span class="x"> </span><span class="s">"nine fifteen"</span><span class="p">)</span><span class="x">
</span></code></pre></div></div>

<p>回到<code class="highlighter-rouge">DoSomething</code>方法，在函数内部，<code class="highlighter-rouge">v</code>的类型是什么?假如传入的参数类型为<code class="highlighter-rouge">int</code>，<code class="highlighter-rouge">v</code>的类型是否就是<code class="highlighter-rouge">int</code>?答案是<code class="highlighter-rouge">interface{}</code>，不管传入的参数是什么类型，Go都会在必要时对其进行类型转换，转换成<code class="highlighter-rouge">interface{}</code>类型，而<code class="highlighter-rouge">interface{}</code>类型，是有值的。</p>

<p>接口的值分为两部分，一个指向底层方法表的指针，和指向保存着具体值的指针。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">MyInterface</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">PrintSelf</span><span class="p">()</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">MyInt</span><span class="x"> </span><span class="kt">int</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">this</span><span class="x"> </span><span class="n">MyInt</span><span class="p">)</span><span class="x"> </span><span class="n">PrintSelf</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"The value is: %d"</span><span class="p">,</span><span class="x"> </span><span class="n">this</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">s</span><span class="x"> </span><span class="n">MyInterface</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>此时<code class="highlighter-rouge">s</code>无具体的类型，也无具体的值，两个指针均指向nil:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/golang/interface/nil-interface.png" alt="" /></p>

<p>当执行:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">MyInt</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="x">
</span><span class="n">s</span><span class="o">.</span><span class="n">PrintSelf</span><span class="p">()</span><span class="x">
</span></code></pre></div></div>

<p>时, <code class="highlighter-rouge">s</code>拥了的具体的类型和确切的值:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/golang/interface/not%20nil%20interface.png" alt="" /></p>

<p>虽然<code class="highlighter-rouge">interface{}</code>作为参数时可以接收任何类型的参数，但是并不代表参数的类型是任意类型，变量在运行时的某一时刻，永远有一个具体的类型。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">DoSomething</span><span class="p">(</span><span class="n">v</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>在<code class="highlighter-rouge">DoSomething</code>方法内部，如果想要获取变量<code class="highlighter-rouge">v</code>的类型，可以使用类型分支(<code class="highlighter-rouge">switch-case</code>)来进行类型检查，也可以使用反射直接获取变量类型:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">DoSomething</span><span class="p">(</span><span class="n">v</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="c">// 使用类型分支</span><span class="x">
	</span><span class="k">switch</span><span class="x"> </span><span class="n">v</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">case</span><span class="x"> </span><span class="no">nil</span><span class="o">:</span><span class="x">
		</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"nil"</span><span class="p">)</span><span class="x">
	</span><span class="k">case</span><span class="x"> </span><span class="kt">string</span><span class="o">:</span><span class="x">
		</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"string"</span><span class="p">)</span><span class="x">
	</span><span class="k">case</span><span class="x"> </span><span class="kt">int</span><span class="o">:</span><span class="x">
		</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"int"</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	
	</span><span class="c">// 使用反射</span><span class="x">
	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"v'type is: %T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">v</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<h4 id="4-作为契约协议的interface">4. 作为契约(协议)的interface</h4>

<p>Golang语言本身并不支持泛型，尽管函数参数可以使用<code class="highlighter-rouge">interface{}</code>来接收任意类型的变量，但是对于<code class="highlighter-rouge">slice</code>而言，我们无法定义一个<code class="highlighter-rouge">[]interface{}</code>来接收任意类型的<code class="highlighter-rouge">[]T</code>，原因在于<code class="highlighter-rouge">T</code>和<code class="highlighter-rouge">interface{}</code>在存储空间中有着截然不同的表现形式。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">PrintSlice</span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="p">[]</span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">v</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">s</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">var</span><span class="x"> </span><span class="n">s</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="m">10</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">s</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="x"> </span><span class="n">i</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="n">PrintSlice</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>在编译时期就会抛出异常:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cannot use s <span class="o">(</span><span class="nb">type</span> <span class="o">[]</span>int<span class="o">)</span> as <span class="nb">type</span> <span class="o">[]</span>interface <span class="o">{}</span> <span class="k">in </span>argument to PrintSlice
</code></pre></div></div>

<p>尽然可以通过代码将<code class="highlighter-rouge">[]T</code>转换成<code class="highlighter-rouge">[]interface{}</code>，但是会带来一些效率上的损耗，并且很丑陋。解决此类问题的通用方法就是使用<code class="highlighter-rouge">interface</code>，如<code class="highlighter-rouge">sort.Interface</code>。</p>

<p>sort包提供了针对任意类型序列根据任意排序函数原地排序的功能，使用<code class="highlighter-rouge">sort.Interface</code>接口来指定通用排序算法和每个具体类型之间的协议。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">Interface</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Len</span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="x">            </span><span class="c">// 获取集合中元素个数的方法</span><span class="x">
	</span><span class="n">Less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">bool</span><span class="x">  </span><span class="c">// 排序的依据</span><span class="x">
	</span><span class="n">Swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x">       </span><span class="c">// 如何在集合中交换两个元素</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>简单地来说，只要类型实现了<code class="highlighter-rouge">sort.Interface</code>接口，就可以使用Golang内部提供的排序算法(根据元素排布动态地选择排序方式)，而无需自行实现。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">Employee</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Name</span><span class="x"> </span><span class="kt">string</span><span class="x">
	</span><span class="n">Salary</span><span class="x"> </span><span class="kt">int</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">Employees</span><span class="x"> </span><span class="p">[]</span><span class="n">Employee</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">em</span><span class="x"> </span><span class="n">Employees</span><span class="p">)</span><span class="x"> </span><span class="n">Len</span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">em</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">em</span><span class="x"> </span><span class="n">Employees</span><span class="p">)</span><span class="x"> </span><span class="n">Less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">bool</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Salary</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">Salary</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">em</span><span class="x"> </span><span class="n">Employees</span><span class="p">)</span><span class="x"> </span><span class="n">Swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">em</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">employees</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">Employees</span><span class="p">{</span><span class="x">
		</span><span class="n">Employee</span><span class="p">{</span><span class="s">"smart"</span><span class="p">,</span><span class="x"> </span><span class="m">5000</span><span class="p">},</span><span class="x">
		</span><span class="n">Employee</span><span class="p">{</span><span class="s">"Aelam"</span><span class="p">,</span><span class="x"> </span><span class="m">4500</span><span class="p">},</span><span class="x">
		</span><span class="n">Employee</span><span class="p">{</span><span class="s">"Lin"</span><span class="p">,</span><span class="x"> </span><span class="m">8500</span><span class="p">},</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="n">sort</span><span class="o">.</span><span class="n">Sort</span><span class="p">(</span><span class="n">employees</span><span class="p">)</span><span class="x">
	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">employees</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p><code class="highlighter-rouge">sort.Sort</code>接收一个<code class="highlighter-rouge">sort.Interface</code>类型参数，而<code class="highlighter-rouge">Employees</code>实现了该接口，故在<code class="highlighter-rouge">sort.Sort</code>内部，可以完全不用管<code class="highlighter-rouge">Employees</code>的具体类型是什么，只需调用接口中定义好的方法，是接口和实现类型之间的契约。</p>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/author/smartkeyerror" style="background-image: url(/assets/images/author.png)"><span class="hidden">smartkeyerror's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/author/smartkeyerror">smartkeyerror</a></h4>

                        
                            <p> 日拱一卒，功不唐捐</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> China</span>
                            <span class="author-link icon-link"><a href="https://smartkeyerror.com"> https://smartkeyerror.com</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=Golang中的interface&amp;url=https://smartkeyerror.comGolang-interface"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://smartkeyerror.comGolang-interface"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=https://smartkeyerror.comGolang-interface"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            

            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>

<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story no-cover" href="/MySQL-InnoDB-Lock">
            <section class="post">
                <h2>MySQL-InnoDB中的锁</h2>
                <p>锁在InnoDB存储引擎中的使用远比我们想象中的更加频繁，及时是一条最为简单的update set语句，其中也涉及到了各种锁的使用。包括常说的一致性锁定读，解决幻读等场景中，同样包含了锁的大量使用。

</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev no-cover" href="/Linux-IO">
            <section class="post">
                <h2>Linux操作系统-文件I/O</h2>
                <p>在操作系统中， 最为复杂同时也最为重要的功能就是文件I/O。 一台PC可以不连接互联网， 但是一定需要程序的载入、文件的打开， 而这些操作与I/O均密不可分。 包括软件开发中， 数据库与I/O的关系密切相关， 有时衡量一个DB的效率， 其实就是在衡量其I/O效率。 理解文件I/O， 就是在理解我们常用应用软件， 如MySQL、Redis、Nginx、ES、Prometheus等的核心。

</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/">知其然, 知其所以然</a> &copy; 2020</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-150652886-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/assets/js/index.js"></script>

</body>
</html>
