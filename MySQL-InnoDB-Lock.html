<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>MySQL-InnoDB中的锁</title>
    <meta name="description" content="Keep coding, Keep curiosity" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />

    <!-- highlight.js -->
<!--    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">-->
<!--    <style>.hljs { background: none; }</style>-->

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="https://smartkeyerror.com//MySQL-InnoDB-Lock" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/page2/" />

    <meta property="og:site_name" content="知其然, 知其所以然" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="MySQL-InnoDB中的锁" />
    <meta property="og:description" content="Keep coding, Keep curiosity" />
    <meta property="og:url" content="https://smartkeyerror.com//MySQL-InnoDB-Lock" />
    <meta property="og:image" content="/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="MySQL-InnoDB中的锁" />
    <meta name="twitter:description" content="Keep coding, Keep curiosity" />
    <meta name="twitter:url" content="https://smartkeyerror.com//MySQL-InnoDB-Lock" />
    <meta name="twitter:image:src" content="/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "知其然, 知其所以然",
    "name": "MySQL-InnoDB中的锁",
    "url": "https://smartkeyerror.com//MySQL-InnoDB-Lock",
    "image": "/assets/images/cover1.jpg",
    "description": "Keep coding, Keep curiosity"
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="知其然, 知其所以然" href="/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/">Home</a></li>
        <li class="nav-archives " role="presentation"><a href="/archives">Archives</a></li>
        <li class="nav-about " role="presentation"><a href="/about">About</a></li>
    </ul>
<!--    <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>-->
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">MySQL-InnoDB中的锁</h1>
            <section class="post-meta">
            <!-- <a href='/'></a> -->

            
                
                    <a href='/author/smartkeyerror'>smartkeyerror</a>
                
            
            <time class="post-date" datetime="2020-01-31">31 Jan 2020</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/tag/MySQL'>MySQL</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <p>锁在InnoDB存储引擎中的使用远比我们想象中的更加频繁，及时是一条最为简单的<code class="highlighter-rouge">update set</code>语句，其中也涉及到了各种锁的使用。包括常说的一致性锁定读，解决幻读等场景中，同样包含了锁的大量使用。</p>

<!---more--->

<h4 id="1-latch和lock">1. Latch和Lock</h4>

<p>在InnoDB存储引擎中，Latch(门闩)是用来保证并发线程操作临界资源的正确性，保证某些操作的原子性。通常又分为Mutex(互斥量)和RWLock(读写锁)，例如Python中<code class="highlighter-rouge">threading.Lock</code>，Java中<code class="highlighter-rouge">synchronized</code>，Golang中的<code class="highlighter-rouge">sync.Mutex</code>，Latch通常应用于操作缓冲池中的LRU列表元素(添加、删除以及移动)，部分场景下的<code class="highlighter-rouge">AUTO_INCREMENT</code>实现。用户通常不会直接地与Latch打交道，并且没有死锁检测。</p>

<p>Lock作用于事务之中，用来锁定表、页、行，锁的添加与释放通常会在事务的起始和结束时进行。数据库中的幻读问题解决就是通过Lock实现的，而非Latch。并且Lock存在死锁检测机制，当发生死锁时，会在某些情况下告知用户，例如在使用一致性锁定读(SELECT…FOR UPDATE)时产生的死锁，会直接抛出1213的Deadlock异常。</p>

<p>尽管Latch与Lock操作的对象均为数据，但是Latch更为底层，操作的对象更加细小。Lock的对象相对于Latch而言，则更加”粗放”，例如表、页数据，此外最重要的是Lock的作用域为事务，Latch则不是。</p>

<h4 id="2-innodb存储引擎中的lock">2. InnoDB存储引擎中的Lock</h4>

<p>为了方便叙述，下面均使用锁来指代InnoDB中的Lock(仍然要说明，Lock以及Latch都可以称为锁，这里只是为了方便叙述)。</p>

<p>InnoDB引擎支持行锁以及表锁，既可以锁定某一行，同时也可以锁定一整张表，先从行级锁说起。</p>

<p>InnoDB引擎实现了两种标准的行级锁:</p>
<ul>
  <li>共享行级锁(S Lock, Share Lock)</li>
  <li>排他行级锁(X Lock, Exclusive Lock)</li>
</ul>

<p>可以认为S Lock和X Lock分别表示读锁和写锁，如同RWLock一样。S Lock允许并发地读取数据，X Lock既限制并发地读取，同时也限制并发地修改。所以说，当某一行数据中存在S锁时，只能再次添加S锁，若想要添加X锁，则需要等待S锁的释放。行级锁X以及S Lock的兼容性如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">-</th>
      <th style="text-align: center">X</th>
      <th style="text-align: center">S</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">X</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">S</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
  </tbody>
</table>

<p>同时，InnoDB支持表级锁，为了支持表级锁与行级锁这两个不同粒度的锁，InnoDB支持一种额外的上锁方式，称之为意向锁(Intention Lock)。</p>

<p>为了更好的理解意向锁，首先假设没有意向锁，只有表锁和行锁。当事务A在更新某一条数据时，会在该数据行上添加X锁。此时另外事务B申请整个表的写锁，如果事务B申请成功，那么它就能修改表中任意一行数据，这与事务持有的X锁冲突。</p>

<p>如果数据库想要避免该冲突，那么需要让事务B阻塞，直到事务A提交释放X锁。转而需要判断事务B阻塞的条件: ①当前表是否被其它事务添加表锁 ②判断表中是否存在行锁。这两个条件判断均可以在表层面实现，而无需遍历所有数据，只需要定义好数据结构即可。一个最简单的实现就是为表锁和行锁添加两个标识位，该标识位在添加和释放锁时进行原子更新，例如:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table_s_lock <span class="o">=</span> <span class="nb">false
</span>table_x_lock <span class="o">=</span> <span class="nb">false
</span>row_s_lock <span class="o">=</span> <span class="nb">true
</span>row_x_lock <span class="o">=</span> <span class="nb">true</span>
</code></pre></div></div>

<p>当某一行添加X锁时，将<code class="highlighter-rouge">row_x_lock</code>置为true，若其余事务想要添加表级别的X锁，则必须等待<code class="highlighter-rouge">row_x_lock</code>更新为false。反之若事务已经添加了表级别的X锁，将<code class="highlighter-rouge">table_x_lock</code>置为true，事务B若想在某一行添加X锁，则需要等待<code class="highlighter-rouge">table_s_lock</code>以及<code class="highlighter-rouge">table_x_lock</code>均更新为false。</p>

<p>虽然上面的标识位能够解决问题，但仍然有些奇怪，奇怪的点在于标识位的判断粒度不同。我们更加希望表级锁与表级锁进行兼容性判断，行级锁与行级锁进行兼容性判断，而不是表级锁与行级锁进行兼容性判断。由此，就有了意向锁的诞生。</p>

<p>意向锁(Intention Lock)将锁定的对象分为多个粒度，当想要对细粒度的数据进行加锁时，那么首先需要对粗粒度的对象添加意向锁。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/intention-Lock.png" alt="" /></p>

<p>例如，若需要对页上的记录R添加X锁，则需要分别对数据库、表、页添加意向锁IX，添加成功后才会对记录R添加X锁，若其中任何一部分导致等待，那么该操作需要等待粗粒度上锁环节的完成。现在来看在有了意向锁之后InnoDB存储引擎如何支持多粒度的锁。</p>

<p>意向锁同样分为两种: 共享和排他</p>

<ul>
  <li>意向共享锁(IS, Intention Share Lock)</li>
  <li>意向排他锁(IX, Intention Exclusive Lock)</li>
</ul>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/intention-lock-example.png" alt="" /></p>

<p>如上图所示，事务A为了给记录R添加X锁(排他锁)，则需要依次对数据库、表、页添加意向排他锁(IX)，假设添加均成功，最终记录R添加了X锁。此时事务B想要向表A中添加表级别的排他锁，由于表A中存在IX锁，与表级别的X锁并不兼容，故事务B等待，等待表A中IX锁的释放。可以看到，在有了意向锁之后，锁的兼容性比较将处理同粒度水平，而不是跨粒度进行比较。这让我想起了一个段子:</p>

<blockquote>
  <p>不要跟傻逼争论，他会把你拉到他的水平上，然后用他丰富的经验打败你</p>
</blockquote>

<p>InnoDB存储引擎中意向锁和表级锁的兼容性如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">-</th>
      <th style="text-align: center">IX</th>
      <th style="text-align: center">IS</th>
      <th style="text-align: center">X(表级别)</th>
      <th style="text-align: center">S(表级别)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">IX</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">IS</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">X(表级别)</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">S(表级别)</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
  </tbody>
</table>

<p>在MySQL 5.5以上、5.7.14以下的版本中，用户可以通过<code class="highlighter-rouge">INFORMATION_SCHEMA</code>下的<code class="highlighter-rouge">INNODB_TRX</code>、<code class="highlighter-rouge">INNODB_LOCKS</code>以及<code class="highlighter-rouge">INNODB_LOCK_WAITS</code>这三张表简单地监控并分析可能存在的锁问题。</p>

<p>在MySQL 8.0版本中，则需要使用<code class="highlighter-rouge">performance_schema</code>下的<code class="highlighter-rouge">data_locks</code>以及<code class="highlighter-rouge">data_lock_waits</code>获取相关的锁以及锁等待信息。</p>

<p>而MySQL版本在5.7.14到8.0之间的用户，只能通过其它手段间接的获取上述信息。</p>

<h5 id="21-创建通用例程">2.1 创建通用例程</h5>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`user`</span> <span class="p">(</span>
  <span class="nv">`id`</span> <span class="n">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="nv">`nickname`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`password`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`user_id`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`mobile`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`mobile_area`</span> <span class="n">smallint</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">comment</span> <span class="nv">"手机号码区域"</span><span class="p">,</span>
  <span class="nv">`gender`</span> <span class="n">tinyint</span> <span class="k">DEFAULT</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nv">`avatar`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`account_id`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`created_at`</span> <span class="n">datetime</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="nv">`updated_at`</span> <span class="n">datetime</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="k">ON</span> <span class="k">UPDATE</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="nv">`deleted_at`</span> <span class="n">datetime</span><span class="p">,</span>
  <span class="nv">`status`</span> <span class="n">tinyint</span> <span class="k">DEFAULT</span> <span class="mi">1</span> <span class="k">comment</span> <span class="nv">"用户状态"</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`user_id`</span> <span class="p">(</span><span class="nv">`user_id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`mobile`</span> <span class="p">(</span><span class="nv">`mobile`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`account_id`</span> <span class="p">(</span><span class="nv">`account_id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`created_at`</span> <span class="p">(</span><span class="nv">`created_at`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`updated_at`</span> <span class="p">(</span><span class="nv">`updated_at`</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="p">(</span><span class="nv">`user_id`</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="p">(</span><span class="nv">`account_id`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">1</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span> <span class="k">COLLATE</span><span class="o">=</span><span class="n">utf8mb4_general_ci</span><span class="p">;</span>
</code></pre></div></div>

<p>这是一张非常普通但又普遍的用户信息表，其中包含了唯一主键，唯一辅助索引以及普通辅助索引。</p>

<h5 id="22-innodb_trx">2.2 INNODB_TRX</h5>
<p><code class="highlighter-rouge">INNODB_TRX</code>表中主要记录了当前正在执行的事务信息，包括只读事务。首先来看字段和字段所表示的含义:</p>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TRX_ID</td>
      <td>InnoDB存储引擎内部的唯一事务ID</td>
    </tr>
    <tr>
      <td>TRX_WEIGHT</td>
      <td>事务权重(与事务修改的行数和锁定的行数有关)，当两个事务执行发生死锁时，InnoDB会选择权重较低的事务进行回滚</td>
    </tr>
    <tr>
      <td>TRX_STATE</td>
      <td>当前的事务执行状态，包括RUNNING, LOCK WAIT, ROLLING BACK, 以及COMMITTING，LOCK WAIT表示当前事务正等待某个锁的释放</td>
    </tr>
    <tr>
      <td>TRX_STARTED</td>
      <td>事务开始时间，格式如2000-01-01 14:01:08</td>
    </tr>
    <tr>
      <td>TRX_REQUESTED_LOCK_ID</td>
      <td>当前事务所等待的锁ID，该字段只有在状态为LOCK WAIT才有值，否则为NULL。可与<code class="highlighter-rouge">INNODB_LOCKS</code>通过LOCK_ID字段进行关联查询，获取更为详细的锁信息。</td>
    </tr>
    <tr>
      <td>TRX_WAIT_STARTED</td>
      <td>当前事务等待锁的起始时间，在状态为LOCK WAIT时才有值，否则为NULL。</td>
    </tr>
    <tr>
      <td>TRX_QUERY</td>
      <td>当前事务<strong>正在</strong>执行的SQL语句(不是事务所有的执行语句)</td>
    </tr>
    <tr>
      <td>TRX_OPERATION_STATE</td>
      <td>事务的当前操作状态，包括PREPARING, UPDATING, DELETING, COMMITTING以及NULL，该字段在绝大部分情况下均为NULL，捕捉某一事务的瞬间执行状态还是比较困难的(除非是大事务)</td>
    </tr>
    <tr>
      <td>TRX_TABLES_IN_USE</td>
      <td>正在执行的SQL语句所操作的表数量，是一个动态变化值，通常很难观测</td>
    </tr>
    <tr>
      <td>TRX_TABLES_LOCKED</td>
      <td>当前事务在各个表中添加行锁的表数量</td>
    </tr>
    <tr>
      <td>TRX_LOCK_STRUCTS</td>
      <td>当前事务持有的锁数量</td>
    </tr>
    <tr>
      <td>TRX_LOCK_MEMORY_BYTES</td>
      <td>当前事务中锁结构的内存总占用</td>
    </tr>
    <tr>
      <td>TRX_ROWS_LOCKED</td>
      <td>当前事务锁住的近似数据总行数</td>
    </tr>
    <tr>
      <td>TRX_ROWS_MODIFIED</td>
      <td>当前事务插入、修改的总行数</td>
    </tr>
    <tr>
      <td>TRX_CONCURRENCY_TICKETS</td>
      <td>表示当前事务在换出之前所能做的工作之和</td>
    </tr>
    <tr>
      <td>TRX_ISOLATION_LEVEL</td>
      <td>当前事务隔离级别，包括READ UNCIMMITTED、READ COMMITTED、READ REPEATABLE以及SERIALIZABLE</td>
    </tr>
    <tr>
      <td>TRX_UNIQUE_CHECKS</td>
      <td>当前事务是否开启唯一性检查</td>
    </tr>
    <tr>
      <td>TRX_FOREIGN_KEY_CHECKS</td>
      <td>当前事务是否开启外键检查</td>
    </tr>
    <tr>
      <td>TRX_LAST_FOREIGN_KEY_ERROR</td>
      <td>当前事务执行时最后发生的外键错误</td>
    </tr>
    <tr>
      <td>TRX_ADAPTIVE_HASH_LATCHED</td>
      <td>当前事务是否锁定了自适应哈希索引</td>
    </tr>
  </tbody>
</table>

<p>在这20多个字段中，较为重要的包括事务ID，事务执行状态，事务等待锁的起始时间，事务锁定的近似总行数。</p>

<h5 id="23-innodb_locks">2.3 INNODB_LOCKS</h5>

<p><code class="highlighter-rouge">INNODB_LOCKS</code>表中记录了当前所有未释放的锁，包括行锁、页锁以及表锁，当某个事务发生严重的锁等待时，通常会在该表中查找蛛丝马迹，确定问题的根源。</p>

<p>但是，<code class="highlighter-rouge">INNODB_LOCKS</code>和<code class="highlighter-rouge">INNODB_LOCK_WAITS</code>这两张表在5.7.14以上版本中被废弃不用，在8.0版本中使用<code class="highlighter-rouge">data_locks</code>以及<code class="highlighter-rouge">data_lock_waits</code>进行代替，故以下内容均采用MySQL 8.0版本进行描述。</p>

<h5 id="24-data_locks">2.4 data_locks</h5>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ENGINE</td>
      <td>申请或持有锁的存储引擎类型</td>
    </tr>
    <tr>
      <td>ENGINE_LOCK_ID</td>
      <td>存储引擎内部的锁ID，该值会发生动态变化，外部系统不应该依赖该值</td>
    </tr>
    <tr>
      <td>ENGINE_TRANSACTION_ID</td>
      <td>持有锁的事务ID，与INNODB_TRX中的TRX_ID对应</td>
    </tr>
    <tr>
      <td>THREAD_ID</td>
      <td>持有锁的线程ID</td>
    </tr>
    <tr>
      <td>EVENT_ID</td>
      <td>事件ID，该字段将于下方进行详细描述</td>
    </tr>
    <tr>
      <td>OBJECT_SCHEMA</td>
      <td>锁所在的schema(database)</td>
    </tr>
    <tr>
      <td>OBJECT_NAME</td>
      <td>锁所在的表名称</td>
    </tr>
    <tr>
      <td>PARTITION_NAME</td>
      <td>锁所在分片名称</td>
    </tr>
    <tr>
      <td>SUBPARTITION_NAME</td>
      <td>锁所在的子分片名称</td>
    </tr>
    <tr>
      <td>INDEX_NAME</td>
      <td>被添加锁的索引名称</td>
    </tr>
    <tr>
      <td>OBJECT_INSTANCE_BEGIN</td>
      <td>锁的内存空间起始地址</td>
    </tr>
    <tr>
      <td>LOCK_TYPE</td>
      <td>锁类型，包含TABLE和RECORD</td>
    </tr>
    <tr>
      <td>LOCK_MODE</td>
      <td>锁的模式，包括S,X,IS,IX,AUTO_INC以及UNKNOWN</td>
    </tr>
    <tr>
      <td>LOCK_STATUS</td>
      <td>锁的状态，InnoDB引擎中包括GRANTED(已添加)和WAITING(等待中)</td>
    </tr>
    <tr>
      <td>LOCK_DATA</td>
      <td>锁覆盖的范围，该字段将于下方详细描述</td>
    </tr>
  </tbody>
</table>

<p>以一个具体的例子为例:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Mario</span><span class="p">.</span><span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
               <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140374385659344</span><span class="p">:</span><span class="mi">1453</span><span class="p">:</span><span class="mi">140374295256456</span>
<span class="n">ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">632837</span>
            <span class="n">THREAD_ID</span><span class="p">:</span> <span class="mi">56</span>
             <span class="n">EVENT_ID</span><span class="p">:</span> <span class="mi">28</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
       <span class="n">PARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
    <span class="n">SUBPARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">NULL</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140374295256456</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="k">TABLE</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">IX</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="k">NULL</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
               <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140374385659344</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140374295253576</span>
<span class="n">ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">632837</span>
            <span class="n">THREAD_ID</span><span class="p">:</span> <span class="mi">56</span>
             <span class="n">EVENT_ID</span><span class="p">:</span> <span class="mi">28</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
       <span class="n">PARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
    <span class="n">SUBPARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140374295253576</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p>当我们使用<code class="highlighter-rouge">FOR UPDATE</code>一致性锁定读向id为1的行添加一个写锁时，可以看到<code class="highlighter-rouge">data_locks</code>中生成了两条记录。从<code class="highlighter-rouge">LOCK_TYPE</code>以及<code class="highlighter-rouge">LOCK_MODE</code>来看，第一条为表级别意向排他锁(IX)，第二条为行记录排他锁(X)。注意到X锁后面还有一个说明: <code class="highlighter-rouge">REC_NOT_GAP</code>，表示排他非间隙行锁，这是行锁的一种实现，将在后面小节中描述。</p>

<p><code class="highlighter-rouge">LOCK_DATA</code>在IX项中为NULL，这是因为在InnoDB存储引擎中，该字段只会在<code class="highlighter-rouge">LOCK_TYPE</code>为<code class="highlighter-rouge">RECORD</code>时才有实际值，对于<code class="highlighter-rouge">TABLE</code>类型的锁而言，该值为NULL。<code class="highlighter-rouge">LOCK_DATA</code>根据不同的加锁方式会有不同具体值。当我们使用主键ID(primary key)进行加锁时，<code class="highlighter-rouge">LOCK_DATA</code>仅包含聚簇索引行记录，此时<code class="highlighter-rouge">LOCK_DATA</code>的值通常为主键ID。当我们使用辅助索引对记录加锁时，锁住的范围则会包括辅助索引+聚簇索引，所以此时<code class="highlighter-rouge">data_locks</code>会生成3条记录(表级别意向锁+索引记录锁+聚簇索引记录锁)，此时<code class="highlighter-rouge">LOCK_DATA</code>的值为”辅助索引字段值+主键ID”</p>

<p>例如:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Mario</span><span class="p">.</span><span class="k">user</span> <span class="k">where</span> <span class="n">user_id</span> <span class="o">=</span> <span class="nv">"168236477"</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
          <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">NULL</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="k">TABLE</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">IX</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="k">NULL</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">user_id_2</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="cm">/* LOCK_DATA为FieldValue+记录对应的主键ID。由于user_id为unique，故此处仅一条记录 */</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="s1">'168236477'</span><span class="p">,</span> <span class="mi">3</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">3</span>
</code></pre></div></div>

<h5 id="25-data_lock_waits">2.5 data_lock_waits</h5>

<p><code class="highlighter-rouge">data_lock_waits</code>相比于<code class="highlighter-rouge">INNODB_TRX</code>以及<code class="highlighter-rouge">data_locks</code>而言则要更复杂一些，该表实际上是一个ManyToMany的关系表，记录了<code class="highlighter-rouge">data_locks</code>中锁之间的等待以及依赖关系，同时也记录了锁所对应的事务/会话信息。</p>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ENGINE</td>
      <td>存储引擎类型</td>
    </tr>
    <tr>
      <td>REQUESTING_ENGINE_LOCK_ID</td>
      <td>存储引擎内锁ID，对应于data_locks表中的ENGINE_LOCK_ID</td>
    </tr>
    <tr>
      <td>REQUESTING_ENGINE_TRANSACTION_ID</td>
      <td>存储引擎内事务ID</td>
    </tr>
    <tr>
      <td>REQUESTING_THREAD_ID</td>
      <td>线程ID</td>
    </tr>
    <tr>
      <td>REQUESTING_EVENT_ID</td>
      <td>事件ID</td>
    </tr>
    <tr>
      <td>REQUESTING_OBJECT_INSTANCE_BEGIN</td>
      <td>锁的内存空间起始地址</td>
    </tr>
    <tr>
      <td>BLOCKING_ENGINE_LOCK_ID</td>
      <td>等待释放的锁ID</td>
    </tr>
    <tr>
      <td>BLOCKING_ENGINE_TRANSACTION_ID</td>
      <td>等待结束的事务ID</td>
    </tr>
    <tr>
      <td>BLOCKING_THREAD_ID</td>
      <td>等待结束的线程ID</td>
    </tr>
    <tr>
      <td>BLOCKING_EVENT_ID</td>
      <td>等待结束的事件ID</td>
    </tr>
    <tr>
      <td>BLOCKING_OBJECT_INSTANCE_BEGIN</td>
      <td>等待结束的锁的内存空间起始地址</td>
    </tr>
  </tbody>
</table>

<p>例如:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_lock_waits</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
                          <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">REQUESTING_ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140678484647376</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140678365511992</span>
<span class="n">REQUESTING_ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">635403</span>
            <span class="n">REQUESTING_THREAD_ID</span><span class="p">:</span> <span class="mi">48</span>
             <span class="n">REQUESTING_EVENT_ID</span><span class="p">:</span> <span class="mi">15</span>
<span class="n">REQUESTING_OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365511992</span>
         <span class="n">BLOCKING_ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140678484646504</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140678365506120</span>
  <span class="cm">/*等待ID为635400的事务释放锁*/</span>
  <span class="n">BLOCKING_ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">635400</span>
              <span class="n">BLOCKING_THREAD_ID</span><span class="p">:</span> <span class="mi">47</span>
               <span class="n">BLOCKING_EVENT_ID</span><span class="p">:</span> <span class="mi">12</span>
  <span class="n">BLOCKING_OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/data_lock_waits.png" alt="" /></p>

<h4 id="3-innodb存储引擎行锁算法">3. InnoDB存储引擎行锁算法</h4>

<p>InnoDB存储引擎存在3种行锁算法，分别为:</p>

<ul>
  <li>Record Lock: 单个行记录上的锁</li>
  <li>Gap Lock: 间隙锁，锁定一个范围，单不包含记录本身</li>
  <li>Next-Key Lock: Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身</li>
</ul>

<p>Record Lock表示单个行记录上的锁，这非常好理解，例如我们<code class="highlighter-rouge">update</code>一条或多条数据时，事务会为这一条或者多条数据均添加X锁。当使用主键ID进行更新时，记录仅包含聚簇索引行记录。当使用辅助索引进行更新时，将会锁住聚簇索引记录+辅助索引记录。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="k">user</span> <span class="k">set</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="cm">/* 省略部分非关键信息 */</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">commit</span><span class="p">;</span>
</code></pre></div></div>

<p>当使用主键ID进行一致性锁定读时，<code class="highlighter-rouge">data_locks</code>生成两条锁记录，一条为table IX，另一条为行记录的X锁，注意<code class="highlighter-rouge">LOCK_MODE</code>后面的附加声明: REC_NOT_GAP，表示当前锁的算法仅为行记录锁，非间隙锁。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="k">user</span> <span class="k">set</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">where</span> <span class="n">user_id</span> <span class="o">=</span> <span class="nv">"174269548"</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">user_id_2</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="s1">'174269548'</span><span class="p">,</span> <span class="mi">1</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506464</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p>而使用辅助索引进行一致性锁定读时，除了table IX以及聚簇索引的X锁以外，还会有额外的辅助索引X锁，<code class="highlighter-rouge">LOCK_MODE</code>同样备注了非间隙锁的标识。</p>

<p>间隙锁的存在主要是为了解决幻读问题，幻读是指当某事务读取一定范围内的数据时，其余事务在该范围内插入了一条或多条数据，或者删除了一条或多条数据，导致前一个事务读取的数据条数发生改变，如同出现幻觉，所以称为幻读。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="n">supremum</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">record</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">3</span>
</code></pre></div></div>

<p>当我们对某一个范围使用一致性锁定读时，就可以看到间隙锁的产生。<code class="highlighter-rouge">LOCK_MODE</code>仅为X时，就表示当前锁添加了间隙锁。并且在<code class="highlighter-rouge">LOCK_DATA</code>有supremum pseudo-record的解释说明，该说明表示MySQL决定锁定最大间隙范围。在本例中，为id大于2的所有数据，故另一个事务执行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">insert</span> <span class="k">into</span> <span class="k">user</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">nickname</span><span class="p">,</span> <span class="n">password</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">mobile_area</span><span class="p">,</span> <span class="n">gender</span><span class="p">,</span> <span class="n">avatar</span><span class="p">,</span> <span class="n">account_id</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="nv">"jojo"</span><span class="p">,</span> <span class="nv">"passwd"</span><span class="p">,</span> <span class="nv">"147523659"</span><span class="p">,</span> <span class="nv">"13555555555"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">"https://jojo.com"</span><span class="p">,</span> <span class="nv">"1753681429"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>将会被阻塞，直至前一个事务释放间隙锁或者当前事务锁等待超时。</p>

<p>在理解了间隙锁以后，Next-Key Lock就很容易理解了，锁定一个记录+一个范围。上面例子均有一个特点，就是不管是主键ID，还是user_id，它们都具有unique约束，而对于非唯一的辅助索引而言，即使是精确查询并加锁，也会添加Gap Lock，此时就是Next-Key Lock。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">updated_at</span> <span class="o">=</span> <span class="nv">"2020-01-23 21:32:52"</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="cm">/*此时DB中仅存在一条数据更新时间为"2020-01-23 21:32:52"*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">updated_at</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="n">supremum</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">record</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">updated_at</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">0</span><span class="n">x99A56F5834</span><span class="p">,</span> <span class="mi">1</span>
<span class="o">***************************</span> <span class="mi">4</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">updated_at</code>字段仅添加了普通索引，并且值为”2020-01-23 21:32:52”的记录主键ID为1，从<code class="highlighter-rouge">data_locks</code>的最后一条记录也可以看出。在该表的第二行和第三行中分别添加了间隙锁，第三行的<code class="highlighter-rouge">LOCK_DATA</code>字段值为16进制数+主键ID。</p>

<p>此外，<strong>需要尤为注意的是，<code class="highlighter-rouge">READ COMMITTED</code>事务隔离级别下，将不会有间隙锁的添加</strong>。在文章<a href="https://smartkeyerror.com/django-concurrent-data-process">Django处理数据并发问题</a>中描述了使用Django默认的<code class="highlighter-rouge">READ COMMITTED</code>事务隔离级别所带来的问题。</p>

<h4 id="4-自增长与锁">4. 自增长与锁</h4>

<p>自增长在数据库中是非常常见的属性，MySQL提供<code class="highlighter-rouge">AUTO_INCREMENT</code>属性使得列可具备自增长的功能。在InnoDB存储引擎内存结构中，对每个含有自增长值的表都有一个自增长计数器。</p>

<p>最初自增长是采用特殊的表锁实现，称为AUTO_INC Locking，为了提高插入的性能，锁并不是在事务结束时才释放，而是在完成对自增长值插入的SQL语句后立即释放。虽然AUTO_INC Locking从一定程度上提高了并发插入的效率，但是仍存在性能问题: 事务必须等待前一个事务插入语句的结束。所以，后续就有了轻量级的互斥量自增长实现。</p>

<p>互斥量的实现就是文章最开头所说的Latch，由硬件协助实现。该实现方式只有在确定所插入的行数时才会使用，否则，将仍然使用AUTO_INC Locking。</p>

<h4 id="5-metadata-lock">5. Metadata Lock</h4>

<p>Metadata Lock，又称为MDL，相较于行锁和表锁，其范围更广，对象包括数据库、表、行以及触发器和外键等，与InnoDB其它锁一样，在事务开始时获取，事务结束时释放，其设计目的在于保证在事务执行过程中表的结构不会被修改。</p>

<p>通常来讲，只有在修改表结构的时候我们才会直接地与MDL打交道，例如向某张表添加一列，或者删除某一列。在DML执行非常频繁的应用中，当我们执行ALTER TABLE table ADD column时，很有可能出现整个MySQL挂掉的情况，其原因就在于表结构修改语句获取MDL时阻塞，导致后续对该表的查询、修改和删除等语句阻塞。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/MDL.png" alt="" /></p>

<p>session A与session B会向表user添加只读MDL，而session C想要申请可写的MDL，由于前面两个事务均为提交，故只能阻塞。此时由于session C写锁的申请，导致session D以及后续的所有DML操作均会被阻塞，简单来说，此时表user不可读写。</p>

<p>如果user表中的读写非常频繁，将会导致大量的查询或更新语句阻塞，且状态均为<code class="highlighter-rouge">waiting for metadata lock</code>。此时若客户端存在超时重试机制，那么会导致大量新的会话建立，最后达到MySQL线程数量的限制，导致整个DB不可用。</p>

<p>在MySQL 5.6版本以上支持Online DDL，其过程如下:</p>
<ul>
  <li>ALTER TABLE table ADD column语句获取MDL写锁</li>
  <li>获取成功后，将其降级为MDL读锁</li>
  <li>执行真正的DDL操作，如添加、删除列，期间可以执行DML语句</li>
  <li>升级MDL读锁为写锁</li>
  <li>释放MDL写锁，整个DDL过程结束</li>
</ul>

<p>真正导致数据库不可读写的步骤为1、4，第3步为实际运行时间最长的步骤，不会影响表的读写操作，只要内存和磁盘容量足够，数据量再多也灭有关系。所以，DDL的关键影响因素不在于数据量，而是在于数据读写的QPS。这也是为什么表结构修改操作要放到月黑风高的凌晨进行操作的原因: 那时候访问量最少，而不是数据量最少。</p>

<p>在更改表结构时造成大面积读写操作阻塞的另一个原因就是长事务，即长时间运行的事务。即使QPS非常小，但是系统中存在长事务，同样会造成DDL语句获取写锁阻塞，从而阻塞后续的读写语句。</p>

<h4 id="6-reference">6. Reference</h4>

<ul>
  <li>https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_latch</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-trx-table.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/data-locks-table.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/data-lock-waits-table.html</li>
</ul>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/author/smartkeyerror" style="background-image: url(/assets/images/author.jpg)"><span class="hidden">smartkeyerror's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/author/smartkeyerror">smartkeyerror</a></h4>

                        
                            <p> 日拱一卒，功不唐捐</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> China</span>
                            <span class="author-link icon-link"><a href="https://smartkeyerror.com"> https://smartkeyerror.com</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=MySQL-InnoDB中的锁&amp;url=https://smartkeyerror.comMySQL-InnoDB-Lock"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://smartkeyerror.comMySQL-InnoDB-Lock"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=https://smartkeyerror.comMySQL-InnoDB-Lock"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            

            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>

<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story no-cover" href="/Linux-Use-EasyConnect">
            <section class="post">
                <h2>Linux主机通过Windows虚拟机转发Easyconnect内网请求</h2>
                <p>世界上有个恶心的公司叫Sangfor，开发出了恶心的工具EasyConnect，本来这东西都是给在校的学生用的，好不好用都无所谓。但是很多公司也开始使用这个来访问内网，并且还不支持Linux(反正到目前Ubuntu下的64bit版本连接就没成功过)，这就很令人讨厌了。回想起Ubuntu下使用Wine安装微信的种种难受，决定还是使用Windows虚拟机开启EasyConnect，并把部分的Linux流量打进虚拟机。

</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev no-cover" href="/Golang-interface">
            <section class="post">
                <h2>Golang中的interface</h2>
                <p>Golang除了方便使用的协程以外，最令我感到惊讶的就是interface，接口。在其它语言中，接口承担的主要作用为解耦和协议，但是在Golang中，interface还作为一种”通用”类型广泛使用于标准库和第三方库中。

</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/">知其然, 知其所以然</a> &copy; 2020</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-150652886-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/assets/js/index.js"></script>

</body>
</html>
