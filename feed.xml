<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>知其然, 知其所以然 - Articles</title>
    <description>Keep coding, Keep curiosity</description>
    <link>
    https://smartkeyerror.com</link>
    
      
      <item>
        <title>VXLAN—构建Overlay容器网络</title>
        
          <description>&lt;p&gt;由于VLAN实现中的VLAN ID仅有12位，只能划分4096个虚拟局域网网段，对于云计算等领域而言，其用户远远不止4096个。并且，VLAN依赖于交换机等物理设备的实现，一旦升级物理设备，集群网络可能需要重新配置。因此，基于上述的限制，VMware、Cisco等大型网络企业推出了VXLAN解决方案。&lt;/p&gt;

</description>
        
        <pubDate>Thu, 06 Aug 2020 09:06:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/VXLAN</link>
        <guid isPermaLink="true">https://smartkeyerror.com/VXLAN</guid>
      </item>
      
    
      
      <item>
        <title>浅析gRPC</title>
        
          <description>&lt;p&gt;gRPC是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。(这Ctrl-C/V也是没有下限了….&lt;/p&gt;

</description>
        
        <pubDate>Thu, 23 Jul 2020 09:06:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/gRPC</link>
        <guid isPermaLink="true">https://smartkeyerror.com/gRPC</guid>
      </item>
      
    
      
      <item>
        <title>揭开Python元类(metaclass)神秘的面纱</title>
        
          <description>&lt;p&gt;Python语言的&lt;code class=&quot;highlighter-rouge&quot;&gt;metaclass&lt;/code&gt;特性一直是初学者的”噩梦”，当初博主在学习元类时也是一头雾水，但是一旦真正的理解了什么是”动态语言”之后，元类就不再神秘与难以理解了。Python这门动态语言最大的特性就是不需要一个类的字节码就能够在运行时创建出一个类，这是理解元类最为关键的信息。&lt;/p&gt;

</description>
        
        <pubDate>Mon, 13 Jul 2020 10:06:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Python-metaclass</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Python-metaclass</guid>
      </item>
      
    
      
      <item>
        <title>MySQL向客户端发送数据，客户端不接收会发生什么?</title>
        
          <description>&lt;p&gt;MySQL服务端在发送数据时，为了减少数据在用户空间和内核空间的复制次数，往往会使用缓冲区对数据进行缓冲。那么，如果客户端在接收大量数据时，选择不接收，或者处理非常慢的时候，会影响MySQL的正常运行吗?&lt;/p&gt;

</description>
        
        <pubDate>Wed, 17 Jun 2020 10:50:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/MySQL-Sending-Data</link>
        <guid isPermaLink="true">https://smartkeyerror.com/MySQL-Sending-Data</guid>
      </item>
      
    
      
      <item>
        <title>TCP有限状态机</title>
        
          <description>&lt;p&gt;相较于Linux进程状态的变迁，TCP的状态变迁则会复杂许多，当然这与TCP本身的实现有关。当线上的Web服务或者是基于TCP连接的服务出现了时断时续的网络状况时，往往需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;tcpdump&lt;/code&gt;以及TCP连接的状态进行问题定位。同时，这一复杂的有限状态机设计也能够为业务的设计提供指导性的帮助。&lt;/p&gt;

</description>
        
        <pubDate>Tue, 09 Jun 2020 18:06:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/TCP-Finite-State-Machine</link>
        <guid isPermaLink="true">https://smartkeyerror.com/TCP-Finite-State-Machine</guid>
      </item>
      
    
      
      <item>
        <title>InnoDB独特的LRU</title>
        
          <description>&lt;p&gt;由于硬盘和内存的造价差异，一台主机实例的硬盘容量通常会远超于内存容量。对于数据库等应用而言，为了保证更快的查询效率，通常会将使用过的数据放在内存中进行加速读取。LRU算法经常用于数据的置换，但InnoDB的LRU却更加独特。&lt;/p&gt;

</description>
        
        <pubDate>Tue, 09 Jun 2020 18:06:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/InnoDB-LRU</link>
        <guid isPermaLink="true">https://smartkeyerror.com/InnoDB-LRU</guid>
      </item>
      
    
      
      <item>
        <title>MySQL主从复制</title>
        
          <description>&lt;p&gt;MySQL的异步复制算的上是一种典型的单领导者复制模式，就复制本身而已并无特殊之处。但是复制的细节，例如binlog的格式选取，从节点如何在保证数据准确的情况下进行并行复制，MySQL的实现方案总是能令人眼前一亮。&lt;/p&gt;

</description>
        
        <pubDate>Thu, 04 Jun 2020 07:06:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/MySQL-Replication</link>
        <guid isPermaLink="true">https://smartkeyerror.com/MySQL-Replication</guid>
      </item>
      
    
      
      <item>
        <title>InnoDB如何保证事务的原子性与持久性</title>
        
          <description>&lt;p&gt;在InnoDB存储引擎中，一个事务的执行将涉及到3个日志的数据写入: redo log，undo log以及binlog。其中redo log以及binlog主要实现事务的原子性和持久性，而undo log主要用于实现事务的隔离性。&lt;/p&gt;

</description>
        
        <pubDate>Thu, 28 May 2020 18:06:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/InnoDB-AD</link>
        <guid isPermaLink="true">https://smartkeyerror.com/InnoDB-AD</guid>
      </item>
      
    
      
      <item>
        <title>Linux主机通过Windows虚拟机转发Easyconnect内网请求</title>
        
          <description>&lt;p&gt;世界上有个恶心的公司叫Sangfor，开发出了恶心的工具EasyConnect，本来这东西都是给在校的学生用的，好不好用都无所谓。但是很多公司也开始使用这个来访问内网，并且还不支持Linux(反正到目前Ubuntu下的64bit版本连接就没成功过)，这就很令人讨厌了。回想起Ubuntu下使用Wine安装微信的种种难受，决定还是使用Windows虚拟机开启EasyConnect，并把部分的Linux流量打进虚拟机。&lt;/p&gt;

</description>
        
        <pubDate>Thu, 27 Feb 2020 12:06:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Linux-Use-EasyConnect</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Linux-Use-EasyConnect</guid>
      </item>
      
    
      
      <item>
        <title>MySQL-InnoDB中的锁</title>
        
          <description>&lt;p&gt;锁在InnoDB存储引擎中的使用远比我们想象中的更加频繁，及时是一条最为简单的&lt;code class=&quot;highlighter-rouge&quot;&gt;update set&lt;/code&gt;语句，其中也涉及到了各种锁的使用。包括常说的一致性锁定读，解决幻读等场景中，同样包含了锁的大量使用。&lt;/p&gt;

</description>
        
        <pubDate>Fri, 31 Jan 2020 10:06:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/MySQL-InnoDB-Lock</link>
        <guid isPermaLink="true">https://smartkeyerror.com/MySQL-InnoDB-Lock</guid>
      </item>
      
    
      
      <item>
        <title>Golang中的interface</title>
        
          <description>&lt;p&gt;Golang除了方便使用的协程以外，最令我感到惊讶的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;interface&lt;/code&gt;，接口。在其它语言中，接口承担的主要作用为解耦和协议，但是在Golang中，&lt;code class=&quot;highlighter-rouge&quot;&gt;interface&lt;/code&gt;还作为一种”通用”类型广泛使用于标准库和第三方库中。&lt;/p&gt;

</description>
        
        <pubDate>Wed, 25 Dec 2019 08:25:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Golang-interface</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Golang-interface</guid>
      </item>
      
    
      
      <item>
        <title>Linux操作系统-文件I/O</title>
        
          <description>&lt;p&gt;在操作系统中， 最为复杂同时也最为重要的功能就是文件I/O。 一台PC可以不连接互联网， 但是一定需要程序的载入、文件的打开， 而这些操作与I/O均密不可分。 包括软件开发中， 数据库与I/O的关系密切相关， 有时衡量一个DB的效率， 其实就是在衡量其I/O效率。 理解文件I/O， 就是在理解我们常用应用软件， 如MySQL、Redis、Nginx、ES、Prometheus等的核心。&lt;/p&gt;

</description>
        
        <pubDate>Tue, 17 Dec 2019 09:39:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Linux-IO</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Linux-IO</guid>
      </item>
      
    
      
      <item>
        <title>MySQL中的悲观锁与常见的死锁场景</title>
        
          <description>&lt;p&gt;在MySQL中， 锁机制是并发条件下保护数据一致性与稳定性的一个非常重要的机制， 并且事务的实现也依赖于于锁机制。 其锁定的数据不单包括数据行记录， 同时也包括缓冲池中的LRU列表数据、日志数据等。 悲观锁(FOR UPDATE)则是日常开发中使用最多的一种锁， 但是， 由于事务隔离级别的多样性导致了悲观锁在使用时常常会有不同的表现， 死锁在程序员稍不注意时就会发生。&lt;/p&gt;

</description>
        
        <pubDate>Wed, 18 Sep 2019 21:39:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/MySQL-Pessimistic-Lock</link>
        <guid isPermaLink="true">https://smartkeyerror.com/MySQL-Pessimistic-Lock</guid>
      </item>
      
    
      
      <item>
        <title>MySQL中的联合索引与覆盖索引</title>
        
          <description>&lt;p&gt;在上一篇文章中， 通过解析InnoDB存储引擎的&lt;code class=&quot;highlighter-rouge&quot;&gt;.ibd&lt;/code&gt;数据存储文件得到了数据与索引的真实组织方式: 数据通过聚集索引在逻辑上连续存放， 二级索引保存数据主键ID(Row ID)， 多棵B+Tree组合起来提供高效的索引数据查询。 除辅助索引(二级索引)外， 联合索引与覆盖索引在日常中也会经常用到。&lt;/p&gt;

</description>
        
        <pubDate>Sun, 01 Sep 2019 21:39:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/MySQL-union-index-and-cover-index</link>
        <guid isPermaLink="true">https://smartkeyerror.com/MySQL-union-index-and-cover-index</guid>
      </item>
      
    
      
      <item>
        <title>MySQL物理存储方式</title>
        
          <description>&lt;p&gt;MySQL是基于磁盘进行数据存储的关系型数据库， 所有的数据、索引等数据均以磁盘文件的方式存储， 在有需要时载入内存读取。 为了加快数据查询的效率， 通常会在一些字段上添加索引， 但是许多文档都会告诉我们， 不要添加太多的索引， 索引不要太长， 使用数字或者空字符串来代替NULL值， 为什么会有这些建议? 这些建议又是否正确?  答案都能够从MySQL数据的物理存储方式中找到。&lt;/p&gt;

</description>
        
        <pubDate>Thu, 15 Aug 2019 21:39:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/MySQL-physical-structure</link>
        <guid isPermaLink="true">https://smartkeyerror.com/MySQL-physical-structure</guid>
      </item>
      
    
      
      <item>
        <title>数据变更操作日志设计</title>
        
          <description>&lt;p&gt;当系统的某些行为涉及到资金与资产的数据变更时，常常会为其增加操作日志，便于后续的问题排查。例如红包的使用明细，银行转账的详细记录等等。操作日志记录这个需求看起来很简单，但是深挖下去，依然能找到很有趣的东西。&lt;/p&gt;

</description>
        
        <pubDate>Sat, 10 Aug 2019 21:39:25 +0000</pubDate>
        <link>
        https://smartkeyerror.com/change-log-system-design</link>
        <guid isPermaLink="true">https://smartkeyerror.com/change-log-system-design</guid>
      </item>
      
    
      
      <item>
        <title>那些有趣的数据结构与算法(05)--限流</title>
        
          <description>&lt;p&gt;有时候限流也可以称为防刷，这两者的界定并不是很明显，常用的限流算法包括固定窗口，滑动窗口，漏桶以及令牌桶算法，它们都有各自的优势与最适合的使用场景，算法不分好坏，只分场景。&lt;/p&gt;

</description>
        
        <pubDate>Sat, 20 Jul 2019 21:54:55 +0000</pubDate>
        <link>
        https://smartkeyerror.com/limits</link>
        <guid isPermaLink="true">https://smartkeyerror.com/limits</guid>
      </item>
      
    
      
      <item>
        <title>那些有趣的数据结构与算法(04)--B-Tree与B+Tree</title>
        
          <description>&lt;p&gt;树型结构由于其良好的递归特性， 高效的查询效率， 在软件系统设计中有着非常广泛的使用。 IO多路复用的epoll实现采用红黑树组织和管理sockfd， 以支持快速的增删改查； Golang中的Timer采用多叉堆实现； Java中的TreeMap以及TreeSet同样采用红黑树实现…而在MySQL中， 索引的构建同样采用树结构实现。&lt;/p&gt;

</description>
        
        <pubDate>Sun, 23 Jun 2019 16:01:47 +0000</pubDate>
        <link>
        https://smartkeyerror.com/B+Tree-and-B-Tree</link>
        <guid isPermaLink="true">https://smartkeyerror.com/B+Tree-and-B-Tree</guid>
      </item>
      
    
      
      <item>
        <title>DevOps基础(1)--Shell脚本编程</title>
        
          <description>&lt;p&gt;由于Docker容器以及Kubernetes容器编排服务的蓬勃发展， 服务器以及业务服务的运维不再是运维工程师的专属， 业务的开发工程师也必须加入到运维的领域之中， 与运维工程师合作， 形成一套完整、高效的自动化运维与部署的系统。 而在我看来， 传统的运维工程师将会逐渐被应用开发工程师所取代， 因为Kubernetes赋予了开发人员强大的负载均衡、自动横向拓展以及高效管理的相关功能。 而在这些宏大的系统建设之前， Shell编程是无论如何都离不开的话题。&lt;/p&gt;

</description>
        
        <pubDate>Mon, 17 Jun 2019 09:31:51 +0000</pubDate>
        <link>
        https://smartkeyerror.com/shell-programing</link>
        <guid isPermaLink="true">https://smartkeyerror.com/shell-programing</guid>
      </item>
      
    
      
      <item>
        <title>DevOps基础(2)--Ansible自动化运维工具</title>
        
          <description>&lt;p&gt;Shell脚本能够为我们提供一部分的系统运维功能， 例如定时任务， 由Jenkins所管理的边缘触发任务等等， 但是如果想要对多台服务器进行管理和运维， 就需要Ansible来协助完成。&lt;/p&gt;

</description>
        
        <pubDate>Mon, 17 Jun 2019 08:33:42 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Ansible</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Ansible</guid>
      </item>
      
    
      
      <item>
        <title>操作系统原理(01)-I/O</title>
        
          <description>&lt;p&gt;在写了许多代码， 搭建了一些分布式服务之后， 越发觉得一个大型的高并发系统就是一个操作系统。 在分布式系统中， 我们会讲数据一致性， 如何做到缓存和DB的一致性， 这也是操作系统需要解决的问题: 内核高速页缓存如何与磁盘文件数据一致。 又比如对于一些耗时且非必需的任务， 在分布式系统中很有可能采用消息队列来进行异步处理， 例如邮件的发送， 而在操作系统中， I/O也是一个非常耗时的任务， 同样采用了异步处理的方式来最大化的利用系统资源， 只不过并不是采用消息队列而已。&lt;/p&gt;

</description>
        
        <pubDate>Mon, 15 Apr 2019 10:17:46 +0000</pubDate>
        <link>
        https://smartkeyerror.com/operation-system-with-IO</link>
        <guid isPermaLink="true">https://smartkeyerror.com/operation-system-with-IO</guid>
      </item>
      
    
      
      <item>
        <title>分布式系统基础学习(05)--分布式缓存设计</title>
        
          <description>&lt;p&gt;在单机缓存中， 并发的安全性问题与语言的并发安全问题完全可以归为一类， 缓存的穿透问题可以采用巧妙的数据结构进行处理， 很多问题本质上仍然是一些基础问题。&lt;/p&gt;

</description>
        
        <pubDate>Mon, 01 Apr 2019 10:17:46 +0000</pubDate>
        <link>
        https://smartkeyerror.com/distributed-cache</link>
        <guid isPermaLink="true">https://smartkeyerror.com/distributed-cache</guid>
      </item>
      
    
      
      <item>
        <title>一文理解Flask Web开发</title>
        
          <description>&lt;p&gt;Flask作为Python语言中最为轻量的Web框架， 由于其核心内容的简洁以及良好的可拓展性， 一直受到广泛的开发者所喜爱。 对比于Django， Flask并没有”我给你的就是最好的， 别管那么多， 拿着用就好”的思想， 而是让开发者自己做出选择， 自己设计开发一个组件， 或者挑选一个你喜欢的第三方库。&lt;/p&gt;

</description>
        
        <pubDate>Sun, 31 Mar 2019 09:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Flask-Web</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Flask-Web</guid>
      </item>
      
    
      
      <item>
        <title>那些有趣的数据结构与算法(03)--并查集</title>
        
          <description>&lt;p&gt;在《算法》(第四版)的第一章最后一小节中， 也就是”案例研究: union-find算法”这一小节， 我看到了并查集。 在我完整的阅读了所有的算法内容之后， 脑子里只剩下两个字: 优美。&lt;/p&gt;

</description>
        
        <pubDate>Mon, 25 Mar 2019 15:02:02 +0000</pubDate>
        <link>
        https://smartkeyerror.com/UnionFind</link>
        <guid isPermaLink="true">https://smartkeyerror.com/UnionFind</guid>
      </item>
      
    
      
      <item>
        <title>那些有趣的数据结构与算法(02)--Bitmap</title>
        
          <description>&lt;p&gt;在我刚接触Python这门开发语言时， 并没有想用它做Web后端开发， 而是拿来写爬虫。 第一个接触的爬虫框架就是Scrapy。 网络爬虫绕不开的一个话题就是URL去重问题。 在Scrapy原生框架下， 使用的是集合来对URL进行去重的。 集合本身采用哈希表实现， 是一种典型的以空间换时间的数据结构， 当URL数量极为庞大时， 使用这种策略的去重很有可能导致内存溢出而造成服务器宕机的问题。 此时， Bitmap走进了我的视线。&lt;/p&gt;

</description>
        
        <pubDate>Mon, 18 Mar 2019 15:02:02 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Bitmap</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Bitmap</guid>
      </item>
      
    
      
      <item>
        <title>Redis基本数据结构与实现</title>
        
          <description>&lt;p&gt;Redis内置了5种对外开放的数据结构， 分别是字符串， 列表， 集合， 有序集合以及哈希对象。 每一种数据结构的底层实现都会由存入的数据产生动态变化， 这也是Redis具有极佳吞吐量的原因之一。 本篇文章主要描述其基本数据结构的实现以及这些结构在使用时的注意事项。&lt;/p&gt;

</description>
        
        <pubDate>Wed, 13 Mar 2019 09:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Redis-base-data-structure</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Redis-base-data-structure</guid>
      </item>
      
    
      
      <item>
        <title>那些有趣的数据结构与算法(01)--优先队列</title>
        
          <description>&lt;p&gt;优先队列为动态变化的数据赋予了高效且准确的排序能力， 尽管有非常大规模的数据， 二叉堆所实现的优先队列依然能够表现出色。&lt;/p&gt;

</description>
        
        <pubDate>Tue, 12 Mar 2019 14:54:58 +0000</pubDate>
        <link>
        https://smartkeyerror.com/PriorityQueue</link>
        <guid isPermaLink="true">https://smartkeyerror.com/PriorityQueue</guid>
      </item>
      
    
      
      <item>
        <title>分布式系统基础学习(04)--Nginx</title>
        
          <description>&lt;p&gt;Nginx不管是在单机部署还是在集群部署下， 都起着非常重要的作用。 底层由C语言编写， 并且采用事件驱动模型对Socket连接进行管理， 所以有着非常高效的请求处理能力， 并且支持海量的并发。 本篇文章不会对Nginx的底层原理进行深究， 而是整理自己在工作中所遇到的一些问题和积累的经验。&lt;/p&gt;

</description>
        
        <pubDate>Tue, 15 Jan 2019 10:09:44 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Nginx</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Nginx</guid>
      </item>
      
    
      
      <item>
        <title>分布式系统基础学习(03)--消息队列(RabbitMQ)</title>
        
          <description>&lt;p&gt;消息队列常常被用于跨进程通信， 异步调用， 系统解耦以及流量削峰等场景下。 目前市场上的消息队列种类繁多， 有LinkedIn开源的&lt;code class=&quot;highlighter-rouge&quot;&gt;kafka&lt;/code&gt;， 阿里开源的&lt;code class=&quot;highlighter-rouge&quot;&gt;RocketMQ&lt;/code&gt;， 以及使用较为广泛的&lt;code class=&quot;highlighter-rouge&quot;&gt;RabbiMQ&lt;/code&gt;。 &lt;code class=&quot;highlighter-rouge&quot;&gt;Redis&lt;/code&gt;虽然也可以做消息队列， 但是更多的是用来做缓存和其它工具使用。 但是随着Redis 5.0 版本的发布， Redis的功能越来越丰富， 也不排除在未来的某一天也能够占据消息队列的重要一席。&lt;/p&gt;

</description>
        
        <pubDate>Fri, 11 Jan 2019 09:52:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/message-queue</link>
        <guid isPermaLink="true">https://smartkeyerror.com/message-queue</guid>
      </item>
      
    
      
      <item>
        <title>分布式系统基础学习(01)--通信(TCP/UDP)</title>
        
          <description>&lt;p&gt;分布式系统是一个很庞大的话题， 在我个人的知识版图中， 也仅仅只是对一小部分土地进行了开荒。 不管是分布式系统， 还是单机应用系统， 都是建立在互联网通信机制之上的。 而提到通信， 就不得不提到&lt;code class=&quot;highlighter-rouge&quot;&gt;TCP/UDP&lt;/code&gt;这两个非常经典的协议。&lt;/p&gt;

</description>
        
        <pubDate>Thu, 03 Jan 2019 09:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/distributed-system-of-communication</link>
        <guid isPermaLink="true">https://smartkeyerror.com/distributed-system-of-communication</guid>
      </item>
      
    
      
      <item>
        <title>Java并发编程(07)--锁</title>
        
          <description>&lt;p&gt;锁在并发编程中可以说是必须使用的一种资源保护技术， 而且是一种及其庞大且复杂的技术， 随着计算机学科的发展， 锁技术同样的在不断的发展和优化。 作为一个开发者， 当然无法直接深入到CPU的最底层去理解锁的原理， 但是通过一些其它的手段可以间接的理解锁的原理以及运行机制。
本篇文章进行一个现阶段的总结， 整理一下所学的全部关于锁的知识， 涉及的编程语言包括&lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;， 应用包括&lt;code class=&quot;highlighter-rouge&quot;&gt;MySQL&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;Redis&lt;/code&gt;， 如有错误， 还请指正。&lt;/p&gt;

</description>
        
        <pubDate>Mon, 31 Dec 2018 09:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Lock</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Lock</guid>
      </item>
      
    
      
      <item>
        <title>Java并发编程(06)--AbstractQueuedSynchronizer</title>
        
          <description>&lt;p&gt;在整理下一篇文章， 有关锁的知识之前， 有一个无论如何都绕不开的话题：&lt;code class=&quot;highlighter-rouge&quot;&gt;AbstractQueuedSynchronizer&lt;/code&gt;， 队列同步器， 通常简称AQS。&lt;/p&gt;

</description>
        
        <pubDate>Wed, 26 Dec 2018 09:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/AbstractQueuedSynchronizer</link>
        <guid isPermaLink="true">https://smartkeyerror.com/AbstractQueuedSynchronizer</guid>
      </item>
      
    
      
      <item>
        <title>Java并发编程(05)--Python线程池源码剖析</title>
        
          <description>&lt;p&gt;本来是一个对&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;并发编程的一个学习和总结专题， 虽然&lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt;有&lt;code class=&quot;highlighter-rouge&quot;&gt;GIL&lt;/code&gt;的存在， 但不能否认其线程池的实现非常的简洁而优雅， 此外温故而知新， 通过理解其它语言的线程池也能够加深我们对&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;线程池的理解。&lt;/p&gt;

</description>
        
        <pubDate>Mon, 24 Dec 2018 09:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Python-ThreadingPool</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Python-ThreadingPool</guid>
      </item>
      
    
      
      <item>
        <title>Java并发编程(04)--线程池</title>
        
          <description>&lt;p&gt;抛开&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;自己封装的&lt;code class=&quot;highlighter-rouge&quot;&gt;newFixedThreadPool&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;newCachedThreadPool&lt;/code&gt;等工厂线程池方法， 最核心的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt;的配置， 包括线程池的大小， 工作队列， 空闲线程存活时间以及饱和策略。&lt;/p&gt;

</description>
        
        <pubDate>Tue, 18 Dec 2018 09:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Java-ThreadingPool</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Java-ThreadingPool</guid>
      </item>
      
    
      
      <item>
        <title>Java并发编程(03)--任务的取消与异常处理</title>
        
          <description>&lt;p&gt;在前面的一章整理并发编程的一些基础内容， 包括任务的创建， 任务的执行， 线程池的简单使用， 加入一个线程以及守护线程和线程同步。 基本上涵盖了绝大多数的基础内容， 在本章中学习任务的取消与异常处理。&lt;/p&gt;

</description>
        
        <pubDate>Fri, 14 Dec 2018 09:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/task-cancel-and-exception</link>
        <guid isPermaLink="true">https://smartkeyerror.com/task-cancel-and-exception</guid>
      </item>
      
    
      
      <item>
        <title>Java并发编程(02)--CPU和缓存一致性</title>
        
          <description>&lt;p&gt;在继续学习&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;并发编程之前， CPU的执行过程以及CPU缓存一致性问题是必须要了解的， 这一部分的内容是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;并发设计的基石， 对后续内容的了解也有非常大的帮助。&lt;/p&gt;

</description>
        
        <pubDate>Tue, 11 Dec 2018 09:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/CPU-and-cache</link>
        <guid isPermaLink="true">https://smartkeyerror.com/CPU-and-cache</guid>
      </item>
      
    
      
      <item>
        <title>Java并发编程(01)--基础学习</title>
        
          <description>&lt;p&gt;打了2年多的&lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt;代码， 大大小小的项目也做了一些， 代码规范和并发效率一直以来是比较头疼的问题。 因为&lt;code class=&quot;highlighter-rouge&quot;&gt;GIL&lt;/code&gt;全局解释器锁的存在使得&lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt;程序员永远只能使用单核， 并且在锁的保护下许多的效率问题都被掩盖。 在学习了&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;之后， 对其并发模块的设计深感惊艳， 比如&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;的分段锁实现， &lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;关键字保证变量的可见性， 所以在这里对其进行整理并进一步加深理解。&lt;/p&gt;

</description>
        
        <pubDate>Mon, 10 Dec 2018 08:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Java-Concurrent-Base</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Java-Concurrent-Base</guid>
      </item>
      
    
      
      <item>
        <title>Java基础编程(06)--反射</title>
        
          <description>&lt;p&gt;为了保持&lt;code class=&quot;highlighter-rouge&quot;&gt;Java基础编程&lt;/code&gt;系列的完整性， 反射机制还是写一下， 没有什么太难的地方。 在文章的最后与&lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt;进行了一个对比和演示， 用于加深对这两种语言设计本身的理解。&lt;/p&gt;

</description>
        
        <pubDate>Fri, 07 Dec 2018 08:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Reflect</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Reflect</guid>
      </item>
      
    
      
      <item>
        <title>Java基础编程(05)--常用的设计模式(02)</title>
        
          <description>&lt;p&gt;在前面的一篇文章中大致了描述了单例模式， 原型模式， 策略模式， 责任链模式， 代理模式以及观察者模式， 本文接上。&lt;/p&gt;

</description>
        
        <pubDate>Wed, 05 Dec 2018 11:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Java-Design-Pattern-02</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Java-Design-Pattern-02</guid>
      </item>
      
    
      
      <item>
        <title>Java基础编程(04)--常用的设计模式(01)</title>
        
          <description>&lt;p&gt;在前面&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;系统中介绍了装饰模式， 在&lt;code class=&quot;highlighter-rouge&quot;&gt;接口与抽象类&lt;/code&gt;中介绍了适配器模式， 以及设计模式的基础， 设计原则。 设计模式其实并没有那么神秘， 那么复杂， 本质上仍然是六大设计原则的体现。 既然要写， 就把所有的设计模式统统讲完， 才有快感。 另外这篇文章同样也会结合&lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt;语言中的设计模式一起进行梳理， 这样做会进一步的加深我们对设计模式的理解， 至少在我这里是这样的。&lt;/p&gt;

</description>
        
        <pubDate>Wed, 05 Dec 2018 10:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Java-Design-Pattern</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Java-Design-Pattern</guid>
      </item>
      
    
      
      <item>
        <title>Java基础编程(03)--容器</title>
        
          <description>&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中的各种容器类是对基本数据结构， 如顺序表， 链表， 平衡二叉树， 红黑树等最直接的体现， 容器在使用时最重要的就是其在不同的应用场景下的时间复杂度。 例如， 需要一个有序的容器， 需要频繁的向其头部和尾部分别执行删除和插入操作， 此时选择数组所实现的容器就非常的不明智。 所以， 如果想要彻底理解&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中的容器， 首先要理解计算机世界中的基础数据结构。 另外需要说明的是， 本篇博文没有任何代码， 只对各种容器的原理进行说明。&lt;/p&gt;

</description>
        
        <pubDate>Sat, 01 Dec 2018 04:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Java-Container</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Java-Container</guid>
      </item>
      
    
      
      <item>
        <title>Java基础编程(02)--接口与抽象类</title>
        
          <description>&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中， 我认为接口和抽象类是能够让”匠人”充分发挥其想象力和创造力的地方， 这两个类结构使得软件大师们能够编写出精美， 优雅和巧妙的代码。 而在我这种低端程序员手中， 它仅仅只是一个结构而已， 离品尝到其设计精髓不知还隔着多少座大山。&lt;/p&gt;

</description>
        
        <pubDate>Fri, 30 Nov 2018 02:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Java-Interface-and-abstract-class</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Java-Interface-and-abstract-class</guid>
      </item>
      
    
      
      <item>
        <title>Java基础编程(01)--I/O系统</title>
        
          <description>&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中的I/O系统相较于&lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt;要复杂许多， 不管是从设计上还是实现上。 这一块儿的内容也是我在学习&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;时遇到的最大的困难(并发包都比这个好理解)， 经过了持(san)之(tian)以(da)恒(yu)的学习之后， 算是对Java I/O系统有一个基本的认识和理解。&lt;/p&gt;

</description>
        
        <pubDate>Thu, 29 Nov 2018 02:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/Java-IO</link>
        <guid isPermaLink="true">https://smartkeyerror.com/Java-IO</guid>
      </item>
      
    
      
      <item>
        <title>MySQL权限管理</title>
        
          <description>&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MySQL&lt;/code&gt;的权限管理重要性等同于服务器数据的重要性， 权限体系如果建立的不到位的话， 也就意味着生产数据处于危险状态。&lt;/p&gt;

</description>
        
        <pubDate>Tue, 30 Oct 2018 09:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/MySQL-Permissions</link>
        <guid isPermaLink="true">https://smartkeyerror.com/MySQL-Permissions</guid>
      </item>
      
    
      
      <item>
        <title>MySQL慢查询日志分析工具</title>
        
          <description>&lt;p&gt;慢查询日志使我们对MySQL进行性能优化的关键指标， 只有在确定了哪些查询的确是慢查询之后才能对症下药， 进行性能优化， 而不是凭自身的感觉去判断， 结果有事往往出乎意料。 直接打开慢查询日志进行查看效率比较低效， 所以需要借助&lt;code class=&quot;highlighter-rouge&quot;&gt;pt-query-digest&lt;/code&gt;工具来进行分析。&lt;/p&gt;

</description>
        
        <pubDate>Thu, 25 Oct 2018 09:49:09 +0000</pubDate>
        <link>
        https://smartkeyerror.com/MySQL-slow-query-analysis-tool</link>
        <guid isPermaLink="true">https://smartkeyerror.com/MySQL-slow-query-analysis-tool</guid>
      </item>
      
    
      
      <item>
        <title>binlog的正确打开方式</title>
        
          <description>&lt;p&gt;在前面的主从复制中我们提到了bin-log， 主从复制中bing-log主要作为一种增量复制的方法进行主库与从库的同步。 在日常生产中， bin-log常常也作为实时数据恢复的必要手段。&lt;/p&gt;

</description>
        
        <pubDate>Tue, 23 Oct 2018 10:18:00 +0000</pubDate>
        <link>
        https://smartkeyerror.com/MySQL-binlog</link>
        <guid isPermaLink="true">https://smartkeyerror.com/MySQL-binlog</guid>
      </item>
      
    
      
      <item>
        <title>Django处理数据并发问题</title>
        
          <description>&lt;p&gt;在Web开发中， 请求的并发处理通常会直接反映到数据库中数据的并发处理。 如果需要在并发的条件下保证数据的准确性， 则必须借助锁的力量来完成。 锁又分乐观锁和悲观锁， 表示了世界的两极。 本篇文章只是以Django作为载体， 来描述数据的并发处理。&lt;/p&gt;

</description>
        
        <pubDate>Tue, 18 Sep 2018 10:18:00 +0000</pubDate>
        <link>
        https://smartkeyerror.com/django-concurrent-data-process</link>
        <guid isPermaLink="true">https://smartkeyerror.com/django-concurrent-data-process</guid>
      </item>
      
    
  </channel>
</rss>
