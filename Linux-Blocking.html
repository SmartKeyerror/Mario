<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>Linux 阻塞与唤醒实现原理</title>
    <meta name="description" content="Keep coding, Keep curiosity" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />

    <!-- highlight.js -->
<!--    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">-->
<!--    <style>.hljs { background: none; }</style>-->

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="https://smartkeyerror.com//Linux-Blocking" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/page2/" />

    <meta property="og:site_name" content="知其然, 知其所以然" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Linux 阻塞与唤醒实现原理" />
    <meta property="og:description" content="Keep coding, Keep curiosity" />
    <meta property="og:url" content="https://smartkeyerror.com//Linux-Blocking" />
    <meta property="og:image" content="/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Linux 阻塞与唤醒实现原理" />
    <meta name="twitter:description" content="Keep coding, Keep curiosity" />
    <meta name="twitter:url" content="https://smartkeyerror.com//Linux-Blocking" />
    <meta name="twitter:image:src" content="/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "知其然, 知其所以然",
    "name": "Linux 阻塞与唤醒实现原理",
    "url": "https://smartkeyerror.com//Linux-Blocking",
    "image": "/assets/images/cover1.jpg",
    "description": "Keep coding, Keep curiosity"
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="知其然, 知其所以然" href="/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/">Home</a></li>
        <li class="nav-archives " role="presentation"><a href="/archives">Archives</a></li>
        <li class="nav-about " role="presentation"><a href="/about">About</a></li>
    </ul>
<!--    <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>-->
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">Linux 阻塞与唤醒实现原理</h1>
            <section class="post-meta">
            <!-- <a href='/'></a> -->

            
                
                    <a href='/author/smartkeyerror'>smartkeyerror</a>
                
            
            <time class="post-date" datetime="2020-09-09">09 Sep 2020</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/tag/Linux'>Linux</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <p>在前面的文件 I/O 文章中，我们有提到 Linux 文件 I/O 支持阻塞和非阻塞的数据读取方式，当采用阻塞方式进行 I/O 时，进程将会阻塞在<code class="highlighter-rouge">read()</code>或者<code class="highlighter-rouge">write()</code>系统调用上，直到文件可读或者是内核缓冲区可写。这些阻塞与唤醒的实现与内核调度紧密相关，Linux 内核使用等待队列和完成量来实现该功能。</p>
<blockquote>
  <p>注: 本篇文章所用Linux内核源码版本为v5.8</p>
</blockquote>

<!---more--->

<h3 id="1-进程状态有限状态机">1. 进程状态有限状态机</h3>

<p>进程并不总是可以立即运行的，一方面是 CPU 资源有限，另一方面则是进程时常需要等待外部事件的发生，例如 I/O 事件、定时器事件等。</p>

<p>因此，对进程的状态进行分类就是一件非常有必要的事情，对于等待某事件发生的进程给予 CPU 资源是没有任何意义的，因为此时事件可能仍未发生。而对于正等待 CPU 资源的进程而言，在得到 CPU 之后即可立即执行。调度器为了尽可能最大地使用硬件资源，通常会将进程分为3个主要的状态: 运行、等待和睡眠。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/schedule/process-state.png" alt="" /></p>

<p>处于运行状态的进程正在使用 CPU 等资源，从上图中可以看到，运行态的进程在执行完任务后结束，进入到结束状态。当 CPU 时间片到期之后，调度器选择其它进程执行，此时将进入等待状态。同时，当运行时的进程发起 I/O 操作，或者等待其它事件的发生时，将进入睡眠状态。</p>

<p>处于等待状态的进程由于缺少 CPU 资源而被迫停止运行，只要调度器下次选中该进程即可立即执行，由等待状态转变为运行状态。</p>

<p>处于睡眠状态的进程在等待外部事件的发生，例如 I/O 操作的数据抵达，创建的定时器到期等等，<strong>处于睡眠状态的进程永远不会被调度器进行选择并执行</strong>。当期望的事件到达后，进程由睡眠状态更改为等待状态，等待调度器的下一次选择。</p>

<p>处于等待的进程将会被放置于就绪队列中（红黑树实现），而处于睡眠状态的进程则放置于等待队列（双链表实现）中。调度器的目光主要放在就绪队列上，从该队列中取出下一个将要执行的进程，而等待队列和就绪队列中的进程会因为事件的发生而进行相互转移。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/schedule/read-and-wait-queue.png" alt="" /></p>

<p>在实际的内核实现中，进程的运行状态表示要比上文所述更加详细一些，进程状态定义于<code class="highlighter-rouge">include/linux/sched.h</code>:</p>

<ul>
  <li><code class="highlighter-rouge">TASK_RUNNING</code>，可运行状态。此时进程并不一定正在运行，一旦得到调度器的调度即可立即运行。</li>
  <li><code class="highlighter-rouge">TASK_INTERRUPTIBLE</code>，可中断睡眠状态。此时进程因为等待外部事件的发生而睡眠，此时可由信号或者是内核唤醒。</li>
  <li><code class="highlighter-rouge">TASK_UNINTERRUPTIBLE</code>，不可中断睡眠状态。和<code class="highlighter-rouge">TASK_INTERRUPTIBLE</code>状态类似，等待外部事件发生的睡眠状态。不同的是改状态只能由内核亲自唤醒，不能由信号唤醒，通常用于进程必须等待某件工作完成，不能被 Kill。</li>
</ul>

<p>除了这三个核心进程状态以外，还有<code class="highlighter-rouge">__TASK_STOPPED</code>、<code class="highlighter-rouge">__TASK_TRACED</code>等状态，由于这些状态在本文中并不重要，所以略去。</p>

<h3 id="2-等待队列">2. 等待队列</h3>

<p>等待队列相关的源码位于<code class="highlighter-rouge">include/linux/wait.h</code>以及<code class="highlighter-rouge">kernel/sched/wait.c</code>文件中，头文件中定义了等待队列以及队列元素的基本数据结构，<code class="highlighter-rouge">wait.c</code>源文件则主要包含具体的方法实现。</p>

<p>首先来看等待队列的基本结构，分为队列头和队列项:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 等待队列头 */</span>
<span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>       <span class="cm">/* 自旋锁 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">head</span><span class="p">;</span>   <span class="cm">/* previous、next指针 */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="n">wait_queue_head_t</span><span class="p">;</span>

<span class="cm">/* 等待队列元素 */</span>
<span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>  <span class="cm">/* 标识位 */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="k">private</span><span class="p">;</span>   <span class="cm">/* 通常指向等待进程 */</span>
	<span class="n">wait_queue_func_t</span>	<span class="n">func</span><span class="p">;</span>   <span class="cm">/* 唤醒函数 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">entry</span><span class="p">;</span>  <span class="cm">/* previous、next指针 */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在内核的链表实现中，绝大多数的链表均为循环双链表，等待队列也不例外。因为等待队列可能会在系统中断时进行修改，所以必须要添加互斥锁机制保护队列元素。</p>

<p>等待队列元素的设计也非常简洁，除了双链表必要的前后指针以外，仅包含一个指向等待进程<code class="highlighter-rouge">task_struct</code>实例的指针，一个唤醒函数和一个标识位。</p>

<p>唤醒函数通常由调度器实现，如<code class="highlighter-rouge">kernel/sched/core.c</code>中定义的<code class="highlighter-rouge">try_to_wake_up</code>方法，可以简单的认为唤醒函数就是将进程的状态由<code class="highlighter-rouge">TASK_INTERRUPTIBLE</code>或<code class="highlighter-rouge">TASK_UNINTERRUPTIBLE</code>修改为<code class="highlighter-rouge">TASK_RUNNING</code>，并将其加入至就绪队列中。</p>

<p><code class="highlighter-rouge">wait.h</code>中提供了一系列与等待队列相关的宏定义供外部使用，例如<code class="highlighter-rouge">wait_event</code>，本质上是对等待队列的进一步封装:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define wait_event(wq_head, condition)						\
do {										\
	might_sleep();								\
	if (condition)								\
		break;								\
    </span><span class="cm">/* 这里将原有的__wait_event宏展开，使用___wait_event代替 */</span><span class="cp">     \
	___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0, schedule())	\
} while (0)
</span></code></pre></div></div>

<p>其中<code class="highlighter-rouge">wq_head</code>即<code class="highlighter-rouge">wait_queue_head</code>，<code class="highlighter-rouge">condition</code>则是一个C语言表达式，表示一个等待条件。宏定义的<code class="highlighter-rouge">wait_event</code>使得使用标准C表达式指定条件成为可能，如果使用函数实现的话，无法做到如宏实现的灵活性。注意到在调用<code class="highlighter-rouge">___wait_event</code>之前会首先检查一遍条件是否满足，避免进行无效的睡眠。</p>

<p>在<code class="highlighter-rouge">___wait_event</code>宏定义中传入的进程状态为<code class="highlighter-rouge">TASK_UNINTERRUPTIBLE</code>，也就是说，<code class="highlighter-rouge">wait_event</code>实现的事件等待是不可中断的。当然，<code class="highlighter-rouge">wait.h</code>中同样提供了其它时间等待实现:</p>

<ul>
  <li><code class="highlighter-rouge">wait_event_timeout</code>: 带有超时时间的不可中断事件等待</li>
  <li><code class="highlighter-rouge">wait_event_interruptible</code>: 可中断的事件等待</li>
  <li><code class="highlighter-rouge">wait_event_interruptible_timeout</code>: 带有超时时间的可中断事件等待</li>
</ul>

<p>最后再来看<code class="highlighter-rouge">___wait_event</code>实现，该方法将会把当前进程包装成<code class="highlighter-rouge">wait_queue_entry</code>对象，并发安全地放置于等待队列中，并且在实际的让出CPU资源、引发调度器重新调度之前会再一次的检查等待事件是否发生，避免无效睡眠。由于源代码中该方法宏定义实现符号较多，所以将原实现抽象成伪代码:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">___wait_event</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">exclusive</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 初始化队列元素 */</span>
    <span class="n">init_wait_entry</span><span class="p">(...);</span>
    
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="cm">/* 将队列元素插入至等待队列中(线程安全) */</span>
        <span class="kt">long</span> <span class="n">__int</span> <span class="o">=</span> <span class="n">prepare_to_wait_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__wq_entry</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
        
        <span class="cm">/* 检查事件条件是否满足 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
            
        <span class="cm">/* 触发调度器重新调度 */</span>
        <span class="n">schedule</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于唤醒一个进程在前文中已经描述过了，通用方法为<code class="highlighter-rouge">wake_up()</code>，本质上会调用内核调度模块中的<code class="highlighter-rouge">try_to_wake_up()</code>来唤醒某个进程，唤醒的实质是将进程状态修改为<code class="highlighter-rouge">TASK_RUNNING</code>，从等待队列中移出并加入至就绪队列中。</p>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/author/smartkeyerror" style="background-image: url(/assets/images/author.jpg)"><span class="hidden">smartkeyerror's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/author/smartkeyerror">smartkeyerror</a></h4>

                        
                            <p> 日拱一卒，功不唐捐</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> China</span>
                            <span class="author-link icon-link"><a href="https://smartkeyerror.com"> https://smartkeyerror.com</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=Linux 阻塞与唤醒实现原理&amp;url=https://smartkeyerror.comLinux-Blocking"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://smartkeyerror.comLinux-Blocking"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=https://smartkeyerror.comLinux-Blocking"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            

            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>

<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story no-cover" href="/c-pointers-and-memory">
            <section class="post">
                <h2>C指针与内存</h2>
                <p>C 语言指针真正精髓的地方在于指针可以进行加减法，这一点极大的提升了程序的对指针使用的灵活性，同时也带来了不小的学习负担。正是因为 C 语言指针可运算，才奠定了如今 C 语言的地位。

</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev no-cover" href="/Kubernetes-Informer">
            <section class="post">
                <h2>Kubernetes-Informer</h2>
                <p>Kubernetes 声明式API的核心就在于用户提交的YAML文件表示期望状态，Kubernetes 需要根据该期望状态与集群实际状态进行对比，并根据对比的结果作出相应的操作。期望状态由 APIServer 保存在 Etcd 中，Kubernetes 对资源进行调谐时，是否均需要通过 APIServer 查询 Etcd 来获取期望状态呢?

</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/">知其然, 知其所以然</a> &copy; 2020</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/10.1.2/styles/monokai-sublime.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="https://cdn.bootcdn.net/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-150652886-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/assets/js/index.js"></script>

</body>
</html>
