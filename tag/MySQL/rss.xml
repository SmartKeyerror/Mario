<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description>Keep coding, Keep curiosity</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>MySQL向客户端发送数据，客户端不接收会发生什么?</title>
	  <link>//MySQL-Sending-Data</link>
	  <author></author>
	  <pubDate>2020-06-17T10:50:25+00:00</pubDate>
	  <guid>//MySQL-Sending-Data</guid>
	  <description><![CDATA[
	     <p>MySQL服务端在发送数据时，为了减少数据在用户空间和内核空间的复制次数，往往会使用缓冲区对数据进行缓冲。那么，如果客户端在接收大量数据时，选择不接收，或者处理非常慢的时候，会影响MySQL的正常运行吗?</p>

<!---more--->

<h3 id="1-tcp连接的收发模型">1. TCP连接的收发模型</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/TCP-buffer.png" alt="" /></p>

<p>当调用<code class="highlighter-rouge">write()</code>或者<code class="highlighter-rouge">send()</code>系统调用向socket写入数据时，并不会直接被发送至网络，而是被发送至位于内核空间的TCP发送缓冲区。在缓冲区中，由TCP连接的窗口控制发送频率和数量。当发送缓冲区已满时，阻塞模式下的<code class="highlighter-rouge">write()</code>调用将会一直阻塞，直到有可用的发送缓冲区为止。而非阻塞模式下则会直接返回-1，<code class="highlighter-rouge">errno</code>将会被置为<code class="highlighter-rouge">EAGAIN</code>或者是<code class="highlighter-rouge">EWOULDBLOCK</code>。</p>

<p>对于<code class="highlighter-rouge">read()</code>或者是<code class="highlighter-rouge">recv()</code>系统调用读取socket数据时，情况和发送数据基本类似，只不过是读取接收缓冲区中的内容。阻塞模式下如果接收缓冲区为空，那么将会阻塞，而非阻塞模式下则会立即返回，<code class="highlighter-rouge">errno</code>为<code class="highlighter-rouge">EAGAIN</code>或者是<code class="highlighter-rouge">EWOULDBLOCK</code>。</p>

<p>接收方与发送方的窗口大小、MSS大小以及网络状况都会对发送缓冲区的动态大小变化造成影响。当接收方的缓冲区较小时，也就意味地接收窗口较小，那么当发送方持续发送数据时，很有可能将发送缓冲区填满导致发送方数据写入的阻塞。同样地，如果发送方的网络出现波动导致大量的丢包，由拥塞避免阶段重新进入慢启动阶段，也会导致发送缓冲区的数据不能及时地发出。</p>

<p>在一般的Linux操作系统下，发送缓冲区和接收缓冲区的的大小默认为208K。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span><span class="nb">cat</span> /proc/sys/net/core/wmem_default
212992
smartkeyerror@Zero:~<span class="nv">$ </span><span class="nb">cat</span> /proc/sys/net/core/rmem_default
212992
</code></pre></div></div>

<h3 id="2-mysql结果发送与客户端接收">2. MySQL结果发送与客户端接收</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/MySQL-Send.png" alt="" /></p>

<p>当客户端向MySQL请求查询数据时，MySQL会将结果暂存于net_buffer中，net_buffer的大小默认为16K，由参数<code class="highlighter-rouge">net_buffer_length</code>决定。当net_buffer已满或者是无更多结果时，调用网络接口将数据写入至TCP连接的发送缓冲区中。如果发送缓冲区已满，那么该查询请求的数据发送将会阻塞，直到有可用的发送缓冲区为止。</p>

<p>当TCP发送缓冲区已满时，通过<code class="highlighter-rouge">show processlist</code>将会得到Query语句”正在发送给客户端”的结果:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/Sending-To-Client.png" alt="" /></p>

<p>当出现State为<code class="highlighter-rouge">Sending to client</code>的查询语句时，表示当前线程已将TCP发送缓冲区填满，无法继续发送数据给客户端，并等待客户端接收数据。</p>

<p>如果出现了较多的<code class="highlighter-rouge">Sending to client</code>状态的线程，那么要么是客户端网络情况较差，要么是客户端在处理结果时过慢，此时需要优化客户端代码。</p>

<p><code class="highlighter-rouge">Sending to client</code>状态需要和<code class="highlighter-rouge">Sending data</code>状态区分开来，前者表示正在等待客户端接收结果，而后者则表示事务正在执行(不一定在发送数据，也可能在等待锁)。</p>

<h3 id="3-客户端不接收mysql的发送数据会发生什么">3. 客户端不接收MySQL的发送数据会发生什么?</h3>

<h4 id="31-innodb的一致性非锁定读">3.1 InnoDB的一致性非锁定读</h4>

<p>在InnoDB存储引擎中，每条UPDATE语句都会默认的在该TABLE上添加一个意向写锁(IX Lock)，并且在要修改的数据行上添加X Lock，防止其它线程对其同时更新。而在这个过程中，普通的数据读取操作依然能够进行，并不会等待X Lock的释放，极大的提升了数据库的并发读取能力，该读取方式称为一致性非锁定读，由undo段实现。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/undo-read.png" alt="" /></p>

<p>在undo段中，同一行数据可能因为事务并发的执行而导致出现多个版本的快照，在一致性非锁定读中，只需要选择其中一个快照数据进行读取即可。在RC隔离级别，总是读取最新版本的快照数据，而在RR隔离级别下，总是读取事务开始时的行数据版本。</p>

<h4 id="32-sending-to-client导致undo段迅速膨胀">3.2 <code class="highlighter-rouge">Sending to client</code>导致undo段迅速膨胀</h4>

<p>当服务端出现大量的线程处于<code class="highlighter-rouge">Sending to client</code>状态时，所执行的查询语句未完成，那么会导致长事务的产生。而如果此时数据更新较为频繁时，将会导致undo段空间迅速膨胀，因为长事务的进行导致undo页无法被回收。</p>

<p>最常见的例子就是使用<code class="highlighter-rouge">mysqldump</code>对数据进行热备时，备份存储节点的磁盘已满，导致<code class="highlighter-rouge">mysqldump</code>无法向备份文件中写入数据。数据由客户端的接收缓冲区开始堆积，到服务端的发送缓冲区，再到<code class="highlighter-rouge">net_buffer</code>，最终可能会导致undo段的数据堆积，使得MySQL服务出现大面积的异常。</p>

<h3 id="4-小结">4. 小结</h3>

<p>综上，客户端如果在处理MySQL发送的大量数据时，应该尽可能地将其暂存在本地的某个缓冲区中，而后应用程序想怎么处理、以何种速度处理都没问题，避免让MySQL产生过多的长事务。</p>

	  ]]></description>
	</item>

	<item>
	  <title>InnoDB独特的LRU</title>
	  <link>//InnoDB-LRU</link>
	  <author></author>
	  <pubDate>2020-06-09T18:06:25+00:00</pubDate>
	  <guid>//InnoDB-LRU</guid>
	  <description><![CDATA[
	     <p>由于硬盘和内存的造价差异，一台主机实例的硬盘容量通常会远超于内存容量。对于数据库等应用而言，为了保证更快的查询效率，通常会将使用过的数据放在内存中进行加速读取。LRU算法经常用于数据的置换，但InnoDB的LRU却更加独特。</p>

<!---more--->

<h3 id="1-总览">1. 总览</h3>

<p>InnoDB存储引擎是基于硬盘存储的，并且以页(page)的方式对数据记录进行管理。由于硬盘和CPU之间数据处理速度存在巨大差异，所以必须要使用内存来弥补两者之间的速度鸿沟。</p>

<p>正如同操作系统在读取硬盘文件时会将其纳入内核缓冲区一样，InnoDB存储引擎也会为硬盘中的数据和索引建立位于用户空间的内存缓冲池。当数据库从硬盘读取数据时，首先将其放置于位于内存的缓冲池中，下一次读取相同的数据时，首先判断是否位于缓冲池中。若在，则直接返回，若不在，再从硬盘中进行读取。</p>

<p>当修改数据页时，首先修改位于缓冲池中的数据页，InnoDB会寻找合适的时机将此修改持久化至硬盘中，该合适的时机通常由Checkpoint技术决定。</p>

<p>在Linux操作系统中，位于内核的内核缓冲区就是为了提高系统的I/O效率而产生的，那么为什么InnoDB还要建立自己的缓冲区? 内核缓冲区的终端为硬盘，需要处理诸如页对齐、数据边界等和硬盘硬件相关的事宜，而InnoDB缓冲区则主要服务于应用，并不关心硬件细节，并且可由应用程序控制。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/InnoDB-Buffer/InnoDB-Buffer-Pool.png" alt="" /></p>

<p>如上图所示，InnoDB缓冲池主要由数据页和索引页构成，两者占据了缓冲区的绝大部分空间。除此之外，undo页、插入缓冲以及自适应哈希索引等内容也位于缓冲池中。</p>

<h3 id="2-数据页与索引页的lru">2. 数据页与索引页的LRU</h3>

<p>数据页和索引页的目的在于缓存一部分的表数据和索引数据，其数据总量通常会超过缓冲池大小，所以缓冲池中应只缓冲那些经常使用的热点数据。InnoDB内存管理使用的是最近最少使用(Least Recently Used, LRU)算法。来淘汰最久未使用的数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/InnoDB-Buffer/normal-LRU.png" alt="" /></p>

<p>在一般的LRU算法中，当链表中的某一个数据被读取时，将会将其放置于队首。当新增数据且链表已达最大数量时，将链表尾部的数据移除，并将新增的数据置于链表首部。</p>

<p>但是，InnoDB并没有采用传统的LRU算法，而是对其进行了一些更能够适应自身行为的改进: 最近访问到的数据并不直接放到LRU列表的首部，而是放到LRU列表的midpoiont位置。在默认配置下，midpoint位于LRU列表的5/8处。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/InnoDB-Buffer/midpoint.png" alt="" /></p>

<p>如上图所示，在midpoint之前的列表称之为new列表，或者使用Java中的GC术语: 新生代，在midpoint之后的列表称之为old列表，或者说，老年代。</p>

<p>当new列表中的数据被访问时，直接将其放置于LRU列表的首部。当出现新的页面进入LRU时，将其放置于midpoint位置，<strong>此时该数据页将会位于old列表</strong>。</p>

<p>当old列表中的数据被访问时，需要进行判断。如果当前页在old列表中存在时间超过了1秒，则将其移到列表首部。若存在时间小于1秒，则位置保持不变。该判断时间由<code class="highlighter-rouge">innodb_old_blocks_time</code>决定，默认为1000毫秒，即1秒。</p>

<p>另外一点需要注意的是，InnoDB管理数据的最小单位是页(page)，而不是数据库中的某一行。即如果两条记录处于同一页，在两次间隔时间超过<code class="highlighter-rouge">innodb_old_blocks_time</code>的不同行记录的访问也会将该页置于LRU的首部。</p>

<p>InnoDB如此设计的原因在于若使用朴素的LRU算法实现的，某些索引或者表扫描操作可能会将所有的索引页和数据页置换出去，而这些数据通常只是一次性使用的，热点数据被刷出之后，会严重的影响MySQL的性能。当采用midpoint实现后，至少能够保证5/8的数据都是热点数据，即使出现了大范围的表扫描和索引扫描。</p>

<p>让我们来具体分析下对大表进行顺序扫描的过程:</p>

<ol>
  <li>当扫描开始时，InnoDB会一次性地取出16KB的一页数据，将其置于LRU 5/8的位置。</li>
  <li>由于是顺序扫描，那么同一页将会被访问多次，但是访问的间隔一定不会超过默认的<code class="highlighter-rouge">innodb_old_blocks_time</code>，即1秒。所以该页并不会被置于LRU列表的首部，也就不会将真正的热点数据置换而出。</li>
  <li>后续的数据扫描将会在下一页进行，重复上述过程。</li>
</ol>

<p>通过执行<code class="highlighter-rouge">show engine innodb status\G;</code>可以查看InnoDB缓冲池的各种指标，包括当前缓冲池的大小。此外还有一个非常重要的性能指标: 内存命中率。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; show engine innodb status<span class="se">\G</span><span class="p">;</span>
Buffer pool hit rate 976 / 1000, young-making rate 0 / 1000 not 0 / 1000
</code></pre></div></div>

<p>其中Buffer pool hit rate即为缓冲池内存命中率，在一个线上服务中，如果要保证响应时间的话，命中率应不低于95%。 如果某台MySQL实例的hit rate低于此值的话，需要查看设置的缓冲池总大小，以及是否进行了频繁的大范围数据扫描导致LRU列表被污染。</p>

<p>除了增加缓冲池的大小来提高效率以外，当遇到持续的热点问题时，即预估将来的热点数据不止63%，也可以调整midpoint的值来减少热点数据被刷出的概率:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># innodb_old_blocks_pct默认值为37%, 即5/8</span>
mysql&gt; <span class="nb">set </span>global innodb_old_blocks_pct <span class="o">=</span> 20<span class="p">;</span>
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL主从复制</title>
	  <link>//MySQL-Replication</link>
	  <author></author>
	  <pubDate>2020-06-04T07:06:25+00:00</pubDate>
	  <guid>//MySQL-Replication</guid>
	  <description><![CDATA[
	     <p>MySQL的异步复制算的上是一种典型的单领导者复制模式，就复制本身而已并无特殊之处。但是复制的细节，例如binlog的格式选取，从节点如何在保证数据准确的情况下进行并行复制，MySQL的实现方案总是能令人眼前一亮。</p>

<!---more--->

<h3 id="1-binlog">1. binlog</h3>

<p>在经典的复制模型下，主节点和从节点的数据复制都是通过日志的传输进行的。例如Redis主从复制，复制的是<code class="highlighter-rouge">appendonly.aof</code>文件中的逻辑操作记录。又如Raft一致性算法，复制的是作为”日志项”的数据记录，<code class="highlighter-rouge">LogEntry</code>。而在MySQL中，则是使用binlog作为主节点和从节点的数据复制依据。</p>

<p>实际上，如果观察大多数数据库应用的话，会发现它们都会有逻辑日志这一概念，其中记录了对数据的逻辑增删改。一方面用于数据库在宕机时的数据恢复(Redis、MySQL)，另一方面则用于主从复制之中。</p>

<h4 id="11-binlog记录了哪些内容">1.1 binlog记录了哪些内容?</h4>

<p>有非常多的方式来查看binlog中的逻辑日志，一种是在MySQL-Client中查看，另一种则是直接查看位于硬盘中的binlog文件。前者其实也是读取位于硬盘中的binlog文件，只不过会对文件内容进行解析，并增加binlog内容的可读性。而后者则能够获取到更多的信息。</p>

<ul>
  <li>MySQL-Client</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">binary</span> <span class="n">logs</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">binlog</span> <span class="n">events</span> <span class="k">in</span> <span class="s1">'mysql-bin.000193'</span><span class="p">;</span>
</code></pre></div></div>

<p>所得到的结果如下所示:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/show-events.png" alt="" /></p>

<p>其中<code class="highlighter-rouge">Pos</code>表示该逻辑日志的起始位置，<code class="highlighter-rouge">End_log_pos</code>表示该逻辑日志的结束位置。<code class="highlighter-rouge">Event_type</code>表示事件名称，<code class="highlighter-rouge">Server_id</code>则是由用户配置的当前MySQL实例的集群ID，<code class="highlighter-rouge">Info</code>中记录了较为简短的逻辑事件。在起始位置为219的地方，实际上执行了一条<code class="highlighter-rouge">insert</code>语句，但是<code class="highlighter-rouge">Info</code>列中并没有给出详细信息。</p>

<ul>
  <li>mysqlbinlog</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span>mysqlbinlog <span class="nt">-vv</span> mysql-bin.000193
</code></pre></div></div>

<p>得到的输出结果如下:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span>
<span class="cm">/*!*/</span><span class="p">;</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">302</span>
<span class="o">#</span> <span class="err">中间省去一些注释内容</span>
<span class="cm">/*!*/</span><span class="p">;</span>

<span class="o">###</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="nv">`Mario`</span><span class="p">.</span><span class="nv">`hugo`</span>
<span class="o">###</span> <span class="k">SET</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">1</span><span class="o">=</span><span class="mi">7</span> <span class="cm">/* INT meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">2</span><span class="o">=</span><span class="s1">'2020-06-02 14:32:02'</span> <span class="cm">/* DATETIME(0) meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">3</span><span class="o">=</span><span class="s1">'2020-06-02 14:54:07'</span> <span class="cm">/* DATETIME(0) meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">4</span><span class="o">=</span><span class="s1">'nami'</span> <span class="cm">/* VARSTRING(256) meta=256 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">5</span><span class="o">=</span><span class="s1">'16399553366'</span> <span class="cm">/* VARSTRING(44) meta=44 nullable=0 is_null=0 */</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">428</span>
<span class="o">#</span><span class="mi">200602</span> <span class="mi">14</span><span class="p">:</span><span class="mi">54</span><span class="p">:</span><span class="mi">07</span> <span class="n">server</span> <span class="n">id</span> <span class="mi">1</span>  <span class="n">end_log_pos</span> <span class="mi">459</span> <span class="n">CRC32</span> <span class="mi">0</span><span class="n">x27a642a3</span> 	<span class="n">Xid</span> <span class="o">=</span> <span class="mi">146</span>
<span class="k">COMMIT</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">459</span>
</code></pre></div></div>

<p>其输出内容要比<code class="highlighter-rouge">show binlog events</code>更加完整，除了事务的起始位置和结束位置以外，还包括事务的执行时间，以及完整的数据记录、相关字段的注释。所以，当需要查看binlog的详细内容时，尽量使用<code class="highlighter-rouge">mysqlbinlog</code>命令行工具。</p>

<h4 id="12-binlog日志格式">1.2 binlog日志格式</h4>

<p>MySQL一共提供了3种binlog日志格式，分别是<code class="highlighter-rouge">STATEMENT</code>，<code class="highlighter-rouge">ROW</code>以及<code class="highlighter-rouge">MIXED</code>。</p>

<ul>
  <li>查看当前binlog_format格式</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="nv">"binlog_format"</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>在线修改binlog_format格式</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="k">global</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="k">STATEMENT</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="k">global</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="k">ROW</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="k">global</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="n">MIXED</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">STATEMENT</code>日志格式仅记录用户所执行的SQL语句，用户执行什么，binlog就记录什么，属于最节省硬盘空间的一种日志格式。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/STATEMENT.png" alt="" /></p>

<p>但是，无论是出于数据恢复的考虑，还是出于主从复制的目的，都不应该将binlog格式设置为<code class="highlighter-rouge">STATEMENT</code>。其原因在于<code class="highlighter-rouge">STATEMENT</code>格式的日志依赖于执行SQL时的上下文，例如日期函数，<code class="highlighter-rouge">rand</code>函数，不同的执行环境下得到的结果可能并不相同，从而导致主从的数据不一致。而对于数据恢复而言，当然是数据越详细越完整更好。</p>

<p><code class="highlighter-rouge">ROW</code>日志格式将记录完整的数据变更记录，每一条<code class="highlighter-rouge">insert</code>语句都会记录每个字段的插入值，对于<code class="highlighter-rouge">update</code>语句，则会记录数据更新前和更新后的完整数据(<code class="highlighter-rouge">binlog_row_image</code>值为<code class="highlighter-rouge">FULL</code>)。其缺点就是占用硬盘空间较多，假设一条<code class="highlighter-rouge">update</code>语句更新了10万条数据，那么在<code class="highlighter-rouge">ROW</code>格式的binlog中则同样会记录10万条数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/ROW.png" alt="" /></p>

<p><code class="highlighter-rouge">MIXED</code>日志格式结合了<code class="highlighter-rouge">STATEMENT</code>和<code class="highlighter-rouge">ROW</code>日志格式，当MySQL认为当前SQL语句不会引起歧义，即不会导致主从不一致时，将使用<code class="highlighter-rouge">STATEMENT</code>格式记录，反之使用<code class="highlighter-rouge">ROW</code>格式进行记录。节省了一部分的硬盘使用空间，同时又能够保证数据在主从之间的一致性。</p>

<p>在实际应用中，应将binlog日志格式最低设置为<code class="highlighter-rouge">MIXED</code>，如果磁盘空间确实比较紧张的话。否则，就应该将binlog日志格式设置为<code class="highlighter-rouge">ROW</code>，该格式对于数据的误删操作恢复有非常大的帮助。</p>

<h4 id="13-binlog_row_image">1.3 binlog_row_image</h4>

<p>当<code class="highlighter-rouge">binlog_format</code>的值为<code class="highlighter-rouge">ROW</code>时，还有一个控制binlog日志记录的参数: <code class="highlighter-rouge">binlog_row_image</code>。该参数同样有3个可选项: <code class="highlighter-rouge">FULL</code>，<code class="highlighter-rouge">MINIMAL</code>以及<code class="highlighter-rouge">NOBLOB</code>。该参数控制了<code class="highlighter-rouge">ROW</code>格式的binlog日志在写入数据时是否写入完整数据。</p>

<p><code class="highlighter-rouge">FULL</code>将会记录数据修改前后的完整字段，包括未被修改的字段:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/FULL.png" alt="" /></p>

<p><code class="highlighter-rouge">MINIMAL</code>则采用最小记录原则，仅记录修改行的关键定位信息(例如主键或者唯一键)，以及最终被修改的字段的修改值，而不会记录那些没有被修改的字段:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/MINIMAL.png" alt="" /></p>

<p><code class="highlighter-rouge">NOBLOB</code>和<code class="highlighter-rouge">FULL</code>非常类似，会记录完整的字段修改前后数据，只不过不会记录未被修改的、且字段类型为BLOG或TEXT的数据，实际应用较少。</p>

<p>在主从复制中，如果主库网络带宽或者从库网络带宽无法立即升级，并且同步的日志量较大时，可临时的将<code class="highlighter-rouge">binlog_row_image</code>参数由<code class="highlighter-rouge">FULL</code>更改为<code class="highlighter-rouge">MINIMAL</code>，减少一部分的网络带宽使用。</p>

<h3 id="2-异步复制模型">2. 异步复制模型</h3>

<p>对于异步复制模型而言，从原理上来说，只需要将逻辑日志不断地发送给所有的从节点，让从节点重新执行逻辑日志的内容即可，也不需要关心从节点是否接收成功并且执行成功。</p>

<p>MySQL的异步复制模型也确实如此。主节点开启<code class="highlighter-rouge">binlog dump</code>线程，用于锁定地读取binlog内容，并通过TCP长连接发送给从节点。而对于从节点来说，将会开启一个<code class="highlighter-rouge">slave I/O</code>线程，用于和主节点建立TCP连接，以及接收主节点发送的binlog逻辑日志，并将接收到的数据写入自身的中继日志(relay log)文件中。另外的一个线程，即<code class="highlighter-rouge">slave SQL</code>线程，将不断地读取中继日志数据，并执行其中的逻辑SQL语句。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/master-slave.png" alt="" /></p>

<h4 id="21-为什么需要relay-log中继日志">2.1 为什么需要relay log(中继日志)?</h4>

<p>从节点在接收到主节点发送的binlog日志之后，并没有直接执行，而是存储在relay log中，由另外一个线程读取该文件的数据并执行。那么MySQL为什么要使用这种会降低复制效率的设计?</p>

<p>个人认为原因有两点，一方面relay log可以作为日志同步的缓冲区。主节点发送日志的速度可能要大于从节点执行日志的速度，此时就需要一个缓冲区来弥补两者之间的速度差，避免主节点发送的binlog被阻塞在socket缓冲区中。</p>

<p>另外一个作用就是利于故障时的问题排查。relay log的结构与binlog非常相似，通过在从节点持久化一份主节点发送的日志，那么在出现故障时，可查看该文件的内容来大致地判断是主节点出了问题，还是从节点出了问题。</p>

<p>这种数据冗余的设计在业务系统设计中其实也非常实用，相较于直接执行外部发送的数据，采用”生产者-消费者”模型将会有更好的健壮性: 在微服务中，”数据同步”是一件极易出错，且令人无比蛋疼的苦差事。当保留源数据，并在源数据的基础之上开展业务的话，能避免许多麻烦。</p>

<h3 id="3-并行复制">3. 并行复制</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/master-slave-load.png" alt="" /></p>

<p>在主节点中，由于存在各种各样的<code class="highlighter-rouge">Lock</code>， 例如共享锁，排它锁，意向锁等等，使得事务可以并发执行，而无需担心数据不一致的问题。但是，在从节点如果想要并发执行binlog中的内容，并不是一件容易的事情，其原因在于事务和事务之间并不是完全独立存在的，而是存在依赖性。</p>

<p>如上图所示，从节点Execute中继日志的内容将会成为主从复制最后的延迟点，同时，也可能是最大的延迟点: 因为<code class="highlighter-rouge">binlog dump</code>线程以及<code class="highlighter-rouge">slave I/O</code>线程均是对文件的顺序读取和写入，而<code class="highlighter-rouge">slave SQL</code>线程在执行语句时，则没有那么简单。</p>

<h4 id="31-并行复制所面对的问题">3.1 并行复制所面对的问题</h4>

<p>假设现在有3个事务并发执行，且修改的是同一行数据，并且事务提交的顺序为<code class="highlighter-rouge">TRX-1</code>，<code class="highlighter-rouge">TRX-2</code>，<code class="highlighter-rouge">TRX-3</code>，则数据的新旧程度为: <code class="highlighter-rouge">TRX-3</code> &gt; <code class="highlighter-rouge">TRX-2</code> &gt; <code class="highlighter-rouge">TRX-1</code>。</p>

<p>当从节点SQL执行线程读取中继日志时，并不知道这3个事务是修改的同一条数据，如果只是简单地将这3个事务分配给3个Worker执行的话，完全有可能发生旧数据覆盖新数据的情况，即<code class="highlighter-rouge">TRX-1</code>最后被执行，<code class="highlighter-rouge">TRX-3</code>的最新更新将会丢失，导致从节点和主节点的数据不一致。</p>

<h4 id="32-基于table的并行复制">3.2 基于table的并行复制</h4>

<p>如果两个事务是对不同的表进行操作，那么这两个事务即可并行执行。处理方式也非常简单，对表名称进行哈希，并对结果进行worker数量的取模，将该事务分发至对应的worker即可。</p>

<p>但是，如果事务同时对多张表进行了修改的话，上述模型就会出现问题: 该事务应该分配给哪个worker? 所以，还需要记录每个线程中有哪些事务正在执行或者排队，操作的是哪些表。对于线程私有变量，可以使用<code class="highlighter-rouge">ThreadLocal</code>来实现，外部也可方便的获取线程中的私有内容。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/parallel-with-table.png" alt="" /></p>

<p>如上图所示，Assigner线程读取relay log中的内容，并对数据进行解析，决定将该事物分配给哪个worker执行。worker线程则是事务的执行线程，并且使用哈希表记录下当前线程队列中有多少个事务正在修改哪些表。其中key为表名称，value为队列中有多少事务修改该表。</p>

<p>当Assigner读取到只修改table-1的事务时，遍历所有worker的哈希表，判断是否有其它worker正在执行关于table-1的事务，发现只有worker-1存在，那么将会直接将其分发至worker-1线程，并将事务追加至该worker的队列中，以此保证对同一个表的操作串行执行。</p>

<p>当Assigner读取到同时修改table-1和table-3的事务时，首先根据解析规则获取到这两个表应该被分配的worker，然后取出两个队列中正在对table-1和table-3所修改的事务数量。发现worker-1存在对table-1的事务，而worker-2对table-3的修改事务数量为0，那么Assigner将会将该事务分配给worker-1。</p>

<p>当Assigner读取到同时修改table-1和table-4的事务时，发现worker-1和worker-2都存在对两个表的修改，那么Assigner将会等待，等待worker-1对table-1的修改事务数量为0，或者是worker-2对table-4的修改事务数量为0。</p>

<p>在大多数情况下基于表的并行复制策略能够快速地执行，但是，如果遇到热点表的话，该热点表仍然是串行复制，同样会出现效率问题。</p>

<h4 id="33-基于行的并行复制">3.3 基于行的并行复制</h4>

<p>既然基于表的并行复制会有热点表的问题，那么基于行的并行复制总没有热点表的问题了吧? 并且同一条数据的修改频率并不会特别高。基于行的并行复制虽然能够有着更快的执行效率，但是同样地带来的更多的内存开销和CPU计算开销。</p>

<p>在基于行的并行复制中，至少需要记录下所有正在被修改或者是已经在队列中的行数据，那么显而易见的，worker线程中的哈希表将会有存在大量的数据。所以综合来看，基于行的并行复制并不是一个好的选择，甚至可以说是一个比较差的选择。</p>

<p>但是，MySQL针对基于行的复制进行了优化，将判断两个事务是否存在”冲突”(即是否更新了同一行)由从节点转移至主节点。MySQL会记录下更新的每一行的哈希值，组成一个集合。为了能够唯一标识同一行，哈希值通常由”库名+表名+唯一索引名+唯一索引值”计算得到，而唯一索引通常是主键。</p>

<p>如果两个事务没有同时更新同一条数据，那么两个事务的集合就不存在交集，它们是可以并行执行的。并且该哈希值集合是在主节点写入binlog时即计算好的，不需要从节点再次解析binlog event，节省了从节点的一部分计算资源。</p>

<h4 id="34-基于group-commit的并行复制">3.4 基于Group Commit的并行复制</h4>

<p>InnoDB存储引擎是通过redo log + binlog来实现事务的原子性以及持久性的，为了保证数据的一致性，两个日志的数据写入通过”两阶段提交”完成，并且使用组提交(Group Commit)来提高事务的并发效率。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/LSN-Commit.png" alt="" /></p>

<p>当未使用组提交时，当<code class="highlighter-rouge">trx:1</code>提交，仅将该事务的数据持久化至redo log以及binlog中，当有两万个事务并发执行时，将需要执行四万次<code class="highlighter-rouge">fsync</code>系统调用。</p>

<p>当使用组提交时，当<code class="highlighter-rouge">trx:1</code>提交，redo log buffer中可能存在多个事务的物理页修改，那么此时<code class="highlighter-rouge">trx:1</code>将会作为Leader，将当前最大的LSN redo log持久化至磁盘，以减少<code class="highlighter-rouge">fsync</code>的系统调用次数。并且，为了尽可能多地在一次写入中写入更多的数据，InnoDB还会推迟redo log的<code class="highlighter-rouge">fsync</code>过程。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/delay-fsync.png" alt="" /></p>

<p>更具体的上下文请参考文章: <a href="https://smartkeyerror.com/InnoDB-AD">InnoDB如何保证事务的原子性与持久性</a></p>

<p><strong>假设多个事务能够同时进入prepare阶段，那么这些事务一定能够并行执行。</strong> 接下来分析一下这句话的正确性:</p>

<ol>
  <li>事务A和事务B并发执行，准备修改同一条数据。由于X Lock的存在，当一个事务修改数据时，另一个事务将会被阻塞，等待前一个事务<strong>提交</strong>。</li>
  <li>假设事务A首先获得了X Lock，成功修改了数据并提交了事务。而此时，事务B仍然处于运行中，在获取到数据的X Lock之后才开始执行自己的修改。</li>
</ol>

<p>所以，<strong>只要是能够同时进入prepare的阶段，事务一定是经过了锁冲突的检验，一定能够在从库并行执行</strong>。</p>

<p>如此一来，当redo log在使用最大的LSN持久化至磁盘时，使用一个<code class="highlighter-rouge">commit_id</code>对该事务进行标记。下次的redo log持久化将<code class="highlighter-rouge">commit_id</code>自增。从库在并行执行binlog event是，只要是相同的<code class="highlighter-rouge">commit_id</code>，就使其并发执行。</p>

<h4 id="35-mysql提供的并行复制配置项">3.5 MySQL提供的并行复制配置项</h4>

<p>MySQL一共提供了三种并行复制策略，由参数<code class="highlighter-rouge">binlog_transaction_dependency_tracking</code>控制(MySQL版本大于5.7.22)。</p>

<ul>
  <li>COMMIT_ORDER: 利用Group Commit机制进行并行执行。</li>
  <li>WRITESET: 基于行的并行执行。</li>
  <li>WRITESET_SESSION: 建立在WRITESET策略之上，只不过多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li>
</ul>

<p>其中COMMIT_ORDER为默认策略，当使用该策略时，可以调整<code class="highlighter-rouge">binlog_group_commit_sync_delay</code>以及<code class="highlighter-rouge">binlog_group_commit_sync_no_delay_count</code>来使得主节点更慢的提交，使从节点更快的执行事务。</p>

<p>当主节点事务执行的并发度较高时，可以选择COMMIT_ORDER策略。当主节点事务执行并发度并不高，并且趋近于单线程或者双线程时，可选择WRITESET策略。</p>

<h3 id="4-主从延迟来源">4. 主从延迟来源</h3>

<h4 id="41-从节点硬件资源不足">4.1 从节点硬件资源不足</h4>

<p>有时候我们会认为从库只负责读请求，而不处理客户端的写请求，所以从库的内存、硬盘以及CPU都可以使用较低配置。但事实上，从库需要处理的数据写入并不会比主库要少，同时还要处理比主库更多的读请求。因此，从库的硬件资源应该至少和主库相同，甚至可以高于从库。</p>

<p>通过<code class="highlighter-rouge">top</code>或者是<code class="highlighter-rouge">htop</code>可以很清晰的得到从节点的内存以及CPU使用率，使用<code class="highlighter-rouge">iostat</code>查看从节点的磁盘I/O活动情况。<code class="highlighter-rouge">iostat</code>有几个非常关键的指标:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span>iostat <span class="nt">-m</span>
Linux 4.15.0-101-generic <span class="o">(</span>Zero<span class="o">)</span>         2020年06月04日  _x86_64_        <span class="o">(</span>8 CPU<span class="o">)</span>

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           4.93    0.01    2.58    0.59    0.00   91.88
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">%iowait</code>表示CPU等待输入输出完成时间的百分比，<code class="highlighter-rouge">%idle</code>表示CPU空闲百分比。如果<code class="highlighter-rouge">%iowait</code>的值较高，说明硬盘存在I/O瓶颈; 如果<code class="highlighter-rouge">%idle</code>持续较低，说明系统的CPU处理能力较弱，此时应处理CPU资源。</p>

<h4 id="42-主节点大事务与从节点长事务">4.2 主节点大事务与从节点长事务</h4>

<p>大事务是指更新了较多数据行的事务，当从节点重放大事务的binlog event时，不管是使用<code class="highlighter-rouge">COMMIT_ORDER</code>还是<code class="highlighter-rouge">WRITESET</code>并行复制策略，后续操作均需要等待该事务的执行，事务执行所需要的执行时间越久，主从延迟就会越高。所以，尽量地将大事务拆分成多个小事务执行。</p>

<p>从节点长事务同样也可能导致主从延迟的产生。例如，当从库开启了一个长事务:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">hugo</span> <span class="k">WHERE</span> <span class="n">username</span> <span class="o">=</span> <span class="nv">"smart"</span><span class="p">;</span>
</code></pre></div></div>

<p>执行完<code class="highlighter-rouge">SELECT</code>语句之后因为种种原因长时间未提交事务，那么此时若主库对该表进行了DDL操作，即使<code class="highlighter-rouge">hugo</code>表只有几行数据，也会长时间的阻塞: 因为此时DDL操作无法获取到<code class="highlighter-rouge">hugo</code>表的意向排它锁(IX)。</p>

<p>如果主表的DDL操作在白天进行，并且恰好存在对该表的某一个长事务的话，即使不是高峰期也会带来非常大的主从延迟。</p>

<h4 id="43-从节点未开启并行复制">4.3 从节点未开启并行复制</h4>

<p>从节点的并行执行worker数量由<code class="highlighter-rouge">slave_parallel_workers</code>参数决定，最大值为1024，通常将其设置为CPU核心数的一半。</p>

	  ]]></description>
	</item>

	<item>
	  <title>InnoDB如何保证事务的原子性与持久性</title>
	  <link>//InnoDB-AD</link>
	  <author></author>
	  <pubDate>2020-05-28T18:06:25+00:00</pubDate>
	  <guid>//InnoDB-AD</guid>
	  <description><![CDATA[
	     <p>在InnoDB存储引擎中，一个事务的执行将涉及到3个日志的数据写入: redo log，undo log以及binlog。其中redo log以及binlog主要实现事务的原子性和持久性，而undo log主要用于实现事务的隔离性。</p>

<!---more--->

<h3 id="1-redo-log">1. redo log</h3>

<p>redo log又称之为重做日志，主要记录了事务对数据页(Page)的物理修改。redo log由两部分组成: 一是位于内存的redo log buffer，用于对redo log进行缓冲，目的在于提升性能。另一部分则位于硬盘中，用于对redo log的持久化。</p>

<h4 id="11-redo-log-buffer">1.1 redo log buffer</h4>

<p>redo log buffer用于优化redo log的写入性能，默认大小为16MB，最大大小为4GB。当一个事务对数据页进行修改时，首先将修改内容放置于缓冲中，而后再对其进行持久化。</p>

<h4 id="12-redo-log">1.2 redo log</h4>

<p>默认情况下，redo log由两个文件构成，<code class="highlighter-rouge">ib_logfile0</code>以及<code class="highlighter-rouge">ib_logfile1</code>。redo log的大小由配置文件决定，在5.7版本中，默认大小为48MB。由于其大小固定，所以数据在写入该日志文件时，将使用循环写入的方式: 首先从头开始写，写到末尾，然后再从头开始写，后面写入的内容会覆盖最初的内容，所以称之为循环写入。</p>

<p>redo log的文件大小设置和MySQL的负载相关，通常来说redo log应该能容纳至少一个小时的数据修改，一般<code class="highlighter-rouge">innodb_log_file_size</code>设置为1GB，<code class="highlighter-rouge">innodb_log_files_in_group</code>设置为4，总计4GB的redo log容量。重做日志大小如果设置的过大，宕机恢复时所花的时间也会越多，所以并不是越大越好。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/redo-log.png" alt="" /></p>

<p>redo log buffer中的数据将会在以下时机持久化至位于磁盘的redo log中:</p>

<ul>
  <li>事务提交</li>
  <li>当redo log buffer有一半的空间已经被使用时</li>
  <li>InnoDB后台线程每秒将数据持久化至硬盘</li>
</ul>

<p>所以，需要明确的是，当某个事务未提交(commit)时，该事务对物理数据页的修改也可能会持久化至redo log文件中。</p>

<h4 id="13-lsn">1.3 LSN</h4>

<p>在redo log中，还有一个非常重要的属性: LSN，Log Sequence Number，即日志序列号。接下来我们将会看到，LSN在数据恢复以及Group Commit中起到了决定性的作用。</p>

<p>在InnoDB存储引擎中，LSN占用8个字节，且单调递增。LSN所表示的含义包括redo log的总量，checkpoint的位置以及数据页的版本。</p>

<p>假设当前redo log的LSN为1000，事务T1写入了200字节的redo log，那么LSN将递增至1200。若事务T2写入了500字节的redo log，那么LSN又将变成1700。所以通过查看LSN的大小即可知道redo log的总量，单位为字节。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; show engine innodb status<span class="se">\G</span><span class="p">;</span>
<span class="nt">---</span>
LOG
<span class="nt">---</span>
Log sequence number 20598039739
Log flushed up to   20598039739
Pages flushed up to 20598039739
Last checkpoint at  20598039730
0 pending log flushes, 0 pending chkp writes
10 log i/o<span class="s1">'s done, 0.00 log i/o'</span>s/second
</code></pre></div></div>

<p>如上所示，Log sequence number表示当前的LSN，Log flushed up to表示已经刷新到redo log文件的LSN。</p>

<h3 id="2-binlog">2. binlog</h3>

<p>binlog为MySQL层面的逻辑日志，用于记录对哪一行数据进行了哪些修改，不管使用何种存储引擎，都会有binlog的记录。redo log则是InnoDB存储引擎所特有的日志记录，并且其中记录的是对物理数据页的修改。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/logical-binlog.png" alt="" /></p>

<p>关于binlog的更多内容将在后续的MySQL主从复制中描述。</p>

<h3 id="3-事务执行过程">3. 事务执行过程</h3>

<p>InnoDB存储引擎在提交事务时，为了保证原子性和持久性，将会采用”两阶段”提交的方式写入redo log和binlog。</p>

<h4 id="31-一阶段">3.1 一阶段</h4>

<p>首先，在MySQL中所有执行的SQL语句都会有一个全局递增且循环使用的query_id。当用户开启事务并执行语句后，MySQL将会把第一个语句的query_id分配给该事务，作为Xid的值。</p>

<p>当用户执行<code class="highlighter-rouge">COMMIT</code>提交事务时，将redo log buffer的内容调用<code class="highlighter-rouge">write()</code>系统调用写入内核缓冲区，并调用<code class="highlighter-rouge">fsync()</code>系统调用确保数据写入至硬盘(至少是硬盘的缓冲区)，更新状态为prepare。</p>

<h4 id="32-二阶段">3.2 二阶段</h4>

<p>将产生的binlog调用<code class="highlighter-rouge">write()</code>系统调用写入内核缓冲区，并调用<code class="highlighter-rouge">fsync()</code>系统调用将数据持久化至硬盘，写入成功后事务即可被提交，并更新状态为commit。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/2PC.png" alt="" /></p>

<p>当数据成功地写入到binlog以后，即可返回给用户事务提交成功。由于数据写入<code class="highlighter-rouge">.ibd</code>文件需要随机读写，所以将会由其它线程异步写入，以提高事务执行的效率。</p>

<p>现在来看两阶段提交在数据库Crash的情况:</p>

<ul>
  <li>binlog有记录，但redo log状态为prepare: 此时表示在写入binlog数据库崩溃，需要根据binlog进行数据恢复</li>
  <li>binlog有记录，redo log状态为commit: 事务正常提交，无需恢复</li>
  <li>binlog无记录，redo log状态为prepare: 事务执行一半时崩溃，无需恢复</li>
  <li>binlog无记录，redo log状态为commit: 在binlog持久化时崩溃，事务直接回滚</li>
</ul>

<p>可以看到，通过上述的两阶段提交方式能够保证不会产生脏事务，并且已成功提交的事务也能够在MySQL崩溃后重启恢复。</p>

<p>当redo log和binlog均正确的写入数据以后，就可以返回<code class="highlighter-rouge">OK</code>给用户了。至于何时将用户的修改持久化至<code class="highlighter-rouge">.ibd</code>文件中，由MySQL后台线程决定。</p>

<p>基于redo log和binlog的WAL(Write-Ahead Log)机制可以保证数据的原子性以及持久性，并且由于日志是顺序读写，所以事务的执行速度会快很多。</p>

<h3 id="4-group-commit">4. Group Commit</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/2PC.png" alt="" /></p>

<p>从上图模型可以看到，每一个事务的提交，都会伴随着两次<code class="highlighter-rouge">write()</code>以及<code class="highlighter-rouge">fsync()</code>系统调用。对于<code class="highlighter-rouge">Write()</code>调用来说，仅仅只是将用户缓冲区的内容写入至内核缓冲区中，虽然会有用户态与内核态的切换，但是仍然要比<code class="highlighter-rouge">fsync()</code>要快。</p>

<p>如果采用上述模型实现事务的话，如果有两万个并发事务执行，那么磁盘的IO负载将会达到四万，并且事务的执行效率将会非常之差。</p>

<p>为了解决事务执行效率问题，MySQL引入了组提交(Group Commit)技术: 在事务提交时，尽可能多地向文件中写入数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/LSN-Commit.png" alt="" /></p>

<p>如上图所示，共有3个事务并行执行，其中trx:1事务准备提交。按照之前的模型，将trx:1的redo log写入至磁盘中，并将binlog写入至磁盘中。</p>

<p>而在Group Commit中，当trx:1准备提交时，将会刷新最大的LSN之前未刷新的所有redo log。在该示例中，trx:1准备刷新时，则会将LSN为1600之前的所有redo log一齐刷新至磁盘。原来需要6次系统调用，现在只需要2次。</p>

<p>为了能够让redo log在每次写入时尽可能多的写入，MySQL将redo log调用<code class="highlighter-rouge">fsync()</code>的时机延迟，延迟至binlog调用<code class="highlighter-rouge">write()</code>之后:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/delay-fsync.png" alt="" /></p>

<p>这样一来，binlog也能够组提交了，能够有效地减少IOPS的消耗。</p>

<p>MySQL额外的提供了两个延迟参数来提高binlog的组提交效率:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 表示延迟多少微秒后才调用binlog的fsync()</span>
binlog_group_commit_sync_delay

<span class="c"># 表示累积了多少个binlog才调用binlog的fsync()</span>
binlog_group_commit_sync_no_delay_count
</code></pre></div></div>

<p>这两个参数为”或”关系，即只要满足一个条件，就会调用<code class="highlighter-rouge">fsync()</code>。当磁盘IO出现性能瓶颈时，可根据实际负载来设置该值，从而降低磁盘IO负载，代价是会增加事务的响应时间。</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL-InnoDB中的锁</title>
	  <link>//MySQL-InnoDB-Lock</link>
	  <author></author>
	  <pubDate>2020-01-31T10:06:25+00:00</pubDate>
	  <guid>//MySQL-InnoDB-Lock</guid>
	  <description><![CDATA[
	     <p>锁在InnoDB存储引擎中的使用远比我们想象中的更加频繁，及时是一条最为简单的<code class="highlighter-rouge">update set</code>语句，其中也涉及到了各种锁的使用。包括常说的一致性锁定读，解决幻读等场景中，同样包含了锁的大量使用。</p>

<!---more--->

<h4 id="1-latch和lock">1. Latch和Lock</h4>

<p>在InnoDB存储引擎中，Latch(门闩)是用来保证并发线程操作临界资源的正确性，保证某些操作的原子性。通常又分为Mutex(互斥量)和RWLock(读写锁)，例如Python中<code class="highlighter-rouge">threading.Lock</code>，Java中<code class="highlighter-rouge">synchronized</code>，Golang中的<code class="highlighter-rouge">sync.Mutex</code>，Latch通常应用于操作缓冲池中的LRU列表元素(添加、删除以及移动)，部分场景下的<code class="highlighter-rouge">AUTO_INCREMENT</code>实现。用户通常不会直接地与Latch打交道，并且没有死锁检测。</p>

<p>Lock作用于事务之中，用来锁定表、页、行，锁的添加与释放通常会在事务的起始和结束时进行。数据库中的幻读问题解决就是通过Lock实现的，而非Latch。并且Lock存在死锁检测机制，当发生死锁时，会在某些情况下告知用户，例如在使用一致性锁定读(SELECT…FOR UPDATE)时产生的死锁，会直接抛出1213的Deadlock异常。</p>

<p>尽管Latch与Lock操作的对象均为数据，但是Latch更为底层，操作的对象更加细小。Lock的对象相对于Latch而言，则更加”粗放”，例如表、页数据，此外最重要的是Lock的作用域为事务，Latch则不是。</p>

<h4 id="2-innodb存储引擎中的lock">2. InnoDB存储引擎中的Lock</h4>

<p>为了方便叙述，下面均使用锁来指代InnoDB中的Lock(仍然要说明，Lock以及Latch都可以称为锁，这里只是为了方便叙述)。</p>

<p>InnoDB引擎支持行锁以及表锁，既可以锁定某一行，同时也可以锁定一整张表，先从行级锁说起。</p>

<p>InnoDB引擎实现了两种标准的行级锁:</p>
<ul>
  <li>共享行级锁(S Lock, Share Lock)</li>
  <li>排他行级锁(X Lock, Exclusive Lock)</li>
</ul>

<p>可以认为S Lock和X Lock分别表示读锁和写锁，如同RWLock一样。S Lock允许并发地读取数据，X Lock既限制并发地读取，同时也限制并发地修改。所以说，当某一行数据中存在S锁时，只能再次添加S锁，若想要添加X锁，则需要等待S锁的释放。行级锁X以及S Lock的兼容性如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">-</th>
      <th style="text-align: center">X</th>
      <th style="text-align: center">S</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">X</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">S</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
  </tbody>
</table>

<p>同时，InnoDB支持表级锁，为了支持表级锁与行级锁这两个不同粒度的锁，InnoDB支持一种额外的上锁方式，称之为意向锁(Intention Lock)。</p>

<p>为了更好的理解意向锁，首先假设没有意向锁，只有表锁和行锁。当事务A在更新某一条数据时，会在该数据行上添加X锁。此时另外事务B申请整个表的写锁，如果事务B申请成功，那么它就能修改表中任意一行数据，这与事务持有的X锁冲突。</p>

<p>如果数据库想要避免该冲突，那么需要让事务B阻塞，直到事务A提交释放X锁。转而需要判断事务B阻塞的条件: ①当前表是否被其它事务添加表锁 ②判断表中是否存在行锁。这两个条件判断均可以在表层面实现，而无需遍历所有数据，只需要定义好数据结构即可。一个最简单的实现就是为表锁和行锁添加两个标识位，该标识位在添加和释放锁时进行原子更新，例如:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table_s_lock <span class="o">=</span> <span class="nb">false
</span>table_x_lock <span class="o">=</span> <span class="nb">false
</span>row_s_lock <span class="o">=</span> <span class="nb">true
</span>row_x_lock <span class="o">=</span> <span class="nb">true</span>
</code></pre></div></div>

<p>当某一行添加X锁时，将<code class="highlighter-rouge">row_x_lock</code>置为true，若其余事务想要添加表级别的X锁，则必须等待<code class="highlighter-rouge">row_x_lock</code>更新为false。反之若事务已经添加了表级别的X锁，将<code class="highlighter-rouge">table_x_lock</code>置为true，事务B若想在某一行添加X锁，则需要等待<code class="highlighter-rouge">table_s_lock</code>以及<code class="highlighter-rouge">table_x_lock</code>均更新为false。</p>

<p>虽然上面的标识位能够解决问题，但仍然有些奇怪，奇怪的点在于标识位的判断粒度不同。我们更加希望表级锁与表级锁进行兼容性判断，行级锁与行级锁进行兼容性判断，而不是表级锁与行级锁进行兼容性判断。由此，就有了意向锁的诞生。</p>

<p>意向锁(Intention Lock)将锁定的对象分为多个粒度，当想要对细粒度的数据进行加锁时，那么首先需要对粗粒度的对象添加意向锁。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/intention-Lock.png" alt="" /></p>

<p>例如，若需要对页上的记录R添加X锁，则需要分别对数据库、表、页添加意向锁IX，添加成功后才会对记录R添加X锁，若其中任何一部分导致等待，那么该操作需要等待粗粒度上锁环节的完成。现在来看在有了意向锁之后InnoDB存储引擎如何支持多粒度的锁。</p>

<p>意向锁同样分为两种: 共享和排他</p>

<ul>
  <li>意向共享锁(IS, Intention Share Lock)</li>
  <li>意向排他锁(IX, Intention Exclusive Lock)</li>
</ul>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/intention-lock-example.png" alt="" /></p>

<p>如上图所示，事务A为了给记录R添加X锁(排他锁)，则需要依次对数据库、表、页添加意向排他锁(IX)，假设添加均成功，最终记录R添加了X锁。此时事务B想要向表A中添加表级别的排他锁，由于表A中存在IX锁，与表级别的X锁并不兼容，故事务B等待，等待表A中IX锁的释放。可以看到，在有了意向锁之后，锁的兼容性比较将处理同粒度水平，而不是跨粒度进行比较。这让我想起了一个段子:</p>

<blockquote>
  <p>不要跟傻逼争论，他会把你拉到他的水平上，然后用他丰富的经验打败你</p>
</blockquote>

<p>InnoDB存储引擎中意向锁和表级锁的兼容性如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">-</th>
      <th style="text-align: center">IX</th>
      <th style="text-align: center">IS</th>
      <th style="text-align: center">X(表级别)</th>
      <th style="text-align: center">S(表级别)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">IX</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">IS</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">X(表级别)</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">S(表级别)</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
  </tbody>
</table>

<p>在MySQL 5.5以上、5.7.14以下的版本中，用户可以通过<code class="highlighter-rouge">INFORMATION_SCHEMA</code>下的<code class="highlighter-rouge">INNODB_TRX</code>、<code class="highlighter-rouge">INNODB_LOCKS</code>以及<code class="highlighter-rouge">INNODB_LOCK_WAITS</code>这三张表简单地监控并分析可能存在的锁问题。</p>

<p>在MySQL 8.0版本中，则需要使用<code class="highlighter-rouge">performance_schema</code>下的<code class="highlighter-rouge">data_locks</code>以及<code class="highlighter-rouge">data_lock_waits</code>获取相关的锁以及锁等待信息。</p>

<p>而MySQL版本在5.7.14到8.0之间的用户，只能通过其它手段间接的获取上述信息。</p>

<h5 id="21-创建通用例程">2.1 创建通用例程</h5>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`user`</span> <span class="p">(</span>
  <span class="nv">`id`</span> <span class="n">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="nv">`nickname`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`password`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`user_id`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`mobile`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`mobile_area`</span> <span class="n">smallint</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">comment</span> <span class="nv">"手机号码区域"</span><span class="p">,</span>
  <span class="nv">`gender`</span> <span class="n">tinyint</span> <span class="k">DEFAULT</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nv">`avatar`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`account_id`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`created_at`</span> <span class="n">datetime</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="nv">`updated_at`</span> <span class="n">datetime</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="k">ON</span> <span class="k">UPDATE</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="nv">`deleted_at`</span> <span class="n">datetime</span><span class="p">,</span>
  <span class="nv">`status`</span> <span class="n">tinyint</span> <span class="k">DEFAULT</span> <span class="mi">1</span> <span class="k">comment</span> <span class="nv">"用户状态"</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`user_id`</span> <span class="p">(</span><span class="nv">`user_id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`mobile`</span> <span class="p">(</span><span class="nv">`mobile`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`account_id`</span> <span class="p">(</span><span class="nv">`account_id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`created_at`</span> <span class="p">(</span><span class="nv">`created_at`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`updated_at`</span> <span class="p">(</span><span class="nv">`updated_at`</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="p">(</span><span class="nv">`user_id`</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="p">(</span><span class="nv">`account_id`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">1</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span> <span class="k">COLLATE</span><span class="o">=</span><span class="n">utf8mb4_general_ci</span><span class="p">;</span>
</code></pre></div></div>

<p>这是一张非常普通但又普遍的用户信息表，其中包含了唯一主键，唯一辅助索引以及普通辅助索引。</p>

<h5 id="22-innodb_trx">2.2 INNODB_TRX</h5>
<p><code class="highlighter-rouge">INNODB_TRX</code>表中主要记录了当前正在执行的事务信息，包括只读事务。首先来看字段和字段所表示的含义:</p>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TRX_ID</td>
      <td>InnoDB存储引擎内部的唯一事务ID</td>
    </tr>
    <tr>
      <td>TRX_WEIGHT</td>
      <td>事务权重(与事务修改的行数和锁定的行数有关)，当两个事务执行发生死锁时，InnoDB会选择权重较低的事务进行回滚</td>
    </tr>
    <tr>
      <td>TRX_STATE</td>
      <td>当前的事务执行状态，包括RUNNING, LOCK WAIT, ROLLING BACK, 以及COMMITTING，LOCK WAIT表示当前事务正等待某个锁的释放</td>
    </tr>
    <tr>
      <td>TRX_STARTED</td>
      <td>事务开始时间，格式如2000-01-01 14:01:08</td>
    </tr>
    <tr>
      <td>TRX_REQUESTED_LOCK_ID</td>
      <td>当前事务所等待的锁ID，该字段只有在状态为LOCK WAIT才有值，否则为NULL。可与<code class="highlighter-rouge">INNODB_LOCKS</code>通过LOCK_ID字段进行关联查询，获取更为详细的锁信息。</td>
    </tr>
    <tr>
      <td>TRX_WAIT_STARTED</td>
      <td>当前事务等待锁的起始时间，在状态为LOCK WAIT时才有值，否则为NULL。</td>
    </tr>
    <tr>
      <td>TRX_QUERY</td>
      <td>当前事务<strong>正在</strong>执行的SQL语句(不是事务所有的执行语句)</td>
    </tr>
    <tr>
      <td>TRX_OPERATION_STATE</td>
      <td>事务的当前操作状态，包括PREPARING, UPDATING, DELETING, COMMITTING以及NULL，该字段在绝大部分情况下均为NULL，捕捉某一事务的瞬间执行状态还是比较困难的(除非是大事务)</td>
    </tr>
    <tr>
      <td>TRX_TABLES_IN_USE</td>
      <td>正在执行的SQL语句所操作的表数量，是一个动态变化值，通常很难观测</td>
    </tr>
    <tr>
      <td>TRX_TABLES_LOCKED</td>
      <td>当前事务在各个表中添加行锁的表数量</td>
    </tr>
    <tr>
      <td>TRX_LOCK_STRUCTS</td>
      <td>当前事务持有的锁数量</td>
    </tr>
    <tr>
      <td>TRX_LOCK_MEMORY_BYTES</td>
      <td>当前事务中锁结构的内存总占用</td>
    </tr>
    <tr>
      <td>TRX_ROWS_LOCKED</td>
      <td>当前事务锁住的近似数据总行数</td>
    </tr>
    <tr>
      <td>TRX_ROWS_MODIFIED</td>
      <td>当前事务插入、修改的总行数</td>
    </tr>
    <tr>
      <td>TRX_CONCURRENCY_TICKETS</td>
      <td>表示当前事务在换出之前所能做的工作之和</td>
    </tr>
    <tr>
      <td>TRX_ISOLATION_LEVEL</td>
      <td>当前事务隔离级别，包括READ UNCIMMITTED、READ COMMITTED、READ REPEATABLE以及SERIALIZABLE</td>
    </tr>
    <tr>
      <td>TRX_UNIQUE_CHECKS</td>
      <td>当前事务是否开启唯一性检查</td>
    </tr>
    <tr>
      <td>TRX_FOREIGN_KEY_CHECKS</td>
      <td>当前事务是否开启外键检查</td>
    </tr>
    <tr>
      <td>TRX_LAST_FOREIGN_KEY_ERROR</td>
      <td>当前事务执行时最后发生的外键错误</td>
    </tr>
    <tr>
      <td>TRX_ADAPTIVE_HASH_LATCHED</td>
      <td>当前事务是否锁定了自适应哈希索引</td>
    </tr>
  </tbody>
</table>

<p>在这20多个字段中，较为重要的包括事务ID，事务执行状态，事务等待锁的起始时间，事务锁定的近似总行数。</p>

<h5 id="23-innodb_locks">2.3 INNODB_LOCKS</h5>

<p><code class="highlighter-rouge">INNODB_LOCKS</code>表中记录了当前所有未释放的锁，包括行锁、页锁以及表锁，当某个事务发生严重的锁等待时，通常会在该表中查找蛛丝马迹，确定问题的根源。</p>

<p>但是，<code class="highlighter-rouge">INNODB_LOCKS</code>和<code class="highlighter-rouge">INNODB_LOCK_WAITS</code>这两张表在5.7.14以上版本中被废弃不用，在8.0版本中使用<code class="highlighter-rouge">data_locks</code>以及<code class="highlighter-rouge">data_lock_waits</code>进行代替，故以下内容均采用MySQL 8.0版本进行描述。</p>

<h5 id="24-data_locks">2.4 data_locks</h5>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ENGINE</td>
      <td>申请或持有锁的存储引擎类型</td>
    </tr>
    <tr>
      <td>ENGINE_LOCK_ID</td>
      <td>存储引擎内部的锁ID，该值会发生动态变化，外部系统不应该依赖该值</td>
    </tr>
    <tr>
      <td>ENGINE_TRANSACTION_ID</td>
      <td>持有锁的事务ID，与INNODB_TRX中的TRX_ID对应</td>
    </tr>
    <tr>
      <td>THREAD_ID</td>
      <td>持有锁的线程ID</td>
    </tr>
    <tr>
      <td>EVENT_ID</td>
      <td>事件ID，该字段将于下方进行详细描述</td>
    </tr>
    <tr>
      <td>OBJECT_SCHEMA</td>
      <td>锁所在的schema(database)</td>
    </tr>
    <tr>
      <td>OBJECT_NAME</td>
      <td>锁所在的表名称</td>
    </tr>
    <tr>
      <td>PARTITION_NAME</td>
      <td>锁所在分片名称</td>
    </tr>
    <tr>
      <td>SUBPARTITION_NAME</td>
      <td>锁所在的子分片名称</td>
    </tr>
    <tr>
      <td>INDEX_NAME</td>
      <td>被添加锁的索引名称</td>
    </tr>
    <tr>
      <td>OBJECT_INSTANCE_BEGIN</td>
      <td>锁的内存空间起始地址</td>
    </tr>
    <tr>
      <td>LOCK_TYPE</td>
      <td>锁类型，包含TABLE和RECORD</td>
    </tr>
    <tr>
      <td>LOCK_MODE</td>
      <td>锁的模式，包括S,X,IS,IX,AUTO_INC以及UNKNOWN</td>
    </tr>
    <tr>
      <td>LOCK_STATUS</td>
      <td>锁的状态，InnoDB引擎中包括GRANTED(已添加)和WAITING(等待中)</td>
    </tr>
    <tr>
      <td>LOCK_DATA</td>
      <td>锁覆盖的范围，该字段将于下方详细描述</td>
    </tr>
  </tbody>
</table>

<p>以一个具体的例子为例:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Mario</span><span class="p">.</span><span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
               <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140374385659344</span><span class="p">:</span><span class="mi">1453</span><span class="p">:</span><span class="mi">140374295256456</span>
<span class="n">ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">632837</span>
            <span class="n">THREAD_ID</span><span class="p">:</span> <span class="mi">56</span>
             <span class="n">EVENT_ID</span><span class="p">:</span> <span class="mi">28</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
       <span class="n">PARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
    <span class="n">SUBPARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">NULL</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140374295256456</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="k">TABLE</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">IX</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="k">NULL</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
               <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140374385659344</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140374295253576</span>
<span class="n">ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">632837</span>
            <span class="n">THREAD_ID</span><span class="p">:</span> <span class="mi">56</span>
             <span class="n">EVENT_ID</span><span class="p">:</span> <span class="mi">28</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
       <span class="n">PARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
    <span class="n">SUBPARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140374295253576</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p>当我们使用<code class="highlighter-rouge">FOR UPDATE</code>一致性锁定读向id为1的行添加一个写锁时，可以看到<code class="highlighter-rouge">data_locks</code>中生成了两条记录。从<code class="highlighter-rouge">LOCK_TYPE</code>以及<code class="highlighter-rouge">LOCK_MODE</code>来看，第一条为表级别意向排他锁(IX)，第二条为行记录排他锁(X)。注意到X锁后面还有一个说明: <code class="highlighter-rouge">REC_NOT_GAP</code>，表示排他非间隙行锁，这是行锁的一种实现，将在后面小节中描述。</p>

<p><code class="highlighter-rouge">LOCK_DATA</code>在IX项中为NULL，这是因为在InnoDB存储引擎中，该字段只会在<code class="highlighter-rouge">LOCK_TYPE</code>为<code class="highlighter-rouge">RECORD</code>时才有实际值，对于<code class="highlighter-rouge">TABLE</code>类型的锁而言，该值为NULL。<code class="highlighter-rouge">LOCK_DATA</code>根据不同的加锁方式会有不同具体值。当我们使用主键ID(primary key)进行加锁时，<code class="highlighter-rouge">LOCK_DATA</code>仅包含聚簇索引行记录，此时<code class="highlighter-rouge">LOCK_DATA</code>的值通常为主键ID。当我们使用辅助索引对记录加锁时，锁住的范围则会包括辅助索引+聚簇索引，所以此时<code class="highlighter-rouge">data_locks</code>会生成3条记录(表级别意向锁+索引记录锁+聚簇索引记录锁)，此时<code class="highlighter-rouge">LOCK_DATA</code>的值为”辅助索引字段值+主键ID”</p>

<p>例如:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Mario</span><span class="p">.</span><span class="k">user</span> <span class="k">where</span> <span class="n">user_id</span> <span class="o">=</span> <span class="nv">"168236477"</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
          <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">NULL</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="k">TABLE</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">IX</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="k">NULL</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">user_id_2</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="cm">/* LOCK_DATA为FieldValue+记录对应的主键ID。由于user_id为unique，故此处仅一条记录 */</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="s1">'168236477'</span><span class="p">,</span> <span class="mi">3</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">3</span>
</code></pre></div></div>

<h5 id="25-data_lock_waits">2.5 data_lock_waits</h5>

<p><code class="highlighter-rouge">data_lock_waits</code>相比于<code class="highlighter-rouge">INNODB_TRX</code>以及<code class="highlighter-rouge">data_locks</code>而言则要更复杂一些，该表实际上是一个ManyToMany的关系表，记录了<code class="highlighter-rouge">data_locks</code>中锁之间的等待以及依赖关系，同时也记录了锁所对应的事务/会话信息。</p>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ENGINE</td>
      <td>存储引擎类型</td>
    </tr>
    <tr>
      <td>REQUESTING_ENGINE_LOCK_ID</td>
      <td>存储引擎内锁ID，对应于data_locks表中的ENGINE_LOCK_ID</td>
    </tr>
    <tr>
      <td>REQUESTING_ENGINE_TRANSACTION_ID</td>
      <td>存储引擎内事务ID</td>
    </tr>
    <tr>
      <td>REQUESTING_THREAD_ID</td>
      <td>线程ID</td>
    </tr>
    <tr>
      <td>REQUESTING_EVENT_ID</td>
      <td>事件ID</td>
    </tr>
    <tr>
      <td>REQUESTING_OBJECT_INSTANCE_BEGIN</td>
      <td>锁的内存空间起始地址</td>
    </tr>
    <tr>
      <td>BLOCKING_ENGINE_LOCK_ID</td>
      <td>等待释放的锁ID</td>
    </tr>
    <tr>
      <td>BLOCKING_ENGINE_TRANSACTION_ID</td>
      <td>等待结束的事务ID</td>
    </tr>
    <tr>
      <td>BLOCKING_THREAD_ID</td>
      <td>等待结束的线程ID</td>
    </tr>
    <tr>
      <td>BLOCKING_EVENT_ID</td>
      <td>等待结束的事件ID</td>
    </tr>
    <tr>
      <td>BLOCKING_OBJECT_INSTANCE_BEGIN</td>
      <td>等待结束的锁的内存空间起始地址</td>
    </tr>
  </tbody>
</table>

<p>例如:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_lock_waits</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
                          <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">REQUESTING_ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140678484647376</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140678365511992</span>
<span class="n">REQUESTING_ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">635403</span>
            <span class="n">REQUESTING_THREAD_ID</span><span class="p">:</span> <span class="mi">48</span>
             <span class="n">REQUESTING_EVENT_ID</span><span class="p">:</span> <span class="mi">15</span>
<span class="n">REQUESTING_OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365511992</span>
         <span class="n">BLOCKING_ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140678484646504</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140678365506120</span>
  <span class="cm">/*等待ID为635400的事务释放锁*/</span>
  <span class="n">BLOCKING_ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">635400</span>
              <span class="n">BLOCKING_THREAD_ID</span><span class="p">:</span> <span class="mi">47</span>
               <span class="n">BLOCKING_EVENT_ID</span><span class="p">:</span> <span class="mi">12</span>
  <span class="n">BLOCKING_OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/data_lock_waits.png" alt="" /></p>

<h4 id="3-innodb存储引擎行锁算法">3. InnoDB存储引擎行锁算法</h4>

<p>InnoDB存储引擎存在3种行锁算法，分别为:</p>

<ul>
  <li>Record Lock: 单个行记录上的锁</li>
  <li>Gap Lock: 间隙锁，锁定一个范围，单不包含记录本身</li>
  <li>Next-Key Lock: Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身</li>
</ul>

<p>Record Lock表示单个行记录上的锁，这非常好理解，例如我们<code class="highlighter-rouge">update</code>一条或多条数据时，事务会为这一条或者多条数据均添加X锁。当使用主键ID进行更新时，记录仅包含聚簇索引行记录。当使用辅助索引进行更新时，将会锁住聚簇索引记录+辅助索引记录。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="k">user</span> <span class="k">set</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="cm">/* 省略部分非关键信息 */</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">commit</span><span class="p">;</span>
</code></pre></div></div>

<p>当使用主键ID进行一致性锁定读时，<code class="highlighter-rouge">data_locks</code>生成两条锁记录，一条为table IX，另一条为行记录的X锁，注意<code class="highlighter-rouge">LOCK_MODE</code>后面的附加声明: REC_NOT_GAP，表示当前锁的算法仅为行记录锁，非间隙锁。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="k">user</span> <span class="k">set</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">where</span> <span class="n">user_id</span> <span class="o">=</span> <span class="nv">"174269548"</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">user_id_2</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="s1">'174269548'</span><span class="p">,</span> <span class="mi">1</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506464</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p>而使用辅助索引进行一致性锁定读时，除了table IX以及聚簇索引的X锁以外，还会有额外的辅助索引X锁，<code class="highlighter-rouge">LOCK_MODE</code>同样备注了非间隙锁的标识。</p>

<p>间隙锁的存在主要是为了解决幻读问题，幻读是指当某事务读取一定范围内的数据时，其余事务在该范围内插入了一条或多条数据，或者删除了一条或多条数据，导致前一个事务读取的数据条数发生改变，如同出现幻觉，所以称为幻读。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="n">supremum</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">record</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">3</span>
</code></pre></div></div>

<p>当我们对某一个范围使用一致性锁定读时，就可以看到间隙锁的产生。<code class="highlighter-rouge">LOCK_MODE</code>仅为X时，就表示当前锁添加了间隙锁。并且在<code class="highlighter-rouge">LOCK_DATA</code>有supremum pseudo-record的解释说明，该说明表示MySQL决定锁定最大间隙范围。在本例中，为id大于2的所有数据，故另一个事务执行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">insert</span> <span class="k">into</span> <span class="k">user</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">nickname</span><span class="p">,</span> <span class="n">password</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">mobile_area</span><span class="p">,</span> <span class="n">gender</span><span class="p">,</span> <span class="n">avatar</span><span class="p">,</span> <span class="n">account_id</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="nv">"jojo"</span><span class="p">,</span> <span class="nv">"passwd"</span><span class="p">,</span> <span class="nv">"147523659"</span><span class="p">,</span> <span class="nv">"13555555555"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">"https://jojo.com"</span><span class="p">,</span> <span class="nv">"1753681429"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>将会被阻塞，直至前一个事务释放间隙锁或者当前事务锁等待超时。</p>

<p>在理解了间隙锁以后，Next-Key Lock就很容易理解了，锁定一个记录+一个范围。上面例子均有一个特点，就是不管是主键ID，还是user_id，它们都具有unique约束，而对于非唯一的辅助索引而言，即使是精确查询并加锁，也会添加Gap Lock，此时就是Next-Key Lock。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">updated_at</span> <span class="o">=</span> <span class="nv">"2020-01-23 21:32:52"</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="cm">/*此时DB中仅存在一条数据更新时间为"2020-01-23 21:32:52"*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">updated_at</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="n">supremum</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">record</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">updated_at</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">0</span><span class="n">x99A56F5834</span><span class="p">,</span> <span class="mi">1</span>
<span class="o">***************************</span> <span class="mi">4</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">updated_at</code>字段仅添加了普通索引，并且值为”2020-01-23 21:32:52”的记录主键ID为1，从<code class="highlighter-rouge">data_locks</code>的最后一条记录也可以看出。在该表的第二行和第三行中分别添加了间隙锁，第三行的<code class="highlighter-rouge">LOCK_DATA</code>字段值为16进制数+主键ID。</p>

<p>此外，<strong>需要尤为注意的是，<code class="highlighter-rouge">READ COMMITTED</code>事务隔离级别下，将不会有间隙锁的添加</strong>。在文章<a href="https://smartkeyerror.com/django-concurrent-data-process">Django处理数据并发问题</a>中描述了使用Django默认的<code class="highlighter-rouge">READ COMMITTED</code>事务隔离级别所带来的问题。</p>

<h4 id="4-自增长与锁">4. 自增长与锁</h4>

<p>自增长在数据库中是非常常见的属性，MySQL提供<code class="highlighter-rouge">AUTO_INCREMENT</code>属性使得列可具备自增长的功能。在InnoDB存储引擎内存结构中，对每个含有自增长值的表都有一个自增长计数器。</p>

<p>最初自增长是采用特殊的表锁实现，称为AUTO_INC Locking，为了提高插入的性能，锁并不是在事务结束时才释放，而是在完成对自增长值插入的SQL语句后立即释放。虽然AUTO_INC Locking从一定程度上提高了并发插入的效率，但是仍存在性能问题: 事务必须等待前一个事务插入语句的结束。所以，后续就有了轻量级的互斥量自增长实现。</p>

<p>互斥量的实现就是文章最开头所说的Latch，由硬件协助实现。该实现方式只有在确定所插入的行数时才会使用，否则，将仍然使用AUTO_INC Locking。</p>

<h4 id="5-metadata-lock">5. Metadata Lock</h4>

<p>Metadata Lock，又称为MDL，相较于行锁和表锁，其范围更广，对象包括数据库、表、行以及触发器和外键等，与InnoDB其它锁一样，在事务开始时获取，事务结束时释放，其设计目的在于保证在事务执行过程中表的结构不会被修改。</p>

<p>通常来讲，只有在修改表结构的时候我们才会直接地与MDL打交道，例如向某张表添加一列，或者删除某一列。在DML执行非常频繁的应用中，当我们执行ALTER TABLE table ADD column时，很有可能出现整个MySQL挂掉的情况，其原因就在于表结构修改语句获取MDL时阻塞，导致后续对该表的查询、修改和删除等语句阻塞。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/MDL.png" alt="" /></p>

<p>session A与session B会向表user添加只读MDL，而session C想要申请可写的MDL，由于前面两个事务均为提交，故只能阻塞。此时由于session C写锁的申请，导致session D以及后续的所有DML操作均会被阻塞，简单来说，此时表user不可读写。</p>

<p>如果user表中的读写非常频繁，将会导致大量的查询或更新语句阻塞，且状态均为<code class="highlighter-rouge">waiting for metadata lock</code>。此时若客户端存在超时重试机制，那么会导致大量新的会话建立，最后达到MySQL线程数量的限制，导致整个DB不可用。</p>

<p>在MySQL 5.6版本以上支持Online DDL，其过程如下:</p>
<ul>
  <li>ALTER TABLE table ADD column语句获取MDL写锁</li>
  <li>获取成功后，将其降级为MDL读锁</li>
  <li>执行真正的DDL操作，如添加、删除列，期间可以执行DML语句</li>
  <li>升级MDL读锁为写锁</li>
  <li>释放MDL写锁，整个DDL过程结束</li>
</ul>

<p>真正导致数据库不可读写的步骤为1、4，第3步为实际运行时间最长的步骤，不会影响表的读写操作，只要内存和磁盘容量足够，数据量再多也灭有关系。所以，DDL的关键影响因素不在于数据量，而是在于数据读写的QPS。这也是为什么表结构修改操作要放到月黑风高的凌晨进行操作的原因: 那时候访问量最少，而不是数据量最少。</p>

<p>在更改表结构时造成大面积读写操作阻塞的另一个原因就是长事务，即长时间运行的事务。即使QPS非常小，但是系统中存在长事务，同样会造成DDL语句获取写锁阻塞，从而阻塞后续的读写语句。</p>

<h4 id="6-reference">6. Reference</h4>

<ul>
  <li>https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_latch</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-trx-table.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/data-locks-table.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/data-lock-waits-table.html</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL中的悲观锁与常见的死锁场景</title>
	  <link>//MySQL-Pessimistic-Lock</link>
	  <author></author>
	  <pubDate>2019-09-18T21:39:25+00:00</pubDate>
	  <guid>//MySQL-Pessimistic-Lock</guid>
	  <description><![CDATA[
	     <p>在MySQL中， 锁机制是并发条件下保护数据一致性与稳定性的一个非常重要的机制， 并且事务的实现也依赖于于锁机制。 其锁定的数据不单包括数据行记录， 同时也包括缓冲池中的LRU列表数据、日志数据等。 悲观锁(FOR UPDATE)则是日常开发中使用最多的一种锁， 但是， 由于事务隔离级别的多样性导致了悲观锁在使用时常常会有不同的表现， 死锁在程序员稍不注意时就会发生。</p>

<!---more--->

<h4 id="1-悲观锁概述">1. 悲观锁概述</h4>
<p>在通用的程序设计语言中， 锁通常是基于某一个对象， 或者是一组对象而言。 在Python、Java和Golang中， 分别提供了<code class="highlighter-rouge">threading.Lock</code>、<code class="highlighter-rouge">synchronized</code>以及<code class="highlighter-rouge">sync.Mutex</code>互斥所机制。 而数据库要更为特殊一些， 其原因就在于我们所管理的不是一个个的对象， 而是一行行的数据。</p>

<p>InnoDB存储引擎支持的最小锁粒度为行锁， 可以通过在事务中执行<code class="highlighter-rouge">SELECT .. FOR UPDATE</code>为某一行或者是多行数据添加互斥锁。 锁的生命周期完全由InnoDB管理， 当事务成功提交或者是失败回滚时， 互斥锁则自动释放。</p>

<p>需要注意的一点是， 互斥锁必须在事务中执行才会生效。 当<code class="highlighter-rouge">autocommit</code>为<code class="highlighter-rouge">ON</code>时， 需要显示的使用<code class="highlighter-rouge">BEGIN</code>开启事务， 而后对数据添加互斥锁。</p>

<p>在程序设计语言中， 锁的目的是串行化修改、删除操作， InnoDB中的互斥锁有着同样的目的。 但是， 由于事务隔离级别的分类， 使得互斥锁的行为变得复杂许多。 其中最让人感到迷惑的就是为了解决幻读问题所添加的<code class="highlighter-rouge">GAP Lock</code>。</p>

<h4 id="2-事务隔离级别概述">2. 事务隔离级别概述</h4>

<p>不同的事务隔离级别， 悲观锁会产生不同的行为。 所以， 理解事务隔离级别是理解悲观锁的第一步。</p>

<p>InnoDB事务隔离级别从低到高依次为未提交读(READ UNCOMMITED)， 提交读(READ COMMITED)， 可重复读(READ REPEATABLE)以及串行化(SERIALIZABLE)。</p>

<p>未提交读指的是事务B可以读取到事务A未提交的数据， 此时若事务A回滚， 那么事务B读到的就是错误数据， 也称为脏数据。 该读取行为有时也会被称为脏读， 因为未提交读会导致脏读的问题， 从而导致数据混乱， 所以该事务隔离级别基本不会被使用。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/read-uncommitted-with-dirty-data.png" alt="" /></p>

<p>提交读是指在执行事务B时， 可以读取到事务A提交到的数据， 未提交的数据不可读取。 提交读解决了脏读的问题， 读取到的数据一定是已经持久化至磁盘的数据， 但是会出现同一条SQL语句在执行时出现不一致的情况。 例如事务A、B先后开始执行， 事务A首先读取row-1的内容， 而此时事务B对row-1的内容修改并提交， 此时事务A再次读取row-1数据， 发现其已经发生改变， 而该变化并不是事务A自身进行的。 这种情况又称为不可重复读。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/Read-Committed.png" alt="" /></p>

<p>可重复读， 顾名思义， 解决了提交读的不可重复读问题， 使得事务在读取同一行数据时， 结果并不会因为其它事务的执行而发生改变， 数据发生的修改行为在整个事务内是可以自恰的。 但是并没有解决幻读的问题， 幻读是指其余事务在某一个区间内插入数据， 而非修改数据， 此时事务也会读取到这部分插入的数据。 InnoDB借助MVCC(多版本并发控制)以及锁机制来解决幻读问题。</p>

<p>MVCC即在数据中添加版本号， 数据插入时会有初始版本号， 在修改、删除时更新版本号。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/Repeatable-Read.png" alt="" /></p>

<p>串行化指事务串行化执行， 自然就不会有出现上述出现的脏读、不可重复读以及幻读了。 一个很重要的事实是， 串行化的事务隔离级别执行效率并不会比可重复读事务隔离级别差很多。 同样的， 提交读执行效率也不会比可重复读执行效率高多少， 所以在优化数据库时， 事务隔离级别不应该是效率优化目标， 而是业务优化目标。</p>

<h4 id="3-mysql中的锁">3. MySQL中的锁</h4>

<p>使用<code class="highlighter-rouge">FOR UPDATE</code>对某一行或者是多行数据添加的锁， 其实是由MySQL更细粒度的锁组合而成的， 不同的事务隔离级别有不同的组合方式。</p>

<p>在InnoDB存储引擎中， 存在3种行锁的算法， 其分别为:</p>
<ul>
  <li>Record Lock: 单个行记录上的锁，聚集索引及辅助索引均会添加锁。</li>
  <li>Gap Lock: 间隙锁， 锁定一个范围， 但不包含行记录本身。</li>
  <li>Next-Key Lock: Record Lock + Gap Lock，锁定行记录本身并且锁定一个范围。</li>
</ul>

<p>下面用一个实际的例子来解释Record Lock以及Gap Lock。 首先表结构定义如下:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">lock_test</span> <span class="p">(</span>
  <span class="n">id</span> <span class="n">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="n">a</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">latin1</span><span class="p">;</span>

<span class="c1">-- 插入部分测试数据</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"1"</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"3"</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"5"</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"8"</span><span class="p">);</span>
</code></pre></div></div>

<p>接着执行下面的语句:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “5” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“4”); <br /> 阻塞，等待会话A事务的提交</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">COMMIT;</td>
      <td style="text-align: left">Query OK, 1 row affected (6.87 sec)</td>
    </tr>
  </tbody>
</table>

<p>尽管列<code class="highlighter-rouge">a</code>添加了辅助索引， 但是在对该列使用<code class="highlighter-rouge">FOR UPDATE</code>添加悲观锁时， 仍然会出现其它列被锁定的现象。 这是因为<code class="highlighter-rouge">a = "5"</code>该行数据不仅被添加了Record Lock， 并且也添加了Gap Lock， 其目的就是为了解决幻读问题， 前提是当前事务隔离级别为REPEATABLE READ。</p>

<p>在列<code class="highlighter-rouge">a</code>的辅助索引中， 值”5”之前的值为”3”， 故存在(3, 5)这个间隙， 所以在插入值”4”时， InnoDB为了杜绝幻读现象的发生， 使得只有在会话A事务提交时才允许插入操作的进行。 另外一点需要注意的是， 当查询的索引具有唯一属性时， InnoDB存储引擎会对Next-Key Lock进行优化， 将其降级为Record Lock， 即仅锁住索引本身， 而不锁定一个范围。</p>

<blockquote>
  <p>For a unique index with a unique search condition, InnoDB locks only the index record found, not the gap before it.</p>
</blockquote>

<h4 id="4-锁与事务之间的关联">4. 锁与事务之间的关联</h4>

<p>前面提到了Gap Lock的存在主要是为了解决幻读问题的发生， 而在READ COMMITTED事务隔离级别中， 只解决了脏读问题， 所以说， 在该事务隔离级别下， <code class="highlighter-rouge">FOR UPDATE</code>仅会添加Record Lock， 并不会添加Gap Lock。</p>

<blockquote>
  <p>For locking reads (SELECT with FOR UPDATE or FOR SHARE), UPDATE statements, and DELETE statements, InnoDB locks only index records, not the gaps before them.</p>
</blockquote>

<blockquote>
  <p>Because gap locking is disabled, phantom problems may occur, as other sessions can insert new rows into the gaps</p>
</blockquote>

<p>此外， 如果用户通过索引查询一个值， 并在其之上添加排它锁， 当查询的值不存在时， READ COMMITTED与REPEATABLE READ两个事务隔离级别所产生的行为同样存在差异， 一个最直观的差异就是REPEATABLE READ在并发条件下会产生死锁， 而READ COMMITTED则不会。</p>

<p>READ COMMITTED事务隔离级别:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “100” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “100” FOR UPDATE; <br /> 不会被阻塞</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“100”); <br /> 不会被阻塞</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">6</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“100”); <br /> 不会被阻塞</td>
    </tr>
    <tr>
      <td style="text-align: left">7</td>
      <td style="text-align: left">COMMIT;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">8</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">COMMIT;</td>
    </tr>
  </tbody>
</table>

<p>所以说， 当事务隔离级别为READ COMMITTED时， 无法使用Next-Key Lock来帮助我们实现类似于<code class="highlighter-rouge">update_or_create</code>或者是<code class="highlighter-rouge">get_or_create</code>等方法， 因为在并发条件下会造成重复数据创建， 除非表中存在唯一索引。 这也是Django框架官网中所提到的Multiply records问题。 感兴趣的小伙伴可访问官网获取更多详细内容:</p>

<blockquote>
  <p>https://docs.djangoproject.com/en/2.2/ref/models/querysets/#get-or-create</p>
</blockquote>

<p>REPEATABLE READ事务隔离级别:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE; <br /> 不会被阻塞</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“200”); <br /> 阻塞, 等待事务B的结束</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">6</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“200”); <br /> ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction，死锁发生</td>
    </tr>
  </tbody>
</table>

<p>当在REPEATABLE READ事务隔离级别级别下实现<code class="highlighter-rouge">get_or_create</code>方法时，会产生死锁问题， 原因就在于锁定的记录并不存在， 多个事务可同时对其添加悲观锁， 但是插入语句的执行位置是不确定的， 所以就会有死锁问题的出现。解决此类问题的一个方法就是使用指数退避方式的重试。</p>

<h4 id="5-死锁">5. 死锁</h4>

<p>通常来讲， 如果我们的SQL执行计划较为简单， 几乎所有的执行均为单条语句执行时， 死锁基本与我们无关。 但是当执行计划稍加复杂， 事务执行的语句较多时， 就会出现死锁问题。 一个最经典的死锁场景即为AB-BA死锁。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “400” FOR UPDATE;</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “400” FOR UPDATE<br /> 阻塞, 等待事务B的结束</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">6</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE; <br /> ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction，死锁发生</td>
    </tr>
  </tbody>
</table>

<p>当MySQL检测到死锁时， 会根据其事务权重选择性的回滚其中一个事务。 但是， 权重的判定完全由MySQL决定， 业务系统无法人为的干预， 如果某一个事务在业务系统中非常重要， 但是MySQL却回滚了该事务， 而业务系统仅捕捉了该异常并向外扩散的话， 并不是我们期望的结果。 所以， 在绝大多数场景下， 指数退避的重试策略要更好一些。 或者对于关键性的业务逻辑， 使用Redis等消息队列进行串行化操作。</p>

<p>另外一个死锁场景则是上一小节中我们所见到的并发执行<code class="highlighter-rouge">if not exist then create</code>模式所带来的死锁问题， 该模式在业务场景下其实非常常见。</p>

<h4 id="reference">Reference</h4>
<ul>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL中的联合索引与覆盖索引</title>
	  <link>//MySQL-union-index-and-cover-index</link>
	  <author></author>
	  <pubDate>2019-09-01T21:39:25+00:00</pubDate>
	  <guid>//MySQL-union-index-and-cover-index</guid>
	  <description><![CDATA[
	     <p>在上一篇文章中， 通过解析InnoDB存储引擎的<code class="highlighter-rouge">.ibd</code>数据存储文件得到了数据与索引的真实组织方式: 数据通过聚集索引在逻辑上连续存放， 二级索引保存数据主键ID(Row ID)， 多棵B+Tree组合起来提供高效的索引数据查询。 除辅助索引(二级索引)外， 联合索引与覆盖索引在日常中也会经常用到。</p>

<!---more--->

<h4 id="1-联合索引">1. 联合索引</h4>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">union_test</span> <span class="p">(</span>
	<span class="n">id</span> <span class="n">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
	<span class="n">user_id</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	<span class="n">order_id</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	<span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
	<span class="k">KEY</span> <span class="n">ix_union_order_id_user_id</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">union_test</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"0000"</span><span class="p">,</span> <span class="nv">"A0000"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">union_test</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"0000"</span><span class="p">,</span> <span class="nv">"A0001"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">union_test</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"0001"</span><span class="p">,</span> <span class="nv">"A0003"</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div>

<p>在创建表结构以及插入部分测试数据之后， 我们依然使用<code class="highlighter-rouge">hexdump -C</code>来对<code class="highlighter-rouge">.ibd</code>文件进行分析， 从最基本的数据存储结构中更能够发现联合索引的存储特点。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00010070  73 75 70 72 65 6d 75 6d  03 04 00 00 10 00 36 30  |supremum......60|
00010080  30 35 38 41 31 34 80 00  00 01 03 04 07 00 18 05  |058A14..........|
00010090  e2 30 30 33 36 41 32 30  80 00 00 02 03 04 08 00  |.0036A20........|
000100a0  20 00 fb 30 30 34 33 41  31 33 80 00 00 03 03 04  | ..0043A13......|
000100b0  00 00 28 01 67 30 30 35  39 41 32 31 80 00 00 04  |..<span class="o">(</span>.g0059A21....|
000100c0  03 04 08 00 30 02 65 30  30 34 39 41 38 39 80 00  |....0.e0049A89..|
000100d0  00 05 03 04 00 00 38 01  1f 30 30 35 31 41 35 34  |......8..0051A54|
000100e0  80 00 00 06 02 04 06 00  40 05 76 30 30 32 33 41  |........@.v0023A|
000100f0  36 80 00 00 07 03 04 00  00 48 02 0c 30 30 30 31  |6........H..0001|
00010100  41 35 30 80 00 00 08 03  04 00 00 50 06 19 30 30  |A50........P..00|
00010110  31 35 41 39 31 80 00 00  09 03 04 00 00 58 ff 83  |15A91........X..|
00010120  30 30 34 32 41 37 32 80  00 00 0a 03 04 00 00 60  |0042A72........<span class="sb">`</span>|
00010130  01 56 30 30 33 38 41 39  35 80 00 00 0b 03 04 00  |.V0038A95.......|
00010140  00 68 03 4f 30 30 32 39  41 39 37 80 00 00 0c 03  |.h.O0029A97.....|
00010150  04 05 00 70 05 41 30 30  35 37 41 31 31 80 00 00  |...p.A0057A11...|
00010160  0d 03 04 00 00 78 02 c0  30 30 31 39 41 35 32 80  |.....x..0019A52.|
</code></pre></div></div>

<p>直接截取部分的联合索引内容进行分析， 索引数据从<code class="highlighter-rouge">00010078</code>开始:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span> <span class="mi">04</span>  <span class="cm">/* 倒序索引长度列表 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">36</span>
<span class="mi">30</span> <span class="mi">30</span> <span class="mi">35</span> <span class="mi">38</span>  <span class="cm">/* 列1索引数据 */</span>
<span class="mi">41</span> <span class="mi">31</span> <span class="mi">34</span>  <span class="cm">/* 列2索引数据 */</span>
<span class="mi">80</span> <span class="mi">00</span>  <span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 主键id */</span>
</code></pre></div></div>

<p>可以看到， 联合索引的物理存储方式与单一索引的最大区别就是索引数据不是分开存储的。 所以， 联合索引要比两个或多个单独的索引占用更少的磁盘空间。</p>

<p>事实上， 联合索引与单列索引在组织形式上没什么区别， 都是一棵B+Tree。 只不过联合索引的键值数量不是1， 而是大于等于2。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/union-index.png" alt="" /></p>

<p>如上图所示， 联合索引的第1列数据将严格按照B+Tree的字典序进行排序， 第2列数据则在第一列数据有序的基础上进行排序。 可以认为， 联合索引的B+Tree结构就是对一个多维数组进行排序， 以Python为例:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 假设有如下数据</span>
<span class="n">unsorted_list</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>

<span class="n">res</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">unsorted_list</span><span class="p">)</span>
<span class="c"># Out: [(1, 2), (1, 3), (2, 4), (2, 5), (4, 1), (4, 2)]</span>
</code></pre></div></div>

<p>假设现在有两列数据a, b组合成为了联合索引， 那么当a列相同时， b列数据一定是有序存放的， 也就是说当执行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">a</span> <span class="o">=</span> <span class="n">XX</span> <span class="k">AND</span> <span class="n">b</span> <span class="o">=</span> <span class="n">XX</span><span class="p">;</span>
</code></pre></div></div>

<p>其效率要高于a, b两个单独的索引列查询， 原因就在于其索引数据保存在同一棵B+Tree中， 使用更少的逻辑I/O就能将数据取出。</p>

<p>在单独查询列a时， 依然可以使用联合索引进行查询， 但是在单独查询b列时， 则不可以使用联合索引。 因为b列数据并不是有序存放的。</p>

<p>如上例所示， b列的数据为<code class="highlighter-rouge">[2, 3, 2, 4, 1, 2]</code>， 完全无序， 故使用:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">b</span> <span class="o">=</span> <span class="n">XX</span><span class="p">;</span>
</code></pre></div></div>

<p>进行查询时将无法使用联合索引。 联合索引除了能加速查询以外， 还有另外一个好处， 就是加速<code class="highlighter-rouge">ORDER BY</code>的查询。</p>

<p>这也很好理解， 因为在建立了联合索引以后， 第2列数据， 甚至是第n列数据， 将会有序的组成B+Tree， 如此一来就省去了排序的的时间。</p>

<p>假设现在有4列数据a, b, c, d组成的联合索引(a, b, c, d)， 那么B+Tree的结构为a有序排列， b在a相同的情况下有序排列， c在b相同的情况下有序排列， d在c相同的情况下有序排列。 在查询时， 只要查询条件包含a字段， 均可以使用索引进行查询。</p>

<h4 id="2-覆盖索引cover-index">2. 覆盖索引(Cover Index)</h4>
<p>现在我们已经知道了InnoDB的物理存储方式是一个聚集索引+多个辅助索引组成， 辅助索引包含单列索引以及上面提到的联合索引。 在使用索引进行数据查询时， 首先在辅助索引树中找到该条数据对应的主键id(Row ID)， 而后根据主键id在聚集索引树中进行查询， 粗略的认为就是2次逻辑I/O。</p>

<p>覆盖索引的本质就是不使用聚集索引， 只使用辅助索引就能够将所需要的数据查询出来， 最典型的例子就是<code class="highlighter-rouge">count(*)</code>。</p>

<p>当某张表内存在二级索引时， <code class="highlighter-rouge">count(*)</code>将直接统计二级索引的数量并返回。 由于二级索引的B+Tree要比聚集索引更加的矮胖， 每页能够容纳更多的索引数据行， 所以其效率要高于扫描聚集索引。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">count_test</span> <span class="p">(</span>
	<span class="n">id</span> <span class="n">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
	<span class="n">user_id</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	<span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
	<span class="k">KEY</span> <span class="n">ix_user_id</span> <span class="p">(</span><span class="n">user_id</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/count-with-cover-index.png" alt="" /></p>

<p>如果表内有多个二级索引， 则<code class="highlighter-rouge">count(*)</code>将会选择长度最短的二级索引。 索引长度越短， 每页就能够容纳更多的数据， 就会有更少的逻辑I/O， 因此效率也就越高。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">count_test</span> <span class="k">ADD</span> <span class="n">order_id</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">count_test</span> <span class="k">ADD</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">order_id</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/count-with-shorter-cover-index.png" alt="" /></p>

<p>覆盖索引严格意义上来讲是MySQL的查询优化器所做的优化， 并不是物理上存在的索引。 但是， 借助于覆盖索引的特点， 我们可以有目的的对某些查询进行优化。</p>

<h4 id="3-小结">3. 小结</h4>
<p>联合索引是优化多字段查询以及需要对某个字段进行排序的一种手段， 而覆盖索引则是MySQL查询优化器的一种优化策略， 并不能称为真正意义上的索引。</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL物理存储方式</title>
	  <link>//MySQL-physical-structure</link>
	  <author></author>
	  <pubDate>2019-08-15T21:39:25+00:00</pubDate>
	  <guid>//MySQL-physical-structure</guid>
	  <description><![CDATA[
	     <p>MySQL是基于磁盘进行数据存储的关系型数据库， 所有的数据、索引等数据均以磁盘文件的方式存储， 在有需要时载入内存读取。 为了加快数据查询的效率， 通常会在一些字段上添加索引， 但是许多文档都会告诉我们， 不要添加太多的索引， 索引不要太长， 使用数字或者空字符串来代替NULL值， 为什么会有这些建议? 这些建议又是否正确?  答案都能够从MySQL数据的物理存储方式中找到。</p>

<!---more--->

<h4 id="1-innodb文件格式">1. InnoDB文件格式</h4>
<p>由于InnoDB是MySQL使用最为广泛的存储引擎， 所以本篇博文基于InnoDB存储引擎来讨论其数据存储方式。</p>

<p>当我们创建一个table时， InnoDB会创建三个文件。 一个是表结构定义文件， 另一个为数据实际存储文件， 并且所有的索引也将存放在这个文件中。 最后一个文件保存该table所制定的字符集。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/innodb-table-structure.png" alt="" /></p>

<h4 id="2-innodb行记录格式">2. InnoDB行记录格式</h4>
<p>当我们使用SQL查询一条或者是多条数据时， 数据将会以一行一行的方式返回， 而实际上数据在文件中也的确是使用行记录的方式进行存储的。</p>

<p>不同的InnoDB引擎版本可能有着不同的行记录格式来存放数据， 可以说， 行记录格式的变更将会直接影响到InnoDB的查询以及DML效率。 在MySQL 5.7版本中， 如果对某个table执行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SHOW</span> <span class="k">TABLE</span> <span class="n">STATUS</span> <span class="k">LIKE</span> <span class="nv">"table_name"</span> <span class="err">\</span><span class="k">G</span><span class="p">;</span>
</code></pre></div></div>

<p>将会得到该table的一系列信息， 在这里， 我们只需要知道<code class="highlighter-rouge">Row_format</code>的值即可， 5.7将会返回<code class="highlighter-rouge">Dynamic</code>。</p>

<p>在官网上给出了不同格式的行记录格式之间的差别， 详细内容见官方文档:</p>

<blockquote>
  <p>https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html</p>
</blockquote>

<p>在这里我们只需要知道<code class="highlighter-rouge">Dynamic</code>行记录格式在存储可变字符(Varchar)时， 与<code class="highlighter-rouge">Compact</code>行记录格式有着同样的表现即可。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/Compact-row-format.png" alt="" /></p>

<p>Compact行记录格式将以上图的方式保存在文件中， 需要注意的是， 如果一个table中没有任何的varchar类型， 那么变长字段长度列表将为空。</p>

<p>Compact行记录格式的首部是一个非NULL变长字段长度列表， 并且是按照列的顺序逆序放置的， 其长度表现为:</p>
<ul>
  <li>若列的长度小于255字节， 用1字节表示</li>
  <li>若列的长度大于255字节， 用2字节表示</li>
</ul>

<p>变长字段的长度最大不会超过2字节， 这是因为MySQL中VARCAHR类型的最大长度限制为65535。 变长字段之后的第二个部分为NULL标识位， 该位指示了该行数据中是否存在NULL值， 有则用1表示， 本质上是一个bitmap。</p>

<p>下面用一个实际的例子来具体分析Compact行记录格式的实际存储。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 创建database</span>
<span class="k">CREATE</span> <span class="k">SCHEMA</span> <span class="nv">`coco`</span> <span class="k">DEFAULT</span> <span class="n">CHARACTER</span> <span class="k">SET</span> <span class="n">latin1</span> <span class="p">;</span>

<span class="c1">-- 创建table</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">one</span> <span class="p">(</span>
    <span class="n">id</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">nickname</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="p">(</span><span class="n">nickname</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>

<span class="c1">-- 插入代表性数据</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"a"</span><span class="p">,</span> <span class="nv">"AAA"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"b"</span><span class="p">,</span> <span class="nv">"BBB"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"c"</span><span class="p">,</span> <span class="k">NULL</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"d"</span><span class="p">,</span> <span class="nv">"DDD"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"e"</span><span class="p">,</span> <span class="nv">""</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"f"</span><span class="p">,</span> <span class="nv">"FFF"</span><span class="p">);</span>
</code></pre></div></div>

<p>而后在<code class="highlighter-rouge">/var/lib/mysql/coco</code>中即可找到该表的<code class="highlighter-rouge">.ibd</code>文件了， 使用<code class="highlighter-rouge">hexdump -C one.ibd</code>对其进行16进制的数据解析并查看。 由于数据太长， 所以仅截取部分数据:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000c070  73 75 70 72 65 6d 75 6d  03 01 00 00 00 10 00 1d  |supremum........|
0000c080  80 00 00 01 00 00 00 08  d1 29 bd 00 00 01 35 01  |.........<span class="o">)</span>....5.|
0000c090  10 61 41 41 41 03 01 00  00 00 18 00 1c 80 00 00  |.aAAA...........|
0000c0a0  02 00 00 00 08 d1 29 bd  00 00 01 35 01 1d 62 42  |......<span class="o">)</span>....5..bB|
0000c0b0  42 42 01 02 00 00 20 00  1a 80 00 00 03 00 00 00  |BB.... .........|
0000c0c0  08 d1 29 bd 00 00 01 35  01 2a 63 03 01 00 00 00  |..<span class="o">)</span>....5.<span class="k">*</span>c.....|
0000c0d0  28 00 1d 80 00 00 04 00  00 00 08 d1 29 bd 00 00  |<span class="o">(</span>...........<span class="o">)</span>...|
0000c0e0  01 35 01 37 64 44 44 44  00 01 00 00 00 30 00 1a  |.5.7dDDD.....0..|
0000c0f0  80 00 00 05 00 00 00 08  d1 29 bd 00 00 01 35 01  |.........<span class="o">)</span>....5.|
0000c100  44 65 03 01 00 00 00 38  ff 66 80 00 00 06 00 00  |De.....8.f......|
0000c110  00 08 d1 29 bd 00 00 01  35 01 51 66 46 46 46 00  |...<span class="o">)</span>....5.QfFFF.|
</code></pre></div></div>

<p>实际存储数据从<code class="highlighter-rouge">0000c078</code>开始， 使用Compact行记录格式对其进行整理:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span> <span class="mi">01</span> <span class="cm">/* 变长字段长度列表, 逆序, 第一行varchar数据为('a', 'AAA') */</span>
<span class="mi">00</span> <span class="cm">/* NULL标识位, 该值表示该行未有NULL值的列 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">1</span><span class="n">d</span> <span class="cm">/* 记录头(Record Header)信息, 固定长度为5字节 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="cm">/* Row ID, 这里即为该行数据的主键值(paimary key)，长度为4 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">08</span> <span class="n">d1</span> <span class="mi">29</span> <span class="cm">/* Transaction ID, 即事务ID, 默认为6字节 */</span>
<span class="n">bd</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">35</span> <span class="mi">01</span> <span class="mi">10</span> <span class="cm">/* 回滚指针, 默认为7字节 */</span>
<span class="mi">61</span> <span class="cm">/* 列1数据'a' */</span>
<span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span> <span class="cm">/* 列2数据'AAA' */</span>
</code></pre></div></div>

<p>第2行数据与第1行数据大同小异， 值得关注的是包含有NULL值以及空值的行， 即第3行和第5行， 首先来看第3行数据:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">01</span> <span class="cm">/* 由于该行中只有一列数据类型为varchar，并且非NULL, 所以列表长度为1 */</span>
<span class="mi">02</span> <span class="cm">/* 02转换为2进制结果为10, 表示第二列数据为NULL(注意是逆序) */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">20</span> <span class="mi">00</span> <span class="mi">1</span><span class="n">a</span> <span class="cm">/* 记录头(Record Header)信息, 固定长度为5字节 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">03</span> <span class="cm">/* 第3行数据的主键id */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">08</span> <span class="n">d1</span> <span class="mi">29</span>  <span class="cm">/* Transaction ID, 即事务ID, 默认为6字节 */</span>
<span class="n">bd</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">35</span>  <span class="mi">01</span> <span class="mi">2</span><span class="n">a</span> <span class="cm">/* 回滚指针, 默认为7字节 */</span>
<span class="mi">63</span> <span class="cm">/* 列1数据'c' */</span>
</code></pre></div></div>

<p>可以非常明显的看到， NULL值并没有在文件中进行存储， 而是仅使用NULL标识位来标记某一列是否为NULL。 所以说， NULL值不会占据任何的物理存储空间， 相反， varchar类型的NULL值还会少占用变长字段长度列表空间。</p>

<p>再来看空字符串所在的第5行数据:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 表示第2列的varchar长度为0 */</span>
<span class="mi">00</span>  <span class="cm">/* 该行没有NULL值的列 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">30</span> <span class="mi">00</span> <span class="mi">1</span><span class="n">a</span>  <span class="cm">/* 记录头(Record Header)信息, 固定长度为5字节 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">05</span>  <span class="cm">/* 第5行数据的主键id */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">08</span> <span class="n">d1</span> <span class="mi">29</span>  <span class="cm">/* Transaction ID, 即事务ID, 默认为6字节 */</span>
<span class="n">bd</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">35</span> <span class="mi">01</span> <span class="mi">44</span>   <span class="cm">/* 回滚指针, 默认为7字节 */</span>
<span class="mi">65</span>  <span class="cm">/* 列1数据'e' */</span>
</code></pre></div></div>

<p>可以看到， 空字符串和NULL值一样， 也不占用任何的磁盘存储空间。 只不过与NULL值不同的是， 在首部的变长字符长度列表中仍然占据存储空间， 但是值为0。</p>

<h4 id="3-数据的聚集索引组织方式">3. 数据的聚集索引组织方式</h4>
<p>有些人将聚集索引(Cluster Index)理解成为主键， 或者是主键索引， 这是不准确的。 聚集索引并不是一种索引结构， 而是一种数据的组织方式， 用唯一且不为空的主键来对所有的数据进行组织。 主键， 是最为常见的聚集索引对外表现的形式。</p>

<p>聚集索引最大的特点就在于数据在逻辑上是一定是连续的， 但是在物理是并不一定连续。 比如我们常见的自增主键， 当我们对查询语句不做任何处理时， 默认就是按照主键的递增顺序返回的。</p>

<p>而辅助索引， 或者是二级索引， 是由程序员人为的在某些列上所添加的索引。 辅助索引所代表的数据在逻辑上不一定连续， 物理存储上也不一定连续。</p>

<p>MySQL使用B+Tree来组织数据和索引(关于B+Tree的详细内容， 可见下方传送门)， 在非叶子节点中保存着索引和指针， 在叶子节点保存着数据。 情况又分两种:</p>
<ul>
  <li>聚集索引的叶子节点保存着实际的数据，即一行完整的数据</li>
  <li>辅助索引的叶子节点保存着该行数据的主键ID</li>
</ul>

<p><a href="https://smartkeyerror.com/%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-04-B-Tree%E4%B8%8EB-Tree.html">那些有趣的数据结构与算法(04)–B-Tree与B+Tree</a></p>

<p>也就是说， 假设聚集索引和辅助索引的B+Tree树高均为3的话， 使用主键查询需要3次逻辑I/O。 而使用辅助索引则需要6次逻辑I/O才能找到该行数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/Cluster-Index.png" alt="" /></p>

<p>还记得在上面的Compact行记录格式中的行记录头， 也就是Record Header信息吗?  Record Header的最后两个字节表示下一行数据的偏移量， 其实这个就是B+Tree中的指针。 例如第一行的起始位置为c078， Record Header最后两个字节为001d， 加起来等于c095， 刚好是第二行的起始位置。</p>

<p>在上面的例子中， 我们创建了这样的一张表:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">one</span> <span class="p">(</span>
    <span class="n">id</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">nickname</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="p">(</span><span class="n">nickname</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">nickname</code>字段被我们添加了辅助索引， 同样地， 可以使用<code class="highlighter-rouge">.ibd</code>文件来具体对其结构进行分析。 使用<code class="highlighter-rouge">hexdump -C one.ibd</code>解析文件并找到辅助索引开始的地方:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00010060</span>  <span class="mi">02</span> <span class="mi">00</span> <span class="mi">37</span> <span class="mi">69</span> <span class="mi">6</span><span class="n">e</span> <span class="mi">66</span> <span class="mi">69</span> <span class="mi">6</span><span class="n">d</span>  <span class="mi">75</span> <span class="mi">6</span><span class="n">d</span> <span class="mi">00</span> <span class="mi">07</span> <span class="mi">00</span> <span class="mi">0</span><span class="n">b</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="o">|</span><span class="p">..</span><span class="mi">7</span><span class="n">infimum</span><span class="p">......</span><span class="o">|</span>
<span class="mi">00010070</span>  <span class="mi">73</span> <span class="mi">75</span> <span class="mi">70</span> <span class="mi">72</span> <span class="mi">65</span> <span class="mi">6</span><span class="n">d</span> <span class="mi">75</span> <span class="mi">6</span><span class="n">d</span>  <span class="mi">03</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">0</span><span class="n">e</span> <span class="mi">41</span>  <span class="o">|</span><span class="n">supremum</span><span class="p">.......</span><span class="n">A</span><span class="o">|</span>
<span class="mi">00010080</span>  <span class="mi">41</span> <span class="mi">41</span> <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">03</span> <span class="mi">00</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">18</span> <span class="mi">00</span> <span class="mi">18</span> <span class="mi">42</span> <span class="mi">42</span> <span class="mi">42</span>  <span class="o">|</span><span class="n">AA</span><span class="p">...........</span><span class="n">BBB</span><span class="o">|</span>
<span class="mi">00010090</span>  <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">02</span> <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">20</span>  <span class="mi">00</span> <span class="mi">19</span> <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">03</span> <span class="mi">03</span> <span class="mi">00</span>  <span class="o">|</span><span class="p">.......</span> <span class="p">........</span><span class="o">|</span>
<span class="mi">000100</span><span class="n">a0</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">28</span> <span class="mi">00</span> <span class="mi">19</span> <span class="mi">44</span> <span class="mi">44</span> <span class="mi">44</span>  <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">04</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="o">|</span><span class="p">..(..</span><span class="n">DDD</span><span class="p">........</span><span class="o">|</span>
<span class="mi">000100</span><span class="n">b0</span>  <span class="mi">30</span> <span class="n">ff</span> <span class="n">cc</span> <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">05</span> <span class="mi">03</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">38</span> <span class="n">ff</span> <span class="n">b2</span> <span class="mi">46</span> <span class="mi">46</span>  <span class="o">|</span><span class="mi">0</span><span class="p">..........</span><span class="mi">8</span><span class="p">..</span><span class="n">FF</span><span class="o">|</span>
<span class="mi">000100</span><span class="n">c0</span>  <span class="mi">46</span> <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">06</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="o">|</span><span class="n">F</span><span class="p">...............</span><span class="o">|</span>
<span class="mi">000100</span><span class="n">d0</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="o">|</span><span class="p">................</span><span class="o">|</span>
</code></pre></div></div>

<p>索引数据从00010078的位置开始， 逐行进行分析即可:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span>  <span class="cm">/* 当前索引字段的长度 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">0</span><span class="n">e</span> <span class="cm">/* 不知道是啥 */</span>
<span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span>   <span class="cm">/* 索引值 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 指向的主键id */</span>
</code></pre></div></div>

<p>第2行与第1行基本类似， 现在来看看比较特殊的第3行与第5行。 第3行索引数据内容:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">01</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">20</span> <span class="mi">00</span> <span class="mi">19</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">03</span>  <span class="cm">/* 指向的主键id */</span>
</code></pre></div></div>

<p>当索引的内容为NULL值时， 辅助索引的文件格式也变得奇怪了起来， 和第一行完全不一样， 再来看看第5行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00</span>  <span class="cm">/* 当前索引字段的长度 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">30</span> <span class="n">ff</span> <span class="n">cc</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">05</span>  <span class="cm">/* 指向的主键id */</span>
</code></pre></div></div>

<p>和正常索引内容基本类似， 空字符串仍然没有表示， 仅使用了00表示该字段长度为0。</p>

<h4 id="4-辅助索引叶子节点存储方式">4. 辅助索引叶子节点存储方式</h4>
<p>在MySQL中， 数据管理的最小单元为页(page)， 而并非一行一行的数据。 数据保存在页中， 当我们使用主键查找一行数据时， 其实MySQL并不能直接返回这一行数据， 而是将该行所在的页载入内存， 然后在内存页中进行查找。</p>

<p>通常情况下页大小为16K， 在某些情况下可能会对页进行压缩， 使得页大小为8K或者是4K。 由于B+Tree的特点， 使得每一页内最少为2行数据， 再少就将退化成链表， 显然出于效率的考量不会让此种情况出现。 故而一行数据大小至多为16K， 通过该特性， 就可以研究二级索引的叶子节点是什么样子的了。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">two</span> <span class="p">(</span>
    <span class="n">id</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">nickname</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">8000</span><span class="p">),</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="p">(</span><span class="n">nickname</span><span class="p">(</span><span class="mi">2000</span><span class="p">))</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'A'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'C'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">,</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'E'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">'f'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'F'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">'g'</span><span class="p">,</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">'h'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'H'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">'i'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'G'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">'i'</span><span class="p">,</span> <span class="nv">""</span><span class="p">;</span>
</code></pre></div></div>

<p>由于索引长度的限制， 这里仅取nickname的前2000个字符进行索引， 并插入一些具有代表性的数据。 同样使用<code class="highlighter-rouge">hexdump -C two.ibd</code>对索引结构进行分析:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00010070  73 75 70 72 65 6d 75 6d  d0 87 00 05 00 10 07 e6  |supremum........|
00010080  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|
<span class="k">*</span>
00010850  80 00 00 01 01 00 00 18  07 e6 80 00 00 02 d0 87  |................|
00010860  00 00 00 20 07 e6 43 43  43 43 43 43 43 43 43 43  |... ..CCCCCCCCCC|
00010870  43 43 43 43 43 43 43 43  43 43 43 43 43 43 43 43  |CCCCCCCCCCCCCCCC|
<span class="k">*</span>
00011030  43 43 43 43 43 43 80 00  00 03 01 00 00 28 0f c2  |CCCCCC.......<span class="o">(</span>..|
00011040  80 00 00 04 d0 87 00 00  00 30 07 dc 45 45 45 45  |.........0..EEEE|
00011050  45 45 45 45 45 45 45 45  45 45 45 45 45 45 45 45  |EEEEEEEEEEEEEEEE|
<span class="k">*</span>
00011810  45 45 45 45 45 45 45 45  45 45 45 45 80 00 00 05  |EEEEEEEEEEEE....|
00011820  d0 87 00 00 00 38 0f c2  46 46 46 46 46 46 46 46  |.....8..FFFFFFFF|
00011830  46 46 46 46 46 46 46 46  46 46 46 46 46 46 46 46  |FFFFFFFFFFFFFFFF|
<span class="k">*</span>
00011ff0  46 46 46 46 46 46 46 46  80 00 00 06 01 00 00 40  |FFFFFFFF.......@|
00012000  0f c3 80 00 00 07 d0 87  00 00 00 48 e0 62 48 48  |...........H.bHH|
00012010  48 48 48 48 48 48 48 48  48 48 48 48 48 48 48 48  |HHHHHHHHHHHHHHHH|
<span class="k">*</span>
000127d0  48 48 48 48 48 48 48 48  48 48 48 48 48 48 80 00  |HHHHHHHHHHHHHH..|
000127e0  00 08 d0 87 00 00 00 50  f8 24 47 47 47 47 47 47  |.......P.<span class="nv">$GGGGGG</span>|
000127f0  47 47 47 47 47 47 47 47  47 47 47 47 47 47 47 47  |GGGGGGGGGGGGGGGG|
<span class="k">*</span>
00012fb0  47 47 47 47 47 47 47 47  47 47 80 00 00 09 00 00  |GGGGGGGGGG......|
00012fc0  00 00 58 d0 bb 80 00 00  0a 00 00 00 00 00 00 00  |..X.............|
00012fd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</code></pre></div></div>

<p>从上表中可以看到， 索引数据起始点为00010078， 逐行进行分析可以发现， NULL值和空值的表现形式与上一小节分析的基本相同。</p>

<p>NULL值行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">01</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">18</span> <span class="mi">07</span> <span class="n">e6</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">02</span>  <span class="cm">/* 主键id */</span>

<span class="mi">01</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">28</span> <span class="mi">0</span><span class="n">f</span> <span class="n">c2</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">04</span>  <span class="cm">/* 主键id */</span>

<span class="mi">01</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">40</span> <span class="mi">0</span><span class="n">f</span> <span class="n">c3</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">07</span>  <span class="cm">/* 主键id */</span>
</code></pre></div></div>

<p>空字符串行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">58</span> <span class="n">d0</span> <span class="n">bb</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">0</span><span class="n">a</span>  <span class="cm">/* 主键id */</span>
</code></pre></div></div>

<p>所以说， 分析到这里， 我们完全有理由说NULL值要比空值占用更少的物理存储空间， 包含索引存储空间。 但是， 这是在我们所定义表结构时允许字段值为NULL的前提下， 当我们显式的指定IS NOT NULL时， 情况又会不一样。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">three</span> <span class="p">(</span>
    <span class="n">id</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">nickname</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="p">(</span><span class="n">nickname</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"a"</span><span class="p">,</span> <span class="nv">"AAA"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"b"</span><span class="p">,</span> <span class="nv">""</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"c"</span><span class="p">,</span> <span class="nv">"CCC"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"d"</span><span class="p">,</span> <span class="nv">"DDD"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"e"</span><span class="p">,</span> <span class="nv">"EEE"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"f"</span><span class="p">,</span> <span class="nv">""</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"g"</span><span class="p">,</span> <span class="nv">"GGG"</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">hexdump -C three.ibd</code>可得:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000c070  73 75 70 72 65 6d 75 6d  03 01 00 00 10 00 1c 80  |supremum........|
0000c080  00 00 01 00 00 00 08 dd  21 ba 00 00 01 2f 01 10  |........!..../..|
0000c090  61 41 41 41 00 01 00 00  18 00 19 80 00 00 02 00  |aAAA............|
0000c0a0  00 00 08 dd 22 bb 00 00  01 31 01 10 62 03 01 00  |....<span class="s2">"....1..b...|
0000c0b0  00 20 00 1c 80 00 00 03  00 00 00 08 dd 25 bd 00  |. ...........%..|
0000c0c0  00 01 35 01 10 63 43 43  43 03 01 00 00 28 00 1c  |..5..cCCC....(..|
0000c0d0  80 00 00 04 00 00 00 08  dd 28 bf 00 00 01 36 01  |.........(....6.|
0000c0e0  10 64 44 44 44 03 01 00  00 30 00 1c 80 00 00 05  |.dDDD....0......|
0000c0f0  00 00 00 08 dd 29 c0 00  00 01 37 01 10 65 45 45  |.....)....7..eEE|
0000c100  45 00 01 00 00 38 00 19  80 00 00 06 00 00 00 08  |E....8..........|
0000c110  dd 2a a1 00 00 01 12 01  10 66 03 01 00 00 40 ff  |.*.......f....@.|
0000c120  4f 80 00 00 07 00 00 00  08 dd 2b a2 00 00 01 15  |O.........+.....|
0000c130  01 10 67 47 47 47 00 00  00 00 00 00 00 00 00 00  |..gGGG..........|
</span></code></pre></div></div>

<p>数据从c078开始， 同样进行逐行分析:</p>

<p>第一行数据:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span> <span class="mi">01</span>  <span class="cm">/* 逆序可变字符长度列表 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">1</span><span class="k">c</span>  <span class="cm">/* 记录头信息(Record Header), c078+001c=c094 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 主键id */</span>
<span class="c1">-- Transaction ID + Roll Pointer</span>
<span class="mi">61</span>  <span class="cm">/* 列1数据 */</span>
<span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span>  <span class="cm">/* 列2数据 */</span>
</code></pre></div></div>

<p>第二行数据</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 逆序可变字符长度列表 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">18</span> <span class="mi">00</span> <span class="mi">19</span>  <span class="cm">/* 记录头信息(Record Header), c094+0019=c0ad */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">02</span>  <span class="cm">/* 主键id */</span>
<span class="c1">-- Transaction ID + Roll Pointer</span>
<span class="mi">62</span>  <span class="cm">/* 列1数据, 列2数据为空值, 故无记录 */</span>
</code></pre></div></div>

<p>第三行数据:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span> <span class="mi">01</span>  <span class="cm">/* 逆序可变字符长度列表 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">20</span> <span class="mi">00</span> <span class="mi">1</span><span class="k">c</span>  <span class="cm">/* 记录头信息(Record Header), c0ad+001c=c0c9 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">03</span>  <span class="cm">/* 主键id */</span>
<span class="c1">-- Transaction ID + Roll Pointer</span>
<span class="mi">63</span>  <span class="cm">/* 列1数据 */</span>
<span class="mi">43</span> <span class="mi">43</span> <span class="mi">43</span>  <span class="cm">/* 列2数据 */</span>
</code></pre></div></div>

<p>可以看到， 将<strong>所有</strong>的列设置为NOT NULL之后， 存储内容少了一个NULL标识位， 此时该table的存储效率要高于最初的表结构。</p>

<p>所以说， 如果想要真正的节省表空间存储大小， 需要将<strong>所有</strong>的字段都设置为NOT NULL约束， 否则在存储时仍然需要NULL标识位来标记哪一列数据为非NULL， 即使所有的列都有数据。</p>

<p>最后， NULL真的比空字符串占用更少的空间吗? 答案是不一定。 如果在定义表结构时指定了NOT NULL， 那么数据中就不可能出现NULL值， 也就无从比起。 如果在定义表结构时没有指定NOT NULL， 那么NULL将会比空字符串占用更少的空间。</p>

<h4 id="5-总结">5. 总结</h4>
<p>经过对<code class="highlighter-rouge">.ibd</code>文件的分析， 想必对数据以及索引的组织方式有了一个更加清晰的了解， 并且也能够判断出各种各样优化建议到底是否正确了。</p>

<p>使用数字或者是空串来代替NULL值? 没有必要， 有时还会适得其反， 而且对于添加了二级索引的NULL值， 查询仍然会使用索引。 正确的做法就是在定义表结构的时候就将NULL值扼杀在摇篮里， 如此一来能够节省一部分的磁盘空间以及一定程度上的效率提升。</p>

<p>为什么索引不能太多? 因为每添加一个索引， <code class="highlighter-rouge">.ibd</code>文件中就需要多维护一个B+Tree索引树， 如果某一个table中存在10个索引， 那么就需要维护10棵B+Tree， 写入效率会降低， 并且会浪费磁盘空间。</p>

<p>B+Tree中的指针是用什么实现的? 使用文件偏移量实现， 指向下一行或者是下一个索引的起始位置。</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL权限管理</title>
	  <link>//MySQL-Permissions</link>
	  <author></author>
	  <pubDate>2018-10-30T09:49:09+00:00</pubDate>
	  <guid>//MySQL-Permissions</guid>
	  <description><![CDATA[
	     <p><code class="highlighter-rouge">MySQL</code>的权限管理重要性等同于服务器数据的重要性， 权限体系如果建立的不到位的话， 也就意味着生产数据处于危险状态。</p>

<!---more--->

<h4 id="1-ubuntu-1604-下安装mysql">1. Ubuntu 16.04 下安装MySQL</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt-get update
<span class="nb">sudo </span>apt-get upgrade
<span class="nb">sudo </span>apt-get install mysql-server mysql-client
</code></pre></div></div>

<h4 id="2-修改相关的配置文件">2. 修改相关的配置文件</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>vim /etc/mysql/mysql.conf.d/mysqld.cnf

bind-address <span class="o">=</span> 0.0.0.0
max_connections <span class="o">=</span> 3000

<span class="c"># binlog相关配置</span>
server-id <span class="o">=</span> 2
log_bin <span class="o">=</span> /var/log/mysql/mysql-bin.log
expire_logs_days <span class="o">=</span> 10
max_binlog_size <span class="o">=</span> 100M

<span class="c"># 慢查询日志配置</span>
slow_query_log <span class="o">=</span> 1
slow_query_log_file <span class="o">=</span> /var/log/mysql/mysql-slow.log
long_query_time <span class="o">=</span> 2
</code></pre></div></div>
<p>编辑并保存后重启MySQL服务即可。另外需要在系统层面赋予MySQL最大文件描述符的配置：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>vim /lib/systemd/system/mysql.service

<span class="c"># 添加</span>
<span class="nv">LimitNOFILE</span><span class="o">=</span>65535
<span class="nv">LimitNPROC</span><span class="o">=</span>65535
</code></pre></div></div>

<h4 id="3-管理权限体系的建立">3. 管理权限体系的建立</h4>
<p>通常MySQL的权限分级与开发团队的组织形式直接相关， 包括初级工程师(只能select部分database), 中级工程师(能够对数据进行增删改查)， 高级开发工程师(全部权限)， 但是在现代的web开发， 使用ORM框架的条件下， 对应用的账号则必须赋予较高的权限， 那么能够查看代码的开发人员依然能够拿到较高权限。 所以MySQL的权限控制需要和Linux权限控制相结合： 涉及生产服务器MySQL数据库连接代码应只存放于服务器中， 并对其进行高权限控制， 即该文件只能由高级开发工程师进行查看或者修改， 以保证权限的统一。</p>

<h5 id="31-创建用户并赋予权限">3.1 创建用户并赋予权限</h5>
<p>创建用户使用<code class="highlighter-rouge">GRANT</code>命令， 常见参数及说明如下表所示：</p>

<table>
  <thead>
    <tr>
      <th>GRANT</th>
      <th>ALL PRIVILEGES</th>
      <th>ON database.table</th>
      <th>TO user@address</th>
      <th>IDENTIFIED BY ‘password’</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>创建用户命令</td>
      <td>赋予什么权限</td>
      <td>哪个数据库以及哪张表</td>
      <td>用户名和登录地址</td>
      <td>密码</td>
    </tr>
  </tbody>
</table>

<p>创建smart用户， 并赋予其全部数据库的全部权限， 但只能在ip地址为144.35.177.20的机器上进行登录</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">GRANT</span> <span class="k">ALL</span> <span class="k">PRIVILEGES</span> <span class="k">ON</span> <span class="o">*</span><span class="p">.</span><span class="o">*</span> <span class="k">TO</span> <span class="s1">'smart'</span><span class="o">@</span><span class="s1">'144.35.177.20'</span> <span class="n">IDENTIFIED</span> <span class="k">BY</span> <span class="s1">'passwd'</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="n">FLUSH</span> <span class="k">PRIVILEGES</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">mysql</span><span class="p">.</span><span class="k">user</span> <span class="k">where</span> <span class="k">User</span><span class="o">=</span><span class="nv">"smart"</span> <span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
                  <span class="k">Host</span><span class="p">:</span> <span class="mi">144</span><span class="p">.</span><span class="mi">35</span><span class="p">.</span><span class="mi">177</span><span class="p">.</span><span class="mi">20</span>
                  <span class="k">User</span><span class="p">:</span> <span class="n">smart</span>
           <span class="n">Select_priv</span><span class="p">:</span> <span class="n">Y</span>
           <span class="n">Insert_priv</span><span class="p">:</span> <span class="n">Y</span>
           <span class="n">Update_priv</span><span class="p">:</span> <span class="n">Y</span>
           <span class="n">Delete_priv</span><span class="p">:</span> <span class="n">Y</span>
           <span class="n">Create_priv</span><span class="p">:</span> <span class="n">Y</span>
             <span class="n">Drop_priv</span><span class="p">:</span> <span class="n">Y</span>
           <span class="n">Reload_priv</span><span class="p">:</span> <span class="n">Y</span>
         <span class="n">Shutdown_priv</span><span class="p">:</span> <span class="n">Y</span>
          <span class="n">Process_priv</span><span class="p">:</span> <span class="n">Y</span>
          <span class="p">...</span>  <span class="err">中间省略</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div></div>
<p>在赋予<code class="highlighter-rouge">ALL PRIVILEGES</code>之后该用户除了不能创建用户以外， 用于对数据库的所有控制权限。 这样的账号应该只有运维经理以及高级开发才能拥有。</p>

<p>下面来看一下MySQL具体都有哪些权限:</p>

<table>
  <thead>
    <tr>
      <th>维度</th>
      <th>权限</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>数据</td>
      <td>insert, select, update, delete</td>
    </tr>
    <tr>
      <td>表</td>
      <td>create, drop, references, index, alter, lock table, create temporary table</td>
    </tr>
    <tr>
      <td>主从复制</td>
      <td>replication client, replication slave</td>
    </tr>
    <tr>
      <td>服务器</td>
      <td>shutdown, processlist, grant, super, create role</td>
    </tr>
  </tbody>
</table>

<p>该表简单的对权限进行了一个分类， 作用仅是便于记忆而已。 根据<code class="highlighter-rouge">MySQL</code>官方文档所给出的权限以及每种权限的作用， 下面进行详细的整理。</p>

<ul>
  <li>ALTER: 允许更改表结构， 例如添加索引， 删除字段等。 <code class="highlighter-rouge">ALTER TABLE</code>语句需要有CREATE以及INSERT权限。 当我们对一个表进行重命名的时候， 需要有ALTER和DROP以及CREATE， INSERT的权限。</li>
  <li>ALTER ROUTINE: 使用ALTER存储过程的权限。</li>
  <li>CREATE: 创建表的权限。</li>
  <li>CREATE ROLE: 创建角色的权限， 当一个用户拥有了CREATE USER权限时， 该权限随即拥有。</li>
  <li>CREATE ROUTINE: 允许使用CREATE存储过程。</li>
  <li>CREATE TEMPORARY TABLES: 允许使用<code class="highlighter-rouge">CREATE TEMPORARY TABLE</code>语句来创建临时表， 这张临时表的 DROP TABLE， INSERT， UPDATE等权限随之赋予。</li>
  <li>CREATE USER: 能够使用 ALTER USER， CREATE ROLE， CREATE USER， DROP ROLE， DROP USER, RENAME USER， 以及REVOKE ALL PRIVILEGES等语句， 属于管理员权限。</li>
  <li>CREATE VIEW: 允许创建视图。</li>
  <li>DELETE: 允许从表中删除数据。</li>
  <li>DROP: 删除整张表以及数据的权限， TRUNCATE TABLE命令需要有该权限才能够执行。</li>
  <li>DROP ROLE: 允许删除某一个用户， 当用户具有了CREATE USER的权限时， 该权限随之赋予。</li>
  <li>GRANT OPTION: 允许为用户添加权限。</li>
  <li>INDEX: 允许添加和删除索引， 当用于具有CREATE的权限时， 该权限随之赋予。</li>
  <li>INSERT: 向表中插入数据的权限。</li>
  <li>LOCK TABLES: 锁表的权限。</li>
  <li>PROCESS: 允许查询当前数据库所运行的后台线程信息， 例如主从复制线程信息。</li>
  <li>RELOAD: 允许运行flush-xxx相关命令， 包括刷新权限， 日志等， 属于管理员权限。</li>
  <li>REPLICATION CLIENT： 允许使用SHOW MASTER STATUS, SHOW SLAVE STATUS, SHOW BINARY LOGS等语句， 主要用于主从复制。</li>
  <li>REPLICATION SLAVE: 允许更新主库的变化。</li>
  <li>SUPER: 这是一个相当重要的权限， 权限非常大， 并且<code class="highlighter-rouge">MySQL</code>在将来的版本中将会移除这个权限， 的确， 该权限比较危险。 SUPER权限能够在运行时修改系统变量， 该更主从复制相关信息， 以及更重要的， 该权限可以在<code class="highlighter-rouge">MySQL Session</code>中删除binlog日志文件， 即<code class="highlighter-rouge">purge master logs</code>命令。</li>
  <li>UPDATE: 更新表数据的权限。</li>
</ul>

<p>可以看到， 比较危险的权限也就是DROP, CREATE USER， GRANT OPTION， RELOAD以及SUPER权限， 其中最危险的就是SUPER权限， <strong>除了管理员以外， 任何账号均不能有SUPER权限</strong>。</p>

<h6 id="311-创建mysqldump账户并赋予权限">3.1.1 创建mysqldump账户并赋予权限</h6>
<p><code class="highlighter-rouge">mysqldump</code>命令的权限讲实话我并不清楚， 查阅网上相关资料之后进行创建并赋予：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">user</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span> <span class="n">identified</span> <span class="k">by</span> <span class="s1">'passwd'</span><span class="p">;</span>
<span class="k">grant</span> <span class="k">select</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span><span class="p">;</span>
<span class="k">grant</span> <span class="k">show</span> <span class="k">view</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span><span class="p">;</span>
<span class="k">grant</span> <span class="k">lock</span> <span class="n">tables</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span><span class="p">;</span>
<span class="k">grant</span> <span class="k">trigger</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span><span class="p">;</span>
<span class="o">//</span> <span class="err">如果需要在备份时刷新二进制日志，</span> <span class="err">还需要以下权限</span>
<span class="k">grant</span> <span class="n">reload</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span><span class="p">;</span>
<span class="k">grant</span> <span class="n">replication</span> <span class="n">slave</span><span class="p">,</span> <span class="n">replication</span> <span class="n">client</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span><span class="p">;</span>
</code></pre></div></div>
<p>那么此时使用该账户进行登录， 进行查看<code class="highlighter-rouge">myProjects</code>库， 其余的增删改操作均不能进行。</p>

<h6 id="312-创建主从复制的账号并赋予权限">3.1.2 创建主从复制的账号并赋予权限</h6>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">grant</span> <span class="n">replication</span> <span class="n">slave</span><span class="p">,</span> <span class="n">replication</span> <span class="n">client</span> <span class="k">on</span> <span class="o">*</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="n">repl</span><span class="o">@</span><span class="s1">'192.168.0.%'</span> <span class="n">dentified</span> <span class="k">by</span> <span class="s1">'passwd'</span><span class="p">;</span>
</code></pre></div></div>
<p>这里使用<code class="highlighter-rouge">%</code>通配符来对该局域网内的所有机器进行权限的赋予。</p>

<h6 id="313-创建项目账号并赋予权限">3.1.3 创建项目账号并赋予权限</h6>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">grant</span> <span class="k">all</span> <span class="k">privileges</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'shop'</span><span class="o">@</span><span class="s1">'192.168.1.6'</span> <span class="n">identified</span> <span class="k">by</span> <span class="s1">'complex-passwd'</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="32-查看某个用户的权限">3.2 查看某个用户的权限</h4>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">show</span> <span class="n">grants</span> <span class="k">for</span> <span class="s1">'user'</span><span class="o">@</span><span class="s1">'address'</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="33-回收用户权限以及删除用户">3.3 回收用户权限以及删除用户</h4>
<p>回收用户所有权限</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">revoke</span> <span class="k">all</span> <span class="k">on</span> <span class="o">*</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="s1">'user'</span><span class="o">@</span><span class="s1">'address'</span><span class="p">;</span>
</code></pre></div></div>
<p>回收用户部分权限</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">revoke</span> <span class="k">drop</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="s1">'user'</span><span class="o">@</span><span class="s1">'address'</span><span class="p">;</span>
</code></pre></div></div>
<p>删除用户</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">drop</span> <span class="k">user</span> <span class="s1">'user'</span><span class="o">@</span><span class="s1">'address'</span><span class="p">;</span>
</code></pre></div></div>

<p>修改某个用户的密码</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">update</span> <span class="n">mysql</span><span class="p">.</span><span class="k">user</span> <span class="k">set</span> <span class="n">authentication_string</span><span class="o">=</span><span class="n">password</span><span class="p">(</span><span class="nv">"passwd"</span><span class="p">)</span> <span class="k">where</span> <span class="k">user</span><span class="o">=</span><span class="nv">"user"</span><span class="p">;</span>
</code></pre></div></div>

<p>在执行完上面儿的语句之后， 尽量的执行<code class="highlighter-rouge">flush privileges;</code>命令刷新一下权限。</p>

<h4 id="4-关于权限管理的一些杂谈">4. 关于权限管理的一些杂谈</h4>
<p>MySQL并没有提供不给用户授予什么权限的命令， 也就是没有<code class="highlighter-rouge">exclude</code>这种语法， 但是我们可以先给用户授予全部的权限， 然后将不必要的权限进行回收。 像<code class="highlighter-rouge">drop</code>这种很危险的权限就不要随便给， 如果库里面儿只有逻辑删除的话， <code class="highlighter-rouge">delete</code>权限都可以不给， 有需要的时候让管理员进行协助处理。 尽可能的用最小权限做更安全的事情， 毕竟使用<code class="highlighter-rouge">binlog</code>进行数据恢复也不可能保证100%成功， 将危险扼杀在摇篮里才是正解。</p>

<p>权限管理对于管理员来讲确实是比较麻烦的一件事情， 很多团队<code class="highlighter-rouge">root</code>账号满天跑， 包括笔者在内的团队在初期也是这样的。 在付出了血淋淋的代价之后才开始对权限进行管理， 亡羊补牢为时尚晚， 埋过的雷总会炸的。</p>


	  ]]></description>
	</item>

	<item>
	  <title>MySQL慢查询日志分析工具</title>
	  <link>//MySQL-slow-query-analysis-tool</link>
	  <author></author>
	  <pubDate>2018-10-25T09:49:09+00:00</pubDate>
	  <guid>//MySQL-slow-query-analysis-tool</guid>
	  <description><![CDATA[
	     <p>慢查询日志使我们对MySQL进行性能优化的关键指标， 只有在确定了哪些查询的确是慢查询之后才能对症下药， 进行性能优化， 而不是凭自身的感觉去判断， 结果有事往往出乎意料。 直接打开慢查询日志进行查看效率比较低效， 所以需要借助<code class="highlighter-rouge">pt-query-digest</code>工具来进行分析。</p>

<!---more--->

<h4 id="0-degine-mysql-version-57">0. Degine: MySQL Version: 5.7</h4>

<h4 id="1-percona-toolkit工具包的下载与安装">1. Percona Toolkit工具包的下载与安装</h4>
<p><code class="highlighter-rouge">Percona Toolkit</code>工具包包含了<code class="highlighter-rouge">pt-slave-delay</code>， <code class="highlighter-rouge">pt-query-digest</code>， <code class="highlighter-rouge">pt-mysql-summary</code>等非常有用的工具。</p>
<blockquote>
  <p>https://www.percona.com/downloads/percona-toolkit/LATEST/</p>
</blockquote>

<p>找对对应的版本以及平台进行安装即可。</p>

<h4 id="2-pt-query-digest的基本使用">2. pt-query-digest的基本使用</h4>
<p>首先来看一下分析的基本结果：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pt-query-digest <span class="nt">--report</span> mysql-slow.log
</code></pre></div></div>
<p>核心输出结果如下：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">Current</span> <span class="n">date</span><span class="p">:</span> <span class="n">Tue</span> <span class="n">Oct</span> <span class="mi">16</span> <span class="mi">11</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mi">55</span> <span class="mi">2018</span>
<span class="o">#</span> <span class="n">Hostname</span><span class="p">:</span> <span class="n">Zero</span>
<span class="o">#</span> <span class="n">Files</span><span class="p">:</span> <span class="n">mysql</span><span class="o">-</span><span class="n">slow</span><span class="p">.</span><span class="n">log</span>
<span class="o">#</span> <span class="n">Overall</span><span class="p">:</span> <span class="mi">7</span><span class="p">.</span><span class="mi">77</span><span class="n">k</span> <span class="n">total</span><span class="p">,</span> <span class="mi">94</span> <span class="k">unique</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">QPS</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">02</span><span class="n">x</span> <span class="n">concurrency</span> <span class="n">___________</span>
<span class="o">#</span> <span class="n">Time</span> <span class="n">range</span><span class="p">:</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">18</span> <span class="mi">14</span><span class="p">:</span><span class="mi">11</span><span class="p">:</span><span class="mi">31</span> <span class="k">to</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">16</span> <span class="mi">10</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">13</span>
<span class="o">#</span> <span class="n">Attribute</span>          <span class="n">total</span>     <span class="k">min</span>     <span class="k">max</span>     <span class="k">avg</span>     <span class="mi">95</span><span class="o">%</span>  <span class="n">stddev</span>  <span class="n">median</span>
<span class="o">#</span> <span class="o">============</span>     <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span>
<span class="o">#</span> <span class="k">Exec</span> <span class="n">time</span>         <span class="mi">77201</span><span class="n">s</span>   <span class="mi">500</span><span class="n">ms</span>    <span class="mi">166</span><span class="n">s</span>     <span class="mi">10</span><span class="n">s</span>     <span class="mi">37</span><span class="n">s</span>     <span class="mi">15</span><span class="n">s</span>      <span class="mi">4</span><span class="n">s</span>
<span class="o">#</span> <span class="k">Lock</span> <span class="n">time</span>           <span class="mi">203</span><span class="n">s</span>       <span class="mi">0</span>     <span class="mi">22</span><span class="n">s</span>    <span class="mi">26</span><span class="n">ms</span>   <span class="mi">138</span><span class="n">us</span>   <span class="mi">500</span><span class="n">ms</span>    <span class="mi">73</span><span class="n">us</span>
<span class="o">#</span> <span class="k">Rows</span> <span class="n">sent</span>          <span class="mi">2</span><span class="p">.</span><span class="mi">46</span><span class="n">M</span>       <span class="mi">0</span>  <span class="mi">78</span><span class="p">.</span><span class="mi">34</span><span class="n">k</span>  <span class="mi">331</span><span class="p">.</span><span class="mi">51</span>  <span class="mi">511</span><span class="p">.</span><span class="mi">45</span>   <span class="mi">4</span><span class="p">.</span><span class="mi">37</span><span class="n">k</span>    <span class="mi">0</span><span class="p">.</span><span class="mi">99</span>
<span class="o">#</span> <span class="k">Rows</span> <span class="n">examine</span>      <span class="mi">63</span><span class="p">.</span><span class="mi">82</span><span class="k">G</span>       <span class="mi">0</span>  <span class="mi">52</span><span class="p">.</span><span class="mi">93</span><span class="n">M</span>   <span class="mi">8</span><span class="p">.</span><span class="mi">41</span><span class="n">M</span>  <span class="mi">28</span><span class="p">.</span><span class="mi">56</span><span class="n">M</span>  <span class="mi">11</span><span class="p">.</span><span class="mi">25</span><span class="n">M</span>   <span class="mi">3</span><span class="p">.</span><span class="mi">68</span><span class="n">M</span>
<span class="o">#</span> <span class="n">Query</span> <span class="k">size</span>         <span class="mi">5</span><span class="p">.</span><span class="mi">06</span><span class="n">M</span>       <span class="mi">6</span>  <span class="mi">16</span><span class="p">.</span><span class="mi">48</span><span class="n">k</span>  <span class="mi">682</span><span class="p">.</span><span class="mi">18</span>   <span class="mi">2</span><span class="p">.</span><span class="mi">06</span><span class="n">k</span>  <span class="mi">724</span><span class="p">.</span><span class="mi">05</span>  <span class="mi">420</span><span class="p">.</span><span class="mi">77</span>
</code></pre></div></div>
<p>可以看到结果还是比较直观的， 包括执行时间， 加锁时间等， 横坐标中最有价值的信息为<code class="highlighter-rouge">95%</code>， 意义为将查询从小到大排列， 取位于整个排列的95%位置， 这样以来就会滤掉较大的值， 减少极值对统计的影响。 可以看到上面的输出<code class="highlighter-rouge">Exec time - 95% </code>输出结果为37s， 数值比较大， 所以完全有必要进行慢查询的优化。</p>

<p>继续来看输出：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">Profile</span>
<span class="o">#</span> <span class="n">Rank</span> <span class="n">Query</span> <span class="n">ID</span>                      <span class="n">Response</span> <span class="n">time</span>    <span class="n">Calls</span> <span class="n">R</span><span class="o">/</span><span class="k">Call</span>  <span class="n">V</span><span class="o">/</span><span class="n">M</span>
<span class="o">#</span> <span class="o">====</span> <span class="o">=============================</span> <span class="o">================</span> <span class="o">=====</span> <span class="o">=======</span> <span class="o">=====</span>
<span class="o">#</span>    <span class="mi">1</span> <span class="mi">0</span><span class="n">x530A2CE72ED76F6FD03452E6</span><span class="p">...</span> <span class="mi">20003</span><span class="p">.</span><span class="mi">2369</span> <span class="mi">25</span><span class="p">.</span><span class="mi">9</span><span class="o">%</span>   <span class="mi">478</span> <span class="mi">41</span><span class="p">.</span><span class="mi">8478</span> <span class="mi">17</span><span class="p">.</span><span class="mi">77</span> <span class="k">SELECT</span> <span class="n">lv_pt_order</span> <span class="n">lv_pt_order_detail</span> <span class="n">lv_pt_goods</span> <span class="n">lv_user</span>
<span class="o">#</span>    <span class="mi">2</span> <span class="mi">0</span><span class="n">x1B1C071EBB0DECB4FCB8B4C9</span><span class="p">...</span> <span class="mi">19870</span><span class="p">.</span><span class="mi">1927</span> <span class="mi">25</span><span class="p">.</span><span class="mi">7</span><span class="o">%</span>   <span class="mi">855</span> <span class="mi">23</span><span class="p">.</span><span class="mi">2400</span>  <span class="mi">6</span><span class="p">.</span><span class="mi">26</span> <span class="k">SELECT</span> <span class="n">lv_pt_order</span> <span class="n">lv_pt_order_detail</span> <span class="n">lv_pt_goods</span> <span class="n">lv_user</span>
<span class="o">#</span>    <span class="mi">3</span> <span class="mi">0</span><span class="n">x84CAC95FCB28351DEB798161</span><span class="p">...</span>  <span class="mi">9187</span><span class="p">.</span><span class="mi">0368</span> <span class="mi">11</span><span class="p">.</span><span class="mi">9</span><span class="o">%</span>   <span class="mi">727</span> <span class="mi">12</span><span class="p">.</span><span class="mi">6369</span>  <span class="mi">8</span><span class="p">.</span><span class="mi">70</span> <span class="k">SELECT</span> <span class="n">lv_pt_order</span> <span class="n">lv_pt_order_detail</span> <span class="n">lv_pt_goods</span> <span class="n">lv_user</span>
<span class="o">#</span>    <span class="mi">4</span> <span class="mi">0</span><span class="n">x32D67A543AD02B4178806916</span><span class="p">...</span>  <span class="mi">6330</span><span class="p">.</span><span class="mi">5023</span>  <span class="mi">8</span><span class="p">.</span><span class="mi">2</span><span class="o">%</span>  <span class="mi">1545</span>  <span class="mi">4</span><span class="p">.</span><span class="mi">0974</span>  <span class="mi">5</span><span class="p">.</span><span class="mi">78</span> <span class="k">UPDATE</span> <span class="n">lv_session</span>
</code></pre></div></div>
<p>其中<code class="highlighter-rouge">Query ID</code>是每一个查询的哈希值指纹， <code class="highlighter-rouge">Response time</code>包括所有查询的返回时间以及占比， <code class="highlighter-rouge">Calls</code>为查询的次数， <code class="highlighter-rouge">R/Call</code>为该查询的平均时间， <code class="highlighter-rouge">V/M</code>为方差均值比， 表示该查询的返回时间波动性， 该值越大越有优化的价值。</p>

<p>再往下面就是对<code class="highlighter-rouge">Profile</code>中的每一条进行的详细分析。</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">Query</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">QPS</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">01</span><span class="n">x</span> <span class="n">concurrency</span><span class="p">,</span> <span class="n">ID</span> <span class="mi">0</span><span class="n">x530A2CE72ED76F6FD03452E68015715F</span> <span class="k">at</span> <span class="n">byte</span> <span class="mi">6465751</span>
<span class="o">#</span> <span class="n">This</span> <span class="n">item</span> <span class="k">is</span> <span class="n">included</span> <span class="k">in</span> <span class="n">the</span> <span class="n">report</span> <span class="n">because</span> <span class="n">it</span> <span class="n">matches</span> <span class="c1">--limit.</span>
<span class="o">#</span> <span class="n">Scores</span><span class="p">:</span> <span class="n">V</span><span class="o">/</span><span class="n">M</span> <span class="o">=</span> <span class="mi">17</span><span class="p">.</span><span class="mi">77</span>
<span class="o">#</span> <span class="n">Time</span> <span class="n">range</span><span class="p">:</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">09</span><span class="o">-</span><span class="mi">20</span> <span class="mi">18</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">33</span> <span class="k">to</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">13</span> <span class="mi">00</span><span class="p">:</span><span class="mi">03</span><span class="p">:</span><span class="mi">20</span>
<span class="o">#</span> <span class="n">Attribute</span>    <span class="n">pct</span>   <span class="n">total</span>     <span class="k">min</span>     <span class="k">max</span>     <span class="k">avg</span>     <span class="mi">95</span><span class="o">%</span>  <span class="n">stddev</span>  <span class="n">median</span>
<span class="o">#</span> <span class="o">============</span> <span class="o">===</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span>
<span class="o">#</span> <span class="k">Count</span>          <span class="mi">6</span>     <span class="mi">478</span>
<span class="o">#</span> <span class="k">Exec</span> <span class="n">time</span>     <span class="mi">25</span>  <span class="mi">20003</span><span class="n">s</span>     <span class="mi">12</span><span class="n">s</span>    <span class="mi">166</span><span class="n">s</span>     <span class="mi">42</span><span class="n">s</span>     <span class="mi">97</span><span class="n">s</span>     <span class="mi">27</span><span class="n">s</span>     <span class="mi">32</span><span class="n">s</span>
<span class="o">#</span> <span class="k">Lock</span> <span class="n">time</span>      <span class="mi">0</span>    <span class="mi">86</span><span class="n">ms</span>    <span class="mi">58</span><span class="n">us</span>    <span class="mi">23</span><span class="n">ms</span>   <span class="mi">179</span><span class="n">us</span>   <span class="mi">144</span><span class="n">us</span>     <span class="mi">1</span><span class="n">ms</span>   <span class="mi">108</span><span class="n">us</span>
<span class="o">#</span> <span class="k">Rows</span> <span class="n">sent</span>      <span class="mi">0</span>   <span class="mi">8</span><span class="p">.</span><span class="mi">98</span><span class="n">k</span>      <span class="mi">10</span>      <span class="mi">20</span>   <span class="mi">19</span><span class="p">.</span><span class="mi">25</span>   <span class="mi">19</span><span class="p">.</span><span class="mi">46</span>    <span class="mi">2</span><span class="p">.</span><span class="mi">54</span>   <span class="mi">19</span><span class="p">.</span><span class="mi">46</span>
<span class="o">#</span> <span class="k">Rows</span> <span class="n">examine</span>  <span class="mi">24</span>  <span class="mi">15</span><span class="p">.</span><span class="mi">74</span><span class="k">G</span>  <span class="mi">24</span><span class="p">.</span><span class="mi">48</span><span class="n">M</span>  <span class="mi">52</span><span class="p">.</span><span class="mi">93</span><span class="n">M</span>  <span class="mi">33</span><span class="p">.</span><span class="mi">71</span><span class="n">M</span>  <span class="mi">51</span><span class="p">.</span><span class="mi">29</span><span class="n">M</span>  <span class="mi">10</span><span class="p">.</span><span class="mi">49</span><span class="n">M</span>  <span class="mi">27</span><span class="p">.</span><span class="mi">20</span><span class="n">M</span>
<span class="o">#</span> <span class="n">Query</span> <span class="k">size</span>     <span class="mi">3</span> <span class="mi">183</span><span class="p">.</span><span class="mi">98</span><span class="n">k</span>     <span class="mi">393</span>     <span class="mi">404</span>  <span class="mi">394</span><span class="p">.</span><span class="mi">14</span>  <span class="mi">400</span><span class="p">.</span><span class="mi">73</span>    <span class="mi">5</span><span class="p">.</span><span class="mi">50</span>  <span class="mi">381</span><span class="p">.</span><span class="mi">65</span>
<span class="o">#</span> <span class="n">String</span><span class="p">:</span>
<span class="o">#</span> <span class="n">Databases</span>    <span class="n">we8</span>
<span class="o">#</span> <span class="n">Hosts</span>
<span class="o">#</span> <span class="n">Users</span>        <span class="n">root</span>
<span class="o">#</span> <span class="n">Query_time</span> <span class="n">distribution</span>
<span class="o">#</span>   <span class="mi">1</span><span class="n">us</span>
<span class="o">#</span>  <span class="mi">10</span><span class="n">us</span>
<span class="o">#</span> <span class="mi">100</span><span class="n">us</span>
<span class="o">#</span>   <span class="mi">1</span><span class="n">mss</span>
<span class="o">#</span>  <span class="mi">10</span><span class="n">ms</span>
<span class="o">#</span> <span class="mi">100</span><span class="n">ms</span>
<span class="o">#</span>    <span class="mi">1</span><span class="n">s</span>
<span class="o">#</span>  <span class="mi">10</span><span class="n">s</span><span class="o">+</span>  <span class="o">################################################################</span>
<span class="o">#</span> <span class="n">Tables</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">TABLE</span> <span class="n">STATUS</span> <span class="k">FROM</span> <span class="nv">`we8`</span> <span class="k">LIKE</span> <span class="s1">'lv_pt_order'</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`we8`</span><span class="p">.</span><span class="nv">`lv_pt_order`</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">TABLE</span> <span class="n">STATUS</span> <span class="k">FROM</span> <span class="nv">`we8`</span> <span class="k">LIKE</span> <span class="s1">'lv_pt_order_detail'</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`we8`</span><span class="p">.</span><span class="nv">`lv_pt_order_detail`</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">TABLE</span> <span class="n">STATUS</span> <span class="k">FROM</span> <span class="nv">`we8`</span> <span class="k">LIKE</span> <span class="s1">'lv_pt_goods'</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`we8`</span><span class="p">.</span><span class="nv">`lv_pt_goods`</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">TABLE</span> <span class="n">STATUS</span> <span class="k">FROM</span> <span class="nv">`we8`</span> <span class="k">LIKE</span> <span class="s1">'lv_user'</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`we8`</span><span class="p">.</span><span class="nv">`lv_user`</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span> <span class="k">EXPLAIN</span> <span class="cm">/*!50100 PARTITIONS*/</span>
<span class="k">SELECT</span> <span class="nv">`o`</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="nv">`od`</span><span class="p">.</span><span class="nv">`attr`</span><span class="p">,</span> <span class="nv">`od`</span><span class="p">.</span><span class="nv">`num`</span><span class="p">,</span> <span class="nv">`od`</span><span class="p">.</span><span class="nv">`pic`</span><span class="p">,</span> <span class="nv">`od`</span><span class="p">.</span><span class="nv">`goods_name`</span><span class="p">,</span> <span class="nv">`g`</span><span class="p">.</span><span class="nv">`name`</span> <span class="k">AS</span> <span class="nv">`goods_name`</span><span class="p">,</span> <span class="nv">`u`</span><span class="p">.</span><span class="nv">`nickname`</span> <span class="k">FROM</span> <span class="nv">`lv_pt_order`</span> <span class="nv">`o`</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="nv">`lv_pt_order_detail`</span> <span class="nv">`od`</span> <span class="k">ON</span> <span class="n">od</span><span class="p">.</span><span class="n">order_id</span><span class="o">=</span><span class="n">o</span><span class="p">.</span><span class="n">id</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="nv">`lv_pt_goods`</span> <span class="nv">`g`</span> <span class="k">ON</span> <span class="k">g</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">od</span><span class="p">.</span><span class="n">goods_id</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="nv">`lv_user`</span> <span class="nv">`u`</span> <span class="k">ON</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">o</span><span class="p">.</span><span class="n">user_id</span> <span class="k">WHERE</span> <span class="p">((</span><span class="nv">`o`</span><span class="p">.</span><span class="nv">`is_delete`</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">AND</span> <span class="p">(</span><span class="nv">`o`</span><span class="p">.</span><span class="nv">`store_id`</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span> <span class="k">AND</span> <span class="p">(</span><span class="nv">`o`</span><span class="p">.</span><span class="nv">`is_cancel`</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="nv">`o`</span><span class="p">.</span><span class="nv">`addtime`</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">20</span><span class="err">\</span><span class="k">G</span>
</code></pre></div></div>
<p>可以看到这条详细分析对应着<code class="highlighter-rouge">Profile</code>中的<code class="highlighter-rouge">Rank 1</code>, 其中<code class="highlighter-rouge">pct</code>即percentage， 表示该查询在该文件中的占比， 其余的基本大同小异。
在表格下方有一个直方图， 表示该查询的时间分布情况， 再往下就是实际的慢查询语句。
可以很直观的看到这条SQL语句的平均执行时间为42s， 最大查询时间166s,  总计执行了478次， 也算是颠覆了我对慢查询时间的认知， 我以为2s的查询就已经很糟糕了， 没想到这里竟然有100+s。</p>

<h4 id="3-pt-query-digest筛选参数">3. pt-query-digest筛选参数</h4>
<p>上面儿的内容基本上就是<code class="highlighter-rouge">pt-query-digest</code>所能够产生的结果， 另外可以添加一些参数来进行筛选。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 给出最近1个小时的慢查询分析结果</span>
pt-query-digest <span class="nt">--report</span> <span class="nt">--since</span> 3600s mysql-slow.log

<span class="c"># 给出一个时间区间的慢查询分析结果</span>
pt-query-digest <span class="nt">--report</span> <span class="nt">--since</span> <span class="s1">'2018-09-20 18:23:33'</span> <span class="nt">--until</span> <span class="s1">'2018-10-13 00:03:20'</span> mysql-slow.log

<span class="c"># 给出某个用户的所有慢查询， 在设计应用时， 前台和后台可以使用不同的MySQL账户</span>
pt-query-digest <span class="nt">--filter</span> <span class="s1">'($event-&gt;{user} || "") =~ m/^root/i'</span> mysql-slow.log
</code></pre></div></div>

<p>更多的内容请见官网。</p>

<blockquote>
  <p>https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html#</p>
</blockquote>

	  ]]></description>
	</item>


</channel>
</rss>
