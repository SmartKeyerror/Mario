<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description>Keep coding, Keep curiosity</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>MySQL-InnoDB中的锁</title>
	  <link>//MySQL-InnoDB-Lock</link>
	  <author></author>
	  <pubDate>2020-01-31T10:06:25+00:00</pubDate>
	  <guid>//MySQL-InnoDB-Lock</guid>
	  <description><![CDATA[
	     <p>锁在InnoDB存储引擎中的使用远比我们想象中的更加频繁，及时是一条最为简单的<code class="highlighter-rouge">update set</code>语句，其中也涉及到了各种锁的使用。包括常说的一致性锁定读，解决幻读等场景中，同样包含了锁的大量使用。</p>

<!---more--->

<h4 id="1-latch和lock">1. Latch和Lock</h4>

<p>在InnoDB存储引擎中，Latch(门闩)是用来保证并发线程操作临界资源的正确性，保证某些操作的原子性。通常又分为Mutex(互斥量)和RWLock(读写锁)，例如Python中<code class="highlighter-rouge">threading.Lock</code>，Java中<code class="highlighter-rouge">synchronized</code>，Golang中的<code class="highlighter-rouge">sync.Mutex</code>，Latch通常应用于操作缓冲池中的LRU列表元素(添加、删除以及移动)，部分场景下的<code class="highlighter-rouge">AUTO_INCREMENT</code>实现。用户通常不会直接地与Latch打交道，并且没有死锁检测。</p>

<p>Lock作用于事务之中，用来锁定表、页、行，锁的添加与释放通常会在事务的起始和结束时进行。数据库中的幻读问题解决就是通过Lock实现的，而非Latch。并且Lock存在死锁检测机制，当发生死锁时，会在某些情况下告知用户，例如在使用一致性锁定读(SELECT…FOR UPDATE)时产生的死锁，会直接抛出1213的Deadlock异常。</p>

<p>尽管Latch与Lock操作的对象均为数据，但是Latch更为底层，操作的对象更加细小。Lock的对象相对于Latch而言，则更加”粗放”，例如表、页数据，此外最重要的是Lock的作用域为事务，Latch则不是。</p>

<h4 id="2-innodb存储引擎中的lock">2. InnoDB存储引擎中的Lock</h4>

<p>为了方便叙述，下面均使用锁来指代InnoDB中的Lock(仍然要说明，Lock以及Latch都可以称为锁，这里只是为了方便叙述)。</p>

<p>InnoDB引擎支持行锁以及表锁，既可以锁定某一行，同时也可以锁定一整张表，先从行级锁说起。</p>

<p>InnoDB引擎实现了两种标准的行级锁:</p>
<ul>
  <li>共享行级锁(S Lock, Share Lock)</li>
  <li>排他行级锁(X Lock, Exclusive Lock)</li>
</ul>

<p>可以认为S Lock和X Lock分别表示读锁和写锁，如同RWLock一样。S Lock允许并发地读取数据，X Lock既限制并发地读取，同时也限制并发地修改。所以说，当某一行数据中存在S锁时，只能再次添加S锁，若想要添加X锁，则需要等待S锁的释放。行级锁X以及S Lock的兼容性如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">-</th>
      <th style="text-align: center">X</th>
      <th style="text-align: center">S</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">X</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">S</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
  </tbody>
</table>

<p>同时，InnoDB支持表级锁，为了支持表级锁与行级锁这两个不同粒度的锁，InnoDB支持一种额外的上锁方式，称之为意向锁(Intention Lock)。</p>

<p>为了更好的理解意向锁，首先假设没有意向锁，只有表锁和行锁。当事务A在更新某一条数据时，会在该数据行上添加X锁。此时另外事务B申请整个表的写锁，如果事务B申请成功，那么它就能修改表中任意一行数据，这与事务持有的X锁冲突。</p>

<p>如果数据库想要避免该冲突，那么需要让事务B阻塞，直到事务A提交释放X锁。转而需要判断事务B阻塞的条件: ①当前表是否被其它事务添加表锁 ②判断表中是否存在行锁。这两个条件判断均可以在表层面实现，而无需遍历所有数据，只需要定义好数据结构即可。一个最简单的实现就是为表锁和行锁添加两个标识位，该标识位在添加和释放锁时进行原子更新，例如:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table_s_lock <span class="o">=</span> <span class="nb">false
</span>table_x_lock <span class="o">=</span> <span class="nb">false
</span>row_s_lock <span class="o">=</span> <span class="nb">true
</span>row_x_lock <span class="o">=</span> <span class="nb">true</span>
</code></pre></div></div>

<p>当某一行添加X锁时，将<code class="highlighter-rouge">row_x_lock</code>置为true，若其余事务想要添加表级别的X锁，则必须等待<code class="highlighter-rouge">row_x_lock</code>更新为false。反之若事务已经添加了表级别的X锁，将<code class="highlighter-rouge">table_x_lock</code>置为true，事务B若想在某一行添加X锁，则需要等待<code class="highlighter-rouge">table_s_lock</code>以及<code class="highlighter-rouge">table_x_lock</code>均更新为false。</p>

<p>虽然上面的标识位能够解决问题，但仍然有些奇怪，奇怪的点在于标识位的判断粒度不同。我们更加希望表级锁与表级锁进行兼容性判断，行级锁与行级锁进行兼容性判断，而不是表级锁与行级锁进行兼容性判断。由此，就有了意向锁的诞生。</p>

<p>意向锁(Intention Lock)将锁定的对象分为多个粒度，当想要对细粒度的数据进行加锁时，那么首先需要对粗粒度的对象添加意向锁。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/intention-Lock.png" alt="" /></p>

<p>例如，若需要对页上的记录R添加X锁，则需要分别对数据库、表、页添加意向锁IX，添加成功后才会对记录R添加X锁，若其中任何一部分导致等待，那么该操作需要等待粗粒度上锁环节的完成。现在来看在有了意向锁之后InnoDB存储引擎如何支持多粒度的锁。</p>

<p>意向锁同样分为两种: 共享和排他</p>

<ul>
  <li>意向共享锁(IS, Intention Share Lock)</li>
  <li>意向排他锁(IX, Intention Exclusive Lock)</li>
</ul>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/intention-lock-example.png" alt="" /></p>

<p>如上图所示，事务A为了给记录R添加X锁(排他锁)，则需要依次对数据库、表、页添加意向排他锁(IX)，假设添加均成功，最终记录R添加了X锁。此时事务B想要向表A中添加表级别的排他锁，由于表A中存在IX锁，与表级别的X锁并不兼容，故事务B等待，等待表A中IX锁的释放。可以看到，在有了意向锁之后，锁的兼容性比较将处理同粒度水平，而不是跨粒度进行比较。这让我想起了一个段子:</p>

<blockquote>
  <p>不要跟傻逼争论，他会把你拉到他的水平上，然后用他丰富的经验打败你</p>
</blockquote>

<p>InnoDB存储引擎中意向锁和表级锁的兼容性如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">-</th>
      <th style="text-align: center">IX</th>
      <th style="text-align: center">IS</th>
      <th style="text-align: center">X(表级别)</th>
      <th style="text-align: center">S(表级别)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">IX</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">IS</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">X(表级别)</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">S(表级别)</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
  </tbody>
</table>

<p>在MySQL 5.5以上、5.7.14以下的版本中，用户可以通过<code class="highlighter-rouge">INFORMATION_SCHEMA</code>下的<code class="highlighter-rouge">INNODB_TRX</code>、<code class="highlighter-rouge">INNODB_LOCKS</code>以及<code class="highlighter-rouge">INNODB_LOCK_WAITS</code>这三张表简单地监控并分析可能存在的锁问题。</p>

<p>在MySQL 8.0版本中，则需要使用<code class="highlighter-rouge">performance_schema</code>下的<code class="highlighter-rouge">data_locks</code>以及<code class="highlighter-rouge">data_lock_waits</code>获取相关的锁以及锁等待信息。</p>

<p>而MySQL版本在5.7.14到8.0之间的用户，只能通过其它手段间接的获取上述信息。</p>

<h5 id="21-创建通用例程">2.1 创建通用例程</h5>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`user`</span> <span class="p">(</span>
  <span class="nv">`id`</span> <span class="n">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="nv">`nickname`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`password`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`user_id`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`mobile`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`mobile_area`</span> <span class="n">smallint</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">comment</span> <span class="nv">"手机号码区域"</span><span class="p">,</span>
  <span class="nv">`gender`</span> <span class="n">tinyint</span> <span class="k">DEFAULT</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nv">`avatar`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`account_id`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`created_at`</span> <span class="n">datetime</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="nv">`updated_at`</span> <span class="n">datetime</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="k">ON</span> <span class="k">UPDATE</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="nv">`deleted_at`</span> <span class="n">datetime</span><span class="p">,</span>
  <span class="nv">`status`</span> <span class="n">tinyint</span> <span class="k">DEFAULT</span> <span class="mi">1</span> <span class="k">comment</span> <span class="nv">"用户状态"</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`user_id`</span> <span class="p">(</span><span class="nv">`user_id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`mobile`</span> <span class="p">(</span><span class="nv">`mobile`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`account_id`</span> <span class="p">(</span><span class="nv">`account_id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`created_at`</span> <span class="p">(</span><span class="nv">`created_at`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`updated_at`</span> <span class="p">(</span><span class="nv">`updated_at`</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="p">(</span><span class="nv">`user_id`</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="p">(</span><span class="nv">`account_id`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">1</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span> <span class="k">COLLATE</span><span class="o">=</span><span class="n">utf8mb4_general_ci</span><span class="p">;</span>
</code></pre></div></div>

<p>这是一张非常普通但又普遍的用户信息表，其中包含了唯一主键，唯一辅助索引以及普通辅助索引。</p>

<h5 id="22-innodb_trx">2.2 INNODB_TRX</h5>
<p><code class="highlighter-rouge">INNODB_TRX</code>表中主要记录了当前正在执行的事务信息，包括只读事务。首先来看字段和字段所表示的含义:</p>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TRX_ID</td>
      <td>InnoDB存储引擎内部的唯一事务ID</td>
    </tr>
    <tr>
      <td>TRX_WEIGHT</td>
      <td>事务权重(与事务修改的行数和锁定的行数有关)，当两个事务执行发生死锁时，InnoDB会选择权重较低的事务进行回滚</td>
    </tr>
    <tr>
      <td>TRX_STATE</td>
      <td>当前的事务执行状态，包括RUNNING, LOCK WAIT, ROLLING BACK, 以及COMMITTING，LOCK WAIT表示当前事务正等待某个锁的释放</td>
    </tr>
    <tr>
      <td>TRX_STARTED</td>
      <td>事务开始时间，格式如2000-01-01 14:01:08</td>
    </tr>
    <tr>
      <td>TRX_REQUESTED_LOCK_ID</td>
      <td>当前事务所等待的锁ID，该字段只有在状态为LOCK WAIT才有值，否则为NULL。可与<code class="highlighter-rouge">INNODB_LOCKS</code>通过LOCK_ID字段进行关联查询，获取更为详细的锁信息。</td>
    </tr>
    <tr>
      <td>TRX_WAIT_STARTED</td>
      <td>当前事务等待锁的起始时间，在状态为LOCK WAIT时才有值，否则为NULL。</td>
    </tr>
    <tr>
      <td>TRX_QUERY</td>
      <td>当前事务<strong>正在</strong>执行的SQL语句(不是事务所有的执行语句)</td>
    </tr>
    <tr>
      <td>TRX_OPERATION_STATE</td>
      <td>事务的当前操作状态，包括PREPARING, UPDATING, DELETING, COMMITTING以及NULL，该字段在绝大部分情况下均为NULL，捕捉某一事务的瞬间执行状态还是比较困难的(除非是大事务)</td>
    </tr>
    <tr>
      <td>TRX_TABLES_IN_USE</td>
      <td>正在执行的SQL语句所操作的表数量，是一个动态变化值，通常很难观测</td>
    </tr>
    <tr>
      <td>TRX_TABLES_LOCKED</td>
      <td>当前事务在各个表中添加行锁的表数量</td>
    </tr>
    <tr>
      <td>TRX_LOCK_STRUCTS</td>
      <td>当前事务持有的锁数量</td>
    </tr>
    <tr>
      <td>TRX_LOCK_MEMORY_BYTES</td>
      <td>当前事务中锁结构的内存总占用</td>
    </tr>
    <tr>
      <td>TRX_ROWS_LOCKED</td>
      <td>当前事务锁住的近似数据总行数</td>
    </tr>
    <tr>
      <td>TRX_ROWS_MODIFIED</td>
      <td>当前事务插入、修改的总行数</td>
    </tr>
    <tr>
      <td>TRX_CONCURRENCY_TICKETS</td>
      <td>表示当前事务在换出之前所能做的工作之和</td>
    </tr>
    <tr>
      <td>TRX_ISOLATION_LEVEL</td>
      <td>当前事务隔离级别，包括READ UNCIMMITTED、READ COMMITTED、READ REPEATABLE以及SERIALIZABLE</td>
    </tr>
    <tr>
      <td>TRX_UNIQUE_CHECKS</td>
      <td>当前事务是否开启唯一性检查</td>
    </tr>
    <tr>
      <td>TRX_FOREIGN_KEY_CHECKS</td>
      <td>当前事务是否开启外键检查</td>
    </tr>
    <tr>
      <td>TRX_LAST_FOREIGN_KEY_ERROR</td>
      <td>当前事务执行时最后发生的外键错误</td>
    </tr>
    <tr>
      <td>TRX_ADAPTIVE_HASH_LATCHED</td>
      <td>当前事务是否锁定了自适应哈希索引</td>
    </tr>
  </tbody>
</table>

<p>在这20多个字段中，较为重要的包括事务ID，事务执行状态，事务等待锁的起始时间，事务锁定的近似总行数。</p>

<h5 id="23-innodb_locks">2.3 INNODB_LOCKS</h5>

<p><code class="highlighter-rouge">INNODB_LOCKS</code>表中记录了当前所有未释放的锁，包括行锁、页锁以及表锁，当某个事务发生严重的锁等待时，通常会在该表中查找蛛丝马迹，确定问题的根源。</p>

<p>但是，<code class="highlighter-rouge">INNODB_LOCKS</code>和<code class="highlighter-rouge">INNODB_LOCK_WAITS</code>这两张表在5.7.14以上版本中被废弃不用，在8.0版本中使用<code class="highlighter-rouge">data_locks</code>以及<code class="highlighter-rouge">data_lock_waits</code>进行代替，故以下内容均采用MySQL 8.0版本进行描述。</p>

<h5 id="24-data_locks">2.4 data_locks</h5>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ENGINE</td>
      <td>申请或持有锁的存储引擎类型</td>
    </tr>
    <tr>
      <td>ENGINE_LOCK_ID</td>
      <td>存储引擎内部的锁ID，该值会发生动态变化，外部系统不应该依赖该值</td>
    </tr>
    <tr>
      <td>ENGINE_TRANSACTION_ID</td>
      <td>持有锁的事务ID，与INNODB_TRX中的TRX_ID对应</td>
    </tr>
    <tr>
      <td>THREAD_ID</td>
      <td>持有锁的线程ID</td>
    </tr>
    <tr>
      <td>EVENT_ID</td>
      <td>事件ID，该字段将于下方进行详细描述</td>
    </tr>
    <tr>
      <td>OBJECT_SCHEMA</td>
      <td>锁所在的schema(database)</td>
    </tr>
    <tr>
      <td>OBJECT_NAME</td>
      <td>锁所在的表名称</td>
    </tr>
    <tr>
      <td>PARTITION_NAME</td>
      <td>锁所在分片名称</td>
    </tr>
    <tr>
      <td>SUBPARTITION_NAME</td>
      <td>锁所在的子分片名称</td>
    </tr>
    <tr>
      <td>INDEX_NAME</td>
      <td>被添加锁的索引名称</td>
    </tr>
    <tr>
      <td>OBJECT_INSTANCE_BEGIN</td>
      <td>锁的内存空间起始地址</td>
    </tr>
    <tr>
      <td>LOCK_TYPE</td>
      <td>锁类型，包含TABLE和RECORD</td>
    </tr>
    <tr>
      <td>LOCK_MODE</td>
      <td>锁的模式，包括S,X,IS,IX,AUTO_INC以及UNKNOWN</td>
    </tr>
    <tr>
      <td>LOCK_STATUS</td>
      <td>锁的状态，InnoDB引擎中包括GRANTED(已添加)和WAITING(等待中)</td>
    </tr>
    <tr>
      <td>LOCK_DATA</td>
      <td>锁覆盖的范围，该字段将于下方详细描述</td>
    </tr>
  </tbody>
</table>

<p>以一个具体的例子为例:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Mario</span><span class="p">.</span><span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
               <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140374385659344</span><span class="p">:</span><span class="mi">1453</span><span class="p">:</span><span class="mi">140374295256456</span>
<span class="n">ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">632837</span>
            <span class="n">THREAD_ID</span><span class="p">:</span> <span class="mi">56</span>
             <span class="n">EVENT_ID</span><span class="p">:</span> <span class="mi">28</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
       <span class="n">PARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
    <span class="n">SUBPARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">NULL</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140374295256456</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="k">TABLE</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">IX</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="k">NULL</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
               <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140374385659344</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140374295253576</span>
<span class="n">ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">632837</span>
            <span class="n">THREAD_ID</span><span class="p">:</span> <span class="mi">56</span>
             <span class="n">EVENT_ID</span><span class="p">:</span> <span class="mi">28</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
       <span class="n">PARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
    <span class="n">SUBPARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140374295253576</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p>当我们使用<code class="highlighter-rouge">FOR UPDATE</code>一致性锁定读向id为1的行添加一个写锁时，可以看到<code class="highlighter-rouge">data_locks</code>中生成了两条记录。从<code class="highlighter-rouge">LOCK_TYPE</code>以及<code class="highlighter-rouge">LOCK_MODE</code>来看，第一条为表级别意向排他锁(IX)，第二条为行记录排他锁(X)。注意到X锁后面还有一个说明: <code class="highlighter-rouge">REC_NOT_GAP</code>，表示排他非间隙行锁，这是行锁的一种实现，将在后面小节中描述。</p>

<p><code class="highlighter-rouge">LOCK_DATA</code>在IX项中为NULL，这是因为在InnoDB存储引擎中，该字段只会在<code class="highlighter-rouge">LOCK_TYPE</code>为<code class="highlighter-rouge">RECORD</code>时才有实际值，对于<code class="highlighter-rouge">TABLE</code>类型的锁而言，该值为NULL。<code class="highlighter-rouge">LOCK_DATA</code>根据不同的加锁方式会有不同具体值。当我们使用主键ID(primary key)进行加锁时，<code class="highlighter-rouge">LOCK_DATA</code>仅包含聚簇索引行记录，此时<code class="highlighter-rouge">LOCK_DATA</code>的值通常为主键ID。当我们使用辅助索引对记录加锁时，锁住的范围则会包括辅助索引+聚簇索引，所以此时<code class="highlighter-rouge">data_locks</code>会生成3条记录(表级别意向锁+索引记录锁+聚簇索引记录锁)，此时<code class="highlighter-rouge">LOCK_DATA</code>的值为”辅助索引字段值+主键ID”</p>

<p>例如:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Mario</span><span class="p">.</span><span class="k">user</span> <span class="k">where</span> <span class="n">user_id</span> <span class="o">=</span> <span class="nv">"168236477"</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
          <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">NULL</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="k">TABLE</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">IX</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="k">NULL</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">user_id_2</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="cm">/* LOCK_DATA为FieldValue+记录对应的主键ID。由于user_id为unique，故此处仅一条记录 */</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="s1">'168236477'</span><span class="p">,</span> <span class="mi">3</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">3</span>
</code></pre></div></div>

<h5 id="25-data_lock_waits">2.5 data_lock_waits</h5>

<p><code class="highlighter-rouge">data_lock_waits</code>相比于<code class="highlighter-rouge">INNODB_TRX</code>以及<code class="highlighter-rouge">data_locks</code>而言则要更复杂一些，该表实际上是一个ManyToMany的关系表，记录了<code class="highlighter-rouge">data_locks</code>中锁之间的等待以及依赖关系，同时也记录了锁所对应的事务/会话信息。</p>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ENGINE</td>
      <td>存储引擎类型</td>
    </tr>
    <tr>
      <td>REQUESTING_ENGINE_LOCK_ID</td>
      <td>存储引擎内锁ID，对应于data_locks表中的ENGINE_LOCK_ID</td>
    </tr>
    <tr>
      <td>REQUESTING_ENGINE_TRANSACTION_ID</td>
      <td>存储引擎内事务ID</td>
    </tr>
    <tr>
      <td>REQUESTING_THREAD_ID</td>
      <td>线程ID</td>
    </tr>
    <tr>
      <td>REQUESTING_EVENT_ID</td>
      <td>事件ID</td>
    </tr>
    <tr>
      <td>REQUESTING_OBJECT_INSTANCE_BEGIN</td>
      <td>锁的内存空间起始地址</td>
    </tr>
    <tr>
      <td>BLOCKING_ENGINE_LOCK_ID</td>
      <td>等待释放的锁ID</td>
    </tr>
    <tr>
      <td>BLOCKING_ENGINE_TRANSACTION_ID</td>
      <td>等待结束的事务ID</td>
    </tr>
    <tr>
      <td>BLOCKING_THREAD_ID</td>
      <td>等待结束的线程ID</td>
    </tr>
    <tr>
      <td>BLOCKING_EVENT_ID</td>
      <td>等待结束的事件ID</td>
    </tr>
    <tr>
      <td>BLOCKING_OBJECT_INSTANCE_BEGIN</td>
      <td>等待结束的锁的内存空间起始地址</td>
    </tr>
  </tbody>
</table>

<p>例如:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_lock_waits</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
                          <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">REQUESTING_ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140678484647376</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140678365511992</span>
<span class="n">REQUESTING_ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">635403</span>
            <span class="n">REQUESTING_THREAD_ID</span><span class="p">:</span> <span class="mi">48</span>
             <span class="n">REQUESTING_EVENT_ID</span><span class="p">:</span> <span class="mi">15</span>
<span class="n">REQUESTING_OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365511992</span>
         <span class="n">BLOCKING_ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140678484646504</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140678365506120</span>
  <span class="cm">/*等待ID为635400的事务释放锁*/</span>
  <span class="n">BLOCKING_ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">635400</span>
              <span class="n">BLOCKING_THREAD_ID</span><span class="p">:</span> <span class="mi">47</span>
               <span class="n">BLOCKING_EVENT_ID</span><span class="p">:</span> <span class="mi">12</span>
  <span class="n">BLOCKING_OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/data_lock_waits.png" alt="" /></p>

<h4 id="3-innodb存储引擎行锁算法">3. InnoDB存储引擎行锁算法</h4>

<p>InnoDB存储引擎存在3种行锁算法，分别为:</p>

<ul>
  <li>Record Lock: 单个行记录上的锁</li>
  <li>Gap Lock: 间隙锁，锁定一个范围，单不包含记录本身</li>
  <li>Next-Key Lock: Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身</li>
</ul>

<p>Record Lock表示单个行记录上的锁，这非常好理解，例如我们<code class="highlighter-rouge">update</code>一条或多条数据时，事务会为这一条或者多条数据均添加X锁。当使用主键ID进行更新时，记录仅包含聚簇索引行记录。当使用辅助索引进行更新时，将会锁住聚簇索引记录+辅助索引记录。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="k">user</span> <span class="k">set</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="cm">/* 省略部分非关键信息 */</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">commit</span><span class="p">;</span>
</code></pre></div></div>

<p>当使用主键ID进行一致性锁定读时，<code class="highlighter-rouge">data_locks</code>生成两条锁记录，一条为table IX，另一条为行记录的X锁，注意<code class="highlighter-rouge">LOCK_MODE</code>后面的附加声明: REC_NOT_GAP，表示当前锁的算法仅为行记录锁，非间隙锁。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="k">user</span> <span class="k">set</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">where</span> <span class="n">user_id</span> <span class="o">=</span> <span class="nv">"174269548"</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">user_id_2</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="s1">'174269548'</span><span class="p">,</span> <span class="mi">1</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506464</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p>而使用辅助索引进行一致性锁定读时，除了table IX以及聚簇索引的X锁以外，还会有额外的辅助索引X锁，<code class="highlighter-rouge">LOCK_MODE</code>同样备注了非间隙锁的标识。</p>

<p>间隙锁的存在主要是为了解决幻读问题，幻读是指当某事务读取一定范围内的数据时，其余事务在该范围内插入了一条或多条数据，或者删除了一条或多条数据，导致前一个事务读取的数据条数发生改变，如同出现幻觉，所以称为幻读。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="n">supremum</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">record</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">3</span>
</code></pre></div></div>

<p>当我们对某一个范围使用一致性锁定读时，就可以看到间隙锁的产生。<code class="highlighter-rouge">LOCK_MODE</code>仅为X时，就表示当前锁添加了间隙锁。并且在<code class="highlighter-rouge">LOCK_DATA</code>有supremum pseudo-record的解释说明，该说明表示MySQL决定锁定最大间隙范围。在本例中，为id大于2的所有数据，故另一个事务执行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">insert</span> <span class="k">into</span> <span class="k">user</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">nickname</span><span class="p">,</span> <span class="n">password</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">mobile_area</span><span class="p">,</span> <span class="n">gender</span><span class="p">,</span> <span class="n">avatar</span><span class="p">,</span> <span class="n">account_id</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="nv">"jojo"</span><span class="p">,</span> <span class="nv">"passwd"</span><span class="p">,</span> <span class="nv">"147523659"</span><span class="p">,</span> <span class="nv">"13555555555"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">"https://jojo.com"</span><span class="p">,</span> <span class="nv">"1753681429"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>将会被阻塞，直至前一个事务释放间隙锁或者当前事务锁等待超时。</p>

<p>在理解了间隙锁以后，Next-Key Lock就很容易理解了，锁定一个记录+一个范围。上面例子均有一个特点，就是不管是主键ID，还是user_id，它们都具有unique约束，而对于非唯一的辅助索引而言，即使是精确查询并加锁，也会添加Gap Lock，此时就是Next-Key Lock。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">updated_at</span> <span class="o">=</span> <span class="nv">"2020-01-23 21:32:52"</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="cm">/*此时DB中仅存在一条数据更新时间为"2020-01-23 21:32:52"*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">updated_at</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="n">supremum</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">record</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">updated_at</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">0</span><span class="n">x99A56F5834</span><span class="p">,</span> <span class="mi">1</span>
<span class="o">***************************</span> <span class="mi">4</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">updated_at</code>字段仅添加了普通索引，并且值为”2020-01-23 21:32:52”的记录主键ID为1，从<code class="highlighter-rouge">data_locks</code>的最后一条记录也可以看出。在该表的第二行和第三行中分别添加了间隙锁，第三行的<code class="highlighter-rouge">LOCK_DATA</code>字段值为16进制数+主键ID。</p>

<p>此外，<strong>需要尤为注意的是，<code class="highlighter-rouge">READ COMMITTED</code>事务隔离级别下，将不会有间隙锁的添加</strong>。在文章<a href="https://smartkeyerror.com/django-concurrent-data-process">Django处理数据并发问题</a>中描述了使用Django默认的<code class="highlighter-rouge">READ COMMITTED</code>事务隔离级别所带来的问题。</p>

<h4 id="4-自增长与锁">4. 自增长与锁</h4>

<p>自增长在数据库中是非常常见的属性，MySQL提供<code class="highlighter-rouge">AUTO_INCREMENT</code>属性使得列可具备自增长的功能。在InnoDB存储引擎内存结构中，对每个含有自增长值的表都有一个自增长计数器。</p>

<p>最初自增长是采用特殊的表锁实现，称为AUTO_INC Locking，为了提高插入的性能，锁并不是在事务结束时才释放，而是在完成对自增长值插入的SQL语句后立即释放。虽然AUTO_INC Locking从一定程度上提高了并发插入的效率，但是仍存在性能问题: 事务必须等待前一个事务插入语句的结束。所以，后续就有了轻量级的互斥量自增长实现。</p>

<p>互斥量的实现就是文章最开头所说的Latch，由硬件协助实现。该实现方式只有在确定所插入的行数时才会使用，否则，将仍然使用AUTO_INC Locking。</p>

<h4 id="5-metadata-lock">5. Metadata Lock</h4>

<p>Metadata Lock，又称为MDL，相较于行锁和表锁，其范围更广，对象包括数据库、表、行以及触发器和外键等，与InnoDB其它锁一样，在事务开始时获取，事务结束时释放，其设计目的在于保证在事务执行过程中表的结构不会被修改。</p>

<p>通常来讲，只有在修改表结构的时候我们才会直接地与MDL打交道，例如向某张表添加一列，或者删除某一列。在DML执行非常频繁的应用中，当我们执行ALTER TABLE table ADD column时，很有可能出现整个MySQL挂掉的情况，其原因就在于表结构修改语句获取MDL时阻塞，导致后续对该表的查询、修改和删除等语句阻塞。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/MDL.png" alt="" /></p>

<p>session A与session B会向表user添加只读MDL，而session C想要申请可写的MDL，由于前面两个事务均为提交，故只能阻塞。此时由于session C写锁的申请，导致session D以及后续的所有DML操作均会被阻塞，简单来说，此时表user不可读写。</p>

<p>如果user表中的读写非常频繁，将会导致大量的查询或更新语句阻塞，且状态均为<code class="highlighter-rouge">waiting for metadata lock</code>。此时若客户端存在超时重试机制，那么会导致大量新的会话建立，最后达到MySQL线程数量的限制，导致整个DB不可用。</p>

<p>在MySQL 5.6版本以上支持Online DDL，其过程如下:</p>
<ul>
  <li>ALTER TABLE table ADD column语句获取MDL写锁</li>
  <li>获取成功后，将其降级为MDL读锁</li>
  <li>执行真正的DDL操作，如添加、删除列，期间可以执行DML语句</li>
  <li>升级MDL读锁为写锁</li>
  <li>释放MDL写锁，整个DDL过程结束</li>
</ul>

<p>真正导致数据库不可读写的步骤为1、4，第3步为实际运行时间最长的步骤，不会影响表的读写操作，只要内存和磁盘容量足够，数据量再多也灭有关系。所以，DDL的关键影响因素不在于数据量，而是在于数据读写的QPS。这也是为什么表结构修改操作要放到月黑风高的凌晨进行操作的原因: 那时候访问量最少，而不是数据量最少。</p>

<p>在更改表结构时造成大面积读写操作阻塞的另一个原因就是长事务，即长时间运行的事务。即使QPS非常小，但是系统中存在长事务，同样会造成DDL语句获取写锁阻塞，从而阻塞后续的读写语句。</p>

<h4 id="6-reference">6. Reference</h4>

<ul>
  <li>https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_latch</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-trx-table.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/data-locks-table.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/data-lock-waits-table.html</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL中的悲观锁与常见的死锁场景</title>
	  <link>//MySQL-Pessimistic-Lock</link>
	  <author></author>
	  <pubDate>2019-09-18T21:39:25+00:00</pubDate>
	  <guid>//MySQL-Pessimistic-Lock</guid>
	  <description><![CDATA[
	     <p>在MySQL中， 锁机制是并发条件下保护数据一致性与稳定性的一个非常重要的机制， 并且事务的实现也依赖于于锁机制。 其锁定的数据不单包括数据行记录， 同时也包括缓冲池中的LRU列表数据、日志数据等。 悲观锁(FOR UPDATE)则是日常开发中使用最多的一种锁， 但是， 由于事务隔离级别的多样性导致了悲观锁在使用时常常会有不同的表现， 死锁在程序员稍不注意时就会发生。</p>

<!---more--->

<h4 id="1-悲观锁概述">1. 悲观锁概述</h4>
<p>在通用的程序设计语言中， 锁通常是基于某一个对象， 或者是一组对象而言。 在Python、Java和Golang中， 分别提供了<code class="highlighter-rouge">threading.Lock</code>、<code class="highlighter-rouge">synchronized</code>以及<code class="highlighter-rouge">sync.Mutex</code>互斥所机制。 而数据库要更为特殊一些， 其原因就在于我们所管理的不是一个个的对象， 而是一行行的数据。</p>

<p>InnoDB存储引擎支持的最小锁粒度为行锁， 可以通过在事务中执行<code class="highlighter-rouge">SELECT .. FOR UPDATE</code>为某一行或者是多行数据添加互斥锁。 锁的生命周期完全由InnoDB管理， 当事务成功提交或者是失败回滚时， 互斥锁则自动释放。</p>

<p>需要注意的一点是， 互斥锁必须在事务中执行才会生效。 当<code class="highlighter-rouge">autocommit</code>为<code class="highlighter-rouge">ON</code>时， 需要显示的使用<code class="highlighter-rouge">BEGIN</code>开启事务， 而后对数据添加互斥锁。</p>

<p>在程序设计语言中， 锁的目的是串行化修改、删除操作， InnoDB中的互斥锁有着同样的目的。 但是， 由于事务隔离级别的分类， 使得互斥锁的行为变得复杂许多。 其中最让人感到迷惑的就是为了解决幻读问题所添加的<code class="highlighter-rouge">GAP Lock</code>。</p>

<h4 id="2-事务隔离级别概述">2. 事务隔离级别概述</h4>

<p>不同的事务隔离级别， 悲观锁会产生不同的行为。 所以， 理解事务隔离级别是理解悲观锁的第一步。</p>

<p>InnoDB事务隔离级别从低到高依次为未提交读(READ UNCOMMITED)， 提交读(READ COMMITED)， 可重复读(READ REPEATABLE)以及串行化(SERIALIZABLE)。</p>

<p>未提交读指的是事务B可以读取到事务A未提交的数据， 此时若事务A回滚， 那么事务B读到的就是错误数据， 也称为脏数据。 该读取行为有时也会被称为脏读， 因为未提交读会导致脏读的问题， 从而导致数据混乱， 所以该事务隔离级别基本不会被使用。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/read-uncommitted-with-dirty-data.png" alt="" /></p>

<p>提交读是指在执行事务B时， 可以读取到事务A提交到的数据， 未提交的数据不可读取。 提交读解决了脏读的问题， 读取到的数据一定是已经持久化至磁盘的数据， 但是会出现同一条SQL语句在执行时出现不一致的情况。 例如事务A、B先后开始执行， 事务A首先读取row-1的内容， 而此时事务B对row-1的内容修改并提交， 此时事务A再次读取row-1数据， 发现其已经发生改变， 而该变化并不是事务A自身进行的。 这种情况又称为不可重复读。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/Read-Committed.png" alt="" /></p>

<p>可重复读， 顾名思义， 解决了提交读的不可重复读问题， 使得事务在读取同一行数据时， 结果并不会因为其它事务的执行而发生改变， 数据发生的修改行为在整个事务内是可以自恰的。 但是并没有解决幻读的问题， 幻读是指其余事务在某一个区间内插入数据， 而非修改数据， 此时事务也会读取到这部分插入的数据。 InnoDB借助MVCC(多版本并发控制)以及锁机制来解决幻读问题。</p>

<p>MVCC即在数据中添加版本号， 数据插入时会有初始版本号， 在修改、删除时更新版本号。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/Repeatable-Read.png" alt="" /></p>

<p>串行化指事务串行化执行， 自然就不会有出现上述出现的脏读、不可重复读以及幻读了。 一个很重要的事实是， 串行化的事务隔离级别执行效率并不会比可重复读事务隔离级别差很多。 同样的， 提交读执行效率也不会比可重复读执行效率高多少， 所以在优化数据库时， 事务隔离级别不应该是效率优化目标， 而是业务优化目标。</p>

<h4 id="3-mysql中的锁">3. MySQL中的锁</h4>

<p>使用<code class="highlighter-rouge">FOR UPDATE</code>对某一行或者是多行数据添加的锁， 其实是由MySQL更细粒度的锁组合而成的， 不同的事务隔离级别有不同的组合方式。</p>

<p>在InnoDB存储引擎中， 存在3种行锁的算法， 其分别为:</p>
<ul>
  <li>Record Lock: 单个行记录上的锁，聚集索引及辅助索引均会添加锁。</li>
  <li>Gap Lock: 间隙锁， 锁定一个范围， 但不包含行记录本身。</li>
  <li>Next-Key Lock: Record Lock + Gap Lock，锁定行记录本身并且锁定一个范围。</li>
</ul>

<p>下面用一个实际的例子来解释Record Lock以及Gap Lock。 首先表结构定义如下:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">lock_test</span> <span class="p">(</span>
  <span class="n">id</span> <span class="n">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="n">a</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">latin1</span><span class="p">;</span>

<span class="c1">-- 插入部分测试数据</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"1"</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"3"</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"5"</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"8"</span><span class="p">);</span>
</code></pre></div></div>

<p>接着执行下面的语句:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “5” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“4”); <br /> 阻塞，等待会话A事务的提交</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">COMMIT;</td>
      <td style="text-align: left">Query OK, 1 row affected (6.87 sec)</td>
    </tr>
  </tbody>
</table>

<p>尽管列<code class="highlighter-rouge">a</code>添加了辅助索引， 但是在对该列使用<code class="highlighter-rouge">FOR UPDATE</code>添加悲观锁时， 仍然会出现其它列被锁定的现象。 这是因为<code class="highlighter-rouge">a = "5"</code>该行数据不仅被添加了Record Lock， 并且也添加了Gap Lock， 其目的就是为了解决幻读问题， 前提是当前事务隔离级别为REPEATABLE READ。</p>

<p>在列<code class="highlighter-rouge">a</code>的辅助索引中， 值”5”之前的值为”3”， 故存在(3, 5)这个间隙， 所以在插入值”4”时， InnoDB为了杜绝幻读现象的发生， 使得只有在会话A事务提交时才允许插入操作的进行。 另外一点需要注意的是， 当查询的索引具有唯一属性时， InnoDB存储引擎会对Next-Key Lock进行优化， 将其降级为Record Lock， 即仅锁住索引本身， 而不锁定一个范围。</p>

<blockquote>
  <p>For a unique index with a unique search condition, InnoDB locks only the index record found, not the gap before it.</p>
</blockquote>

<h4 id="4-锁与事务之间的关联">4. 锁与事务之间的关联</h4>

<p>前面提到了Gap Lock的存在主要是为了解决幻读问题的发生， 而在READ COMMITTED事务隔离级别中， 只解决了脏读问题， 所以说， 在该事务隔离级别下， <code class="highlighter-rouge">FOR UPDATE</code>仅会添加Record Lock， 并不会添加Gap Lock。</p>

<blockquote>
  <p>For locking reads (SELECT with FOR UPDATE or FOR SHARE), UPDATE statements, and DELETE statements, InnoDB locks only index records, not the gaps before them.</p>
</blockquote>

<blockquote>
  <p>Because gap locking is disabled, phantom problems may occur, as other sessions can insert new rows into the gaps</p>
</blockquote>

<p>此外， 如果用户通过索引查询一个值， 并在其之上添加排它锁， 当查询的值不存在时， READ COMMITTED与REPEATABLE READ两个事务隔离级别所产生的行为同样存在差异， 一个最直观的差异就是REPEATABLE READ在并发条件下会产生死锁， 而READ COMMITTED则不会。</p>

<p>READ COMMITTED事务隔离级别:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “100” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “100” FOR UPDATE; <br /> 不会被阻塞</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“100”); <br /> 不会被阻塞</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">6</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“100”); <br /> 不会被阻塞</td>
    </tr>
    <tr>
      <td style="text-align: left">7</td>
      <td style="text-align: left">COMMIT;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">8</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">COMMIT;</td>
    </tr>
  </tbody>
</table>

<p>所以说， 当事务隔离级别为READ COMMITTED时， 无法使用Next-Key Lock来帮助我们实现类似于<code class="highlighter-rouge">update_or_create</code>或者是<code class="highlighter-rouge">get_or_create</code>等方法， 因为在并发条件下会造成重复数据创建， 除非表中存在唯一索引。 这也是Django框架官网中所提到的Multiply records问题。 感兴趣的小伙伴可访问官网获取更多详细内容:</p>

<blockquote>
  <p>https://docs.djangoproject.com/en/2.2/ref/models/querysets/#get-or-create</p>
</blockquote>

<p>REPEATABLE READ事务隔离级别:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE; <br /> 不会被阻塞</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“200”); <br /> 阻塞, 等待事务B的结束</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">6</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“200”); <br /> ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction，死锁发生</td>
    </tr>
  </tbody>
</table>

<p>当在REPEATABLE READ事务隔离级别级别下实现<code class="highlighter-rouge">get_or_create</code>方法时，会产生死锁问题， 原因就在于锁定的记录并不存在， 多个事务可同时对其添加悲观锁， 但是插入语句的执行位置是不确定的， 所以就会有死锁问题的出现。解决此类问题的一个方法就是使用指数退避方式的重试。</p>

<h4 id="5-死锁">5. 死锁</h4>

<p>通常来讲， 如果我们的SQL执行计划较为简单， 几乎所有的执行均为单条语句执行时， 死锁基本与我们无关。 但是当执行计划稍加复杂， 事务执行的语句较多时， 就会出现死锁问题。 一个最经典的死锁场景即为AB-BA死锁。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “400” FOR UPDATE;</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “400” FOR UPDATE<br /> 阻塞, 等待事务B的结束</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">6</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE; <br /> ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction，死锁发生</td>
    </tr>
  </tbody>
</table>

<p>当MySQL检测到死锁时， 会根据其事务权重选择性的回滚其中一个事务。 但是， 权重的判定完全由MySQL决定， 业务系统无法人为的干预， 如果某一个事务在业务系统中非常重要， 但是MySQL却回滚了该事务， 而业务系统仅捕捉了该异常并向外扩散的话， 并不是我们期望的结果。 所以， 在绝大多数场景下， 指数退避的重试策略要更好一些。 或者对于关键性的业务逻辑， 使用Redis等消息队列进行串行化操作。</p>

<p>另外一个死锁场景则是上一小节中我们所见到的并发执行<code class="highlighter-rouge">if not exist then create</code>模式所带来的死锁问题， 该模式在业务场景下其实非常常见。</p>

<h4 id="reference">Reference</h4>
<ul>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL中的联合索引与覆盖索引</title>
	  <link>//MySQL-union-index-and-cover-index</link>
	  <author></author>
	  <pubDate>2019-09-01T21:39:25+00:00</pubDate>
	  <guid>//MySQL-union-index-and-cover-index</guid>
	  <description><![CDATA[
	     <p>在上一篇文章中， 通过解析InnoDB存储引擎的<code class="highlighter-rouge">.ibd</code>数据存储文件得到了数据与索引的真实组织方式: 数据通过聚集索引在逻辑上连续存放， 二级索引保存数据主键ID(Row ID)， 多棵B+Tree组合起来提供高效的索引数据查询。 除辅助索引(二级索引)外， 联合索引与覆盖索引在日常中也会经常用到。</p>

<!---more--->

<h4 id="1-联合索引">1. 联合索引</h4>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">union_test</span> <span class="p">(</span>
	<span class="n">id</span> <span class="n">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
	<span class="n">user_id</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	<span class="n">order_id</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	<span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
	<span class="k">KEY</span> <span class="n">ix_union_order_id_user_id</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">union_test</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"0000"</span><span class="p">,</span> <span class="nv">"A0000"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">union_test</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"0000"</span><span class="p">,</span> <span class="nv">"A0001"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">union_test</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"0001"</span><span class="p">,</span> <span class="nv">"A0003"</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div>

<p>在创建表结构以及插入部分测试数据之后， 我们依然使用<code class="highlighter-rouge">hexdump -C</code>来对<code class="highlighter-rouge">.ibd</code>文件进行分析， 从最基本的数据存储结构中更能够发现联合索引的存储特点。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00010070  73 75 70 72 65 6d 75 6d  03 04 00 00 10 00 36 30  |supremum......60|
00010080  30 35 38 41 31 34 80 00  00 01 03 04 07 00 18 05  |058A14..........|
00010090  e2 30 30 33 36 41 32 30  80 00 00 02 03 04 08 00  |.0036A20........|
000100a0  20 00 fb 30 30 34 33 41  31 33 80 00 00 03 03 04  | ..0043A13......|
000100b0  00 00 28 01 67 30 30 35  39 41 32 31 80 00 00 04  |..<span class="o">(</span>.g0059A21....|
000100c0  03 04 08 00 30 02 65 30  30 34 39 41 38 39 80 00  |....0.e0049A89..|
000100d0  00 05 03 04 00 00 38 01  1f 30 30 35 31 41 35 34  |......8..0051A54|
000100e0  80 00 00 06 02 04 06 00  40 05 76 30 30 32 33 41  |........@.v0023A|
000100f0  36 80 00 00 07 03 04 00  00 48 02 0c 30 30 30 31  |6........H..0001|
00010100  41 35 30 80 00 00 08 03  04 00 00 50 06 19 30 30  |A50........P..00|
00010110  31 35 41 39 31 80 00 00  09 03 04 00 00 58 ff 83  |15A91........X..|
00010120  30 30 34 32 41 37 32 80  00 00 0a 03 04 00 00 60  |0042A72........<span class="sb">`</span>|
00010130  01 56 30 30 33 38 41 39  35 80 00 00 0b 03 04 00  |.V0038A95.......|
00010140  00 68 03 4f 30 30 32 39  41 39 37 80 00 00 0c 03  |.h.O0029A97.....|
00010150  04 05 00 70 05 41 30 30  35 37 41 31 31 80 00 00  |...p.A0057A11...|
00010160  0d 03 04 00 00 78 02 c0  30 30 31 39 41 35 32 80  |.....x..0019A52.|
</code></pre></div></div>

<p>直接截取部分的联合索引内容进行分析， 索引数据从<code class="highlighter-rouge">00010078</code>开始:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span> <span class="mi">04</span>  <span class="cm">/* 倒序索引长度列表 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">36</span>
<span class="mi">30</span> <span class="mi">30</span> <span class="mi">35</span> <span class="mi">38</span>  <span class="cm">/* 列1索引数据 */</span>
<span class="mi">41</span> <span class="mi">31</span> <span class="mi">34</span>  <span class="cm">/* 列2索引数据 */</span>
<span class="mi">80</span> <span class="mi">00</span>  <span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 主键id */</span>
</code></pre></div></div>

<p>可以看到， 联合索引的物理存储方式与单一索引的最大区别就是索引数据不是分开存储的。 所以， 联合索引要比两个或多个单独的索引占用更少的磁盘空间。</p>

<p>事实上， 联合索引与单列索引在组织形式上没什么区别， 都是一棵B+Tree。 只不过联合索引的键值数量不是1， 而是大于等于2。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/union-index.png" alt="" /></p>

<p>如上图所示， 联合索引的第1列数据将严格按照B+Tree的字典序进行排序， 第2列数据则在第一列数据有序的基础上进行排序。 可以认为， 联合索引的B+Tree结构就是对一个多维数组进行排序， 以Python为例:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 假设有如下数据</span>
<span class="n">unsorted_list</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>

<span class="n">res</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">unsorted_list</span><span class="p">)</span>
<span class="c"># Out: [(1, 2), (1, 3), (2, 4), (2, 5), (4, 1), (4, 2)]</span>
</code></pre></div></div>

<p>假设现在有两列数据a, b组合成为了联合索引， 那么当a列相同时， b列数据一定是有序存放的， 也就是说当执行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">a</span> <span class="o">=</span> <span class="n">XX</span> <span class="k">AND</span> <span class="n">b</span> <span class="o">=</span> <span class="n">XX</span><span class="p">;</span>
</code></pre></div></div>

<p>其效率要高于a, b两个单独的索引列查询， 原因就在于其索引数据保存在同一棵B+Tree中， 使用更少的逻辑I/O就能将数据取出。</p>

<p>在单独查询列a时， 依然可以使用联合索引进行查询， 但是在单独查询b列时， 则不可以使用联合索引。 因为b列数据并不是有序存放的。</p>

<p>如上例所示， b列的数据为<code class="highlighter-rouge">[2, 3, 2, 4, 1, 2]</code>， 完全无序， 故使用:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">b</span> <span class="o">=</span> <span class="n">XX</span><span class="p">;</span>
</code></pre></div></div>

<p>进行查询时将无法使用联合索引。 联合索引除了能加速查询以外， 还有另外一个好处， 就是加速<code class="highlighter-rouge">ORDER BY</code>的查询。</p>

<p>这也很好理解， 因为在建立了联合索引以后， 第2列数据， 甚至是第n列数据， 将会有序的组成B+Tree， 如此一来就省去了排序的的时间。</p>

<p>假设现在有4列数据a, b, c, d组成的联合索引(a, b, c, d)， 那么B+Tree的结构为a有序排列， b在a相同的情况下有序排列， c在b相同的情况下有序排列， d在c相同的情况下有序排列。 在查询时， 只要查询条件包含a字段， 均可以使用索引进行查询。</p>

<h4 id="2-覆盖索引cover-index">2. 覆盖索引(Cover Index)</h4>
<p>现在我们已经知道了InnoDB的物理存储方式是一个聚集索引+多个辅助索引组成， 辅助索引包含单列索引以及上面提到的联合索引。 在使用索引进行数据查询时， 首先在辅助索引树中找到该条数据对应的主键id(Row ID)， 而后根据主键id在聚集索引树中进行查询， 粗略的认为就是2次逻辑I/O。</p>

<p>覆盖索引的本质就是不使用聚集索引， 只使用辅助索引就能够将所需要的数据查询出来， 最典型的例子就是<code class="highlighter-rouge">count(*)</code>。</p>

<p>当某张表内存在二级索引时， <code class="highlighter-rouge">count(*)</code>将直接统计二级索引的数量并返回。 由于二级索引的B+Tree要比聚集索引更加的矮胖， 每页能够容纳更多的索引数据行， 所以其效率要高于扫描聚集索引。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">count_test</span> <span class="p">(</span>
	<span class="n">id</span> <span class="n">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
	<span class="n">user_id</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	<span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
	<span class="k">KEY</span> <span class="n">ix_user_id</span> <span class="p">(</span><span class="n">user_id</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/count-with-cover-index.png" alt="" /></p>

<p>如果表内有多个二级索引， 则<code class="highlighter-rouge">count(*)</code>将会选择长度最短的二级索引。 索引长度越短， 每页就能够容纳更多的数据， 就会有更少的逻辑I/O， 因此效率也就越高。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">count_test</span> <span class="k">ADD</span> <span class="n">order_id</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">count_test</span> <span class="k">ADD</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">order_id</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/count-with-shorter-cover-index.png" alt="" /></p>

<p>覆盖索引严格意义上来讲是MySQL的查询优化器所做的优化， 并不是物理上存在的索引。 但是， 借助于覆盖索引的特点， 我们可以有目的的对某些查询进行优化。</p>

<h4 id="3-小结">3. 小结</h4>
<p>联合索引是优化多字段查询以及需要对某个字段进行排序的一种手段， 而覆盖索引则是MySQL查询优化器的一种优化策略， 并不能称为真正意义上的索引。</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL物理存储方式</title>
	  <link>//MySQL-physical-structure</link>
	  <author></author>
	  <pubDate>2019-08-15T21:39:25+00:00</pubDate>
	  <guid>//MySQL-physical-structure</guid>
	  <description><![CDATA[
	     <p>MySQL是基于磁盘进行数据存储的关系型数据库， 所有的数据、索引等数据均以磁盘文件的方式存储， 在有需要时载入内存读取。 为了加快数据查询的效率， 通常会在一些字段上添加索引， 但是许多文档都会告诉我们， 不要添加太多的索引， 索引不要太长， 使用数字或者空字符串来代替NULL值， 为什么会有这些建议? 这些建议又是否正确?  答案都能够从MySQL数据的物理存储方式中找到。</p>

<!---more--->

<h4 id="1-innodb文件格式">1. InnoDB文件格式</h4>
<p>由于InnoDB是MySQL使用最为广泛的存储引擎， 所以本篇博文基于InnoDB存储引擎来讨论其数据存储方式。</p>

<p>当我们创建一个table时， InnoDB会创建三个文件。 一个是表结构定义文件， 另一个为数据实际存储文件， 并且所有的索引也将存放在这个文件中。 最后一个文件保存该table所制定的字符集。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/innodb-table-structure.png" alt="" /></p>

<h4 id="2-innodb行记录格式">2. InnoDB行记录格式</h4>
<p>当我们使用SQL查询一条或者是多条数据时， 数据将会以一行一行的方式返回， 而实际上数据在文件中也的确是使用行记录的方式进行存储的。</p>

<p>不同的InnoDB引擎版本可能有着不同的行记录格式来存放数据， 可以说， 行记录格式的变更将会直接影响到InnoDB的查询以及DML效率。 在MySQL 5.7版本中， 如果对某个table执行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SHOW</span> <span class="k">TABLE</span> <span class="n">STATUS</span> <span class="k">LIKE</span> <span class="nv">"table_name"</span> <span class="err">\</span><span class="k">G</span><span class="p">;</span>
</code></pre></div></div>

<p>将会得到该table的一系列信息， 在这里， 我们只需要知道<code class="highlighter-rouge">Row_format</code>的值即可， 5.7将会返回<code class="highlighter-rouge">Dynamic</code>。</p>

<p>在官网上给出了不同格式的行记录格式之间的差别， 详细内容见官方文档:</p>

<blockquote>
  <p>https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html</p>
</blockquote>

<p>在这里我们只需要知道<code class="highlighter-rouge">Dynamic</code>行记录格式在存储可变字符(Varchar)时， 与<code class="highlighter-rouge">Compact</code>行记录格式有着同样的表现即可。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/Compact-row-format.png" alt="" /></p>

<p>Compact行记录格式将以上图的方式保存在文件中， 需要注意的是， 如果一个table中没有任何的varchar类型， 那么变长字段长度列表将为空。</p>

<p>Compact行记录格式的首部是一个非NULL变长字段长度列表， 并且是按照列的顺序逆序放置的， 其长度表现为:</p>
<ul>
  <li>若列的长度小于255字节， 用1字节表示</li>
  <li>若列的长度大于255字节， 用2字节表示</li>
</ul>

<p>变长字段的长度最大不会超过2字节， 这是因为MySQL中VARCAHR类型的最大长度限制为65535。 变长字段之后的第二个部分为NULL标识位， 该位指示了该行数据中是否存在NULL值， 有则用1表示， 本质上是一个bitmap。</p>

<p>下面用一个实际的例子来具体分析Compact行记录格式的实际存储。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 创建database</span>
<span class="k">CREATE</span> <span class="k">SCHEMA</span> <span class="nv">`coco`</span> <span class="k">DEFAULT</span> <span class="n">CHARACTER</span> <span class="k">SET</span> <span class="n">latin1</span> <span class="p">;</span>

<span class="c1">-- 创建table</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">one</span> <span class="p">(</span>
    <span class="n">id</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">nickname</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="p">(</span><span class="n">nickname</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>

<span class="c1">-- 插入代表性数据</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"a"</span><span class="p">,</span> <span class="nv">"AAA"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"b"</span><span class="p">,</span> <span class="nv">"BBB"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"c"</span><span class="p">,</span> <span class="k">NULL</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"d"</span><span class="p">,</span> <span class="nv">"DDD"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"e"</span><span class="p">,</span> <span class="nv">""</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"f"</span><span class="p">,</span> <span class="nv">"FFF"</span><span class="p">);</span>
</code></pre></div></div>

<p>而后在<code class="highlighter-rouge">/var/lib/mysql/coco</code>中即可找到该表的<code class="highlighter-rouge">.ibd</code>文件了， 使用<code class="highlighter-rouge">hexdump -C one.ibd</code>对其进行16进制的数据解析并查看。 由于数据太长， 所以仅截取部分数据:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000c070  73 75 70 72 65 6d 75 6d  03 01 00 00 00 10 00 1d  |supremum........|
0000c080  80 00 00 01 00 00 00 08  d1 29 bd 00 00 01 35 01  |.........<span class="o">)</span>....5.|
0000c090  10 61 41 41 41 03 01 00  00 00 18 00 1c 80 00 00  |.aAAA...........|
0000c0a0  02 00 00 00 08 d1 29 bd  00 00 01 35 01 1d 62 42  |......<span class="o">)</span>....5..bB|
0000c0b0  42 42 01 02 00 00 20 00  1a 80 00 00 03 00 00 00  |BB.... .........|
0000c0c0  08 d1 29 bd 00 00 01 35  01 2a 63 03 01 00 00 00  |..<span class="o">)</span>....5.<span class="k">*</span>c.....|
0000c0d0  28 00 1d 80 00 00 04 00  00 00 08 d1 29 bd 00 00  |<span class="o">(</span>...........<span class="o">)</span>...|
0000c0e0  01 35 01 37 64 44 44 44  00 01 00 00 00 30 00 1a  |.5.7dDDD.....0..|
0000c0f0  80 00 00 05 00 00 00 08  d1 29 bd 00 00 01 35 01  |.........<span class="o">)</span>....5.|
0000c100  44 65 03 01 00 00 00 38  ff 66 80 00 00 06 00 00  |De.....8.f......|
0000c110  00 08 d1 29 bd 00 00 01  35 01 51 66 46 46 46 00  |...<span class="o">)</span>....5.QfFFF.|
</code></pre></div></div>

<p>实际存储数据从<code class="highlighter-rouge">0000c078</code>开始， 使用Compact行记录格式对其进行整理:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span> <span class="mi">01</span> <span class="cm">/* 变长字段长度列表, 逆序, 第一行varchar数据为('a', 'AAA') */</span>
<span class="mi">00</span> <span class="cm">/* NULL标识位, 该值表示该行未有NULL值的列 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">1</span><span class="n">d</span> <span class="cm">/* 记录头(Record Header)信息, 固定长度为5字节 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="cm">/* Row ID, 这里即为该行数据的主键值(paimary key)，长度为4 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">08</span> <span class="n">d1</span> <span class="mi">29</span> <span class="cm">/* Transaction ID, 即事务ID, 默认为6字节 */</span>
<span class="n">bd</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">35</span> <span class="mi">01</span> <span class="mi">10</span> <span class="cm">/* 回滚指针, 默认为7字节 */</span>
<span class="mi">61</span> <span class="cm">/* 列1数据'a' */</span>
<span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span> <span class="cm">/* 列2数据'AAA' */</span>
</code></pre></div></div>

<p>第2行数据与第1行数据大同小异， 值得关注的是包含有NULL值以及空值的行， 即第3行和第5行， 首先来看第3行数据:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">01</span> <span class="cm">/* 由于该行中只有一列数据类型为varchar，并且非NULL, 所以列表长度为1 */</span>
<span class="mi">02</span> <span class="cm">/* 02转换为2进制结果为10, 表示第二列数据为NULL(注意是逆序) */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">20</span> <span class="mi">00</span> <span class="mi">1</span><span class="n">a</span> <span class="cm">/* 记录头(Record Header)信息, 固定长度为5字节 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">03</span> <span class="cm">/* 第3行数据的主键id */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">08</span> <span class="n">d1</span> <span class="mi">29</span>  <span class="cm">/* Transaction ID, 即事务ID, 默认为6字节 */</span>
<span class="n">bd</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">35</span>  <span class="mi">01</span> <span class="mi">2</span><span class="n">a</span> <span class="cm">/* 回滚指针, 默认为7字节 */</span>
<span class="mi">63</span> <span class="cm">/* 列1数据'c' */</span>
</code></pre></div></div>

<p>可以非常明显的看到， NULL值并没有在文件中进行存储， 而是仅使用NULL标识位来标记某一列是否为NULL。 所以说， NULL值不会占据任何的物理存储空间， 相反， varchar类型的NULL值还会少占用变长字段长度列表空间。</p>

<p>再来看空字符串所在的第5行数据:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 表示第2列的varchar长度为0 */</span>
<span class="mi">00</span>  <span class="cm">/* 该行没有NULL值的列 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">30</span> <span class="mi">00</span> <span class="mi">1</span><span class="n">a</span>  <span class="cm">/* 记录头(Record Header)信息, 固定长度为5字节 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">05</span>  <span class="cm">/* 第5行数据的主键id */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">08</span> <span class="n">d1</span> <span class="mi">29</span>  <span class="cm">/* Transaction ID, 即事务ID, 默认为6字节 */</span>
<span class="n">bd</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">35</span> <span class="mi">01</span> <span class="mi">44</span>   <span class="cm">/* 回滚指针, 默认为7字节 */</span>
<span class="mi">65</span>  <span class="cm">/* 列1数据'e' */</span>
</code></pre></div></div>

<p>可以看到， 空字符串和NULL值一样， 也不占用任何的磁盘存储空间。 只不过与NULL值不同的是， 在首部的变长字符长度列表中仍然占据存储空间， 但是值为0。</p>

<h4 id="3-数据的聚集索引组织方式">3. 数据的聚集索引组织方式</h4>
<p>有些人将聚集索引(Cluster Index)理解成为主键， 或者是主键索引， 这是不准确的。 聚集索引并不是一种索引结构， 而是一种数据的组织方式， 用唯一且不为空的主键来对所有的数据进行组织。 主键， 是最为常见的聚集索引对外表现的形式。</p>

<p>聚集索引最大的特点就在于数据在逻辑上是一定是连续的， 但是在物理是并不一定连续。 比如我们常见的自增主键， 当我们对查询语句不做任何处理时， 默认就是按照主键的递增顺序返回的。</p>

<p>而辅助索引， 或者是二级索引， 是由程序员人为的在某些列上所添加的索引。 辅助索引所代表的数据在逻辑上不一定连续， 物理存储上也不一定连续。</p>

<p>MySQL使用B+Tree来组织数据和索引(关于B+Tree的详细内容， 可见下方传送门)， 在非叶子节点中保存着索引和指针， 在叶子节点保存着数据。 情况又分两种:</p>
<ul>
  <li>聚集索引的叶子节点保存着实际的数据，即一行完整的数据</li>
  <li>辅助索引的叶子节点保存着该行数据的主键ID</li>
</ul>

<p><a href="https://smartkeyerror.com/%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-04-B-Tree%E4%B8%8EB-Tree.html">那些有趣的数据结构与算法(04)–B-Tree与B+Tree</a></p>

<p>也就是说， 假设聚集索引和辅助索引的B+Tree树高均为3的话， 使用主键查询需要3次逻辑I/O。 而使用辅助索引则需要6次逻辑I/O才能找到该行数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/Cluster-Index.png" alt="" /></p>

<p>还记得在上面的Compact行记录格式中的行记录头， 也就是Record Header信息吗?  Record Header的最后两个字节表示下一行数据的偏移量， 其实这个就是B+Tree中的指针。 例如第一行的起始位置为c078， Record Header最后两个字节为001d， 加起来等于c095， 刚好是第二行的起始位置。</p>

<p>在上面的例子中， 我们创建了这样的一张表:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">one</span> <span class="p">(</span>
    <span class="n">id</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">nickname</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="p">(</span><span class="n">nickname</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">nickname</code>字段被我们添加了辅助索引， 同样地， 可以使用<code class="highlighter-rouge">.ibd</code>文件来具体对其结构进行分析。 使用<code class="highlighter-rouge">hexdump -C one.ibd</code>解析文件并找到辅助索引开始的地方:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00010060</span>  <span class="mi">02</span> <span class="mi">00</span> <span class="mi">37</span> <span class="mi">69</span> <span class="mi">6</span><span class="n">e</span> <span class="mi">66</span> <span class="mi">69</span> <span class="mi">6</span><span class="n">d</span>  <span class="mi">75</span> <span class="mi">6</span><span class="n">d</span> <span class="mi">00</span> <span class="mi">07</span> <span class="mi">00</span> <span class="mi">0</span><span class="n">b</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="o">|</span><span class="p">..</span><span class="mi">7</span><span class="n">infimum</span><span class="p">......</span><span class="o">|</span>
<span class="mi">00010070</span>  <span class="mi">73</span> <span class="mi">75</span> <span class="mi">70</span> <span class="mi">72</span> <span class="mi">65</span> <span class="mi">6</span><span class="n">d</span> <span class="mi">75</span> <span class="mi">6</span><span class="n">d</span>  <span class="mi">03</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">0</span><span class="n">e</span> <span class="mi">41</span>  <span class="o">|</span><span class="n">supremum</span><span class="p">.......</span><span class="n">A</span><span class="o">|</span>
<span class="mi">00010080</span>  <span class="mi">41</span> <span class="mi">41</span> <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">03</span> <span class="mi">00</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">18</span> <span class="mi">00</span> <span class="mi">18</span> <span class="mi">42</span> <span class="mi">42</span> <span class="mi">42</span>  <span class="o">|</span><span class="n">AA</span><span class="p">...........</span><span class="n">BBB</span><span class="o">|</span>
<span class="mi">00010090</span>  <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">02</span> <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">20</span>  <span class="mi">00</span> <span class="mi">19</span> <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">03</span> <span class="mi">03</span> <span class="mi">00</span>  <span class="o">|</span><span class="p">.......</span> <span class="p">........</span><span class="o">|</span>
<span class="mi">000100</span><span class="n">a0</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">28</span> <span class="mi">00</span> <span class="mi">19</span> <span class="mi">44</span> <span class="mi">44</span> <span class="mi">44</span>  <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">04</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="o">|</span><span class="p">..(..</span><span class="n">DDD</span><span class="p">........</span><span class="o">|</span>
<span class="mi">000100</span><span class="n">b0</span>  <span class="mi">30</span> <span class="n">ff</span> <span class="n">cc</span> <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">05</span> <span class="mi">03</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">38</span> <span class="n">ff</span> <span class="n">b2</span> <span class="mi">46</span> <span class="mi">46</span>  <span class="o">|</span><span class="mi">0</span><span class="p">..........</span><span class="mi">8</span><span class="p">..</span><span class="n">FF</span><span class="o">|</span>
<span class="mi">000100</span><span class="n">c0</span>  <span class="mi">46</span> <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">06</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="o">|</span><span class="n">F</span><span class="p">...............</span><span class="o">|</span>
<span class="mi">000100</span><span class="n">d0</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="o">|</span><span class="p">................</span><span class="o">|</span>
</code></pre></div></div>

<p>索引数据从00010078的位置开始， 逐行进行分析即可:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span>  <span class="cm">/* 当前索引字段的长度 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">0</span><span class="n">e</span> <span class="cm">/* 不知道是啥 */</span>
<span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span>   <span class="cm">/* 索引值 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 指向的主键id */</span>
</code></pre></div></div>

<p>第2行与第1行基本类似， 现在来看看比较特殊的第3行与第5行。 第3行索引数据内容:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">01</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">20</span> <span class="mi">00</span> <span class="mi">19</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">03</span>  <span class="cm">/* 指向的主键id */</span>
</code></pre></div></div>

<p>当索引的内容为NULL值时， 辅助索引的文件格式也变得奇怪了起来， 和第一行完全不一样， 再来看看第5行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00</span>  <span class="cm">/* 当前索引字段的长度 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">30</span> <span class="n">ff</span> <span class="n">cc</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">05</span>  <span class="cm">/* 指向的主键id */</span>
</code></pre></div></div>

<p>和正常索引内容基本类似， 空字符串仍然没有表示， 仅使用了00表示该字段长度为0。</p>

<h4 id="4-辅助索引叶子节点存储方式">4. 辅助索引叶子节点存储方式</h4>
<p>在MySQL中， 数据管理的最小单元为页(page)， 而并非一行一行的数据。 数据保存在页中， 当我们使用主键查找一行数据时， 其实MySQL并不能直接返回这一行数据， 而是将该行所在的页载入内存， 然后在内存页中进行查找。</p>

<p>通常情况下页大小为16K， 在某些情况下可能会对页进行压缩， 使得页大小为8K或者是4K。 由于B+Tree的特点， 使得每一页内最少为2行数据， 再少就将退化成链表， 显然出于效率的考量不会让此种情况出现。 故而一行数据大小至多为16K， 通过该特性， 就可以研究二级索引的叶子节点是什么样子的了。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">two</span> <span class="p">(</span>
    <span class="n">id</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">nickname</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">8000</span><span class="p">),</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="p">(</span><span class="n">nickname</span><span class="p">(</span><span class="mi">2000</span><span class="p">))</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'A'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'C'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">,</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'E'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">'f'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'F'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">'g'</span><span class="p">,</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">'h'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'H'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">'i'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'G'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">'i'</span><span class="p">,</span> <span class="nv">""</span><span class="p">;</span>
</code></pre></div></div>

<p>由于索引长度的限制， 这里仅取nickname的前2000个字符进行索引， 并插入一些具有代表性的数据。 同样使用<code class="highlighter-rouge">hexdump -C two.ibd</code>对索引结构进行分析:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00010070  73 75 70 72 65 6d 75 6d  d0 87 00 05 00 10 07 e6  |supremum........|
00010080  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|
<span class="k">*</span>
00010850  80 00 00 01 01 00 00 18  07 e6 80 00 00 02 d0 87  |................|
00010860  00 00 00 20 07 e6 43 43  43 43 43 43 43 43 43 43  |... ..CCCCCCCCCC|
00010870  43 43 43 43 43 43 43 43  43 43 43 43 43 43 43 43  |CCCCCCCCCCCCCCCC|
<span class="k">*</span>
00011030  43 43 43 43 43 43 80 00  00 03 01 00 00 28 0f c2  |CCCCCC.......<span class="o">(</span>..|
00011040  80 00 00 04 d0 87 00 00  00 30 07 dc 45 45 45 45  |.........0..EEEE|
00011050  45 45 45 45 45 45 45 45  45 45 45 45 45 45 45 45  |EEEEEEEEEEEEEEEE|
<span class="k">*</span>
00011810  45 45 45 45 45 45 45 45  45 45 45 45 80 00 00 05  |EEEEEEEEEEEE....|
00011820  d0 87 00 00 00 38 0f c2  46 46 46 46 46 46 46 46  |.....8..FFFFFFFF|
00011830  46 46 46 46 46 46 46 46  46 46 46 46 46 46 46 46  |FFFFFFFFFFFFFFFF|
<span class="k">*</span>
00011ff0  46 46 46 46 46 46 46 46  80 00 00 06 01 00 00 40  |FFFFFFFF.......@|
00012000  0f c3 80 00 00 07 d0 87  00 00 00 48 e0 62 48 48  |...........H.bHH|
00012010  48 48 48 48 48 48 48 48  48 48 48 48 48 48 48 48  |HHHHHHHHHHHHHHHH|
<span class="k">*</span>
000127d0  48 48 48 48 48 48 48 48  48 48 48 48 48 48 80 00  |HHHHHHHHHHHHHH..|
000127e0  00 08 d0 87 00 00 00 50  f8 24 47 47 47 47 47 47  |.......P.<span class="nv">$GGGGGG</span>|
000127f0  47 47 47 47 47 47 47 47  47 47 47 47 47 47 47 47  |GGGGGGGGGGGGGGGG|
<span class="k">*</span>
00012fb0  47 47 47 47 47 47 47 47  47 47 80 00 00 09 00 00  |GGGGGGGGGG......|
00012fc0  00 00 58 d0 bb 80 00 00  0a 00 00 00 00 00 00 00  |..X.............|
00012fd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</code></pre></div></div>

<p>从上表中可以看到， 索引数据起始点为00010078， 逐行进行分析可以发现， NULL值和空值的表现形式与上一小节分析的基本相同。</p>

<p>NULL值行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">01</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">18</span> <span class="mi">07</span> <span class="n">e6</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">02</span>  <span class="cm">/* 主键id */</span>

<span class="mi">01</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">28</span> <span class="mi">0</span><span class="n">f</span> <span class="n">c2</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">04</span>  <span class="cm">/* 主键id */</span>

<span class="mi">01</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">40</span> <span class="mi">0</span><span class="n">f</span> <span class="n">c3</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">07</span>  <span class="cm">/* 主键id */</span>
</code></pre></div></div>

<p>空字符串行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">58</span> <span class="n">d0</span> <span class="n">bb</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">0</span><span class="n">a</span>  <span class="cm">/* 主键id */</span>
</code></pre></div></div>

<p>所以说， 分析到这里， 我们完全有理由说NULL值要比空值占用更少的物理存储空间， 包含索引存储空间。 但是， 这是在我们所定义表结构时允许字段值为NULL的前提下， 当我们显式的指定IS NOT NULL时， 情况又会不一样。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">three</span> <span class="p">(</span>
    <span class="n">id</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">nickname</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="p">(</span><span class="n">nickname</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"a"</span><span class="p">,</span> <span class="nv">"AAA"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"b"</span><span class="p">,</span> <span class="nv">""</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"c"</span><span class="p">,</span> <span class="nv">"CCC"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"d"</span><span class="p">,</span> <span class="nv">"DDD"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"e"</span><span class="p">,</span> <span class="nv">"EEE"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"f"</span><span class="p">,</span> <span class="nv">""</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"g"</span><span class="p">,</span> <span class="nv">"GGG"</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">hexdump -C three.ibd</code>可得:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000c070  73 75 70 72 65 6d 75 6d  03 01 00 00 10 00 1c 80  |supremum........|
0000c080  00 00 01 00 00 00 08 dd  21 ba 00 00 01 2f 01 10  |........!..../..|
0000c090  61 41 41 41 00 01 00 00  18 00 19 80 00 00 02 00  |aAAA............|
0000c0a0  00 00 08 dd 22 bb 00 00  01 31 01 10 62 03 01 00  |....<span class="s2">"....1..b...|
0000c0b0  00 20 00 1c 80 00 00 03  00 00 00 08 dd 25 bd 00  |. ...........%..|
0000c0c0  00 01 35 01 10 63 43 43  43 03 01 00 00 28 00 1c  |..5..cCCC....(..|
0000c0d0  80 00 00 04 00 00 00 08  dd 28 bf 00 00 01 36 01  |.........(....6.|
0000c0e0  10 64 44 44 44 03 01 00  00 30 00 1c 80 00 00 05  |.dDDD....0......|
0000c0f0  00 00 00 08 dd 29 c0 00  00 01 37 01 10 65 45 45  |.....)....7..eEE|
0000c100  45 00 01 00 00 38 00 19  80 00 00 06 00 00 00 08  |E....8..........|
0000c110  dd 2a a1 00 00 01 12 01  10 66 03 01 00 00 40 ff  |.*.......f....@.|
0000c120  4f 80 00 00 07 00 00 00  08 dd 2b a2 00 00 01 15  |O.........+.....|
0000c130  01 10 67 47 47 47 00 00  00 00 00 00 00 00 00 00  |..gGGG..........|
</span></code></pre></div></div>

<p>数据从c078开始， 同样进行逐行分析:</p>

<p>第一行数据:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span> <span class="mi">01</span>  <span class="cm">/* 逆序可变字符长度列表 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">1</span><span class="k">c</span>  <span class="cm">/* 记录头信息(Record Header), c078+001c=c094 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 主键id */</span>
<span class="c1">-- Transaction ID + Roll Pointer</span>
<span class="mi">61</span>  <span class="cm">/* 列1数据 */</span>
<span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span>  <span class="cm">/* 列2数据 */</span>
</code></pre></div></div>

<p>第二行数据</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 逆序可变字符长度列表 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">18</span> <span class="mi">00</span> <span class="mi">19</span>  <span class="cm">/* 记录头信息(Record Header), c094+0019=c0ad */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">02</span>  <span class="cm">/* 主键id */</span>
<span class="c1">-- Transaction ID + Roll Pointer</span>
<span class="mi">62</span>  <span class="cm">/* 列1数据, 列2数据为空值, 故无记录 */</span>
</code></pre></div></div>

<p>第三行数据:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span> <span class="mi">01</span>  <span class="cm">/* 逆序可变字符长度列表 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">20</span> <span class="mi">00</span> <span class="mi">1</span><span class="k">c</span>  <span class="cm">/* 记录头信息(Record Header), c0ad+001c=c0c9 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">03</span>  <span class="cm">/* 主键id */</span>
<span class="c1">-- Transaction ID + Roll Pointer</span>
<span class="mi">63</span>  <span class="cm">/* 列1数据 */</span>
<span class="mi">43</span> <span class="mi">43</span> <span class="mi">43</span>  <span class="cm">/* 列2数据 */</span>
</code></pre></div></div>

<p>可以看到， 将<strong>所有</strong>的列设置为NOT NULL之后， 存储内容少了一个NULL标识位， 此时该table的存储效率要高于最初的表结构。</p>

<p>所以说， 如果想要真正的节省表空间存储大小， 需要将<strong>所有</strong>的字段都设置为NOT NULL约束， 否则在存储时仍然需要NULL标识位来标记哪一列数据为非NULL， 即使所有的列都有数据。</p>

<p>最后， NULL真的比空字符串占用更少的空间吗? 答案是不一定。 如果在定义表结构时指定了NOT NULL， 那么数据中就不可能出现NULL值， 也就无从比起。 如果在定义表结构时没有指定NOT NULL， 那么NULL将会比空字符串占用更少的空间。</p>

<h4 id="5-总结">5. 总结</h4>
<p>经过对<code class="highlighter-rouge">.ibd</code>文件的分析， 想必对数据以及索引的组织方式有了一个更加清晰的了解， 并且也能够判断出各种各样优化建议到底是否正确了。</p>

<p>使用数字或者是空串来代替NULL值? 没有必要， 有时还会适得其反， 而且对于添加了二级索引的NULL值， 查询仍然会使用索引。 正确的做法就是在定义表结构的时候就将NULL值扼杀在摇篮里， 如此一来能够节省一部分的磁盘空间以及一定程度上的效率提升。</p>

<p>为什么索引不能太多? 因为每添加一个索引， <code class="highlighter-rouge">.ibd</code>文件中就需要多维护一个B+Tree索引树， 如果某一个table中存在10个索引， 那么就需要维护10棵B+Tree， 写入效率会降低， 并且会浪费磁盘空间。</p>

<p>B+Tree中的指针是用什么实现的? 使用文件偏移量实现， 指向下一行或者是下一个索引的起始位置。</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL权限管理</title>
	  <link>//MySQL-Permissions</link>
	  <author></author>
	  <pubDate>2018-10-30T09:49:09+00:00</pubDate>
	  <guid>//MySQL-Permissions</guid>
	  <description><![CDATA[
	     <p><code class="highlighter-rouge">MySQL</code>的权限管理重要性等同于服务器数据的重要性， 权限体系如果建立的不到位的话， 也就意味着生产数据处于危险状态。</p>

<!---more--->

<h4 id="1-ubuntu-1604-下安装mysql">1. Ubuntu 16.04 下安装MySQL</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt-get update
<span class="nb">sudo </span>apt-get upgrade
<span class="nb">sudo </span>apt-get install mysql-server mysql-client
</code></pre></div></div>

<h4 id="2-修改相关的配置文件">2. 修改相关的配置文件</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>vim /etc/mysql/mysql.conf.d/mysqld.cnf

bind-address <span class="o">=</span> 0.0.0.0
max_connections <span class="o">=</span> 3000

<span class="c"># binlog相关配置</span>
server-id <span class="o">=</span> 2
log_bin <span class="o">=</span> /var/log/mysql/mysql-bin.log
expire_logs_days <span class="o">=</span> 10
max_binlog_size <span class="o">=</span> 100M

<span class="c"># 慢查询日志配置</span>
slow_query_log <span class="o">=</span> 1
slow_query_log_file <span class="o">=</span> /var/log/mysql/mysql-slow.log
long_query_time <span class="o">=</span> 2
</code></pre></div></div>
<p>编辑并保存后重启MySQL服务即可。另外需要在系统层面赋予MySQL最大文件描述符的配置：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>vim /lib/systemd/system/mysql.service

<span class="c"># 添加</span>
<span class="nv">LimitNOFILE</span><span class="o">=</span>65535
<span class="nv">LimitNPROC</span><span class="o">=</span>65535
</code></pre></div></div>

<h4 id="3-管理权限体系的建立">3. 管理权限体系的建立</h4>
<p>通常MySQL的权限分级与开发团队的组织形式直接相关， 包括初级工程师(只能select部分database), 中级工程师(能够对数据进行增删改查)， 高级开发工程师(全部权限)， 但是在现代的web开发， 使用ORM框架的条件下， 对应用的账号则必须赋予较高的权限， 那么能够查看代码的开发人员依然能够拿到较高权限。 所以MySQL的权限控制需要和Linux权限控制相结合： 涉及生产服务器MySQL数据库连接代码应只存放于服务器中， 并对其进行高权限控制， 即该文件只能由高级开发工程师进行查看或者修改， 以保证权限的统一。</p>

<h5 id="31-创建用户并赋予权限">3.1 创建用户并赋予权限</h5>
<p>创建用户使用<code class="highlighter-rouge">GRANT</code>命令， 常见参数及说明如下表所示：</p>

<table>
  <thead>
    <tr>
      <th>GRANT</th>
      <th>ALL PRIVILEGES</th>
      <th>ON database.table</th>
      <th>TO user@address</th>
      <th>IDENTIFIED BY ‘password’</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>创建用户命令</td>
      <td>赋予什么权限</td>
      <td>哪个数据库以及哪张表</td>
      <td>用户名和登录地址</td>
      <td>密码</td>
    </tr>
  </tbody>
</table>

<p>创建smart用户， 并赋予其全部数据库的全部权限， 但只能在ip地址为144.35.177.20的机器上进行登录</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">GRANT</span> <span class="k">ALL</span> <span class="k">PRIVILEGES</span> <span class="k">ON</span> <span class="o">*</span><span class="p">.</span><span class="o">*</span> <span class="k">TO</span> <span class="s1">'smart'</span><span class="o">@</span><span class="s1">'144.35.177.20'</span> <span class="n">IDENTIFIED</span> <span class="k">BY</span> <span class="s1">'passwd'</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="n">FLUSH</span> <span class="k">PRIVILEGES</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">mysql</span><span class="p">.</span><span class="k">user</span> <span class="k">where</span> <span class="k">User</span><span class="o">=</span><span class="nv">"smart"</span> <span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
                  <span class="k">Host</span><span class="p">:</span> <span class="mi">144</span><span class="p">.</span><span class="mi">35</span><span class="p">.</span><span class="mi">177</span><span class="p">.</span><span class="mi">20</span>
                  <span class="k">User</span><span class="p">:</span> <span class="n">smart</span>
           <span class="n">Select_priv</span><span class="p">:</span> <span class="n">Y</span>
           <span class="n">Insert_priv</span><span class="p">:</span> <span class="n">Y</span>
           <span class="n">Update_priv</span><span class="p">:</span> <span class="n">Y</span>
           <span class="n">Delete_priv</span><span class="p">:</span> <span class="n">Y</span>
           <span class="n">Create_priv</span><span class="p">:</span> <span class="n">Y</span>
             <span class="n">Drop_priv</span><span class="p">:</span> <span class="n">Y</span>
           <span class="n">Reload_priv</span><span class="p">:</span> <span class="n">Y</span>
         <span class="n">Shutdown_priv</span><span class="p">:</span> <span class="n">Y</span>
          <span class="n">Process_priv</span><span class="p">:</span> <span class="n">Y</span>
          <span class="p">...</span>  <span class="err">中间省略</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div></div>
<p>在赋予<code class="highlighter-rouge">ALL PRIVILEGES</code>之后该用户除了不能创建用户以外， 用于对数据库的所有控制权限。 这样的账号应该只有运维经理以及高级开发才能拥有。</p>

<p>下面来看一下MySQL具体都有哪些权限:</p>

<table>
  <thead>
    <tr>
      <th>维度</th>
      <th>权限</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>数据</td>
      <td>insert, select, update, delete</td>
    </tr>
    <tr>
      <td>表</td>
      <td>create, drop, references, index, alter, lock table, create temporary table</td>
    </tr>
    <tr>
      <td>主从复制</td>
      <td>replication client, replication slave</td>
    </tr>
    <tr>
      <td>服务器</td>
      <td>shutdown, processlist, grant, super, create role</td>
    </tr>
  </tbody>
</table>

<p>该表简单的对权限进行了一个分类， 作用仅是便于记忆而已。 根据<code class="highlighter-rouge">MySQL</code>官方文档所给出的权限以及每种权限的作用， 下面进行详细的整理。</p>

<ul>
  <li>ALTER: 允许更改表结构， 例如添加索引， 删除字段等。 <code class="highlighter-rouge">ALTER TABLE</code>语句需要有CREATE以及INSERT权限。 当我们对一个表进行重命名的时候， 需要有ALTER和DROP以及CREATE， INSERT的权限。</li>
  <li>ALTER ROUTINE: 使用ALTER存储过程的权限。</li>
  <li>CREATE: 创建表的权限。</li>
  <li>CREATE ROLE: 创建角色的权限， 当一个用户拥有了CREATE USER权限时， 该权限随即拥有。</li>
  <li>CREATE ROUTINE: 允许使用CREATE存储过程。</li>
  <li>CREATE TEMPORARY TABLES: 允许使用<code class="highlighter-rouge">CREATE TEMPORARY TABLE</code>语句来创建临时表， 这张临时表的 DROP TABLE， INSERT， UPDATE等权限随之赋予。</li>
  <li>CREATE USER: 能够使用 ALTER USER， CREATE ROLE， CREATE USER， DROP ROLE， DROP USER, RENAME USER， 以及REVOKE ALL PRIVILEGES等语句， 属于管理员权限。</li>
  <li>CREATE VIEW: 允许创建视图。</li>
  <li>DELETE: 允许从表中删除数据。</li>
  <li>DROP: 删除整张表以及数据的权限， TRUNCATE TABLE命令需要有该权限才能够执行。</li>
  <li>DROP ROLE: 允许删除某一个用户， 当用户具有了CREATE USER的权限时， 该权限随之赋予。</li>
  <li>GRANT OPTION: 允许为用户添加权限。</li>
  <li>INDEX: 允许添加和删除索引， 当用于具有CREATE的权限时， 该权限随之赋予。</li>
  <li>INSERT: 向表中插入数据的权限。</li>
  <li>LOCK TABLES: 锁表的权限。</li>
  <li>PROCESS: 允许查询当前数据库所运行的后台线程信息， 例如主从复制线程信息。</li>
  <li>RELOAD: 允许运行flush-xxx相关命令， 包括刷新权限， 日志等， 属于管理员权限。</li>
  <li>REPLICATION CLIENT： 允许使用SHOW MASTER STATUS, SHOW SLAVE STATUS, SHOW BINARY LOGS等语句， 主要用于主从复制。</li>
  <li>REPLICATION SLAVE: 允许更新主库的变化。</li>
  <li>SUPER: 这是一个相当重要的权限， 权限非常大， 并且<code class="highlighter-rouge">MySQL</code>在将来的版本中将会移除这个权限， 的确， 该权限比较危险。 SUPER权限能够在运行时修改系统变量， 该更主从复制相关信息， 以及更重要的， 该权限可以在<code class="highlighter-rouge">MySQL Session</code>中删除binlog日志文件， 即<code class="highlighter-rouge">purge master logs</code>命令。</li>
  <li>UPDATE: 更新表数据的权限。</li>
</ul>

<p>可以看到， 比较危险的权限也就是DROP, CREATE USER， GRANT OPTION， RELOAD以及SUPER权限， 其中最危险的就是SUPER权限， <strong>除了管理员以外， 任何账号均不能有SUPER权限</strong>。</p>

<h6 id="311-创建mysqldump账户并赋予权限">3.1.1 创建mysqldump账户并赋予权限</h6>
<p><code class="highlighter-rouge">mysqldump</code>命令的权限讲实话我并不清楚， 查阅网上相关资料之后进行创建并赋予：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">user</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span> <span class="n">identified</span> <span class="k">by</span> <span class="s1">'passwd'</span><span class="p">;</span>
<span class="k">grant</span> <span class="k">select</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span><span class="p">;</span>
<span class="k">grant</span> <span class="k">show</span> <span class="k">view</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span><span class="p">;</span>
<span class="k">grant</span> <span class="k">lock</span> <span class="n">tables</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span><span class="p">;</span>
<span class="k">grant</span> <span class="k">trigger</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span><span class="p">;</span>
<span class="o">//</span> <span class="err">如果需要在备份时刷新二进制日志，</span> <span class="err">还需要以下权限</span>
<span class="k">grant</span> <span class="n">reload</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span><span class="p">;</span>
<span class="k">grant</span> <span class="n">replication</span> <span class="n">slave</span><span class="p">,</span> <span class="n">replication</span> <span class="n">client</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'dumper'</span><span class="o">@</span><span class="s1">'localhost'</span><span class="p">;</span>
</code></pre></div></div>
<p>那么此时使用该账户进行登录， 进行查看<code class="highlighter-rouge">myProjects</code>库， 其余的增删改操作均不能进行。</p>

<h6 id="312-创建主从复制的账号并赋予权限">3.1.2 创建主从复制的账号并赋予权限</h6>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">grant</span> <span class="n">replication</span> <span class="n">slave</span><span class="p">,</span> <span class="n">replication</span> <span class="n">client</span> <span class="k">on</span> <span class="o">*</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="n">repl</span><span class="o">@</span><span class="s1">'192.168.0.%'</span> <span class="n">dentified</span> <span class="k">by</span> <span class="s1">'passwd'</span><span class="p">;</span>
</code></pre></div></div>
<p>这里使用<code class="highlighter-rouge">%</code>通配符来对该局域网内的所有机器进行权限的赋予。</p>

<h6 id="313-创建项目账号并赋予权限">3.1.3 创建项目账号并赋予权限</h6>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">grant</span> <span class="k">all</span> <span class="k">privileges</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">'shop'</span><span class="o">@</span><span class="s1">'192.168.1.6'</span> <span class="n">identified</span> <span class="k">by</span> <span class="s1">'complex-passwd'</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="32-查看某个用户的权限">3.2 查看某个用户的权限</h4>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">show</span> <span class="n">grants</span> <span class="k">for</span> <span class="s1">'user'</span><span class="o">@</span><span class="s1">'address'</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="33-回收用户权限以及删除用户">3.3 回收用户权限以及删除用户</h4>
<p>回收用户所有权限</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">revoke</span> <span class="k">all</span> <span class="k">on</span> <span class="o">*</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="s1">'user'</span><span class="o">@</span><span class="s1">'address'</span><span class="p">;</span>
</code></pre></div></div>
<p>回收用户部分权限</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">revoke</span> <span class="k">drop</span> <span class="k">on</span> <span class="n">myProjects</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="s1">'user'</span><span class="o">@</span><span class="s1">'address'</span><span class="p">;</span>
</code></pre></div></div>
<p>删除用户</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">drop</span> <span class="k">user</span> <span class="s1">'user'</span><span class="o">@</span><span class="s1">'address'</span><span class="p">;</span>
</code></pre></div></div>

<p>修改某个用户的密码</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">update</span> <span class="n">mysql</span><span class="p">.</span><span class="k">user</span> <span class="k">set</span> <span class="n">authentication_string</span><span class="o">=</span><span class="n">password</span><span class="p">(</span><span class="nv">"passwd"</span><span class="p">)</span> <span class="k">where</span> <span class="k">user</span><span class="o">=</span><span class="nv">"user"</span><span class="p">;</span>
</code></pre></div></div>

<p>在执行完上面儿的语句之后， 尽量的执行<code class="highlighter-rouge">flush privileges;</code>命令刷新一下权限。</p>

<h4 id="4-关于权限管理的一些杂谈">4. 关于权限管理的一些杂谈</h4>
<p>MySQL并没有提供不给用户授予什么权限的命令， 也就是没有<code class="highlighter-rouge">exclude</code>这种语法， 但是我们可以先给用户授予全部的权限， 然后将不必要的权限进行回收。 像<code class="highlighter-rouge">drop</code>这种很危险的权限就不要随便给， 如果库里面儿只有逻辑删除的话， <code class="highlighter-rouge">delete</code>权限都可以不给， 有需要的时候让管理员进行协助处理。 尽可能的用最小权限做更安全的事情， 毕竟使用<code class="highlighter-rouge">binlog</code>进行数据恢复也不可能保证100%成功， 将危险扼杀在摇篮里才是正解。</p>

<p>权限管理对于管理员来讲确实是比较麻烦的一件事情， 很多团队<code class="highlighter-rouge">root</code>账号满天跑， 包括笔者在内的团队在初期也是这样的。 在付出了血淋淋的代价之后才开始对权限进行管理， 亡羊补牢为时尚晚， 埋过的雷总会炸的。</p>


	  ]]></description>
	</item>

	<item>
	  <title>MySQL慢查询日志分析工具</title>
	  <link>//MySQL-slow-query-analysis-tool</link>
	  <author></author>
	  <pubDate>2018-10-25T09:49:09+00:00</pubDate>
	  <guid>//MySQL-slow-query-analysis-tool</guid>
	  <description><![CDATA[
	     <p>慢查询日志使我们对MySQL进行性能优化的关键指标， 只有在确定了哪些查询的确是慢查询之后才能对症下药， 进行性能优化， 而不是凭自身的感觉去判断， 结果有事往往出乎意料。 直接打开慢查询日志进行查看效率比较低效， 所以需要借助<code class="highlighter-rouge">pt-query-digest</code>工具来进行分析。</p>

<!---more--->

<h4 id="0-degine-mysql-version-57">0. Degine: MySQL Version: 5.7</h4>

<h4 id="1-percona-toolkit工具包的下载与安装">1. Percona Toolkit工具包的下载与安装</h4>
<p><code class="highlighter-rouge">Percona Toolkit</code>工具包包含了<code class="highlighter-rouge">pt-slave-delay</code>， <code class="highlighter-rouge">pt-query-digest</code>， <code class="highlighter-rouge">pt-mysql-summary</code>等非常有用的工具。</p>
<blockquote>
  <p>https://www.percona.com/downloads/percona-toolkit/LATEST/</p>
</blockquote>

<p>找对对应的版本以及平台进行安装即可。</p>

<h4 id="2-pt-query-digest的基本使用">2. pt-query-digest的基本使用</h4>
<p>首先来看一下分析的基本结果：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pt-query-digest <span class="nt">--report</span> mysql-slow.log
</code></pre></div></div>
<p>核心输出结果如下：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">Current</span> <span class="n">date</span><span class="p">:</span> <span class="n">Tue</span> <span class="n">Oct</span> <span class="mi">16</span> <span class="mi">11</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mi">55</span> <span class="mi">2018</span>
<span class="o">#</span> <span class="n">Hostname</span><span class="p">:</span> <span class="n">Zero</span>
<span class="o">#</span> <span class="n">Files</span><span class="p">:</span> <span class="n">mysql</span><span class="o">-</span><span class="n">slow</span><span class="p">.</span><span class="n">log</span>
<span class="o">#</span> <span class="n">Overall</span><span class="p">:</span> <span class="mi">7</span><span class="p">.</span><span class="mi">77</span><span class="n">k</span> <span class="n">total</span><span class="p">,</span> <span class="mi">94</span> <span class="k">unique</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">QPS</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">02</span><span class="n">x</span> <span class="n">concurrency</span> <span class="n">___________</span>
<span class="o">#</span> <span class="n">Time</span> <span class="n">range</span><span class="p">:</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">18</span> <span class="mi">14</span><span class="p">:</span><span class="mi">11</span><span class="p">:</span><span class="mi">31</span> <span class="k">to</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">16</span> <span class="mi">10</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">13</span>
<span class="o">#</span> <span class="n">Attribute</span>          <span class="n">total</span>     <span class="k">min</span>     <span class="k">max</span>     <span class="k">avg</span>     <span class="mi">95</span><span class="o">%</span>  <span class="n">stddev</span>  <span class="n">median</span>
<span class="o">#</span> <span class="o">============</span>     <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span>
<span class="o">#</span> <span class="k">Exec</span> <span class="n">time</span>         <span class="mi">77201</span><span class="n">s</span>   <span class="mi">500</span><span class="n">ms</span>    <span class="mi">166</span><span class="n">s</span>     <span class="mi">10</span><span class="n">s</span>     <span class="mi">37</span><span class="n">s</span>     <span class="mi">15</span><span class="n">s</span>      <span class="mi">4</span><span class="n">s</span>
<span class="o">#</span> <span class="k">Lock</span> <span class="n">time</span>           <span class="mi">203</span><span class="n">s</span>       <span class="mi">0</span>     <span class="mi">22</span><span class="n">s</span>    <span class="mi">26</span><span class="n">ms</span>   <span class="mi">138</span><span class="n">us</span>   <span class="mi">500</span><span class="n">ms</span>    <span class="mi">73</span><span class="n">us</span>
<span class="o">#</span> <span class="k">Rows</span> <span class="n">sent</span>          <span class="mi">2</span><span class="p">.</span><span class="mi">46</span><span class="n">M</span>       <span class="mi">0</span>  <span class="mi">78</span><span class="p">.</span><span class="mi">34</span><span class="n">k</span>  <span class="mi">331</span><span class="p">.</span><span class="mi">51</span>  <span class="mi">511</span><span class="p">.</span><span class="mi">45</span>   <span class="mi">4</span><span class="p">.</span><span class="mi">37</span><span class="n">k</span>    <span class="mi">0</span><span class="p">.</span><span class="mi">99</span>
<span class="o">#</span> <span class="k">Rows</span> <span class="n">examine</span>      <span class="mi">63</span><span class="p">.</span><span class="mi">82</span><span class="k">G</span>       <span class="mi">0</span>  <span class="mi">52</span><span class="p">.</span><span class="mi">93</span><span class="n">M</span>   <span class="mi">8</span><span class="p">.</span><span class="mi">41</span><span class="n">M</span>  <span class="mi">28</span><span class="p">.</span><span class="mi">56</span><span class="n">M</span>  <span class="mi">11</span><span class="p">.</span><span class="mi">25</span><span class="n">M</span>   <span class="mi">3</span><span class="p">.</span><span class="mi">68</span><span class="n">M</span>
<span class="o">#</span> <span class="n">Query</span> <span class="k">size</span>         <span class="mi">5</span><span class="p">.</span><span class="mi">06</span><span class="n">M</span>       <span class="mi">6</span>  <span class="mi">16</span><span class="p">.</span><span class="mi">48</span><span class="n">k</span>  <span class="mi">682</span><span class="p">.</span><span class="mi">18</span>   <span class="mi">2</span><span class="p">.</span><span class="mi">06</span><span class="n">k</span>  <span class="mi">724</span><span class="p">.</span><span class="mi">05</span>  <span class="mi">420</span><span class="p">.</span><span class="mi">77</span>
</code></pre></div></div>
<p>可以看到结果还是比较直观的， 包括执行时间， 加锁时间等， 横坐标中最有价值的信息为<code class="highlighter-rouge">95%</code>， 意义为将查询从小到大排列， 取位于整个排列的95%位置， 这样以来就会滤掉较大的值， 减少极值对统计的影响。 可以看到上面的输出<code class="highlighter-rouge">Exec time - 95% </code>输出结果为37s， 数值比较大， 所以完全有必要进行慢查询的优化。</p>

<p>继续来看输出：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">Profile</span>
<span class="o">#</span> <span class="n">Rank</span> <span class="n">Query</span> <span class="n">ID</span>                      <span class="n">Response</span> <span class="n">time</span>    <span class="n">Calls</span> <span class="n">R</span><span class="o">/</span><span class="k">Call</span>  <span class="n">V</span><span class="o">/</span><span class="n">M</span>
<span class="o">#</span> <span class="o">====</span> <span class="o">=============================</span> <span class="o">================</span> <span class="o">=====</span> <span class="o">=======</span> <span class="o">=====</span>
<span class="o">#</span>    <span class="mi">1</span> <span class="mi">0</span><span class="n">x530A2CE72ED76F6FD03452E6</span><span class="p">...</span> <span class="mi">20003</span><span class="p">.</span><span class="mi">2369</span> <span class="mi">25</span><span class="p">.</span><span class="mi">9</span><span class="o">%</span>   <span class="mi">478</span> <span class="mi">41</span><span class="p">.</span><span class="mi">8478</span> <span class="mi">17</span><span class="p">.</span><span class="mi">77</span> <span class="k">SELECT</span> <span class="n">lv_pt_order</span> <span class="n">lv_pt_order_detail</span> <span class="n">lv_pt_goods</span> <span class="n">lv_user</span>
<span class="o">#</span>    <span class="mi">2</span> <span class="mi">0</span><span class="n">x1B1C071EBB0DECB4FCB8B4C9</span><span class="p">...</span> <span class="mi">19870</span><span class="p">.</span><span class="mi">1927</span> <span class="mi">25</span><span class="p">.</span><span class="mi">7</span><span class="o">%</span>   <span class="mi">855</span> <span class="mi">23</span><span class="p">.</span><span class="mi">2400</span>  <span class="mi">6</span><span class="p">.</span><span class="mi">26</span> <span class="k">SELECT</span> <span class="n">lv_pt_order</span> <span class="n">lv_pt_order_detail</span> <span class="n">lv_pt_goods</span> <span class="n">lv_user</span>
<span class="o">#</span>    <span class="mi">3</span> <span class="mi">0</span><span class="n">x84CAC95FCB28351DEB798161</span><span class="p">...</span>  <span class="mi">9187</span><span class="p">.</span><span class="mi">0368</span> <span class="mi">11</span><span class="p">.</span><span class="mi">9</span><span class="o">%</span>   <span class="mi">727</span> <span class="mi">12</span><span class="p">.</span><span class="mi">6369</span>  <span class="mi">8</span><span class="p">.</span><span class="mi">70</span> <span class="k">SELECT</span> <span class="n">lv_pt_order</span> <span class="n">lv_pt_order_detail</span> <span class="n">lv_pt_goods</span> <span class="n">lv_user</span>
<span class="o">#</span>    <span class="mi">4</span> <span class="mi">0</span><span class="n">x32D67A543AD02B4178806916</span><span class="p">...</span>  <span class="mi">6330</span><span class="p">.</span><span class="mi">5023</span>  <span class="mi">8</span><span class="p">.</span><span class="mi">2</span><span class="o">%</span>  <span class="mi">1545</span>  <span class="mi">4</span><span class="p">.</span><span class="mi">0974</span>  <span class="mi">5</span><span class="p">.</span><span class="mi">78</span> <span class="k">UPDATE</span> <span class="n">lv_session</span>
</code></pre></div></div>
<p>其中<code class="highlighter-rouge">Query ID</code>是每一个查询的哈希值指纹， <code class="highlighter-rouge">Response time</code>包括所有查询的返回时间以及占比， <code class="highlighter-rouge">Calls</code>为查询的次数， <code class="highlighter-rouge">R/Call</code>为该查询的平均时间， <code class="highlighter-rouge">V/M</code>为方差均值比， 表示该查询的返回时间波动性， 该值越大越有优化的价值。</p>

<p>再往下面就是对<code class="highlighter-rouge">Profile</code>中的每一条进行的详细分析。</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">Query</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">QPS</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">01</span><span class="n">x</span> <span class="n">concurrency</span><span class="p">,</span> <span class="n">ID</span> <span class="mi">0</span><span class="n">x530A2CE72ED76F6FD03452E68015715F</span> <span class="k">at</span> <span class="n">byte</span> <span class="mi">6465751</span>
<span class="o">#</span> <span class="n">This</span> <span class="n">item</span> <span class="k">is</span> <span class="n">included</span> <span class="k">in</span> <span class="n">the</span> <span class="n">report</span> <span class="n">because</span> <span class="n">it</span> <span class="n">matches</span> <span class="c1">--limit.</span>
<span class="o">#</span> <span class="n">Scores</span><span class="p">:</span> <span class="n">V</span><span class="o">/</span><span class="n">M</span> <span class="o">=</span> <span class="mi">17</span><span class="p">.</span><span class="mi">77</span>
<span class="o">#</span> <span class="n">Time</span> <span class="n">range</span><span class="p">:</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">09</span><span class="o">-</span><span class="mi">20</span> <span class="mi">18</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">33</span> <span class="k">to</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">13</span> <span class="mi">00</span><span class="p">:</span><span class="mi">03</span><span class="p">:</span><span class="mi">20</span>
<span class="o">#</span> <span class="n">Attribute</span>    <span class="n">pct</span>   <span class="n">total</span>     <span class="k">min</span>     <span class="k">max</span>     <span class="k">avg</span>     <span class="mi">95</span><span class="o">%</span>  <span class="n">stddev</span>  <span class="n">median</span>
<span class="o">#</span> <span class="o">============</span> <span class="o">===</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span> <span class="o">=======</span>
<span class="o">#</span> <span class="k">Count</span>          <span class="mi">6</span>     <span class="mi">478</span>
<span class="o">#</span> <span class="k">Exec</span> <span class="n">time</span>     <span class="mi">25</span>  <span class="mi">20003</span><span class="n">s</span>     <span class="mi">12</span><span class="n">s</span>    <span class="mi">166</span><span class="n">s</span>     <span class="mi">42</span><span class="n">s</span>     <span class="mi">97</span><span class="n">s</span>     <span class="mi">27</span><span class="n">s</span>     <span class="mi">32</span><span class="n">s</span>
<span class="o">#</span> <span class="k">Lock</span> <span class="n">time</span>      <span class="mi">0</span>    <span class="mi">86</span><span class="n">ms</span>    <span class="mi">58</span><span class="n">us</span>    <span class="mi">23</span><span class="n">ms</span>   <span class="mi">179</span><span class="n">us</span>   <span class="mi">144</span><span class="n">us</span>     <span class="mi">1</span><span class="n">ms</span>   <span class="mi">108</span><span class="n">us</span>
<span class="o">#</span> <span class="k">Rows</span> <span class="n">sent</span>      <span class="mi">0</span>   <span class="mi">8</span><span class="p">.</span><span class="mi">98</span><span class="n">k</span>      <span class="mi">10</span>      <span class="mi">20</span>   <span class="mi">19</span><span class="p">.</span><span class="mi">25</span>   <span class="mi">19</span><span class="p">.</span><span class="mi">46</span>    <span class="mi">2</span><span class="p">.</span><span class="mi">54</span>   <span class="mi">19</span><span class="p">.</span><span class="mi">46</span>
<span class="o">#</span> <span class="k">Rows</span> <span class="n">examine</span>  <span class="mi">24</span>  <span class="mi">15</span><span class="p">.</span><span class="mi">74</span><span class="k">G</span>  <span class="mi">24</span><span class="p">.</span><span class="mi">48</span><span class="n">M</span>  <span class="mi">52</span><span class="p">.</span><span class="mi">93</span><span class="n">M</span>  <span class="mi">33</span><span class="p">.</span><span class="mi">71</span><span class="n">M</span>  <span class="mi">51</span><span class="p">.</span><span class="mi">29</span><span class="n">M</span>  <span class="mi">10</span><span class="p">.</span><span class="mi">49</span><span class="n">M</span>  <span class="mi">27</span><span class="p">.</span><span class="mi">20</span><span class="n">M</span>
<span class="o">#</span> <span class="n">Query</span> <span class="k">size</span>     <span class="mi">3</span> <span class="mi">183</span><span class="p">.</span><span class="mi">98</span><span class="n">k</span>     <span class="mi">393</span>     <span class="mi">404</span>  <span class="mi">394</span><span class="p">.</span><span class="mi">14</span>  <span class="mi">400</span><span class="p">.</span><span class="mi">73</span>    <span class="mi">5</span><span class="p">.</span><span class="mi">50</span>  <span class="mi">381</span><span class="p">.</span><span class="mi">65</span>
<span class="o">#</span> <span class="n">String</span><span class="p">:</span>
<span class="o">#</span> <span class="n">Databases</span>    <span class="n">we8</span>
<span class="o">#</span> <span class="n">Hosts</span>
<span class="o">#</span> <span class="n">Users</span>        <span class="n">root</span>
<span class="o">#</span> <span class="n">Query_time</span> <span class="n">distribution</span>
<span class="o">#</span>   <span class="mi">1</span><span class="n">us</span>
<span class="o">#</span>  <span class="mi">10</span><span class="n">us</span>
<span class="o">#</span> <span class="mi">100</span><span class="n">us</span>
<span class="o">#</span>   <span class="mi">1</span><span class="n">mss</span>
<span class="o">#</span>  <span class="mi">10</span><span class="n">ms</span>
<span class="o">#</span> <span class="mi">100</span><span class="n">ms</span>
<span class="o">#</span>    <span class="mi">1</span><span class="n">s</span>
<span class="o">#</span>  <span class="mi">10</span><span class="n">s</span><span class="o">+</span>  <span class="o">################################################################</span>
<span class="o">#</span> <span class="n">Tables</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">TABLE</span> <span class="n">STATUS</span> <span class="k">FROM</span> <span class="nv">`we8`</span> <span class="k">LIKE</span> <span class="s1">'lv_pt_order'</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`we8`</span><span class="p">.</span><span class="nv">`lv_pt_order`</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">TABLE</span> <span class="n">STATUS</span> <span class="k">FROM</span> <span class="nv">`we8`</span> <span class="k">LIKE</span> <span class="s1">'lv_pt_order_detail'</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`we8`</span><span class="p">.</span><span class="nv">`lv_pt_order_detail`</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">TABLE</span> <span class="n">STATUS</span> <span class="k">FROM</span> <span class="nv">`we8`</span> <span class="k">LIKE</span> <span class="s1">'lv_pt_goods'</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`we8`</span><span class="p">.</span><span class="nv">`lv_pt_goods`</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">TABLE</span> <span class="n">STATUS</span> <span class="k">FROM</span> <span class="nv">`we8`</span> <span class="k">LIKE</span> <span class="s1">'lv_user'</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span>    <span class="k">SHOW</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`we8`</span><span class="p">.</span><span class="nv">`lv_user`</span><span class="err">\</span><span class="k">G</span>
<span class="o">#</span> <span class="k">EXPLAIN</span> <span class="cm">/*!50100 PARTITIONS*/</span>
<span class="k">SELECT</span> <span class="nv">`o`</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="nv">`od`</span><span class="p">.</span><span class="nv">`attr`</span><span class="p">,</span> <span class="nv">`od`</span><span class="p">.</span><span class="nv">`num`</span><span class="p">,</span> <span class="nv">`od`</span><span class="p">.</span><span class="nv">`pic`</span><span class="p">,</span> <span class="nv">`od`</span><span class="p">.</span><span class="nv">`goods_name`</span><span class="p">,</span> <span class="nv">`g`</span><span class="p">.</span><span class="nv">`name`</span> <span class="k">AS</span> <span class="nv">`goods_name`</span><span class="p">,</span> <span class="nv">`u`</span><span class="p">.</span><span class="nv">`nickname`</span> <span class="k">FROM</span> <span class="nv">`lv_pt_order`</span> <span class="nv">`o`</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="nv">`lv_pt_order_detail`</span> <span class="nv">`od`</span> <span class="k">ON</span> <span class="n">od</span><span class="p">.</span><span class="n">order_id</span><span class="o">=</span><span class="n">o</span><span class="p">.</span><span class="n">id</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="nv">`lv_pt_goods`</span> <span class="nv">`g`</span> <span class="k">ON</span> <span class="k">g</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">od</span><span class="p">.</span><span class="n">goods_id</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="nv">`lv_user`</span> <span class="nv">`u`</span> <span class="k">ON</span> <span class="n">u</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">o</span><span class="p">.</span><span class="n">user_id</span> <span class="k">WHERE</span> <span class="p">((</span><span class="nv">`o`</span><span class="p">.</span><span class="nv">`is_delete`</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">AND</span> <span class="p">(</span><span class="nv">`o`</span><span class="p">.</span><span class="nv">`store_id`</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span> <span class="k">AND</span> <span class="p">(</span><span class="nv">`o`</span><span class="p">.</span><span class="nv">`is_cancel`</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="nv">`o`</span><span class="p">.</span><span class="nv">`addtime`</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">20</span><span class="err">\</span><span class="k">G</span>
</code></pre></div></div>
<p>可以看到这条详细分析对应着<code class="highlighter-rouge">Profile</code>中的<code class="highlighter-rouge">Rank 1</code>, 其中<code class="highlighter-rouge">pct</code>即percentage， 表示该查询在该文件中的占比， 其余的基本大同小异。
在表格下方有一个直方图， 表示该查询的时间分布情况， 再往下就是实际的慢查询语句。
可以很直观的看到这条SQL语句的平均执行时间为42s， 最大查询时间166s,  总计执行了478次， 也算是颠覆了我对慢查询时间的认知， 我以为2s的查询就已经很糟糕了， 没想到这里竟然有100+s。</p>

<h4 id="3-pt-query-digest筛选参数">3. pt-query-digest筛选参数</h4>
<p>上面儿的内容基本上就是<code class="highlighter-rouge">pt-query-digest</code>所能够产生的结果， 另外可以添加一些参数来进行筛选。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 给出最近1个小时的慢查询分析结果</span>
pt-query-digest <span class="nt">--report</span> <span class="nt">--since</span> 3600s mysql-slow.log

<span class="c"># 给出一个时间区间的慢查询分析结果</span>
pt-query-digest <span class="nt">--report</span> <span class="nt">--since</span> <span class="s1">'2018-09-20 18:23:33'</span> <span class="nt">--until</span> <span class="s1">'2018-10-13 00:03:20'</span> mysql-slow.log

<span class="c"># 给出某个用户的所有慢查询， 在设计应用时， 前台和后台可以使用不同的MySQL账户</span>
pt-query-digest <span class="nt">--filter</span> <span class="s1">'($event-&gt;{user} || "") =~ m/^root/i'</span> mysql-slow.log
</code></pre></div></div>

<p>更多的内容请见官网。</p>

<blockquote>
  <p>https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html#</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>binlog的正确打开方式</title>
	  <link>//MySQL-binlog</link>
	  <author></author>
	  <pubDate>2018-10-23T10:18:00+00:00</pubDate>
	  <guid>//MySQL-binlog</guid>
	  <description><![CDATA[
	     <p>在前面的主从复制中我们提到了bin-log， 主从复制中bing-log主要作为一种增量复制的方法进行主库与从库的同步。 在日常生产中， bin-log常常也作为实时数据恢复的必要手段。</p>

<!---more--->

<h4 id="1-配置binlog">1. 配置binlog</h4>

<p>binlog二进制日志的格式有<code class="highlighter-rouge">statement</code>, <code class="highlighter-rouge">row</code>以及<code class="highlighter-rouge">mixed</code>。 其中<code class="highlighter-rouge">statement</code>格式只会记录增删改以及对表结构变动的SQL语句， 即<code class="highlighter-rouge">update xx set xxx</code>， 不会保存数据改动前的信息， 磁盘占用空间少。 <code class="highlighter-rouge">row</code>格式将会记录完整的数据改动前后信息， 对数据的修改更加直观， 但占用磁盘空间更多。 <code class="highlighter-rouge">mixed</code>为<code class="highlighter-rouge">statement</code>模式和<code class="highlighter-rouge">row</code>模式的混合， 当出现了对表结构的修改(修改， 删除字段)， 为了避免日志中记录海量的信息， 此时MySQL会采用<code class="highlighter-rouge">statement</code>模式记录<code class="highlighter-rouge">alter table</code>， 对于对数据的增删改记录每一行的信息变动。
具体的日志格式参考博文MySQL主从复制。
通常来讲二进制日志的打开比较的简单， ubuntu 18.04下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/mysql/mysql.conf.d/mysqld.cnf

server-id <span class="o">=</span> 2                           <span class="c"># 保持server-id在MySQL集群中的唯一性</span>
log_bin <span class="o">=</span> /var/log/mysql/mysql-bin.log  <span class="c"># 记录binlog的文件位置</span>
expire_logs_days <span class="o">=</span> 10                   <span class="c"># binlog日志过期时间</span>
max_binlog_size <span class="o">=</span> 100M                  <span class="c"># 单个binlog允许的最大文件值</span>
</code></pre></div></div>

<p>配置完成需要对MySQL进行重启。</p>

<h4 id="2-选择哪一种日志格式">2. 选择哪一种日志格式</h4>

<p>前面已经描述了3种日志格式， 在MySQL 5.7 版本中默认为<code class="highlighter-rouge">Row</code>格式。 <code class="highlighter-rouge">statement</code>格式在日志恢复以及主从复制中会出现较多的问题， 所以该格式不予考虑。 <code class="highlighter-rouge">Row</code>格式和<code class="highlighter-rouge">Mixed</code>格式基本能够满足我们的要求， 可以选择其中的一个。
此外， 在<code class="highlighter-rouge">Row</code>模式下还有3个可选的日志格式： <code class="highlighter-rouge">FULL</code>, <code class="highlighter-rouge">MINIMAL</code>, <code class="highlighter-rouge">NOBLOB</code>。 其中<code class="highlighter-rouge">FULL</code>格式将会记录所有的数据上下文， <code class="highlighter-rouge">MINIMAL</code>只会记录被修改的字段， <code class="highlighter-rouge">NOBLOB</code>在<code class="highlighter-rouge">text</code>字段下记录部分上下文， 其余为完整上下文。
当我们有足够的带宽以及磁盘空间， 并且能够保证主从复制之间的网络连接是稳定的情况下， 尽量使用<code class="highlighter-rouge">FULL</code>模式， 更多的信息会带来更好的恢复以及查看。 当主库的更新频率以及数量较大时， 选择<code class="highlighter-rouge">MINIMAL</code>以保证主从复制的低延迟性。</p>

<h4 id="3-常用的查看相关配置的命令">3. 常用的查看相关配置的命令</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 给出完整的binlog配置信息， 但是没有日志记录的路径以及二进制日志是否开启的信息</span>
<span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="nv">"%binlog%"</span><span class="p">;</span>

<span class="c1">-- 给出binlog是否开启以及binlog所在磁盘位置信息</span>
<span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="nv">"%log_bin%"</span><span class="p">;</span>

<span class="c1">-- 给出当前binlog写入文件名以及当前binlog的偏移量</span>
<span class="k">show</span> <span class="n">master</span> <span class="n">status</span><span class="p">;</span>

<span class="c1">-- 给出所有的binlog所记录的偏移量</span>
<span class="k">show</span> <span class="n">master</span> <span class="n">logs</span><span class="p">;</span>

<span class="c1">-- 在shell中对binlog进行解析， -vv参数针对于Row格式的binlog</span>
<span class="n">sudo</span> <span class="n">mysqlbinlog</span> <span class="o">-</span><span class="n">vv</span> <span class="n">mysql</span><span class="o">-</span><span class="n">bin</span><span class="p">.</span><span class="mi">000005</span>
</code></pre></div></div>

<h4 id="4-错误的binlog数据恢复">4. 错误的binlog数据恢复</h4>

<p>binlog并没有我们想象中的那么复杂， 但是也没有那么容易。 如果在某个时间点数据遭到损坏， 然后使用：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>myslbinlog <span class="nt">-vv</span> <span class="nv">start_positon</span><span class="o">=</span>153 <span class="nv">end_position</span><span class="o">=</span>724 <span class="nt">--database</span><span class="o">=</span>temp | mysql <span class="nt">-uroot</span> <span class="nt">-p</span> temp
</code></pre></div></div>

<p>这种方式进行恢复的话， 99%的情况下都会失败。 binlog恢复的原理与主从复制完全相同， 将一定时间区间内的SQL语句重新执行(statement)或者直接进行数据库修改(row)， 假如我们的binlog如下方所示：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">###</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="nv">`repl_test`</span><span class="p">.</span><span class="nv">`new_table`</span>
<span class="o">###</span> <span class="k">SET</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">1</span><span class="o">=</span><span class="mi">6</span> <span class="cm">/* INT meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">2</span><span class="o">=</span><span class="s1">'haha'</span> <span class="cm">/* VARSTRING(45) meta=45 nullable=1 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">3</span><span class="o">=</span><span class="s1">'29'</span> <span class="cm">/* VARSTRING(180) meta=180 nullable=1 is_null=0 */</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">2761</span>

<span class="o">###</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="nv">`repl_test`</span><span class="p">.</span><span class="nv">`student`</span>
<span class="o">###</span> <span class="k">SET</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">1</span><span class="o">=</span><span class="mi">3</span> <span class="cm">/* INT meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">2</span><span class="o">=</span><span class="s1">'Ray'</span> <span class="cm">/* VARSTRING(45) meta=45 nullable=1 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">3</span><span class="o">=</span><span class="s1">'women'</span> <span class="cm">/* VARSTRING(135) meta=135 nullable=1 is_null=0 */</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">3036</span>

<span class="o">###</span> <span class="k">UPDATE</span> <span class="nv">`repl_test`</span><span class="p">.</span><span class="nv">`new_table`</span>
<span class="o">###</span> <span class="k">WHERE</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">1</span><span class="o">=</span><span class="mi">6</span> <span class="cm">/* INT meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">2</span><span class="o">=</span><span class="s1">'haha'</span> <span class="cm">/* VARSTRING(45) meta=45 nullable=1 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">3</span><span class="o">=</span><span class="s1">'29'</span> <span class="cm">/* VARSTRING(180) meta=180 nullable=1 is_null=0 */</span>
<span class="o">###</span> <span class="k">SET</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">1</span><span class="o">=</span><span class="mi">6</span> <span class="cm">/* INT meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">2</span><span class="o">=</span><span class="s1">'haha'</span> <span class="cm">/* VARSTRING(45) meta=45 nullable=1 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">3</span><span class="o">=</span><span class="s1">'27'</span> <span class="cm">/* VARSTRING(180) meta=180 nullable=1 is_null=0 */</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">3325</span>

<span class="o">###</span> <span class="k">DELETE</span> <span class="k">FROM</span> <span class="nv">`repl_test`</span><span class="p">.</span><span class="nv">`new_table`</span>
<span class="o">###</span> <span class="k">WHERE</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">1</span><span class="o">=</span><span class="mi">5</span> <span class="cm">/* INT meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">2</span><span class="o">=</span><span class="s1">'biubiu'</span> <span class="cm">/* VARSTRING(45) meta=45 nullable=1 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">3</span><span class="o">=</span><span class="s1">'24'</span> <span class="cm">/* VARSTRING(180) meta=180 nullable=1 is_null=0 */</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">3602</span>

<span class="o">###</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="nv">`repl_test`</span><span class="p">.</span><span class="nv">`new_table`</span>
<span class="o">###</span> <span class="k">SET</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">1</span><span class="o">=</span><span class="mi">7</span> <span class="cm">/* INT meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">2</span><span class="o">=</span><span class="s1">'cherry'</span> <span class="cm">/* VARSTRING(45) meta=45 nullable=1 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">3</span><span class="o">=</span><span class="s1">'0'</span> <span class="cm">/* VARSTRING(180) meta=180 nullable=1 is_null=0 */</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">3878</span>
</code></pre></div></div>

<p>有一些长， 但是其实内部的结构是很简单的， 基本上就是：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>new_table表插入数据 -&gt; student表插入数据 -&gt; new_table更新数据 -&gt; new_table删除数据 -&gt; new_table插入数据
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">new_table删除数据</code>就是一个误操作， 我们需要进行挽回。 然后我们在此基础上执行：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>mysqlbinlog <span class="nt">-vv</span> mysql-bin.000007 <span class="nt">--start-position</span><span class="o">=</span>2761 <span class="nt">--stop-position</span><span class="o">=</span>3325 | mysql <span class="nt">-uroot</span> <span class="nt">-pkeyerror</span> repl_test
</code></pre></div></div>

<p>因为<code class="highlighter-rouge">DELETE</code>操作的偏移量为3602， 所以我们恢复上一个偏移量的数据， 也就是3325, 那么这条语句无情的抛出了异常：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERROR 1062 <span class="o">(</span>23000<span class="o">)</span> at line 64: Duplicate entry <span class="s1">'3'</span> <span class="k">for </span>key <span class="s1">'PRIMARY'</span>
</code></pre></div></div>

<p>因为在此时此刻， <code class="highlighter-rouge">new_table</code>中id为3的数据是存在的， 并没有被删除， 那么我再重新执行这条<code class="highlighter-rouge">insert</code>语句， 报错是必然的。 那么这个时候怎么恢复？
非常遗憾， 这个时候这样的条件， 只能手动的一条数据一条数据的重新插入， 没有其它的办法。 那么到底该如何的使用binlog来进行自动的恢复呢？</p>

<h4 id="5-正确的binlog数据恢复">5. 正确的binlog数据恢复</h4>

<p>binlog其实是一种增量恢复的模式， 那么既然是增量， 就必然需要有基量以及增量。 基量从哪儿来？ 来自数据库的完整备份， 即<code class="highlighter-rouge">mysqldump</code>。 增量从哪儿来？ 来自于上次完整备份时的binlog到现在的binlog。
可以看下面的示意图：</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-10-13%2011-18-32%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="Alt text" /></p>

<p>当我们为机器安装MySQL并且开启了binlog之后， 就有了mysql-bin文件的产生， 如果我们不去维护binlog的话， 那么当到达了最大容量限制或者MySQL重启时会进行自动切割。 当某一天数据出现了问题，需要使用binlog进行恢复时发现， mysql-bin因为过期时间的配置前面的binlog已经不见了， 并且数据库的备份是11天以前的， 完全无法进行恢复， 欢声笑语打出GG。
通常的做法是在执行数据库备份计划的同时， <code class="highlighter-rouge">flush logs</code>将日志进行主动的切割， 并在本地保留所有binlog日志。 假设我们的备份是每天的凌晨3点进行整体的数据库备份， 然后切割binlog。 在当天的下午2点数据需要进行恢复， 流程如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 停止MySQL服务， 并删除对应的database。
2. 导入备份数据<span class="o">(</span>这时候是凌晨3点时的数据<span class="o">)</span>。
3. 找到分割的binlog， 并找到误删数据的语句， 确定偏移量。
4. 绕开误删除语句的偏移量， 进行数据恢复。
</code></pre></div></div>

<p>这里面就有了一些很重要的步骤： 必须要知道当前的备份所对应的binlog偏移量， 必须要知道误删除语句的binlog偏移量。 只有知道了这些信息才能够进行无损的数据恢复。</p>

<h4 id="6-实践binlog数据恢复">6. 实践binlog数据恢复</h4>

<p>首先我们需要一个更加复杂的数据库结构以应对生产环境的复杂情况， 这里的话就使用<code class="highlighter-rouge">Django</code>框架来自动的生成表结构以及填充数据。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 测试binlog数据恢复的本地数据模型</span>

<span class="k">class</span> <span class="nc">BaseModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">created</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateTimeField</span><span class="p">(</span><span class="n">auto_now_add</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">updated</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateTimeField</span><span class="p">(</span><span class="n">auto_now</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">abstract</span> <span class="o">=</span> <span class="bp">True</span>


<span class="k">class</span> <span class="nc">Chatroom</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">nickname</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">description</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">owner</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">head_img</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">URLField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ChatroomMember</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">nickname</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">head_img</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">URLField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
    <span class="n">city</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">gender</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">BooleanField</span><span class="p">()</span>
    <span class="n">description</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ChatroomRelation</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">chatroom</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Chatroom</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">SET_NULL</span><span class="p">,</span> <span class="n">null</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">member</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">ChatroomMember</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">SET_NULL</span><span class="p">,</span> <span class="n">null</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">joined</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateTimeField</span><span class="p">(</span><span class="n">auto_now_add</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">chatroom_nickname</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">unique_together</span> <span class="o">=</span> <span class="p">(</span><span class="s">"chatroom"</span><span class="p">,</span> <span class="s">"member"</span><span class="p">)</span>
</code></pre></div></div>

<p>在填充数据之后进行<code class="highlighter-rouge">mysqldump</code>进行备份， 需要注意的是一定要记录当前dump的binlog偏移量， 即添加<code class="highlighter-rouge">--master-data</code>参数， 并且在备份时仍有数据进行插入</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysqldump <span class="nt">--master-data</span> <span class="nt">--single-transaction</span> <span class="nt">-uroot</span> <span class="nt">-pkeyerror</span> myProjects <span class="o">&gt;</span> /home/smartkeyerror/mysql_dumps/test.sql
</code></pre></div></div>

<p>打开<code class="highlighter-rouge">test.sql</code>， 可以看到当前备份的偏移量：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CHANGE MASTER TO <span class="nv">MASTER_LOG_FILE</span><span class="o">=</span><span class="s1">'mysql-bin.000007'</span>, <span class="nv">MASTER_LOG_POS</span><span class="o">=</span>99082<span class="p">;</span>

<span class="c"># client-session查看</span>
mysql&gt; show master logs<span class="p">;</span>
+------------------+-----------+
| Log_name         | File_size |
+------------------+-----------+
| mysql-bin.000001 |      3370 |
| mysql-bin.000002 |     19108 |
| mysql-bin.000003 |       177 |
| mysql-bin.000004 |       201 |
| mysql-bin.000005 |    115978 |
| mysql-bin.000006 |       201 |
| mysql-bin.000007 |    125900 |
| mysql-bin.000008 |       154 |
+------------------+-----------+
8 rows <span class="k">in </span><span class="nb">set</span> <span class="o">(</span>0.00 sec<span class="o">)</span>
</code></pre></div></div>

<p>因为在测试的过程中突然断电了(刚好遇到了一个特殊情况)， 所以binlog日志又被切割出去了， 一个很奇怪的现象， 起始位置不是0， 而是154， 我们再切割一个：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; flush logs<span class="p">;</span>
Query OK, 0 rows affected <span class="o">(</span>0.07 sec<span class="o">)</span>

mysql&gt; show master logs<span class="p">;</span>
+------------------+-----------+
| Log_name         | File_size |
+------------------+-----------+
| mysql-bin.000001 |      3370 |
| mysql-bin.000002 |     19108 |
| mysql-bin.000003 |       177 |
| mysql-bin.000004 |       201 |
| mysql-bin.000005 |    115978 |
| mysql-bin.000006 |       201 |
| mysql-bin.000007 |    125900 |
| mysql-bin.000008 |       201 |
| mysql-bin.000009 |       154 |
+------------------+-----------+
9 rows <span class="k">in </span><span class="nb">set</span> <span class="o">(</span>0.00 sec<span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">mysql-bin.000008</code>多了47个偏移， 新切割的binlog起始偏移仍然是154。
回到数据恢复， 在备份时我们知道了日志的偏移量为99082， 并且当时的binlog为<code class="highlighter-rouge">mysql-bin.000007</code>， 首先我们先删除一部分数据， 然后再写入一些数据。
时序图：</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-10-13%2016-13-53%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>那么我们只需要做两件事：找到删除数据的binlog文件位置以及偏移量， 删库(这回不用跑路)后恢复数据。
那就找呗， 在0007 99082至009 38924之间查找<code class="highlighter-rouge">DELETE FROM</code>, 通过使用<code class="highlighter-rouge">grep</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># -C参数会在匹配的关键字前后各打印30行的数据</span>
<span class="nb">sudo </span>mysqlbinlog mysql-bin.000007 <span class="nt">-vv</span> | <span class="nb">grep</span> <span class="nt">-C</span> 30 <span class="s2">"DELETE FROM"</span>
<span class="nb">sudo </span>mysqlbinlog mysql-bin.000008 <span class="nt">-vv</span> | <span class="nb">grep</span> <span class="nt">-C</span> 30 <span class="s2">"DELETE FROM"</span>
</code></pre></div></div>

<p>最终在009 451至009 943发现了<code class="highlighter-rouge">DELETE FROM</code>语句， 那么我们就可以开始恢复数据了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. DROP DATABASE myProjects

2. 导入数据， 抛了异常
ERROR 3021 <span class="o">(</span>HY000<span class="o">)</span> at line 22: This operation cannot be performed with a running slave io thread<span class="p">;</span> run STOP SLAVE IO_THREAD FOR CHANNEL <span class="s1">''</span> first.

3. 运行 STOP SLAVE IO_THREAD FOR CHANNEL <span class="s2">""</span><span class="p">;</span>

4. 重新导入数据

5. 恢复0007 99082到尾部的数据
<span class="nb">sudo </span>mysqlbinlog <span class="nt">--start-position</span><span class="o">=</span>99082 <span class="nt">-vv</span> mysql-bin.000007 | mysql <span class="nt">-uroot</span> <span class="nt">-pkeyerror</span> myProjects

6. 恢复008以及009 451之前的数据
这里有一个如何选择结束点的问题， 首先来看一下grep信息， 选择370报错， 选择287正常， 也不知道为什么

BEGIN
/<span class="k">*</span><span class="o">!</span><span class="k">*</span>/<span class="p">;</span>
<span class="c"># at 287</span>
<span class="c">#181013 15:41:44 server id 2  end_log_pos 370 CRC32 0x4d8bbd3e 	Table_map: `myProjects`.`devOps_chatroomrelation` mapped to number 109</span>
<span class="c"># at 370</span>
<span class="c">#181013 15:41:44 server id 2  end_log_pos 451 CRC32 0xf7657cfe 	Delete_rows: table id 109 flags: STMT_END_F</span>

BINLOG <span class="s1">'
uKHBWxMCAAAAUwAAAHIBAAAAAG0AAAAAAAEACm15UHJvamVjdHMAF2Rldk9wc19jaGF0cm9vbXJl
bGF0aW9uAAcDEhISDwMDBQYGBsgAYD69i00=
uKHBWyACAAAAUQAAAMMBAAAAAG0AAAAAAAEAAgAH/4BqAAAAmaEa7SEEkKWZoRrtIQSQ5pmhGu0h
BJFGCGFva0pWcEdPJQAAABMAAAD+fGX3
'</span>/<span class="k">*</span><span class="o">!</span><span class="k">*</span>/<span class="p">;</span>
<span class="c">### DELETE FROM `myProjects`.`devOps_chatroomrelation`</span>
.... <span class="c"># 中间被我干掉了</span>
<span class="c"># at 451</span>
<span class="c">#181013 15:41:44 server id 2  end_log_pos 534 CRC32 0xade8611d 	Table_map: `myProjects`.`devOps_chatroomrelation` mapped to number 109</span>
<span class="c"># at 534</span>
<span class="c">#181013 15:41:44 server id 2  end_log_pos 615 CRC32 0x55e89f5b 	Delete_rows: table id 109 flags: STMT_END_F</span>

<span class="nb">sudo </span>mysqlbinlog <span class="nt">-vv</span> mysql-bin.000008 | mysql <span class="nt">-uroot</span> <span class="nt">-pkeyerror</span> myProjects

<span class="nb">sudo </span>mysqlbinlog <span class="nt">-vv</span> mysql-bin.000009 <span class="nt">--stop-position</span><span class="o">=</span>287 | mysql <span class="nt">-uroot</span> <span class="nt">-pkeyerror</span> myProjects

<span class="nb">sudo </span>mysqlbinlog <span class="nt">-vv</span> mysql-bin.000009 <span class="nt">--start-position</span><span class="o">=</span>1119 | mysql <span class="nt">-uroot</span> <span class="nt">-pkeyerror</span> myProjects

7. 确认数据正常恢复， 并开启对外服务。
</code></pre></div></div>

<h4 id="7-总结">7. 总结</h4>

<p>上面就是使用binlog进行数据恢复的整个过程， 没有什么特别复杂的地方， 只不过步骤比较繁琐， 偏移量必须准确才能够成功。 对一些比较重要的操作进行整理：</p>
<ol>
  <li>备份时必须添加<code class="highlighter-rouge">--master-data</code>参数； <code class="highlighter-rouge">-F</code>切割二进制日志可选， 添加之后会更加的方便</li>
  <li>必须找到误删数据的偏移量， 备份时绕过这些数据修改。</li>
  <li>因流程较为复杂， 确认无误后进行操作。</li>
</ol>

<p>另外使用<code class="highlighter-rouge">mysqlbinlog</code>对binlog进行解析的话查看起来并不是很方便， 可以在<code class="highlighter-rouge">client</code>中使用</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">show</span> <span class="n">binlog</span> <span class="n">events</span> <span class="p">[</span><span class="k">in</span> <span class="s1">'binlog-name'</span><span class="p">]</span> <span class="p">[</span><span class="k">from</span> <span class="k">position</span><span class="p">]</span> <span class="err">\</span><span class="k">G</span><span class="p">;</span>
</code></pre></div></div>

<p>来更加直观的查看相关内容以及偏移量， 不过这种方式查看的话没有具体数据信息， 可以结合<code class="highlighter-rouge">mysqlbinlog</code>命令共同使用。</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL之主从复制</title>
	  <link>//MySQL-master-slave</link>
	  <author></author>
	  <pubDate>2018-10-23T09:49:09+00:00</pubDate>
	  <guid>//MySQL-master-slave</guid>
	  <description><![CDATA[
	     <p>MySQL的主从复制是建立读写分离以及MySQL集群的根本， 为了能够保证复制的正常运行， 那么就必然需要对其原理以及核心的配置项有足够的了解， 才能够在复杂的生产环境中对错误进行排查。</p>

<!---more--->

<h4 id="1-mysql主从复制原理">1. MySQL主从复制原理</h4>

<p>MySQL之间数据复制的基础是<code class="highlighter-rouge">二进制日志</code>文件(binary log file)。 一台MySQL数据库一旦启用二进制日志后， 其作为master， 它的数据库中所有操作都会以“事件”的方式记录在二进制日志中， 其他数据库作为slave通过一个<code class="highlighter-rouge">I/O线程</code>与主服务器保持通信， 并监控master的二进制日志文件的变化， 如果发现master二进制日志文件发生变化， 则会把变化复制到自己的<code class="highlighter-rouge">中继日志中</code>， 然后slave的一个<code class="highlighter-rouge">SQL线程</code>会把相关的“事件”执行到自己的数据库中， 以此实现从数据库和主数据库的一致性，也就实现了主从复制。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.png" alt="Alt text" /></p>

<h4 id="1-实现mysql主从复制需要进行的配置">1. 实现MySQL主从复制需要进行的配置</h4>
<ol>
  <li>主服务器：
    <ul>
      <li>开启二进制日志</li>
      <li>配置唯一的server-id</li>
      <li>获得master二进制日志文件名及位置</li>
      <li>创建一个用于slave和master通信的用户账号</li>
    </ul>
  </li>
  <li>从服务器：
    <ul>
      <li>配置唯一的server-id</li>
      <li>使用master分配的用户账号读取master二进制日志</li>
      <li>启用slave服务</li>
    </ul>
  </li>
</ol>

<h4 id="2-binlog相关配置以及参数说明">2. binlog相关配置以及参数说明</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; show variables like <span class="s2">"%binlog%"</span><span class="p">;</span>
+--------------------------------------------+----------------------+
| Variable_name                              | Value                |
+--------------------------------------------+----------------------+
| binlog_cache_size                          | 32768                |
| binlog_checksum                            | CRC32                |
| binlog_direct_non_transactional_updates    | OFF                  |
| binlog_error_action                        | ABORT_SERVER         |
| binlog_format                              | ROW                  |
| binlog_group_commit_sync_delay             | 0                    |
| binlog_group_commit_sync_no_delay_count    | 0                    |
| binlog_gtid_simple_recovery                | ON                   |
| binlog_max_flush_queue_time                | 0                    |
| binlog_order_commits                       | ON                   |
| binlog_row_image                           | FULL                 |
| binlog_rows_query_log_events               | OFF                  |
| binlog_stmt_cache_size                     | 32768                |
| binlog_transaction_dependency_history_size | 25000                |
| binlog_transaction_dependency_tracking     | COMMIT_ORDER         |
| innodb_api_enable_binlog                   | OFF                  |
| innodb_locks_unsafe_for_binlog             | OFF                  |
| log_statements_unsafe_for_binlog           | ON                   |
| max_binlog_cache_size                      | 18446744073709547520 |
| max_binlog_size                            | 104857600            |
| max_binlog_stmt_cache_size                 | 18446744073709547520 |
| sync_binlog                                | 1                    |
+--------------------------------------------+----------------------+
22 rows <span class="k">in </span><span class="nb">set</span> <span class="o">(</span>0.00 sec<span class="o">)</span>
</code></pre></div></div>
<p>通过在mysql客户端执行<code class="highlighter-rouge">show variables</code>命令， 可以看到关于<code class="highlighter-rouge">binlog</code>的配置一共有20几项之多。 但是大部分的配置项我们可以直接使用默认值， 有几个配置需要额外的进行关注：</p>

<h5 id="21-binlog_format">2.1 binlog_format</h5>
<p>二进制日志格式有3种格式可选： Statement, Row以及Mixed。 其中Statement格式基于语句进行日志记录， Row格式基于数据修改进行记录。
首先准备一下测试的数据库：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">database</span> <span class="n">repl_test</span><span class="p">;</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`repl_test`</span><span class="p">.</span><span class="nv">`new_table`</span> <span class="p">(</span>
  <span class="nv">`id`</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`name`</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`age`</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span> <span class="n">CHARACTER</span> <span class="k">SET</span> <span class="s1">'utf8mb4'</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">));</span>
</code></pre></div></div>
<h6 id="211-statement">2.1.1 Statement</h6>

<p>简单的来说Statement格式就是记录了数据修改所执行的SQL语句， 那么在做主从复制时从库读取SQL语句并重新进行执行。
我们创建一个database以及一个table， 并在table中插入一些数据来观察一下：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> <span class="k">session</span> <span class="n">binlog_format</span><span class="o">=</span><span class="k">statement</span><span class="p">;</span>

<span class="k">insert</span> <span class="k">into</span> <span class="n">new_table</span> <span class="k">values</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">"smart"</span><span class="p">,</span> <span class="mi">18</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nv">"keyerror"</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
<span class="k">delete</span> <span class="k">from</span> <span class="n">new_table</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>
<p>在二进制日志保存的文件夹中查看二进制日志：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>mysqlbinlog mysql-bin.000001  <span class="c"># Statement格式日志</span>
<span class="nb">sudo </span>mysqlbinlog <span class="nt">-vv</span> mysql-bin.000001  <span class="c"># Row格式日志</span>
</code></pre></div></div>
<p>那么Statement格式的日志就会是这个样子：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>insert into new_table values <span class="o">(</span>1, <span class="s2">"smart"</span>, 18<span class="o">)</span>, <span class="o">(</span>2, <span class="s2">"keyerror"</span>, 25<span class="o">)</span>
....  <span class="c"># 中间一些其它内容</span>
BEGIN
/<span class="k">*</span><span class="o">!</span><span class="k">*</span>/<span class="p">;</span>
<span class="c"># at 2297</span>
<span class="c">#181011 10:16:38 server id 1  end_log_pos 2413 CRC32 0xccb8b51b         Query   thread_id=2     exec_time=0     error_code=0</span>
SET <span class="nv">TIMESTAMP</span><span class="o">=</span>1539224198/<span class="k">*</span><span class="o">!</span><span class="k">*</span>/<span class="p">;</span>
delete from new_table where <span class="nv">id</span><span class="o">=</span>2
/<span class="k">*</span><span class="o">!</span><span class="k">*</span>/<span class="p">;</span>
<span class="c"># at 2413</span>
...
</code></pre></div></div>
<p>可以看到在日志中完整了记录了每一条SQL语句的内容， 从库拿到这些语句重新执行就可以获得与主库相同的数据了。
因为记录的是SQL语句， 那么会极大的降低二进制日志文件的大小， 并且在复制的有着更快的网络传输效率。
缺点也显而易见：像Uuid()这样的函数每次执行返回不同的结果， 那么这样一来在主库和从库中数据就会有不一致的情况。 并且如果某一条SQL语句执行时间过长， 从库同样的也要执行很长时间， 这样一来复制的过程就可能会被阻塞， 主从之间的数据一致性在这段时间就会遭到破坏。 所以一般在生产环境中并不会使用这样的日志格式， 除非有特殊的需求需要进行临时的修改。</p>

<h6 id="212-row">2.1.2 Row</h6>

<p>Row格式在MySQL5.7版本中为默认的二进制日志格式， 日志中会记录每一行数据的修改， 然后在从库中应用这些修改。</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> <span class="k">session</span> <span class="n">binlog_format</span><span class="o">=</span><span class="k">row</span><span class="p">;</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">new_table</span> <span class="k">values</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nv">"zhangsan"</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
<span class="k">update</span> <span class="n">new_table</span> <span class="k">set</span> <span class="n">age</span><span class="o">=</span><span class="mi">19</span> <span class="k">where</span> <span class="n">age</span><span class="o">=</span><span class="mi">18</span><span class="p">;</span>
</code></pre></div></div>
<p>那么此时日志所记录的内容为：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">### INSERT INTO `repl_test`.`new_table`</span>
<span class="c">### SET</span>
<span class="c">###   @1=3 /* INT meta=0 nullable=0 is_null=0 */</span>
<span class="c">###   @2='zhangsan' /* VARSTRING(45) meta=45 nullable=1 is_null=0 */</span>
<span class="c">###   @3='18' /* VARSTRING(180) meta=180 nullable=1 is_null=0 */</span>

<span class="c">### UPDATE `repl_test`.`new_table`</span>
<span class="c">### WHERE</span>
<span class="c">###   @1=1 /* INT meta=0 nullable=0 is_null=0 */</span>
<span class="c">###   @2='smart' /* VARSTRING(45) meta=45 nullable=1 is_null=0 */</span>
<span class="c">###   @3='18' /* VARSTRING(180) meta=180 nullable=1 is_null=0 */</span>
<span class="c">### SET</span>
<span class="c">###   @1=1 /* INT meta=0 nullable=0 is_null=0 */</span>
<span class="c">###   @2='smart' /* VARSTRING(45) meta=45 nullable=1 is_null=0 */</span>
<span class="c">###   @3='19' /* VARSTRING(180) meta=180 nullable=1 is_null=0 */</span>
<span class="c">### UPDATE `repl_test`.`new_table`</span>
<span class="c">### WHERE</span>
<span class="c">###   @1=3 /* INT meta=0 nullable=0 is_null=0 */</span>
<span class="c">###   @2='zhangsan' /* VARSTRING(45) meta=45 nullable=1 is_null=0 */</span>
<span class="c">###   @3='18' /* VARSTRING(180) meta=180 nullable=1 is_null=0 */</span>
<span class="c">### SET</span>
<span class="c">###   @1=3 /* INT meta=0 nullable=0 is_null=0 */</span>
<span class="c">###   @2='zhangsan' /* VARSTRING(45) meta=45 nullable=1 is_null=0 */</span>
<span class="c">###   @3='19' /* VARSTRING(180) meta=180 nullable=1 is_null=0 */</span>
</code></pre></div></div>
<p>可以看到每一行的修改都被记录了， 并且记录了修改行的前后的数据内容， 那么这样一来主库与从库就能够达到完全的数据一致性。
缺点也同样的显而易见， 数据记录的太多太啰嗦， 会占用大量的磁盘空间以及更长时间的网络传输。 但是， 是有办法优化的， 要不然MySQL官方也不会推荐我们使用Row格式。</p>

<h6 id="211-mixed">2.1.1 Mixed</h6>

<p>实际上就是上面两种模式的混合。</p>

<h5 id="21-binlog_row_image">2.1 binlog_row_image</h5>
<p>前面提到了<code class="highlighter-rouge">binlog_format=ROW</code>会带来很大的磁盘以及网络传输开销， 那么<code class="highlighter-rouge">binlog_row_image</code>参数就是为了优化<code class="highlighter-rouge">ROW</code>模式而存在的。
可选值有3个： FULL， MINIMAL, NOBLOB。其中FULL选项将会记录所有内容； MINIMAL仅会记录被修改了列， 无关列不会记录； NOBLOB记录了blog和text之外的所有字段。FULL模式所生成的日志格式就是上面我们看到的。
MINIMAL选项所生成的日志格式：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> <span class="k">session</span> <span class="n">binlog_row_image</span><span class="o">=</span><span class="n">MINIMAL</span><span class="p">;</span>
<span class="k">update</span> <span class="n">new_table</span> <span class="k">set</span> <span class="n">age</span><span class="o">=</span><span class="mi">25</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">### UPDATE `repl_test`.`new_table`</span>
<span class="c">### WHERE</span>
<span class="c">###   @1=1 /* INT meta=0 nullable=0 is_null=0 */</span>
<span class="c">### SET</span>
<span class="c">###   @3='25' /* VARSTRING(180) meta=180 nullable=1 is_null=0 */</span>
</code></pre></div></div>
<p>其中<code class="highlighter-rouge">@1, @3</code>表示第几列， 也就是字段名称。这里的日志表示”将id(@1)为1的数据的年龄(@3)修改为25”， 其余未改动的字段(列)并没有记录在二进制日志中， 减少了日志的记录。</p>

<p>需要特别注意的是： 虽然MINIMAL能够减少日志的数量， 但是由于记录会选择的缺失， 那么通过这种格式的二进制日志对数据库进行恢复的难度就会提高， 排错也会有一些困难。 需要根据实际情况来正确的选择是使用<code class="highlighter-rouge">FULL</code>模式还是<code class="highlighter-rouge">MINIMAL</code>模式。</p>

<h4 id="3-基于日志点的复制和基于gtid的复制">3. 基于日志点的复制和基于GTID的复制</h4>
<h5 id="31-基于日志点的复制">3.1 基于日志点的复制</h5>
<p>基于日志点的复制MySQL会记录当前日志的数据偏移量并且将该值传递给从库， 从库根据该偏移量进行复制。
通常来讲我们启用主从复制是在已经有了主库的情况下而添加从库的， 那么此时就需要将数据导入到从库中：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 只允许读操作不允许写入</span>
flush tables with <span class="nb">read </span>lock<span class="p">;</span>
<span class="c"># 记录日志的偏移量</span>
mysqldump <span class="nt">--master-data</span> <span class="o">[</span>databses | <span class="nt">--all-databases</span><span class="o">]</span> <span class="o">&gt;</span> all.sql
or
xtrbackup <span class="nt">--slave-info</span>  <span class="c"># 第三方工具， 仅用于InnoDB， 属于热备工具</span>
</code></pre></div></div>
<p>那么此时从库就可以开启复制链路了， 其中的<code class="highlighter-rouge">master_log_file</code>以及<code class="highlighter-rouge">master_log_pos</code>可以在刚才的数据库备份中找到：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">将数据进行导入</span>
<span class="n">change</span> <span class="n">master</span> <span class="k">to</span> <span class="n">master_host</span><span class="o">=</span><span class="nv">"192.168.0.5"</span><span class="p">,</span>
                 <span class="n">master_user</span><span class="o">=</span><span class="nv">""</span><span class="p">,</span>
                 <span class="n">master_password</span><span class="o">=</span><span class="nv">""</span><span class="p">,</span>
                 <span class="n">master_log_file</span><span class="o">=</span><span class="nv">"二进制日志文件名"</span><span class="p">,</span>
                 <span class="n">master_log_pos</span><span class="o">=</span><span class="err">偏移量</span>
<span class="k">start</span> <span class="n">slave</span><span class="p">;</span>

<span class="err">主库执行：</span> <span class="n">unlock</span> <span class="n">tables</span><span class="err">；</span>
</code></pre></div></div>

<p>优点： 基于日志点的复制是MySQL最早支持的复制技术， 相对而言BUG比较少， 并且对SQL没有任何的限制， 故障处理较为容易。
缺点： 故障转移时重新获取新主的日志点信息比较困难。</p>

<h5 id="32-基于gtid的复制">3.2 基于GTID的复制</h5>
<p>基于GTID的复制原理上其实是执行每一个事务， 主库中每一个事务都有一个唯一的自增标志。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GTID <span class="o">=</span> server_uuid:transaction_id
</code></pre></div></div>
<p>借助GTID， 在发生主备切换的情况下， MySQL的其它Slave可以自动在新主上找到正确的复制位置， 不再需要像基于日志点复制一样人工的添加日志记录的偏移量， 简化了复杂复制拓扑下集群的维护。 另外，基于GTID的复制可以忽略已经执行过的事务，减少了数据发生不一致的风险。
但是这种模式同样具有缺点： 其故障处理较为复杂， 并且对执行的SQL有一定的限制。</p>


	  ]]></description>
	</item>


</channel>
</rss>
