<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description>Keep coding, Keep curiosity</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Linux 阻塞与唤醒实现原理</title>
	  <link>//Linux-Blocking</link>
	  <author></author>
	  <pubDate>2020-09-09T07:50:25+00:00</pubDate>
	  <guid>//Linux-Blocking</guid>
	  <description><![CDATA[
	     <p>在前面的文件 I/O 文章中，我们有提到 Linux 文件 I/O 支持阻塞和非阻塞的数据读取方式，当采用阻塞方式进行 I/O 时，进程将会阻塞在<code class="highlighter-rouge">read()</code>或者<code class="highlighter-rouge">write()</code>系统调用上，直到文件可读或者是内核缓冲区可写。这些阻塞与唤醒的实现与内核调度紧密相关，Linux 内核使用等待队列和完成量来实现该功能。</p>
<blockquote>
  <p>注: 本篇文章所用Linux内核源码版本为v5.8</p>
</blockquote>

<!---more--->

<h3 id="1-进程状态有限状态机">1. 进程状态有限状态机</h3>

<p>进程并不总是可以立即运行的，一方面是 CPU 资源有限，另一方面则是进程时常需要等待外部事件的发生，例如 I/O 事件、定时器事件等。</p>

<p>因此，对进程的状态进行分类就是一件非常有必要的事情，对于等待某事件发生的进程给予 CPU 资源是没有任何意义的，因为此时事件可能仍未发生。而对于正等待 CPU 资源的进程而言，在得到 CPU 之后即可立即执行。调度器为了尽可能最大地使用硬件资源，通常会将进程分为3个主要的状态: 运行、等待和睡眠。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/schedule/process-state.png" alt="" /></p>

<p>处于运行状态的进程正在使用 CPU 等资源，从上图中可以看到，运行态的进程在执行完任务后结束，进入到结束状态。当 CPU 时间片到期之后，调度器选择其它进程执行，此时将进入等待状态。同时，当运行时的进程发起 I/O 操作，或者等待其它事件的发生时，将进入睡眠状态。</p>

<p>处于等待状态的进程由于缺少 CPU 资源而被迫停止运行，只要调度器下次选中该进程即可立即执行，由等待状态转变为运行状态。</p>

<p>处于睡眠状态的进程在等待外部事件的发生，例如 I/O 操作的数据抵达，创建的定时器到期等等，<strong>处于睡眠状态的进程永远不会被调度器进行选择并执行</strong>。当期望的事件到达后，进程由睡眠状态更改为等待状态，等待调度器的下一次选择。</p>

<p>处于等待的进程将会被放置于就绪队列中（红黑树实现），而处于睡眠状态的进程则放置于等待队列（双链表实现）中。调度器的目光主要放在就绪队列上，从该队列中取出下一个将要执行的进程，而等待队列和就绪队列中的进程会因为事件的发生而进行相互转移。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/schedule/read-and-wait-queue.png" alt="" /></p>

<p>在实际的内核实现中，进程的运行状态表示要比上文所述更加详细一些，进程状态定义于<code class="highlighter-rouge">include/linux/sched.h</code>:</p>

<ul>
  <li><code class="highlighter-rouge">TASK_RUNNING</code>，可运行状态。此时进程并不一定正在运行，一旦得到调度器的调度即可立即运行。</li>
  <li><code class="highlighter-rouge">TASK_INTERRUPTIBLE</code>，可中断睡眠状态。此时进程因为等待外部事件的发生而睡眠，此时可由信号或者是内核唤醒。</li>
  <li><code class="highlighter-rouge">TASK_UNINTERRUPTIBLE</code>，不可中断睡眠状态。和<code class="highlighter-rouge">TASK_INTERRUPTIBLE</code>状态类似，等待外部事件发生的睡眠状态。不同的是改状态只能由内核亲自唤醒，不能由信号唤醒，通常用于进程必须等待某件工作完成，不能被 Kill。</li>
</ul>

<p>除了这三个核心进程状态以外，还有<code class="highlighter-rouge">__TASK_STOPPED</code>、<code class="highlighter-rouge">__TASK_TRACED</code>等状态，由于这些状态在本文中并不重要，所以略去。</p>

<h3 id="2-等待队列">2. 等待队列</h3>

<p>等待队列相关的源码位于<code class="highlighter-rouge">include/linux/wait.h</code>以及<code class="highlighter-rouge">kernel/sched/wait.c</code>文件中，头文件中定义了等待队列以及队列元素的基本数据结构，<code class="highlighter-rouge">wait.c</code>源文件则主要包含具体的方法实现。</p>

<p>首先来看等待队列的基本结构，分为队列头和队列项:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 等待队列头 */</span>
<span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>       <span class="cm">/* 自旋锁 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">head</span><span class="p">;</span>   <span class="cm">/* previous、next指针 */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="n">wait_queue_head_t</span><span class="p">;</span>

<span class="cm">/* 等待队列元素 */</span>
<span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>  <span class="cm">/* 标识位 */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="k">private</span><span class="p">;</span>   <span class="cm">/* 通常指向等待进程 */</span>
	<span class="n">wait_queue_func_t</span>	<span class="n">func</span><span class="p">;</span>   <span class="cm">/* 唤醒函数 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">entry</span><span class="p">;</span>  <span class="cm">/* previous、next指针 */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在内核的链表实现中，绝大多数的链表均为循环双链表，等待队列也不例外。因为等待队列可能会在系统中断时进行修改，所以必须要添加互斥锁机制保护队列元素。</p>

<p>等待队列元素的设计也非常简洁，除了双链表必要的前后指针以外，仅包含一个指向等待进程<code class="highlighter-rouge">task_struct</code>实例的指针，一个唤醒函数和一个标识位。</p>

<p>唤醒函数通常由调度器实现，如<code class="highlighter-rouge">kernel/sched/core.c</code>中定义的<code class="highlighter-rouge">try_to_wake_up</code>方法，可以简单的认为唤醒函数就是将进程的状态由<code class="highlighter-rouge">TASK_INTERRUPTIBLE</code>或<code class="highlighter-rouge">TASK_UNINTERRUPTIBLE</code>修改为<code class="highlighter-rouge">TASK_RUNNING</code>，并将其加入至就绪队列中。</p>

<p><code class="highlighter-rouge">wait.h</code>中提供了一系列与等待队列相关的宏定义供外部使用，例如<code class="highlighter-rouge">wait_event</code>，本质上是对等待队列的进一步封装:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define wait_event(wq_head, condition)						\
do {										\
	might_sleep();								\
	if (condition)								\
		break;								\
    </span><span class="cm">/* 这里将原有的__wait_event宏展开，使用___wait_event代替 */</span><span class="cp">     \
	___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0, schedule())	\
} while (0)
</span></code></pre></div></div>

<p>其中<code class="highlighter-rouge">wq_head</code>即<code class="highlighter-rouge">wait_queue_head</code>，<code class="highlighter-rouge">condition</code>则是一个C语言表达式，表示一个等待条件。宏定义的<code class="highlighter-rouge">wait_event</code>使得使用标准C表达式指定条件成为可能，如果使用函数实现的话，无法做到如宏实现的灵活性。注意到在调用<code class="highlighter-rouge">___wait_event</code>之前会首先检查一遍条件是否满足，避免进行无效的睡眠。</p>

<p>在<code class="highlighter-rouge">___wait_event</code>宏定义中传入的进程状态为<code class="highlighter-rouge">TASK_UNINTERRUPTIBLE</code>，也就是说，<code class="highlighter-rouge">wait_event</code>实现的事件等待是不可中断的。当然，<code class="highlighter-rouge">wait.h</code>中同样提供了其它时间等待实现:</p>

<ul>
  <li><code class="highlighter-rouge">wait_event_timeout</code>: 带有超时时间的不可中断事件等待</li>
  <li><code class="highlighter-rouge">wait_event_interruptible</code>: 可中断的事件等待</li>
  <li><code class="highlighter-rouge">wait_event_interruptible_timeout</code>: 带有超时时间的可中断事件等待</li>
</ul>

<p>最后再来看<code class="highlighter-rouge">___wait_event</code>实现，该方法将会把当前进程包装成<code class="highlighter-rouge">wait_queue_entry</code>对象，并发安全地放置于等待队列中，并且在实际的让出CPU资源、引发调度器重新调度之前会再一次的检查等待事件是否发生，避免无效睡眠。由于源代码中该方法宏定义实现符号较多，所以将原实现抽象成伪代码:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">___wait_event</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">exclusive</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 初始化队列元素 */</span>
    <span class="n">init_wait_entry</span><span class="p">(...);</span>
    
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="cm">/* 将队列元素插入至等待队列中(线程安全) */</span>
        <span class="kt">long</span> <span class="n">__int</span> <span class="o">=</span> <span class="n">prepare_to_wait_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__wq_entry</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
        
        <span class="cm">/* 检查事件条件是否满足 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
            
        <span class="cm">/* 触发调度器重新调度 */</span>
        <span class="n">schedule</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于唤醒一个进程在前文中已经描述过了，通用方法为<code class="highlighter-rouge">wake_up()</code>，本质上会调用内核调度模块中的<code class="highlighter-rouge">try_to_wake_up()</code>来唤醒某个进程，唤醒的实质是将进程状态修改为<code class="highlighter-rouge">TASK_RUNNING</code>，从等待队列中移出并加入至就绪队列中。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Linux操作系统-文件I/O</title>
	  <link>//Linux-IO</link>
	  <author></author>
	  <pubDate>2019-12-17T09:39:25+00:00</pubDate>
	  <guid>//Linux-IO</guid>
	  <description><![CDATA[
	     <p>在操作系统中， 最为复杂同时也最为重要的功能就是文件I/O。 一台PC可以不连接互联网， 但是一定需要程序的载入、文件的打开， 而这些操作与I/O均密不可分。 包括软件开发中， 数据库与I/O的关系密切相关， 有时衡量一个DB的效率， 其实就是在衡量其I/O效率。 理解文件I/O， 就是在理解我们常用应用软件， 如MySQL、Redis、Nginx、ES、Prometheus等的核心。</p>

<!---more--->

<h4 id="1-处于内核态的系统调用">1. 处于内核态的系统调用</h4>

<p>操作系统的本质就是帮助用户更加高效的管理硬件， 向上提供统一的接口， 向下兼容不同的硬件， 使得用户并不需要关心硬件， 如硬盘的细节， 只需要关心操作系统为我们提供的抽象: 文件系统。 然而引入操作系统的代价就是用户对硬件的所有操作， 例如打开一个文件， 运行一个程序， 均需经由操作系统来完成， 如此以来， 就有了系统调用。</p>

<p>系统调用存在的原因就在于操作系统不允许用户直接访问硬件， 如果用户有此需求， 则需将想要访问的地址与内容告诉操作系统， 由操作系统进行硬件的访问， 最后由操作系统将结果返回给用户。</p>

<p>操作系统也是软件， 也是由一行行的代码所组成， 所以必定运行在内存中， 只不过操作系统所运行的内存受到保护， 用户无法直接对其进行操作而已。 当用户想要打开一个文件时， 将文件路径告知操作系统， 此时操作系统将会接管CPU的执行， 并将CPU的某标识位标记为内核态， 执行一系列的I/O操作， 取出结果并将结果发送给用户内存空间后， 再将CPU的执行权交给用户。 从本质上来看， 系统调用其实就是一次进程切换， 只不过所花费的时间要比普通的进程间切换大得多而已。</p>

<p>接下来将会看到， 为了”对抗”系统调用所带来的巨大代价， 先贤们实现了各种各样增加I/O效率的方式。 但是， 没有哪一种方式能够”一招吃遍天下鲜”， 不同的应用场景会有不同的最佳解决方式。</p>

<h4 id="2-linux通用io模型">2. Linux通用I/O模型</h4>

<p>Linux为系统用户提供了一些通用的IO函数， 包括<code class="highlighter-rouge">open</code>、<code class="highlighter-rouge">read</code>、<code class="highlighter-rouge">write</code>等方法， 当用户每次调用这些方法时， 都将产生一次系统调用， 此时程序运行由用户态切换至内核态， 内核做完自己应该完成的事情之后， 将结果保存至用户指定的位置中， 并再由内核态切换至用户态， 使用户继续执行下面的代码。</p>

<p><code class="highlighter-rouge">open</code>方法既能打开一个已经存在的文件， 也能创建并打开一个新的文件。 其原型如下:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="p">...</span><span class="cm">/* mode_t mode */</span><span class="p">)</span>
</code></pre></div></div>

<p>具体的方法使用请参见Linux manual page。 <code class="highlighter-rouge">open</code>方法在成功时将返回该文件的文件描述符， 用于在后续函数调用中指代该文件， 该文件描述符在进程中唯一， 即使打开的是同一个文件， 两者的文件描述符也不相同。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"hole.txt"</span><span class="p">,</span> <span class="n">O_WDONLY</span><span class="p">);</span>   <span class="c1">// 3
</span>    <span class="kt">int</span> <span class="n">fd2</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"hole.txt"</span><span class="p">,</span> <span class="n">O_WDONLY</span><span class="p">);</span>  <span class="c1">// 4
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于用户自定义的文件， 文件描述符通常都是从3开始， 0、1、2这三个描述符分别代表标准输入、标准输出以及标准错误， 定义于<code class="highlighter-rouge">unistd.h</code>头文件中。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Standard file descriptors.  */</span>
<span class="cp">#define	STDIN_FILENO	0	</span><span class="cm">/* Standard input.  */</span><span class="cp">
#define	STDOUT_FILENO	1	</span><span class="cm">/* Standard output.  */</span><span class="cp">
#define	STDERR_FILENO	2	</span><span class="cm">/* Standard error output.  */</span><span class="cp">
</span></code></pre></div></div>

<p><code class="highlighter-rouge">read</code>系统调用此报告文件描述符fd所指代的打开文件中读取数据， 其定义为:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;unistd.h&gt;
</span>
<span class="kt">ssize_t</span> <span class="n">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div></div>

<p>count参数指定最多能读取的字节数， buffer参数提供用来存放数据的内存缓冲区地址(由用户所提供)， 缓冲区至少应有count字节。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX_READ 20
</span><span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAX_READ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

<span class="kt">ssize_t</span> <span class="n">num_read</span><span class="p">;</span>
<span class="n">num_read</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">MAX_READ</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">num_read</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="n">buffer</span><span class="p">[</span><span class="n">num_read</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"The input data was: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</code></pre></div></div>

<p>从标准输入中读取数据和从文件中读取数据会有些许差异， 因为在默认情况下， 从终端读取字符会在遇到换行符(\n)时<code class="highlighter-rouge">read</code>调用就会结束， 而对于普通文件， 则不会这样。</p>

<p>现在来进一步地了解<code class="highlighter-rouge">read</code>系统调用背后所发生的事情。 当程序调用<code class="highlighter-rouge">read</code>方法时， 产生系统调用， 则当前程序执行的状态由用户态切换至内核态， 操作系统将所需要的文件内容读取至内核某缓冲区中。 同时， 由于I/O是一个相对来说代价较大的操作， 为了减少读取磁盘的数据， 操作系统还会额外的读取更多的内容进入内核缓冲区， 下次读取这些内容时， 直接从缓冲区中读取， 不再从磁盘中读取， 从而提升整体效率。 数据进入内核缓冲区后， 内核需要将数据复制到用户缓冲区中， 也就是<code class="highlighter-rouge">read</code>方法所传递的<code class="highlighter-rouge">void *buffer</code>中。 传输完毕后由内核态切换至用户态， <code class="highlighter-rouge">read</code>系统调用完成。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/Linux%20Read.png" alt="" /></p>

<p>在执行<code class="highlighter-rouge">read</code>系统调用时， 总计发生了2次用户态切换， 额外的一次数据复制(kernel to User)。 并且， kernel buffer中保存了多于用户当前所需的数据， 用于加快下一次的<code class="highlighter-rouge">read</code>调用。</p>

<p><code class="highlighter-rouge">write</code>系统调用将数据写入一个打开的文件中， 当调用成功时， 返回实际写入文件的字节数。 与<code class="highlighter-rouge">read</code>系统调用相同， <code class="highlighter-rouge">write</code>调用在返回成功时， 仅是将数据写入到内核缓冲区中， 再由内核寻找适当的时机将该部分数据真正地写入到磁盘中。</p>

<p>采用这一设计可以有效的减少内核必须执行的磁盘传输次数， 因为可能调用10次<code class="highlighter-rouge">write</code>系统调用， 内核仅进行一次磁盘写入， 不仅减少了单个<code class="highlighter-rouge">write</code>系统调用所需时间， 并且提高了操作系统整体的运作效率。</p>

<p>这一机制所带来的唯一问题就是由于数据在某一时刻仅暂存于内核缓冲区中， 当系统发生断电或者是意外宕机时， 该部分数据就会丢失。 对于数据库等对数据要求非常严格的系统， 这种数据丢失是无法接受的。 所以， 内核额外的提供了<code class="highlighter-rouge">fsync</code>等强制刷新数据至磁盘的系统调用。</p>

<p><code class="highlighter-rouge">fsync</code>系统调用将使缓冲区数据和与打开文件描述符fd相关的所有元数据都刷新到磁盘上， 调用<code class="highlighter-rouge">fsync</code>会强制使文件处于Synchronized I/O file integrity completion状态。 所以， 当程序想要确保数据完全写入磁盘时， 可在<code class="highlighter-rouge">write</code>调用后执行<code class="highlighter-rouge">fsync</code>调用， 进行强制刷盘。</p>

<h4 id="3-c标准io函数库">3. C标准I/O函数库</h4>

<p>上面所提到的<code class="highlighter-rouge">open</code>， <code class="highlighter-rouge">read</code>等系统调用均有Linux/Unix系统所提供， 如Windows等操作系统并不支持此类调用。 为了解决不同操作系统底层提供的通用I/O函数不同的问题， ANSI C制定了一系列的标准I/O函数， 其目的就是为了解决代码的可移植性问题以及屏蔽I/O细节(缓冲区大小的选择， 文件锁实现等)。</p>

<p>标准I/O函数库中最常用的方法为<code class="highlighter-rouge">fopen</code>， <code class="highlighter-rouge">fgets</code>,  <code class="highlighter-rouge">fputs</code>以及<code class="highlighter-rouge">printf</code>， <code class="highlighter-rouge">fprintf</code>。 <code class="highlighter-rouge">fopen</code>和<code class="highlighter-rouge">open</code>的作用类似， 以某种模式(只读、只写等)打开一个文件， 唯一不同的是<code class="highlighter-rouge">open</code>返回<code class="highlighter-rouge">int</code>类型的文件描述符， 而<code class="highlighter-rouge">fopen</code>返回<code class="highlighter-rouge">FILE</code>类型的指针。</p>

<p>为了更好的理解<code class="highlighter-rouge">FILE</code>文件对象， 首先需要了解C标准I/O库的过程。 C标准I/O库的底层实现， 同样是基于Linux提供的通用I/O函数， 只不过标准库对其进行了封装而已。</p>

<p>C标准库除了帮助用户处理平台可移植性问题以外， 还会帮助用户减少系统调用的次数， 但是会额外的增加数据在内存间的复制次数。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/C%20Standard%20Libary.png" alt="" /></p>

<p>如上图所示，与Linux通用I/O相比， C标准I/O库自身也维护一个类似于内核缓冲的缓冲池， 内核缓冲区的数据并不会直接被复制到用户缓冲区中， 而是复制到标准库缓冲区中。 并且， 所复制的字节数也远大于用户所需要的字节数(count)， 当下次进行内容读取时， 直接从标准缓冲区中读取， 而不需要进行系统调用从内核缓冲区中读取。</p>

<p>该方式从整体上减少了系统调用的次数， 额外的增加了一次用户空间的数据复制， 由于标准I/O函数对系统调用进行了二次封装， 所以解决了可移植性问题。</p>

<p><code class="highlighter-rouge">fputc</code>以及<code class="highlighter-rouge">fputs</code>分别向所关联的文件流中写入单个字符或者是一串字符。 由于标准IO缓冲区的存在， 调用该方法时仅是将数据写入到C标准IO缓冲区中， 而后C标准库根据相应的条件决定何时执行<code class="highlighter-rouge">write</code>系统调用， 将数据写入内核缓冲区。 此后， 内核将决定在适当的时机将数据真正地写入磁盘。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/fputc.png" alt="" /></p>

<h5 id="31-c标准io缓冲">3.1 C标准I/O缓冲</h5>

<p>标准IO库提供了3种类型的缓冲: 全缓冲、行缓冲以及不带缓冲。</p>

<p>在全缓冲类型下， C函数库只有在完全填满标准IO缓冲区后才进行实际的IO操作， 磁盘文件通常是全缓冲的。 也就是说， 当程序使用<code class="highlighter-rouge">fopen</code>打开一个磁盘文件并调用<code class="highlighter-rouge">fputs</code>进行数据写入时， 数据可能仅写入了标准IO缓冲区中。 在随后的<code class="highlighter-rouge">fputs</code>调用中， 若C标准IO函数发现缓冲区已满， 则进行一次系统调用， 将数据写入至内核缓冲区中。</p>

<p>在行缓冲区类型下， 在输入和输出中遇到换行符(\n)时， 标准IO库执行实际的IO操作。 当一个流涉及到终端时(如标准输出)， 通常时行缓冲的， 例如<code class="highlighter-rouge">printf</code>函数。</p>

<p>不带缓冲则表示只要向标准缓冲区中写入数据， 标准库就会立即进行系统调用， 将数据写入内核缓冲。 标准错误通常是不带缓冲的， 原因在于期望能够尽快的看到错误的产生。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;
#include&lt;fcntl.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"This is printf out | "</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"This is a error output | "</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"BiuBiu</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello Aean: "</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">"I would have written you a short letter. | "</span><span class="p">;</span>
    <span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">43</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>编译并运行上述代码， 将会得到:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is a error output | This is <span class="nb">printf </span>out | BiuBiu
I would have written you a short letter. | Hello Aean:
</code></pre></div></div>

<p>当标准IO函数与系统调用混合使用时， 将会看到与代码期望完全不同的结果。 尽管<code class="highlighter-rouge">printf</code>函数在<code class="highlighter-rouge">fprintf</code>之前执行， 但由于<code class="highlighter-rouge">printf</code>为行缓冲， 而标准错误为不带缓冲， 所以标准错误信息将在标准输出信息打印之前打印。 <code class="highlighter-rouge">write</code>函数为系统调用， 输出的时机要优先于不带换行符的标准输出。</p>

<p>标准IO函数库同时也提供了<code class="highlighter-rouge">fflush</code>函数， 用于将标准缓冲区的数据强制刷新至内核， 如果我们在<code class="highlighter-rouge">printf</code>函数调用后调用<code class="highlighter-rouge">fflush</code>， 则会在标准错误输出之前看到输出。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"This is printf out | "</span><span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"This is a error output | "</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其结果为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is <span class="nb">printf </span>out | This is a error output
</code></pre></div></div>

<p>使用过Docker部署Python项目的小伙伴儿可能对环境变量<code class="highlighter-rouge">PYTHONUNBUFFERED</code>感到很熟悉， 官方文档解释如下:</p>

<blockquote>
  <p>Force stdin, stdout and stderr to be totally unbuffered. On systems where it matters, also put stdin, stdout and stderr in binary mode.</p>
</blockquote>

<p>简单来说， 在Docker中使用该变量， 能够更快的使日志输出， 并且在容器crash的情况下， 也能看到必要的日志信息。</p>

<p>更详细的解释:</p>

<blockquote>
  <p>Setting PYTHONUNBUFFERED=TRUE or PYTHONUNBUFFERED=1 (they are equivalent) allows for log messages to be immediately dumped to the stream instead of being buffered. This is useful for receiving timely log messages and avoiding situations where the application crashes without emitting a relevant message due to the message being “stuck” in a buffer.
As for performance, there can be some (minor) loss that comes with using unbuffered I/O. To mitigate this, I would recommend limiting the number of log messages. If it is a significant concern, one can always leave buffered I/O on and manually flush the buffer when necessary.</p>
</blockquote>

<p>有关Linux通用IO以及C标准IO库的缓冲区， 可用下图清晰总结。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/IO%20buffer.png" alt="" /></p>

<p>原图来源于Linux/Unix系统编程手册， P200。</p>

<h4 id="4-内存映射io">4. 内存映射I/O</h4>

<p>现代操作系统大多数均采用分段+分页的方式来管理内存空间， 其目的就在于使得每一个进程的地址空间独立， 并且使系统能够运行超过其内存空间总数的各种进程。</p>

<p>分页内存管理的基本思想就是映射， 思想和哈希表基本类似: 将一个大范围的空间映射至一个小范围空间内。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/virtaul%20memory.png" alt="" /></p>

<p>当程序想要访问的虚拟地址没有在页表项建立映射时， 系统将发起一个”缺页异常”， 由操作系统建立页表项并建立虚拟地址页与物理地址页的映射关系。 如此一来， 能够使得不常用的数据或者是内存片段被细粒度地换置至磁盘中， 内存中保留常用的数据。</p>

<p><code class="highlighter-rouge">mmap</code>方法的原理与虚拟内存映射基本相同， 将进程的一部分地址空间与磁盘文件建立映射关系， 将文件当做是内存中的一个数组使用， 减少<code class="highlighter-rouge">read</code>, <code class="highlighter-rouge">write</code>以及<code class="highlighter-rouge">lseek</code>的调用。</p>

<p>需要注意的是， 内存映射一个文件并不会导致整个文件被读取到内存中， 就如同虚拟内存空间不会都在物理地址空间一样， 而是仅仅为需要的文件数据保留映射关系。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">mmap</span>

<span class="k">def</span> <span class="nf">memory_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="n">mmap</span><span class="o">.</span><span class="n">ACCESS_WRITE</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDWR</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mmap</span><span class="o">.</span><span class="n">mmap</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="n">access</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">memory_map</span><span class="p">(</span><span class="s">'hello.txt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">15</span><span class="p">])</span>
</code></pre></div></div>

<p>此外，使用内存映射I/O的读写并不一定会比C标准I/O库或者是Linux通用I/O更加高效， 其原因在于虽然<code class="highlighter-rouge">mmap</code>减少了用户态的切换以及减少了数据的复制， 但是增加了处理缺页错误、建立页表项的时间， 并且各个平台对于<code class="highlighter-rouge">mmap</code>的实现也各有不同， 其优点就在于更加简洁的随机读取以及数据写入。</p>

<h4 id="5-异步io">5. 异步I/O</h4>

<p>异步I/O的实现通常会有两种: 当文件可读/可写时， 内核向进程发送一个信号， 或者是内核调用进程提供的回调函数。 在Linux下， AIO有2种实现: 基于线程模拟异步I/O的glibc AIO， 以及由内核实现的Kernel AIO。</p>

<p>对于glibc AIO而言， 是在用户空间使用多线程来模拟实现的， 并不能真正的称之为异步I/O， 但是能够在任意的文件系统、任意的操作系统上运行。</p>

<p>而Kernel AIO采用信号通知的方式实现异步I/O， 只能在Linux操作系统上运行， 基本没有可移植性。 此外， 一个最重要的问题就是Kernel AIO要求用户必须使用<code class="highlighter-rouge">O_DIRECT</code>模式打开文件， 即绕过内核高速缓冲区， 直接将数据传递至文件或者是磁盘设备， 这种方式又称为直接I/O(direct I/O)。</p>

<p>对于大多数应用而言， 使用直接I/O可能会大大的降低性能， 并且会有诸多不便之处。 其原因在于内核针对缓冲区高速缓存做了不少优化， 包括按顺序读取， 在成簇磁盘块上执行I/O， 允许访问同一文件的多个进程共享内核缓冲区。 并且， 直接I/O由于直接将数据传输至磁盘， 所以必须遵守磁盘的一些限制， 包括但不限于: 用于传递数据的缓冲区其内存边界必须对齐为块大小的整数倍， 待传输的数据长度必须是块大小的整数倍…</p>

<p>正是因为诸多限制， 不管是glibc AIO， 还是Kernel AIO， 在绝大部分的应用中都未曾使用， 看起来AIO就是专门为数据库应用所提供的实现。</p>

<h4 id="6-zero-copysendfile">6. Zero Copy(sendfile)</h4>

<p><code class="highlighter-rouge">sendfile</code>系统调用用于在两个文件描述符之间传输数据， 在Linux Kernel 2.6.33以前， <code class="highlighter-rouge">sendfile</code>只能将数据从一个具体的文件发送到一个<code class="highlighter-rouge">socket</code>中。 而在此版本之后， <code class="highlighter-rouge">sendfile</code>的接收方可以是任意的文件， 但是输入端只能是存在于虚拟内存空间的文件描述符， <code class="highlighter-rouge">socket</code>则不在此列。</p>

<p>方法原型为:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;sys/sendfile.h&gt;
</span>
<span class="kt">ssize_t</span> <span class="n">sendfile</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__out_fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__in_fd</span><span class="p">,</span> <span class="kt">off_t</span> <span class="o">*</span><span class="n">__offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">__count</span><span class="p">);</span>
</code></pre></div></div>

<p>一个简单的文件复制示例:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;fcntl.h&gt;
#include&lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/sendfile.h&gt;
</span>
<span class="kt">int</span> <span class="nf">get_file_size</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">stat</span> <span class="n">statbuf</span><span class="p">;</span>
    <span class="n">stat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statbuf</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">statbuf</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 省去错误判断
</span>    <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"foo.txt"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"bar.txt"</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">foo_size</span> <span class="o">=</span> <span class="n">get_file_size</span><span class="p">(</span><span class="s">"foo.txt"</span><span class="p">);</span>
    <span class="n">sendfile</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="n">foo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">foo_size</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外需要注意的是， <code class="highlighter-rouge">sendfile</code>在文件之间传输数据时， 并不支持<code class="highlighter-rouge">O_APPEND</code> flags， 只能覆盖写入。</p>

<p><code class="highlighter-rouge">sendfile</code>系统调用完全在内核空间进行， 数据不会从内核空间拷贝至用户空间， 并且能够得到DMA的硬件支持， 因而速度很快。</p>

<h4 id="7-总结">7. 总结</h4>

<p>对于非数据库类型的应用而言， 文件I/O的可选范围并不广， 即与其花费大量时间调试异步I/O， 不如直接选择C标准库I/O， 因为同时监听成百上千的文件读写并不常见。 对于频繁随机读取和写入的文件而言， 可以使用内存映射I/O来减少<code class="highlighter-rouge">lseek</code>的调用， 而<code class="highlighter-rouge">sendfile</code>系统调用更多地应用于文件至socket的数据传输。</p>

	  ]]></description>
	</item>


</channel>
</rss>
