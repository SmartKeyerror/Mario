<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description>Keep coding, Keep curiosity</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Python虚拟机</title>
	  <link>//Python-Virtual-Machine</link>
	  <author></author>
	  <pubDate>2020-08-18T10:50:25+00:00</pubDate>
	  <guid>//Python-Virtual-Machine</guid>
	  <description><![CDATA[
	     <p>我们常说Python一是门解释型语言，只需要敲下<code class="highlighter-rouge">python code.py</code>就可以运行编写的代码，而无需使用类似于<code class="highlighter-rouge">javac</code>或者<code class="highlighter-rouge">gcc</code>进行编译。那么，Python解释器是真的一行一行读取Python源代码而后执行吗? 实际上，Python在执行程序时和Java、C#一样，都是先将源码进行编译生成字节码，然后由虚拟机进行执行，只不过Python解释器把这两步合二为一了而已。</p>

<!---more--->

<h3 id="1-python程序执行过程">1. Python程序执行过程</h3>

<p>事实上，Python程序在执行过程中同样需要编译(Compile)，编译产生的结果称之为字节码，而后由Python虚拟机逐行地执行这些字节码。所以，Python解释器由两部分组成: 编译器和虚拟机。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/process.png" alt="" /></p>

<p>上图展示了Python程序的执行过程，以及C程序的编译、汇编与链接过程，从该图中可以非常明显地看出Python与C程序的执行区别。Python如此设计的原因在于将程序的执行与底层硬件进一步地分离，无需担心程序的编译、汇编以及链接过程，使得Python程序相较于C程序而言更加易于移植。</p>

<p>这里再说一下Python和Java的区别。Java在程序执行时必须使用<code class="highlighter-rouge">javac</code>对源代码进行编译，但是并不直接编译成机器语言，而是和Python一样，编译成字节码，而后由JVM进行执行。从这一点上来看，Python和Java非常类似，只不过Python的编译过程由解释器完成，用户也可以手动的对Python源代码进行编译，生成<code class="highlighter-rouge">.pyc</code>文件，节省那么一丢丢的时间。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-m</span> compileall &lt;dir&gt;
</code></pre></div></div>

<p>通过运行上述命令可对<code class="highlighter-rouge">&lt;dir&gt;</code>目录下所有的Python文件进行编译，编译结果将会存放于该目录下的<code class="highlighter-rouge">__pycache__</code>的<code class="highlighter-rouge">.pyc</code>文件中。</p>

<h3 id="2-编译过程与字节码">2. 编译过程与字节码</h3>

<p>在Python的内建函数中，定义了<code class="highlighter-rouge">compile</code>以及<code class="highlighter-rouge">exec</code>两个方法，前者将源代码编译成为Code Object对象，Code Object对象中即保存着源代码所对应的字节。而<code class="highlighter-rouge">exec</code>方法则是运行Python语句或者是由<code class="highlighter-rouge">compile</code>方法所返回的Code Object。<code class="highlighter-rouge">exec</code>方法可直接运行Python语句，其参数并一定需要是Code Object。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">snippet</span> <span class="o">=</span> <span class="s">"for i in range(3): print(f'Output: {i}')"</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">snippet</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="s">"exec"</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">result</span>
<span class="o">&lt;</span><span class="n">code</span> <span class="nb">object</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span> <span class="n">at</span> <span class="mh">0x7f8e7e6471e0</span><span class="p">,</span> <span class="nb">file</span> <span class="s">""</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">exec</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">2</span>
</code></pre></div></div>

<p>在上述代码中定义了一个非常简单的Python代码片段，其作用就是在标准输出中打印0，1，2这三个数而已。通过<code class="highlighter-rouge">compile</code>方法对该片段进行编译，得到Code Object对象，并将该对象交由<code class="highlighter-rouge">exec</code>函数执行。下面来具体看下返回的Code Object中到底包含了什么。</p>

<p>在源码<code class="highlighter-rouge">cpython/Include/code.h</code>中定义了<code class="highlighter-rouge">PyCodeObject</code>结构体，即Code Object对象:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Bytecode object */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>               <span class="cm">/* Python定长对象头 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_code</span><span class="p">;</span>          <span class="cm">/* 指令操作码，即字节码 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_consts</span><span class="p">;</span>        <span class="cm">/* 常量列表 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_names</span><span class="p">;</span>         <span class="cm">/* 名称列表(不一定是变量，也可能是函数名称、类名称等) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_filename</span><span class="p">;</span>      <span class="cm">/* 源码文件名称 */</span>
    
    <span class="p">...</span>                         <span class="cm">/* 省略若干字段 */</span>
<span class="p">}</span> <span class="n">PyCodeObject</span><span class="p">;</span>
</code></pre></div></div>

<p>字段<code class="highlighter-rouge">co_code</code>即为Python编译后字节码，其它字段在此处可暂时忽略。字节码的格式为人类不可阅读格式，其形式通常是这样的:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">co_code</span>
<span class="n">b</span><span class="s">'x</span><span class="se">\x1e</span><span class="s">e</span><span class="se">\x00</span><span class="s">d</span><span class="se">\x00\x83\x01</span><span class="s">D</span><span class="se">\x00</span><span class="s">]</span><span class="se">\x12</span><span class="s">Z</span><span class="se">\x01</span><span class="s">e</span><span class="se">\x02</span><span class="s">d</span><span class="se">\x01</span><span class="s">e</span><span class="se">\x01\x9b\x00\x9d\x02\x83\x01\x01\x00</span><span class="s">q</span><span class="se">\n</span><span class="s">W</span><span class="se">\x00</span><span class="s">d</span><span class="se">\x02</span><span class="s">S</span><span class="se">\x00</span><span class="s">'</span>
</code></pre></div></div>

<p>这个时候我们需要一个”反汇编器”来将字节码转换成人类可阅读的格式，”反汇编器”打引号的原因是在Python中并不能称为真正的反汇编器。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">dis</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">co_code</span><span class="p">)</span>
          <span class="mi">0</span> <span class="n">SETUP_LOOP</span>              <span class="mi">30</span> <span class="p">(</span><span class="n">to</span> <span class="mi">32</span><span class="p">)</span>
          <span class="mi">2</span> <span class="n">LOAD_NAME</span>                <span class="mi">0</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
          <span class="mi">4</span> <span class="n">LOAD_CONST</span>               <span class="mi">0</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
          <span class="mi">6</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">1</span>
          <span class="mi">8</span> <span class="n">GET_ITER</span>
    <span class="o">&gt;&gt;</span>   <span class="mi">10</span> <span class="n">FOR_ITER</span>                <span class="mi">18</span> <span class="p">(</span><span class="n">to</span> <span class="mi">30</span><span class="p">)</span>
         <span class="mi">12</span> <span class="n">STORE_NAME</span>               <span class="mi">1</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
         <span class="mi">14</span> <span class="n">LOAD_NAME</span>                <span class="mi">2</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
         <span class="mi">16</span> <span class="n">LOAD_CONST</span>               <span class="mi">1</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
         <span class="mi">18</span> <span class="n">LOAD_NAME</span>                <span class="mi">1</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
         <span class="mi">20</span> <span class="n">FORMAT_VALUE</span>             <span class="mi">0</span>
         <span class="mi">22</span> <span class="n">BUILD_STRING</span>             <span class="mi">2</span>
         <span class="mi">24</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">1</span>
         <span class="mi">26</span> <span class="n">POP_TOP</span>
         <span class="mi">28</span> <span class="n">JUMP_ABSOLUTE</span>           <span class="mi">10</span>
    <span class="o">&gt;&gt;</span>   <span class="mi">30</span> <span class="n">POP_BLOCK</span>
    <span class="o">&gt;&gt;</span>   <span class="mi">32</span> <span class="n">LOAD_CONST</span>               <span class="mi">2</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
         <span class="mi">34</span> <span class="n">RETURN_VALUE</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">dis</code>方法将返回字节码的助记符(mnemonics)，和汇编语言非常类似，从这些助记符的名称上我们就可以大概猜出解释器将要执行的动作，例如<code class="highlighter-rouge">LOAD_NAME</code>加载名称，<code class="highlighter-rouge">LOAD_CONST</code>加载常量。所以，我们完全可以将这些助记符看作是汇编指令，而指令的操作数则在助记符后面描述。例如<code class="highlighter-rouge">LOAD_NAME</code>操作，其操作数的下标为0，而在源代码中使用过的名称保存在<code class="highlighter-rouge">co_names</code>字段中，所以<code class="highlighter-rouge">LOAD_NAME  0</code>即表示加载<code class="highlighter-rouge">result.co_names[0]</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">co_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="s">'range'</span>
</code></pre></div></div>

<p>又比如<code class="highlighter-rouge">LOAD_CONST</code>操作，其操作数的下标也为0，只不过这次操作数不再保存在<code class="highlighter-rouge">co_names</code>，而是<code class="highlighter-rouge">co_consts</code>中，所以<code class="highlighter-rouge">LOAD_CONST  0</code>则表示加载<code class="highlighter-rouge">result.co_consts[0]</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">co_consts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">3</span>
</code></pre></div></div>

<p>由于Code Object对象保存了常量、变量、名称等一系列的上下文内容，所以可以直接对该对象进行反汇编操作:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
  <span class="mi">1</span>           <span class="mi">0</span> <span class="n">SETUP_LOOP</span>              <span class="mi">30</span> <span class="p">(</span><span class="n">to</span> <span class="mi">32</span><span class="p">)</span>
              <span class="mi">2</span> <span class="n">LOAD_NAME</span>                <span class="mi">0</span> <span class="p">(</span><span class="nb">range</span><span class="p">)</span>
              <span class="mi">4</span> <span class="n">LOAD_CONST</span>               <span class="mi">0</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
              <span class="o">...</span>
</code></pre></div></div>

<p>现在，我们可以对Python字节码做一下小结了。Python在编译某段源码时，并不会直接返回字节码，而是返回一个Code Object对象，字节码则保存在该对象的<code class="highlighter-rouge">co_code</code>字段中。由于字节码是一个二进制字节序列，无法直接进行阅读，所以需要通过”反汇编器”(<code class="highlighter-rouge">dis</code>模块)将字节码转换成人类可读的助记符。助记符的形式和汇编语言非常类似，均由操作指令+操作数所组成。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/Compile.png" alt="" /></p>

<h3 id="3-命名空间与作用域">3. 命名空间与作用域</h3>

<p>Python的命名空间与作用域经常被开发者所忽略，在未深入了解Python虚拟机之前，我个人也认为这些东西并不重要。但是，命名空间和变量作用域将会是Python虚拟机在执行过程中一个非常重要的一环。</p>

<p>命名空间实际上是名称到对象的一种映射，本质上就是一个键-值对，所以大部分的命名空间由<code class="highlighter-rouge">dict</code>实现。命名空间可以分为3类: 内置命名空间，全局命名空间与局部命名空间，在作用域存在嵌套的特殊情况下，可能还会有闭包命名空间。</p>

<h4 id="31-内置命名空间build-in">3.1 内置命名空间(Build-in)</h4>
<p>Python语言内置的名称，例如内置函数名(<code class="highlighter-rouge">len</code>, <code class="highlighter-rouge">dis</code>)，内置异常(<code class="highlighter-rouge">Exception</code>)等。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">builtins</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">builtins</span><span class="o">.</span><span class="n">__dict__</span>
</code></pre></div></div>

<h4 id="32-全局命名空间global">3.2 全局命名空间(Global)</h4>

<p>全局命名空间以模块进行划分，每一个模块中都包含了<code class="highlighter-rouge">dict</code>对象，其中保存了模块中的变量名、类名、函数名等等。</p>

<h4 id="33-局部命名空间local">3.3 局部命名空间(Local)</h4>

<p>局部命名空间可以简单的认为就是函数的命名空间，例如函数参数，在函数中定义的局部变量。</p>

<p>在局部命名空间中，有一个非常特殊的情况，就是类定义:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Reader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">4096</span>
    
    <span class="k">class</span> <span class="nc">Inner</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">)</span>
</code></pre></div></div>

<p>在执行<code class="highlighter-rouge">Reader.Inner()</code>语句时，将会抛出<code class="highlighter-rouge">NameError</code>的异常，表示<code class="highlighter-rouge">BUFFER_SIZE</code>未定义。其原因在于类的嵌套并不等同于函数嵌套</p>

<h4 id="34-闭包命名空间enclosing">3.4 闭包命名空间(Enclosing)</h4>

<p>当出现嵌套函数定义时，或者作用域嵌套时，Python将会把内层作用域所依赖的所有外层命名存储在一个特殊的命名空间中，也就是闭包命名空间。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s">"Execute func: {func.__name__}"</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div>

<p>闭包指函数，而不是类，所以在类的嵌套中，将不会存在闭包命名空间:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Reader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">4096</span>
    
    <span class="k">class</span> <span class="nc">Inner</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">)</span>
</code></pre></div></div>

<p>在执行<code class="highlighter-rouge">Reader.Inner()</code>语句时，将会抛出<code class="highlighter-rouge">NameError</code>的异常，表示<code class="highlighter-rouge">BUFFER_SIZE</code>未定义。</p>

<p>当语句需要查找变量<code class="highlighter-rouge">X</code>时，将会按照 Local -&gt; Enclosing -&gt; Global -&gt; Builtin 的顺序进行查找，俗称LEGB规则。</p>

<h3 id="4-python虚拟机的执行">4. Python虚拟机的执行</h3>

<h4 id="41-执行上下文栈帧">4.1 执行上下文——栈帧</h4>

<p>在 x86-64 CPU 中包含了16个64位的通用目的寄存器，这些寄存器用于存储数据或者是指针。在这16个通用目的寄存器中，有两个较为特殊的寄存器: %rsp 与 %rbp。%rsp 为栈指针寄存器，表示运行时栈的结束位置，可以简单地理解为栈顶。%rbp 为栈帧指针，用于标识当前栈帧的起始位置。</p>

<p>在x86体系结构中，函数调用是通过栈和栈帧实现的。当一个函数被调用时，首先做的事情就是将调用者栈帧指针入栈，以保留调用关系。其次将为调用的函数创建栈帧，栈帧中包含了函数的参数、创建的局部变量等信息。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/x86-Stack.png" alt="" /></p>

<p>回到Python虚拟机中，虚拟机在进行函数调用时，运行方式和x86没什么区别，都是由栈和栈帧所实现的。而栈帧则是由<code class="highlighter-rouge">PyFrameObject</code>表示，于源码<code class="highlighter-rouge">cpython/Include/frameobject.h</code>中定义。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_frame</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>           <span class="cm">/* Python固定长度对象头 */</span>
    <span class="k">struct</span> <span class="n">_frame</span> <span class="o">*</span><span class="n">f_back</span><span class="p">;</span>      <span class="cm">/* 指向上一个栈帧的指针 */</span>
    <span class="n">PyCodeObject</span> <span class="o">*</span><span class="n">f_code</span><span class="p">;</span>       <span class="cm">/* Code Object代码对象，其中包含了字节码 */</span>
    
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_builtins</span><span class="p">;</span>       <span class="cm">/* 内建命名空间字典(PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_globals</span><span class="p">;</span>        <span class="cm">/* 全局命名空间字典(PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_locals</span><span class="p">;</span>         <span class="cm">/* 局部命名空间表(通常是数组) */</span>

    <span class="kt">int</span> <span class="n">f_lasti</span><span class="p">;</span>                <span class="cm">/* 上一条指令编号 */</span>
    
    <span class="p">...</span>
<span class="p">}</span> <span class="n">PyFrameObject</span><span class="p">;</span>
</code></pre></div></div>

<p>可以看到，在一个栈帧中包含了Code Object代码对象，三个命名空间表，上一个栈帧指针等信息。可以说，<code class="highlighter-rouge">PyFrameObject</code>对象包含了Python虚拟机执行所需的全部上下文。结合前面提到的字节码和命名空间，我们可以用一张简图来描述。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/FrameObject.png" alt="" /></p>

<h4 id="42-指令的执行">4.2 指令的执行</h4>

<p>指令执行的源码均位于<code class="highlighter-rouge">cpython/Python/ceval.c</code>中，入口函数有两个，一个是<code class="highlighter-rouge">PyEval_EvalCode</code>，另一个则是<code class="highlighter-rouge">PyEval_EvalCodeEx</code>，最终的实际调用函数为<code class="highlighter-rouge">_PyEval_EvalCodeWithName</code>，所以我们只需要关注该函数即可。</p>

<p><code class="highlighter-rouge">_PyEval_EvalCodeWithName</code>函数的主要作用为进行函数调用的例常检查，例如校验函数参数的个数、类型，校验关键字参数等。除此之外，该函数将会初始化栈帧对象并将其交给<code class="highlighter-rouge">PyEval_EvalFrame</code>函数进行处理，最终由<code class="highlighter-rouge">_PyEval_EvalFrameDefault</code>函数真正的运行指令。</p>

<p><code class="highlighter-rouge">_PyEval_EvalFrameDefault</code>函数定义超过了3K行，绝大部分的逻辑其实都是<code class="highlighter-rouge">switch-case</code>: 根据指令类型执行相应的逻辑。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">LOAD_CONST</span><span class="p">):</span> <span class="p">{</span>      <span class="cm">/* 加载常量 */</span>
            <span class="p">...</span>
        <span class="p">}</span>		
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">ROT_TWO</span><span class="p">):</span> <span class="p">{</span>         <span class="cm">/* 交换两个变量 */</span>
            <span class="p">...</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">FORMAT_VALUE</span><span class="p">):{</span>     <span class="cm">/* 格式化字符串 */</span>
            <span class="p">...</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>可以看到<code class="highlighter-rouge">TARGET()</code>调用中的参数其实就是<code class="highlighter-rouge">dis</code>方法返回的助记符，当我们在分析助记符的具体实现逻辑时，可以在该文件中找到对应的C实现方法。</p>

<h4 id="43-gil与字节码的执行">4.3 GIL与字节码的执行</h4>

<p>对于Python中的容器，例如dict，并没有实现像Java中的<code class="highlighter-rouge">ConcurrentHashMap</code>，或者是Golang中的<code class="highlighter-rouge">sync.Map</code>，这是因为Python中的容器(list, dict)本身就是并发安全的，但是在这些容器的源码中并没有发现定义<code class="highlighter-rouge">mutex</code>，也就是说，Python容器的并发安全并不是通过互斥锁实现的。</p>

<p>实际上，Python容器的并发安全是通过GIL实现的，也就是被广大Pythoner口诛笔伐的全局解释器锁。某一个线程想要运行必须要首先获取全局锁，如此一来，在同一时刻只能有一个线程运行，无法充分利用多核的硬件资源。</p>

<p>Python的线程调度非常类似于CPU的时间片实现，只不过并不是以时间为判断标准，而是以执行字节码的数量作为判断标准。当某一个线程执行了足够多的字节码条数时，当前线程将释放全局锁，唤醒其它线程进行执行。</p>

<p><strong>所以，得益于GIL的存在，Python容器在进行诸如扩容、缩容操作时，完全不必担心并发问题，因为一条字节码的执行一定是原子性的。</strong></p>

	  ]]></description>
	</item>

	<item>
	  <title>揭开Python元类(metaclass)神秘的面纱</title>
	  <link>//Python-metaclass</link>
	  <author></author>
	  <pubDate>2020-07-13T10:06:25+00:00</pubDate>
	  <guid>//Python-metaclass</guid>
	  <description><![CDATA[
	     <p>Python语言的<code class="highlighter-rouge">metaclass</code>特性一直是初学者的”噩梦”，当初博主在学习元类时也是一头雾水，但是一旦真正的理解了什么是”动态语言”之后，元类就不再神秘与难以理解了。Python这门动态语言最大的特性就是不需要一个类的字节码就能够在运行时创建出一个类，这是理解元类最为关键的信息。</p>

<!---more--->

<h3 id="1-基础知识汇总">1. 基础知识汇总</h3>

<h4 id="11-stackoverflow">1.1 stackoverflow</h4>

<p>首先，强烈推荐阅读stackoverflow上关于<code class="highlighter-rouge">metaclass</code>的回答，作者并没有使用什么高级词汇，就算英语稀烂也能看的懂。</p>

<blockquote>
  <p>https://stackoverflow.com/a/6581949/12523821</p>
</blockquote>

<h4 id="12-类属性和实例属性">1.2 类属性和实例属性</h4>

<p>类属性表示绑定在一个类上的属性，而实例属性则是绑定在不同实例上的属性，类属性只有一份，而实例属性则可以有多份。当实例属性和类属性重名，并通过实例获取该属性时，会返回实例属性，而不是类属性。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">Hugo</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Hugo</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>      <span class="c"># "smart"</span>

    <span class="n">hugo</span> <span class="o">=</span> <span class="n">Hugo</span><span class="p">(</span><span class="s">"raven"</span><span class="p">)</span>  
    <span class="k">print</span><span class="p">(</span><span class="n">hugo</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>      <span class="c"># "raven"</span>

    <span class="k">print</span><span class="p">(</span><span class="n">Hugo</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>      <span class="c"># "smart"</span>
</code></pre></div></div>

<h4 id="13-__new__方法和__init__方法">1.3 <code class="highlighter-rouge">__new__</code>方法和<code class="highlighter-rouge">__init__</code>方法</h4>

<p>在Python中，实际创建对象的过程是由<code class="highlighter-rouge">__new__</code>方法控制的，该方法接收class对象(cls)。而<code class="highlighter-rouge">__init__</code>方法则是在<code class="highlighter-rouge">__new__</code>方法所创建的对象实例上，进行属性的赋值或者其它操作，所以接收实例对象(self)。</p>

<p>当想要控制创建对象的过程时，应该使用<code class="highlighter-rouge">__new__</code>方法，例如常用的单例模式，而不是使用<code class="highlighter-rouge">__init__</code>方法:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Lock</span>

<span class="k">class</span> <span class="nc">SingletonClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">instance</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span>
        <span class="k">with</span> <span class="n">cls</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="c"># double check</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span><span class="p">:</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span>
</code></pre></div></div>

<h4 id="14-mro">1.4 MRO</h4>

<p>Python是通过MRO列表来实现类的继承的，MRO列表的构造由C3线性化算法实现。实际上，类的继承层级关系最终会表现成包含所有基类的线性顺序表。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Parent init"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Children</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Children</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Children init"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Grandchildren</span><span class="p">(</span><span class="n">Children</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Grandchildren</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Grandchildren init"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Grandchildren</span><span class="o">.</span><span class="n">__mro__</span><span class="p">)</span>
</code></pre></div></div>

<p>运行结果为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>
    &lt;class <span class="s1">'__main__.Grandchildren'</span><span class="o">&gt;</span>, 
    &lt;class <span class="s1">'__main__.Children'</span><span class="o">&gt;</span>, 
    &lt;class <span class="s1">'__main__.Parent'</span><span class="o">&gt;</span>, 
    &lt;class <span class="s1">'object'</span><span class="o">&gt;</span>
<span class="o">)</span>
</code></pre></div></div>

<p>其顺序与继承顺序刚好相反，也就是说，通过类的<code class="highlighter-rouge">__mro__</code>属性即可找到该类的所有父类，包括<code class="highlighter-rouge">object</code>类。</p>

<p>Python同时也提供了内建的反射函数，来返回某个类的MRO列表:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">getmro</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">__mro__</span>
</code></pre></div></div>

<h3 id="2-metaclass">2. metaclass</h3>

<p>我们已经知道了<code class="highlighter-rouge">metaclass</code>是创建一个类的工具，通过<code class="highlighter-rouge">metaclass</code>能够更加灵活地动态地创建一个类，其中一个非常重要的结果就是能够获取到”子类”的全部信息，例如类属性、类方法等。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"get class field: {name}===&gt;{value}"</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">HugoMetaclass</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="n">gender</span> <span class="o">=</span> <span class="s">"male"</span>
</code></pre></div></div>

<p>运行上述代码将会打印出<code class="highlighter-rouge">Hugo</code>类的所有属性信息:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>get class field: <span class="nv">__module__</span><span class="o">===&gt;</span>__main__
get class field: <span class="nv">__qualname__</span><span class="o">===&gt;</span>Hugo
get class field: <span class="nv">name</span><span class="o">===&gt;</span>smart
get class field: <span class="nv">gender</span><span class="o">===&gt;</span>male
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">__module__</code>和<code class="highlighter-rouge">__qualname__</code>为内部属性，而<code class="highlighter-rouge">name</code>和<code class="highlighter-rouge">gender</code>则是用户自定义的类属性。可以看到，在<code class="highlighter-rouge">HugoMetaclass。__new__</code>方法中，完全能够获取到<code class="highlighter-rouge">Hugo</code>类的相关类属性，那么更进一步地来说，不管用户定义了什么样的类属性，都可以使用<code class="highlighter-rouge">metaclass</code>在创建该类之前获取到该类的所有属性。这就为诸如ORM、表单验证等基础服务提供了构建的基础。</p>

<h4 id="21-metaclass的应用">2.1 metaclass的应用</h4>

<p><code class="highlighter-rouge">type</code>的<code class="highlighter-rouge">__new__</code>方法接收4个参数，分别为类对象，类名称，父类元组以及类属性。这四个参数中最为关键的就是父类元组和类属性，通常项目中使用<code class="highlighter-rouge">metaclass</code>时也是和这两个参数频繁打交道。</p>

<h5 id="211-父类元组">2.1.1 父类元组</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">HugoMetaclass</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">HugoChild</span><span class="p">(</span><span class="n">Hugo</span><span class="p">):</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p>运行后将得到以下结果:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">()</span>
<span class="o">(</span>&lt;class <span class="s1">'__main__.Hugo'</span><span class="o">&gt;</span>,<span class="o">)</span>
</code></pre></div></div>

<p>一共需要创建两个类: <code class="highlighter-rouge">Hugo</code>和<code class="highlighter-rouge">HugoChild</code>，<code class="highlighter-rouge">Hugo</code>类直接使用<code class="highlighter-rouge">HugoMetaclass</code>创建，所以其父类元组为空。而<code class="highlighter-rouge">HugoChild</code>直接继承自<code class="highlighter-rouge">Hugo</code>，所以其父类为<code class="highlighter-rouge">Hugo</code>。所以，可以通过<code class="highlighter-rouge">bases</code>参数来判断当前创建的类是否需要进行处理。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 这里所创建的类都是Hugo的子类, 而不是Hugo类</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="212-类属性">2.1.2 类属性</h5>

<p>类属性是”子类”中最为重要的数据，可以说元类的最终目的就是为了根据类属性创建出一个模板，将该模板数据保存在类中。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>

        <span class="c"># 对Hugo类不做任何处理</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="n">klass</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 保存attrs中所有的int类型数据</span>
        <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">klass</span>
        
<span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">HugoMetaclass</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">HugoChild</span><span class="p">(</span><span class="n">Hugo</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="n">age</span> <span class="o">=</span> <span class="mi">24</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
</code></pre></div></div>

<p>上面创建了一个<code class="highlighter-rouge">int</code>类型的”模板”，并保存在了<code class="highlighter-rouge">declared_fields</code>这个字典中。注意不要将<code class="highlighter-rouge">declared_fields</code>挂到<code class="highlighter-rouge">mcs</code>上，<code class="highlighter-rouge">mcs</code>就是<code class="highlighter-rouge">HugoMetaclass</code>，变量绑定到<code class="highlighter-rouge">mcs</code>上会丢失一些信息，导致程序出现BUG。</p>

<p>那么如果<code class="highlighter-rouge">HugoChild</code>又有子类呢? 上述方式是否能够将<code class="highlighter-rouge">HugoChild</code>和其子类的属性一起获取到呢?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoChild</span><span class="p">(</span><span class="n">Hugo</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="n">age</span> <span class="o">=</span> <span class="mi">24</span>

<span class="k">class</span> <span class="nc">HugoGrandChild</span><span class="p">(</span><span class="n">HugoChild</span><span class="p">):</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mi">180</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Hugo</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoGrandChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
</code></pre></div></div>

<p>这时候会发现，这三个类的<code class="highlighter-rouge">declared_fields</code>结果都是<code class="highlighter-rouge">{'height': 180}</code>，<code class="highlighter-rouge">age</code>字段丢失了。原因也很简单，在创建<code class="highlighter-rouge">HugoGrandChild</code>类时，<code class="highlighter-rouge">declared_fields</code>被重新声明成了空字典，所以<code class="highlighter-rouge">HugoChild</code>中的类属性就会丢失。那么有没有什么办法能够得到完整版呢? 这就需要用到上面所提到的MRO列表了。</p>

<p>我们可以通过MRO列表，来获取到<code class="highlighter-rouge">HugoGrandChild</code>的所有父类，而后逐一的遍历找出类型为<code class="highlighter-rouge">int</code>的类属性，保存在<code class="highlighter-rouge">declared_fields</code>这个字典中。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>

        <span class="c"># 对Hugo类不做任何处理</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 保存attrs中所有的int类型数据</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c"># 遍历__mro__列表并找出类型为`int`的类属性, 保存在字典中</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">klass</span><span class="o">.</span><span class="n">__mro__</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="s">'declared_fields'</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">klass</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoGrandChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
</code></pre></div></div>

<p>其运行结果为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span><span class="s1">'age'</span>: 24<span class="o">}</span>
<span class="o">{</span><span class="s1">'height'</span>: 180, <span class="s1">'age'</span>: 24<span class="o">}</span>
</code></pre></div></div>

<p>如此一来，<code class="highlighter-rouge">HugoGrandChild</code>在继承了<code class="highlighter-rouge">HugoChild</code>之后，也能够获取到其中的相关字段，并且父类不会受到子类的影响。</p>

<p>上述代码中存在一些重复的代码片段，将其抽离出来，使代码结构更加清晰:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_instance_or_subclass</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">class_</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">class_</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">class_</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_fields</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">field_class</span><span class="p">):</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">field_name</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">is_instance_or_subclass</span><span class="p">(</span><span class="n">field_value</span><span class="p">,</span> <span class="n">field_class</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">fields</span>

<span class="k">def</span> <span class="nf">_get_fields_by_mro</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">field_class</span><span class="p">):</span>
    <span class="n">mro</span> <span class="o">=</span> <span class="n">klass</span><span class="o">.</span><span class="n">__mro__</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">_get_fields</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s">'declared_fields'</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">__dict__</span><span class="p">),</span>
                <span class="n">field_class</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">mro</span><span class="p">[:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">),</span>
        <span class="p">[],</span>
    <span class="p">)</span>

<span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>

        <span class="c"># 对Hugo类不做任何处理</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 保存attrs中所有的int类型数据</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="n">class_fields</span> <span class="o">=</span> <span class="n">_get_fields</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">inherited_fields</span> <span class="o">=</span> <span class="n">_get_fields_by_mro</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">class_fields</span> <span class="o">+</span> <span class="n">inherited_fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">klass</span>
</code></pre></div></div>

<h3 id="3-小结">3. 小结</h3>

<p><code class="highlighter-rouge">metaclass</code>并不神秘，得益于Python是动态语言，可以在运行时动态地创建一个类的特性，我们能够在事前去创建一些有用的”模板”，在运行时将模板和数据有机的结合起来，最终呈现出宛如魔术般的效果。</p>

	  ]]></description>
	</item>

	<item>
	  <title>一文理解Flask Web开发</title>
	  <link>//Flask-Web</link>
	  <author></author>
	  <pubDate>2019-03-31T09:49:09+00:00</pubDate>
	  <guid>//Flask-Web</guid>
	  <description><![CDATA[
	     <p>Flask作为Python语言中最为轻量的Web框架， 由于其核心内容的简洁以及良好的可拓展性， 一直受到广泛的开发者所喜爱。 对比于Django， Flask并没有”我给你的就是最好的， 别管那么多， 拿着用就好”的思想， 而是让开发者自己做出选择， 自己设计开发一个组件， 或者挑选一个你喜欢的第三方库。</p>

<!---more--->

<h4 id="1-标准web开发流程">1. 标准Web开发流程</h4>
<p>不管开发人员使用什么样的语言， Python也好， Java也好， 又或者什么样的Web框架， 从宏观上来看， 它们的开发流程都是基本相同的。</p>

<p>当服务器收到一个请求时， 首先做的就是对HTTP请求中的参数进行解析， 包括请求的URL， 请求方法， 参数以及Cookie等参数， 将其置于框架的一个内部数据结构中， 便于后续的使用。 在处理完请求参数后， 会在请求正式进入视图函数之前做一些额外处理， 例如验证CSRF-Token， 验证用户Cookie是否合法， 请求的IP是否处于白名单中， 如果验证信息未通过， 则直接返回相应的HTTP状态码以及相关信息， 增强网站的安全性。 在所有的验证通过之后， Web框架根据URL找到对应的视图函数并进行处理， 在处理过程中可能会涉及数据库， Redis以及消息队列的使用， 并很可能存在异步任务的触发。</p>

<p>在视图函数处理过程中， 很有可能因为某些操作而导致异常的产生， 此时Web应用应该判断异常产生的由来， 并进行统一的异常处理。 不管是数据库连接异常， 还是用户表单验证未通过， 都应该给出一个统一的应答， 这样便于前端的数据处理， 也能够让用户知道到底发生了什么。</p>

<p>很多时候为了便于开发人员的错误筛查， 都会在请求返回时添加日志的输出， 包括请求的URL， 请求方法， 参数， 服务器处理该请求的总时间， 请求响应状态码等信息。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/Flask/%E6%A0%87%E5%87%86Web%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="" /></p>

<h4 id="2-一个最简单的flask-demo">2. 一个最简单的Flask Demo</h4>
<p>在了解了一般性的标准Web开发流程之后， 接下来就是使用Flask来完整构建这个流程。 项目是由简入繁的， 博客也同样如此。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>                                 <span class="c"># ①</span>

<span class="n">app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/api/hello"</span><span class="p">)</span>                              <span class="c"># ②</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">"Hello World~"</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">8080</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># ③</span>
</code></pre></div></div>

<p>①: 通过传入当前<code class="highlighter-rouge">.py</code>文件的名称构建Flask核心对象， 此时app对象就有了Flask所有的核心功能， 包括添加视图函数， 添加额外的处理函数等。</p>

<p>②: 通过app对象的<code class="highlighter-rouge">route</code>方法， 使用语法糖对视图函数进行了装饰， 并传入<code class="highlighter-rouge">/api/hello</code>这个URI作为参数。 简单的理解就是当我们请求<code class="highlighter-rouge">/api/hello</code>路径时， 请求会使用<code class="highlighter-rouge">hello</code>函数作为视图函数进行处理。</p>

<p>③: 运行Flask框架， 并绑定本地<code class="highlighter-rouge">127.0.0.1:8080</code>， 以调试模式运行。</p>

<p>不管是路由注册， 还是以本地运行Flask， 都需要Flask核心对象的参与， 在Demo中也就是app对象。 在大型的Flask应用中， 同样如此， Flask核心对象将会作为中间枢纽， 由各种组件向其进行注册。</p>

<h4 id="3-blueprint">3. Blueprint</h4>
<p>对于一个中型应用而言， 通常会对各种接口进行业务上的分类。 例如一个商城， 会有user模块， product模块， order模块， coupon模块等等。 除了这些业务需要， 还有一些内部调用的接口， 比如用户分析， 订单分析等。 如果将这些接口都写在同一个文件中， 可以预见的是， 文件长度将会达到上万行。</p>

<p>所以， 不管我们使用什么样的标准来对接口进行分类， 分类都是必须要做的。 在解释Flask蓝图之前， 以Django为例， 这样更加便于理解。</p>

<p>在Django中， 模块的区分是采用app来实现的。 用户Cookie的处理是一个app， 订单是一个app， 商品相关的接口也将组成一个app。 Django在<code class="highlighter-rouge">settings.py</code>中提供了<code class="highlighter-rouge">INSTALLED_APPS</code>来帮我们自动地管理这些app， 当我们使用<code class="highlighter-rouge">django-admin startapp app_name</code>来创建一个app时， 实际上是创建了一个python package， 而在Django中， 正是通过管理python package来完成对app的管理。</p>

<p>我们只需要将package的名称添加至<code class="highlighter-rouge">INSTALLED_APPS</code>列表中即可， 剩下的模块查找工作由Django处理。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">INSTALLED_APPS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">'django.contrib.admin'</span><span class="p">,</span>
    <span class="s">'django.contrib.auth'</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="s">'user'</span><span class="p">,</span>
    <span class="s">'order'</span><span class="p">,</span>
    <span class="s">'product'</span><span class="p">,</span>
    <span class="s">'cupon'</span>
<span class="p">]</span>
</code></pre></div></div>

<p>而在Flask中， 虽然也提供了类似的机制， 但是其实现方式远没有Django这么直观， 相反的， 这也是Flask中比较难以理解的部分。</p>

<p>Blueprint就是Flask中协助我们将接口拆分成不同app的工具， 并由Flask核心对象完成对这些app的收集。 <strong>在Flask中， 并不是使用package这一粒度进行管理， 而是单一的<code class="highlighter-rouge">py</code>文件</strong>。 正是因为粒度从package缩小至了单独的<code class="highlighter-rouge">py</code>文件， 所以Blueprint的使用才看起来很复杂。</p>

<p>在有了这一基本的理解之后， 使用Blueprint就非常的简单了。 假如在<code class="highlighter-rouge">user</code>模块中， 有两个视图函数文件， 分别命令为<code class="highlighter-rouge">auth.py</code>和<code class="highlighter-rouge">info.py</code>， 其文件组织如下:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">—</span> <span class="n">user</span>
 <span class="o">|--</span> <span class="n">__init__</span><span class="o">.</span><span class="n">py</span>
 <span class="o">|--</span> <span class="n">auth</span><span class="o">.</span><span class="n">py</span>
 <span class="o">|--</span> <span class="n">info</span><span class="o">.</span><span class="n">py</span>
</code></pre></div></div>

<p>在<code class="highlighter-rouge">auth.py</code>以及<code class="highlighter-rouge">info.py</code>中均包含了一些视图函数， 由于我们对接口进行的功能拆分， 所以此时Flask核心对象就需要由Blueprint对象代替:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># auth.py</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Blueprint</span>

<span class="n">bp</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s">"auth"</span><span class="p">,</span> <span class="n">__name__</span><span class="p">,</span> <span class="n">url_prefix</span><span class="o">=</span><span class="s">"/api/auth"</span><span class="p">)</span>

<span class="n">bp</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/login"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">"POST"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="o">...</span>

<span class="n">bp</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/logout"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">"GET"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">logout</span><span class="p">():</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>同样地， 对<code class="highlighter-rouge">info.py</code>如法炮制:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># info.py</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Blueprint</span>

<span class="n">bp</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s">"info"</span><span class="p">,</span> <span class="n">__name__</span><span class="p">,</span> <span class="n">url_prefix</span><span class="o">=</span><span class="s">"/api/info"</span><span class="p">)</span>

<span class="n">bp</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/nick_name"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">"GET"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">get_nick_name</span><span class="p">():</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>现在对<code class="highlighter-rouge">user.py</code>和<code class="highlighter-rouge">info.py</code>进行了Blueprint方式地重写， 那么如何将其与Flask核心对象产生挂接? 答案是在user模块的<code class="highlighter-rouge">__init__.py</code>中对其进行注册:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># user.__init__.py</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">auth</span><span class="p">,</span> <span class="n">info</span>

<span class="k">def</span> <span class="nf">register_user</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">auth</span><span class="o">.</span><span class="n">bp</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">bp</span><span class="p">)</span>
</code></pre></div></div>

<p>此后， 只需要在创建Flask核心对象的文件中将<code class="highlighter-rouge">register_user</code>函数导入， 并传入核心对象进行调用即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># app.py</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>

<span class="kn">from</span> <span class="nn">myFlaskDemo.user</span> <span class="kn">import</span> <span class="n">register_user</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="n">register_user</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</code></pre></div></div>

<p>无论有多少个<code class="highlighter-rouge">app</code>， 都可以通过这样的方式将其注册进Flask核心对象之中， 只不过因为Blueprint是对单一的<code class="highlighter-rouge">py</code>文件进行管理的， 所以就需要比Django做更多的工作来完成这件事情， 其本质上， 都是让Flask核心对象发现这些视图函数而已。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/Flask/Blueprint%E5%AE%9E%E9%99%85%E4%BD%9C%E7%94%A8.png" alt="" /></p>

<h4 id="4-请求的参数处理">4. 请求的参数处理</h4>
<p>在使用<code class="highlighter-rouge">POST</code>方法进行请求时， 通常是使用JSON的方式进行参数传递， 那么如果我们想要取出相应的数据的话， 就势必需要对JSON数据进行<code class="highlighter-rouge">json.loads</code>操作， 转换成Python字典。 这个过程每个处理<code class="highlighter-rouge">POST</code>请求的视图函数都需要进行， 非常的麻烦， 所以我们需要想办法在请求进入视图函数之前就将数据保存在某一个地方。</p>

<p>这个时候就需要用到<code class="highlighter-rouge">before_request</code>这个函数， 同样是由Flask核心对象所提供。 <code class="highlighter-rouge">before_request</code>接收一个函数， 并在每次请求到达视图函数之前执行它。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">request</span>
<span class="kn">from</span> <span class="nn">werkzeug.datastructures</span> <span class="kn">import</span> <span class="n">ImmutableMultiDict</span><span class="p">,</span> <span class="n">CombinedMultiDict</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_request_params_from_json</span><span class="p">():</span>
    <span class="n">json_data</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">get_json</span><span class="p">(</span><span class="n">silent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">json_data</span> <span class="o">=</span> <span class="n">ImmutableMultiDict</span><span class="p">(</span><span class="n">json_data</span><span class="p">)</span>
    <span class="n">request</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">CombinedMultiDict</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="p">[</span><span class="n">json_data</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="p">]))</span>

<span class="n">app</span><span class="o">.</span><span class="n">before_request</span><span class="p">(</span><span class="n">get_request_params_from_json</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="5-约定返回格式">5. 约定返回格式</h4>
<p>数据返回格式的统一与否是检验一个Web API是否合格的最低标准， 这是一个对前端， 自己以及同事都有利的东西， 所以目前已经成为了一种标准。</p>

<p>就目前来说， 用的最多的格式就是<code class="highlighter-rouge">code, message, data</code>， 即:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"code"</span><span class="p">:</span><span class="w"> </span><span class="err">成功码</span><span class="w"> </span><span class="err">or</span><span class="w"> </span><span class="err">错误码</span><span class="p">,</span><span class="w">
    </span><span class="s2">"message"</span><span class="p">:</span><span class="w"> </span><span class="err">错误信息</span><span class="w"> </span><span class="err">or</span><span class="w"> </span><span class="err">''</span><span class="p">,</span><span class="w">
    </span><span class="s2">"data"</span><span class="p">:</span><span class="w"> </span><span class="err">...</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>以<code class="highlighter-rouge">RESTful API</code>而言， 通过HTTP响应的状态码来判断当前访问的结果， 但是呢， 部分的前端程序员对此非常不感冒， 觉得处理HTTP-code相当麻烦。 所有的请求， 不管是表单验证我失败， 还是用户未登录而访问受保护的资源， 这些情况统统给我返回200， 然后在<code class="highlighter-rouge">message</code>字段中标明原因。</p>

<p>很多时候系统出现的问题， 真的就不是技术问题， 而是眼界问题。 通常我们需要定义两个函数， <code class="highlighter-rouge">success</code>以及<code class="highlighter-rouge">fail</code>函数， 接收<code class="highlighter-rouge">code, message, data</code>参数， 调用方根据情况进行参数传递即可:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">success</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="p">{</span><span class="s">'code'</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="s">'message'</span><span class="p">:</span> <span class="s">''</span><span class="p">,</span> <span class="s">'data'</span><span class="p">:</span> <span class="n">data</span><span class="p">}</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">http_code</span><span class="p">,</span> <span class="n">mimetype</span><span class="o">=</span><span class="s">'application/json'</span><span class="p">})</span>

<span class="k">def</span> <span class="nf">fail</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="p">{</span><span class="s">'code'</span><span class="p">:</span> <span class="n">code</span><span class="p">,</span> <span class="s">'message'</span><span class="p">:</span> <span class="n">message</span><span class="p">,</span> <span class="s">'data'</span><span class="p">:</span> <span class="n">data</span><span class="p">}</span>
</code></pre></div></div>

<h4 id="6-请求日志的记录">6. 请求日志的记录</h4>
<p>这部分内容是我认为最有价值的一小节， 无数个被产品打断的瞬间， 告知某个用户的某次操作异常， 而又没有准确日志的记录， 无从排查的教训。 所以在写这部分内容时， 坐在轮椅上的我格外激动…</p>

<p>血一样的教训告诉我， 日志记录一定要全面， 谁请求了哪个URL， 请求方法是什么， 请求参数是什么， 请求响应时间多多少， 这些通通都要记录， 少一个都不行。</p>

<p>下面给出一个示例:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">record_request_log</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">now_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">request_start_time</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="s">'request_start_time'</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">user_id</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="s">'user_id'</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="n">format_str</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">'</span><span class="si">%(remote_addr)</span><span class="s">s request: [</span><span class="si">%(status)</span><span class="s">s] </span><span class="si">%(method)</span><span class="s">s, url: </span><span class="si">%(url)</span><span class="s">s, '</span>
        <span class="s">'args: </span><span class="si">%(args)</span><span class="s">s, json: </span><span class="si">%(json)</span><span class="s">s, '</span>
        <span class="s">'request_start_time: </span><span class="si">%(request_start_time)</span><span class="s">s, response_time: </span><span class="si">%(response_time)</span><span class="s">s, '</span>
        <span class="s">'user_id: </span><span class="si">%(user_id)</span><span class="s">s, '</span>
    <span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">remote_addr</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">remote_addr</span><span class="p">,</span>
        <span class="n">status</span><span class="o">=</span><span class="n">response</span><span class="o">.</span><span class="n">status</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">method</span><span class="p">,</span>
        <span class="n">url</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">url</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="p">,</span>
        <span class="n">json</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">get_json</span><span class="p">(</span><span class="n">silent</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
        <span class="n">request_start_time</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">"</span><span class="si">%</span><span class="s">Y-</span><span class="si">%</span><span class="s">m-</span><span class="si">%</span><span class="s">d </span><span class="si">%</span><span class="s">H:</span><span class="si">%</span><span class="s">M:</span><span class="si">%</span><span class="s">S"</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">())),</span>
        <span class="n">response_time</span> <span class="o">=</span> <span class="n">now_time</span> <span class="o">-</span> <span class="n">request_start_time</span> <span class="k">if</span> <span class="n">request_start_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="s">""</span>
        <span class="n">user_id</span><span class="o">=</span><span class="n">user_id</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">'response'</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">format_str</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>

<span class="n">app</span><span class="o">.</span><span class="n">after_request</span><span class="p">(</span><span class="n">record_request_log</span><span class="p">)</span>
</code></pre></div></div>

<p>同时， 为了让日志的记录更加完整， 例如ERROR日志记录到文件， 或者是通过Kafka发送给ELK日志分析平台， 所以需要对日志的格式进行额外的配置:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># log_config.py</span>

<span class="n">DEFAULT_LOGGING_CONFIGS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'version'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s">'disable_existing_loggers'</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
    <span class="s">'formatters'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'standard'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'format'</span><span class="p">:</span> <span class="s">'</span><span class="si">%(asctime)</span><span class="s">s [</span><span class="si">%(threadName)</span><span class="s">s] [</span><span class="si">%(name)</span><span class="s">s:</span><span class="si">%(funcName)</span><span class="s">s] '</span>
                      <span class="s">'[line:</span><span class="si">%(lineno)</span><span class="s">d] [</span><span class="si">%(levelname)</span><span class="s">s]- </span><span class="si">%(message)</span><span class="s">s'</span><span class="p">}</span>
    <span class="p">},</span>
    <span class="s">'handlers'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'error'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'level'</span><span class="p">:</span> <span class="s">'ERROR'</span><span class="p">,</span>
            <span class="s">'class'</span><span class="p">:</span> <span class="s">'logging.handlers.RotatingFileHandler'</span><span class="p">,</span>
            <span class="s">'filename'</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BASE_DIR</span><span class="p">,</span> <span class="s">'log'</span><span class="p">,</span> <span class="s">'error.log'</span><span class="p">),</span>
            <span class="s">'maxBytes'</span><span class="p">:</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">5</span><span class="p">,</span>
            <span class="s">'backupCount'</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s">'formatter'</span><span class="p">:</span> <span class="s">'standard'</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s">'console'</span><span class="p">:{</span>
            <span class="s">'level'</span><span class="p">:</span> <span class="s">'INFO'</span><span class="p">,</span>
            <span class="s">'class'</span><span class="p">:</span> <span class="s">'logging.StreamHandler'</span><span class="p">,</span>
            <span class="s">'formatter'</span><span class="p">:</span> <span class="s">'standard'</span>
        <span class="p">},</span>
    <span class="p">},</span>
    <span class="s">'loggers'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'root'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'handlers'</span><span class="p">:</span> <span class="p">[</span><span class="s">'error'</span><span class="p">,</span> <span class="s">'console'</span><span class="p">],</span>
            <span class="s">'level'</span><span class="p">:</span> <span class="s">'INFO'</span><span class="p">,</span>
            <span class="s">'propagate'</span><span class="p">:</span> <span class="bp">False</span>
        <span class="p">},</span>
        <span class="s">'response'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'handlers'</span><span class="p">:</span> <span class="p">[</span><span class="s">'error'</span><span class="p">,</span> <span class="s">'console'</span><span class="p">],</span>
            <span class="s">'level'</span><span class="p">:</span> <span class="s">'INFO'</span><span class="p">,</span>
            <span class="s">'propagate'</span><span class="p">:</span> <span class="bp">False</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c"># app.py</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">logging.config</span>

<span class="k">def</span> <span class="nf">create_app</span><span class="p">():</span>
    <span class="o">...</span>

    <span class="n">init_log</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">app</span>

<span class="k">def</span> <span class="nf">init_log</span><span class="p">():</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">dictConfig</span><span class="p">(</span><span class="n">DEFAULT_LOGGING_CONFIGS</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="7-flask中的应用上下文与请求上下文">7. Flask中的应用上下文与请求上下文</h4>
<p>在<code class="highlighter-rouge">AppContext</code>以及<code class="highlighter-rouge">RequestContext</code>中， 使用最多的仍然是<code class="highlighter-rouge">RequestContext</code>， 意思为请求上下文。 那么请求上下文是个什么东西?</p>

<p>在SpringBoot以及Django框架中， request对象是通过函数参数进行传递的， 比如在Django中， 通常会有这样的代码:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SomeUsefulAPIView</span><span class="p">(</span><span class="n">APIView</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span><span class="err">；</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">data</span>
        <span class="o">...</span>
</code></pre></div></div>

<p>然而在Flask中， 却不是这样的:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask_restful</span> <span class="kn">import</span> <span class="n">Resource</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="k">class</span> <span class="nc">SomeUsefulAPIView</span><span class="p">(</span><span class="n">Resource</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>

<p>request对象是通过import进行导入的， 而不是通过参数进行传递的， 这里其实就是请求上下文的表现形式。 在当前的请求线程中， Flask会保存request对象， 并能够在任意文件中通过导入的方式进行使用， 其底层依赖于werkzeug第三方库的<code class="highlighter-rouge">LocalStack</code>。</p>

<p>更进一步地， <code class="highlighter-rouge">LocalStack</code>封装底层的<code class="highlighter-rouge">Local</code>实现， 而<code class="highlighter-rouge">Local</code>对象， 其实就是一个大字典。 首先来看现象:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">werkzeug.local</span> <span class="kn">import</span> <span class="n">Local</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">Local</span><span class="p">()</span>

<span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">15</span>

<span class="k">def</span> <span class="nf">another_threading</span><span class="p">():</span>
    <span class="c"># 开启线程对foo对象的属性进行修改</span>
    <span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">20</span>

    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c"># 确保主线程打印出变量</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"another_thread: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">bar</span><span class="p">))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">another_threading</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">())</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c"># 确保t线程执行完毕</span>
    <span class="c"># 打印主线程变量值</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"main thread: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">bar</span><span class="p">))</span>  <span class="c"># 15</span>
    <span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">25</span>
</code></pre></div></div>

<p>可以看到， 在主线程中， <code class="highlighter-rouge">foo.bar</code>的值并没有受到另外一个线程的影响， 而在t线程中， 也没有受到主线程的影响， 这就是<code class="highlighter-rouge">Local</code>对象的作用: 同一个对象， 在不同的线程中拥有完全独立自主权， 并且其值不会受到其它线程的影响。</p>

<p>现在来看<code class="highlighter-rouge">Local</code>类的源码， 主要是使用Python类字典的功能， 重写<code class="highlighter-rouge">__getattr__</code>以及<code class="highlighter-rouge">__setattr__</code>方法:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Local</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">"__storage__"</span><span class="p">,</span> <span class="s">"__ident_func__"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">"__storage__"</span><span class="p">,</span> <span class="p">{})</span>  <span class="c"># 初始化__storage__变量为字典结构</span>
        <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">"__ident_func__"</span><span class="p">,</span> <span class="n">get_ident</span><span class="p">)</span>
        <span class="c"># get_ident为Python内置的函数， 其作用为获取当前线程的线程id</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__storage__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__ident_func__</span><span class="p">()][</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">ident</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ident_func__</span><span class="p">()</span>  <span class="c"># 函数调用， 获取id值</span>
        <span class="n">storage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__storage__</span>  <span class="c"># storage其实就是一个dict</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># 适用于 {"140672512972544": {"bar": "25"}}的结构</span>
            <span class="n">storage</span><span class="p">[</span><span class="n">ident</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
            <span class="n">storage</span><span class="p">[</span><span class="n">ident</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>
</code></pre></div></div>

<p>所以说， 在上面的测试代码中， <code class="highlighter-rouge">storage</code>变量的内容为:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="s">"线程id-1"</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">"foo"</span><span class="p">:</span> <span class="mi">25</span>
    <span class="p">},</span>
    <span class="s">"线程id-2"</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">"foo"</span><span class="p">:</span> <span class="mi">20</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>那么<code class="highlighter-rouge">LocalStack</code>就很好理解了， 这是一个先进后出的栈结构， 并且栈内容在不同的线程中也是不同的。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/1526973096301.png" alt="" /></p>

<p>如上图所示， 每一个请求在进入时， 都会将request对象压入当前线程的栈中， 那么在该请求的生命周期内， 任意地方都可以将该对象从栈中获取， 并且保证在当前线程中， request请求对象不会被其它线程对象所污染。</p>

<p>所以， 基于此特性， Flask只能使用多线程+协程的方式进行部署， 而不能使用以epoll为底层实现的Reactor模型部署。 所以从这方面来讲的话， 使用Flask解决C10K的问题几乎不能实现。</p>

<h4 id="8-flask-aop的使用">8. Flask AOP的使用</h4>
<p>经常听到别人搞Java的说SpringBoot的AOP多么多么NB， 多么多么厉害， 然而写Python的却是微微一笑， 这东西我们都用烂了。</p>

<p>AOP， 全称Aspect Oriented Programming， 面向切面编程， 在Python中， 装饰器就是一个最佳的面向切面编程的实现。 面向切面编程的含义就是抽离相似逻辑， 将相似的逻辑进行封装并复用， 说白了， 其实就是函数的调用:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">aspect_function</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"在f函数调用之前要做的事情"</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span>  <span class="c"># 调用函数</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"在f函数调用之后要做的事情"</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"调用f函数时出现异常时的处理逻辑"</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">aspect_function</code>函数接收一个函数对象， 并且在其调用之前， 调用之后以及调用出现异常时均作出相同的操作， 那么这些内容其实就是一个切面， 一个所有<code class="highlighter-rouge">f</code>函数调用之前， 之后都需要做的事情。</p>

<p>上面的例子稍加改动， 就是一个装饰器， 可以通过语法糖的形式来实现复用。 不管是在Django的全局异常处理， 还是在Flask中， 模型都是这样的。</p>

<p>AOP在Web框架中最常见的场景就是全局异常处理。 在视图函数中， 经常会有一些意想不到的异常抛出， 如果直接返回给用户500的话会很不友好， 所以尽量的将异常使用日志的方式记录下来， 并且返回给用户可读的内容。 而针对每一个视图函数都写一个大大的<code class="highlighter-rouge">try..except</code>太累了， 此时就有了<code class="highlighter-rouge">errorhandler</code>函数。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">setup_error_handler</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>

    <span class="nd">@app.errorhandler</span><span class="p">(</span><span class="nb">Exception</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">error_exception</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Wrong"</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">"Some wrong happened"</span>

<span class="n">setup_error_handler</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</code></pre></div></div>

<p>一个最简单的全局异常处理就此诞生， 并且由于我们传入了所有异常的爹， 即<code class="highlighter-rouge">Exception</code>类， 所以所有的Python异常都能够捕捉， 再结合前面的统一返回格式， 初步的全局异常处理就成型了。</p>

<h4 id="9-flask-migrate的使用">9. Flask-migrate的使用</h4>
<p>在日常的业务开发中， 数据库的模型不可能一成不变， 总会有新的需求导致数据模型的更改。 而在有ORM模型的Web框架中， 数据库的模型是应该随着应用层的模型代码而变动的。 也就是说， 当我们想要添加/删除某一个字段时， 不能直接在数据库中进行<code class="highlighter-rouge">alter table</code>操作， 而是修改应用层代码， 而后通过某种方式将这些改变映射到数据库中。</p>

<p>在Django中， 提供了内置的<code class="highlighter-rouge">python manage.py makemigrations/migrate</code>帮助我们完成这件事， 而在Flask中， 需要使用第三方库<code class="highlighter-rouge">flask-migrate</code>以及<code class="highlighter-rouge">flask-scrip</code>。</p>

<p>首先来定义一个简单的模型:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TimeMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">created</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">DateTime</span><span class="p">(),</span> <span class="n">default</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>
    <span class="n">updated</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">DateTime</span><span class="p">(),</span> <span class="n">default</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">onupdate</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">deleted</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Boolean</span><span class="p">(),</span> <span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span> <span class="n">TimeMixin</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">autoincrement</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">nickname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">24</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">phone_number</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div></div>

<p>当然， 在首次部署项目时， 可以在代码中直接使用<code class="highlighter-rouge">db.create_all(app)</code>的方式来完成数据模型的写入， 但是这种方式过于僵硬， 无法回滚， 也无法添加新的字段。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pip</span> <span class="n">install</span> <span class="n">flask</span><span class="o">-</span><span class="n">sqlalchemy</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">flask</span><span class="o">-</span><span class="n">migrate</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">flask</span><span class="o">-</span><span class="n">script</span>
</code></pre></div></div>

<p>创建<code class="highlighter-rouge">manage.py</code>文件， 并写入以下内容:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask_script</span> <span class="kn">import</span> <span class="n">Manager</span>
<span class="kn">from</span> <span class="nn">flask_migrate</span> <span class="kn">import</span> <span class="n">Migrate</span><span class="p">,</span> <span class="n">MigrateCommand</span>

<span class="kn">from</span> <span class="nn">app</span> <span class="kn">import</span> <span class="n">create_app</span><span class="p">,</span> <span class="n">db</span>

<span class="n">migrate</span> <span class="o">=</span> <span class="n">Migrate</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>

<span class="n">manager</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
<span class="n">manager</span><span class="o">.</span><span class="n">add_command</span><span class="p">(</span><span class="s">'db'</span><span class="p">,</span> <span class="n">MigrateCommand</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">manager</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div></div>

<ul>
  <li>初始化migrations package:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">python</span> <span class="n">manage</span><span class="o">.</span><span class="n">py</span> <span class="n">db</span> <span class="n">init</span>
</code></pre></div></div>

<ul>
  <li>创建migration文件(相当于Django中的makemigrations)</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">python</span> <span class="n">manage</span><span class="o">.</span><span class="n">py</span> <span class="n">db</span> <span class="n">migrate</span> <span class="o">-</span><span class="n">m</span> <span class="s">"initial migrate"</span>
</code></pre></div></div>

<ul>
  <li>将migration文件映射至数据库中(相当于Django中的migrate)</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">python</span> <span class="n">manage</span><span class="o">.</span><span class="n">py</span> <span class="n">db</span> <span class="n">upgrade</span>
</code></pre></div></div>

<p>此后对模型的修改， 只需要执行<code class="highlighter-rouge">python manage.py db migrate -m "Some useful message"</code>以及<code class="highlighter-rouge">python manage.py db upgrade</code>即可。</p>

<h4 id="10-小结">10. 小结</h4>
<p>其实Web开发讲究的就是一个套路， 当把一个Web框架理解清楚了之后， 其余的都大同小异， 当然这里指的是同步类Web框架， 诸如Tornado,  Netty则不属于此列， 它们由于底层机制的不同， 要更为复杂一些。</p>

<p>有时候看待Web框架也需要使用AOP的思想， 抽离相似的逻辑， 并用此逻辑去学习各种各样的框架， 这种方式在我看来比首先深入了解细节要更加高效， 因为实现细节必定有所差异， 而本质原理却基本类似。</p>

	  ]]></description>
	</item>


</channel>
</rss>
