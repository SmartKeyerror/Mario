<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description>Keep coding, Keep curiosity</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Java基础编程(06)--反射</title>
	  <link>//Reflect</link>
	  <author></author>
	  <pubDate>2018-12-07T08:49:09+00:00</pubDate>
	  <guid>//Reflect</guid>
	  <description><![CDATA[
	     <p>为了保持<code class="highlighter-rouge">Java基础编程</code>系列的完整性， 反射机制还是写一下， 没有什么太难的地方。 在文章的最后与<code class="highlighter-rouge">Python</code>进行了一个对比和演示， 用于加深对这两种语言设计本身的理解。</p>

<!---more--->

<h4 id="1-什么是反射">1. 什么是反射</h4>
<p>以我目前的理解来看， 反射就是一种在运行时借助<code class="highlighter-rouge">Class</code>对象获取一个类所有信息的机制， 包括变量， 构造器以及方法等。 简单的来说就是使用某个产品的说明书， 反向的构造出这个产品， 在构造这个产品的时候， 会发现一些产品所隐藏的信息。</p>

<p>更具体地来讲， 反射能够<strong>在运行时</strong>判断任意一个对象所属的类， 构造任意一个类的对象， 判断任意一个类所具有的成员变量和方法， 以及调用任意一个对象的方法， 包括私有方法。</p>

<p>那么为什么需要有反射机制？ 反射机制在<code class="highlighter-rouge">RPC</code>框架下有着非常重要的应用， 此外， 像<code class="highlighter-rouge">SpringBoot</code>等Web框架也是基于反射机制而构建的， 并且更功利的讲， <code class="highlighter-rouge">EventBus</code>就是用的反射机制来实现观察者模式的。</p>

<h4 id="2-什么是class对象">2. 什么是Class对象</h4>
<p>我们知道使用多态机制能够简化代码的复杂度， 使代码更加的灵活， 如下面的代码片段：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">();</span> <span class="o">}</span>

<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">implements</span> <span class="n">Animal</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Cat running"</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="n">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Dog running"</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Square</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">game</span><span class="o">(</span><span class="n">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span> <span class="n">animal</span><span class="o">.</span><span class="na">run</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在这里我们只对操作基类(<code class="highlighter-rouge">Animal</code>)的引用， 这样一来如果想要对代码进行扩展， 我们可以很轻松的做到， 而不必更改原有的代码结构。 客户端的程序员使用泛化的<code class="highlighter-rouge">Animal</code>来调用<code class="highlighter-rouge">run</code>方法， 尽管对象被泛化了， 但是依然能够产生正确的行为， 那么这个就是多态机制。</p>

<p><code class="highlighter-rouge">Java</code>多态机制的实现是通过<code class="highlighter-rouge">Class</code>对象所实现的， 任何一个<code class="highlighter-rouge">Java</code>类都会有一个唯一的<code class="highlighter-rouge">Class</code>对象， 保存在与类同名的<code class="highlighter-rouge">.class</code>文件中。</p>

<h4 id="3-获取class对象">3. 获取Class对象</h4>
<p>有3种方式可以获取<code class="highlighter-rouge">Class</code>对象， 第一个是<code class="highlighter-rouge">Class</code>类所提供的<code class="highlighter-rouge">forName</code>静态方法， 二是类字面量， 最后一个是<code class="highlighter-rouge">Object</code>对象所提供的<code class="highlighter-rouge">getClass</code>方法。</p>

<h5 id="31-classforname">3.1 Class.forName</h5>
<p>该静态方法接受一个完整的类名， 即<code class="highlighter-rouge">包名.类名</code>， 返回一个该类所对应的<code class="highlighter-rouge">Class</code>对象， 该方法会抛出<code class="highlighter-rouge">ClassNotFoundException</code>， 在没有找到该类的情况下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"chapter21.Reflection.Student"</span><span class="o">);</span>
</code></pre></div></div>

<h5 id="32-类字面量">3.2 类字面量</h5>
<p>有时候我们可以直接导入一个类， 例如<code class="highlighter-rouge">ArrayList</code>， 那么此时就可以直接使用<code class="highlighter-rouge">ArrayList.class</code>来获取<code class="highlighter-rouge">Class</code>对象：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">arrayListClass</span> <span class="o">=</span> <span class="n">ArrayList</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
</code></pre></div></div>

<h5 id="33-objectgetclass">3.3 Object.getClass</h5>
<p>有时候我们可以拿到一个实例对象， 通过该实例对象也可以获取到<code class="highlighter-rouge">Class</code>对象。 该方法是由<code class="highlighter-rouge">Object</code>所提供的， 也就是说任意一个对象都可以使用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">String</span> <span class="n">fullName</span> <span class="o">=</span> <span class="s">"SmartKeyerror"</span><span class="o">;</span>
<span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">stringClass</span> <span class="o">=</span> <span class="n">fullName</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
</code></pre></div></div>

<h4 id="4-获取类结构信息">4. 获取类结构信息</h4>
<p>一个类， 通常由成员变量， 构造函数， 成员方法， 静态方法等所组成， <code class="highlighter-rouge">Class</code>对象提供了一系的方法来获取这些信息。</p>

<p>首先定义一个测试类：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">ID</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"Student: "</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printHello</span><span class="o">()</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello~"</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>通过<code class="highlighter-rouge">getDeclaredMethods</code>可以获取所有的方法， 包括私有， 静态以及成员方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"chapter21.Reflection.Student"</span><span class="o">);</span>
<span class="cm">/* 方法返回Method对象所组成的数组 */</span>
<span class="n">Method</span><span class="o">[]</span> <span class="n">methods</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredMethods</span><span class="o">();</span>
<span class="cm">/* 打印所有的方法名称 */</span>
<span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">methods</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span> <span class="o">});</span>
</code></pre></div></div>

<p>通过<code class="highlighter-rouge">getDeclaredFields</code>可以获得所有的变量， 包括私有， 静态以及成员变量：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Field</span><span class="o">[]</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredFields</span><span class="o">();</span>
<span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">fields</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span> <span class="o">});</span>
</code></pre></div></div>

<p>通过<code class="highlighter-rouge">getDeclaredConstructors</code>可以获取所有的构造方法， 包括私有的构造方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Constructor</span><span class="o">[]</span> <span class="n">constructors</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredConstructors</span><span class="o">();</span>
<span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">constructors</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span> <span class="o">});</span>
</code></pre></div></div>

<p>除了这三个方法以外， 对应的， 还有<code class="highlighter-rouge">getMethods</code>， <code class="highlighter-rouge">getFields</code>， <code class="highlighter-rouge">getConstructors</code>， 这三个方法作用与上面的相同， 只不过无法获取私有的方法， 变量或者是构造器而已。</p>

<p>通过这些方法我们基本上已经能够较为完整的还原出一个类的结构了， 能够知道一个变量是否私有， 名称以及类型； 方法是否私有， 返回类型以及参数类型， 但是无法获取函数的方法体代码， 这个是无法做到的。 以及构造函数的数量和参数类型这些信息。</p>

<h4 id="5-获取准确信息">5. 获取准确信息</h4>
<p>从全局的角度来看， 我们能够通过<code class="highlighter-rouge">Class</code>对象获取各种方法和各种变量所组成的数组， 同样地， 可以根据一些条件来准确的获取单一的方法或者是变量。</p>

<p>在一个类中， 区分一个函数的两个标志就是函数名称和参数类型(虽然参数类型的顺序也可以用来区分， 但是这属于极差的编码习惯)， 同样的， 可以使用这两个信息来准确的找出我们想要的方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 获取setName方法, 参数为函数名称以及参数类型的Class对象 */</span>
<span class="n">Method</span> <span class="n">setNameMethod</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"setName"</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="cm">/* 获取该类的一个实例， 相当于new Student()， 使用无参构造函数 */</span>
<span class="n">Object</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>

<span class="cm">/* 调用该方法， 由于是成员方法， 所以得有个实例 */</span>
<span class="n">setNameMethod</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="s">"smart"</span><span class="o">);</span>

<span class="cm">/* 检测方法调用是否成功 */</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(((</span><span class="n">Student</span><span class="o">)</span><span class="n">instance</span><span class="o">).</span><span class="na">getName</span><span class="o">());</span>
</code></pre></div></div>

<p>获取字段的准确信息要简单一些， 因为字段名称本就是唯一的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Field</span> <span class="n">nameField</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"name"</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">nameField</span><span class="o">.</span><span class="na">getType</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</code></pre></div></div>

<p>基本上这些就是反射机制的核心内容了， 剩下的就是一些细节的处理， 这些内容可以通过查看javadoc来进行了解。</p>

<h4 id="6-python中的反射机制">6. Python中的反射机制</h4>
<p>没有对比就没有伤害， <code class="highlighter-rouge">Python</code>作为一个面向对象的语言， 与<code class="highlighter-rouge">Java</code>一样， 拥有反射机制， 只不过<code class="highlighter-rouge">Python</code>中， 大家更乐意称之为特殊方法， 并且获取信息更加的方便。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s">"""
    This is Student class
    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span>

    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__private_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"This is private"</span><span class="p">)</span>
</code></pre></div></div>

<p>我们可以通过以<code class="highlighter-rouge">__</code>开头的一些特殊方法来获取指定类的结构信息， 例如使用<code class="highlighter-rouge">Student.__dict__</code>来获取<code class="highlighter-rouge">Student</code>的所有方法和一些基本属性：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="s">'__module__'</span><span class="p">:</span> <span class="s">'__main__'</span><span class="p">,</span>
    <span class="s">'__doc__'</span><span class="p">:</span> <span class="s">'</span><span class="se">\n</span><span class="s">    This is Student class</span><span class="se">\n</span><span class="s">    '</span><span class="p">,</span>
    <span class="s">'__init__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">Student</span><span class="o">.</span><span class="n">__init__</span> <span class="n">at</span> <span class="mh">0x7f2d7403b510</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="s">'get_name'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">Student</span><span class="o">.</span><span class="n">get_name</span> <span class="n">at</span> <span class="mh">0x7f2d722e49d8</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="s">'set_name'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">Student</span><span class="o">.</span><span class="n">set_name</span> <span class="n">at</span> <span class="mh">0x7f2d722e4950</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="s">'_Student__private_method'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">Student</span><span class="o">.</span><span class="n">__private_method</span> <span class="n">at</span> <span class="mh">0x7f2d722e4a60</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="s">'__dict__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">attribute</span> <span class="s">'__dict__'</span> <span class="n">of</span> <span class="s">'Student'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="s">'__weakref__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">attribute</span> <span class="s">'__weakref__'</span> <span class="n">of</span> <span class="s">'Student'</span> <span class="n">objects</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到<code class="highlighter-rouge">Python</code>中的私有方法其实最终会变成<code class="highlighter-rouge">_Student__private_method</code>， 我们是可以直接调用这个方法的。</p>

<p>通过实例的<code class="highlighter-rouge">__class__</code>方法可以获取实例的类信息：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">Student</span><span class="p">()</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>

<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">__main__</span><span class="o">.</span><span class="n">Student</span><span class="s">'&gt;</span><span class="err">
</span></code></pre></div></div>

<p>由于实例变量是可以动态添加和修改的， 所以获取这个信息没有什么太大意义， <code class="highlighter-rouge">Python</code>也没有提供。</p>

<p>两种语言对同一个机制放在一起做对比， 很容易就能发现两者的不同， 以及进一步加深对语言本身的理解。 做对比的主要目的还是想传达自己的一个观点： 编程语言， 在很大程度上都是互通的。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Java基础编程(05)--常用的设计模式(02)</title>
	  <link>//Java-Design-Pattern-02</link>
	  <author></author>
	  <pubDate>2018-12-05T11:49:09+00:00</pubDate>
	  <guid>//Java-Design-Pattern-02</guid>
	  <description><![CDATA[
	     <p>在前面的一篇文章中大致了描述了单例模式， 原型模式， 策略模式， 责任链模式， 代理模式以及观察者模式， 本文接上。</p>

<!---more--->

<h4 id="7-过滤器模式">7. 过滤器模式</h4>
<p>过滤器模式有点儿类似于责任链模式， 只不过责任链模式是用于将请求和处理请求进行解耦， 而过滤器模式则更像一个滤网， 将符合我们要求的对象过滤出来。 为了更好的理解过滤器模式， 我们首先创建一个<code class="highlighter-rouge">Student</code>对象， 并赋予常见的属性：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">gender</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">gender</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">gender</span> <span class="o">=</span> <span class="n">gender</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>为了简化代码的书写， 这里的成员变量就直接使用<code class="highlighter-rouge">public</code>来进行修饰， 性别属性使用布尔值表示， <code class="highlighter-rouge">false</code>到底表示男还是女并不重要。 在另外一个地方保存了一组学生对象：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">students</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;();</span>
<span class="n">students</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">"smart"</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="kc">false</span><span class="o">));</span>
<span class="n">students</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
<span class="n">students</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">"bar"</span><span class="o">,</span> <span class="mi">19</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
</code></pre></div></div>

<p>现在我们想要对这一组学生进行一个数据分析， 比如找出年龄小于18岁的， 名字以’s’开头的， 或者是性别为<code class="highlighter-rouge">false</code>的。 就有了第一版的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="n">Student</span> <span class="n">student</span> <span class="o">:</span> <span class="n">students</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">student</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"s"</span><span class="o">))</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">student</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>其余的筛选和这个基本上是一样的， 只不过筛选条件不同而已。 根据需求我们又写了根据年龄和性别筛选的代码。 然后又有需求来了， 筛选年龄小于19岁， 并且性别为<code class="highlighter-rouge">false</code>的学生， 好嘛， 那再加一个：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="n">Student</span> <span class="n">student</span> <span class="o">:</span> <span class="n">students</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">((!</span><span class="n">student</span><span class="o">.</span><span class="na">gender</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">student</span><span class="o">.</span><span class="na">age</span> <span class="o">&lt;</span> <span class="mi">19</span><span class="o">))</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">student</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个时候就会发现代码重复的非常严重， 没有任何的可复用性， 不同的筛选规则不能够组合起来， 造成了大量重复的代码和臃肿的代码结构。</p>

<p>所以我们需要改变策略， 在每次筛选时直接创建一个新的容器对象， 筛选通过的对象添加至容器中， 并返回该容器。 这样一来我们就可以把多个筛选规则组合起来， 一个筛选器的结果是另一个筛选器的输入。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="nf">filterAge</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">students</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">filterList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Student</span> <span class="n">student</span> <span class="o">:</span> <span class="n">students</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">student</span><span class="o">.</span><span class="na">age</span> <span class="o">&lt;</span> <span class="mi">19</span><span class="o">)</span>
            <span class="n">filterList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">student</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">filterList</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-28%2010-41-09%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>该设计模式实在是没什么好说的， 比较简单， 所以就不再分<code class="highlighter-rouge">Java</code>实现和<code class="highlighter-rouge">Python</code>实现， 代码也比较简单， 就不贴了。</p>

<p>比较值得一提的就是Java 8中<code class="highlighter-rouge">Stream</code>以及<code class="highlighter-rouge">Python</code>中的列表推导式， 这两个特性很轻量， 也很实用。</p>

<h4 id="71-stream">7.1 Stream</h4>
<p>函数式编程提出已久， <code class="highlighter-rouge">Java</code>语言在1.8这个版本中才正式的推出了基于函数式编程的种种特性， 我们不得不正视这些特性， 因为有极大的可能函数式编程就是未来的编程首选。</p>

<p>Java 8 中的<code class="highlighter-rouge">Stream</code>是对集合对象功能的增强， 它专注于对集合对象进行各种非常便利， 高效的聚合操作， 或者是大批量的数据操作。 借助于新的<code class="highlighter-rouge">Lambda</code>表达式， 编程效率得到了非常大的提升。 另外， <code class="highlighter-rouge">Stream API</code>还提供了串行和并行两种模式进行汇聚操作， 我们可以使用<code class="highlighter-rouge">fork/join</code>来拆分任务并使用多线程的方法运行， 最终聚合形成结果， 提升系统性能。</p>

<p>那么上面我们写的年龄筛选， 就可以变成这样：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">ageFilterList</span> <span class="o">=</span> <span class="n">students</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">().</span>
        <span class="n">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">age</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="o">).</span>
        <span class="n">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<h5 id="72-列表推导式">7.2 列表推导式</h5>
<p><code class="highlighter-rouge">Python</code>中的列表推导式可谓是一大杀器， 威力极强， 代码逻辑非常清晰：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">age_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">student</span> <span class="k">for</span> <span class="n">student</span> <span class="ow">in</span> <span class="n">student_list</span> <span class="k">if</span> <span class="n">student</span><span class="o">.</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">]</span>
</code></pre></div></div>

<p>列表推导式还是很多花样可以玩儿， 在日常开发中使用的也比较多， 更多的内容如果读者感兴趣的话可以在<code class="highlighter-rouge">Google</code>中查阅相关资料(Ps: 不要用百度了)。</p>

<h4 id="8-简单工厂模式">8. 简单工厂模式</h4>
<p>工厂模式的应用可以说是众多设计模式中应用最为广泛的一种， 提供了一种创建对象的便捷方法， 调用方并不需要知道一个对象的具体创建过程， 不必关系其内部的细节。 工厂模式常常会被分为简单工厂模式， 工厂模式， 以及抽象工厂模式， 在这一小节介绍简单工厂模式。</p>

<h5 id="81-java实现">8.1 Java实现</h5>
<p>假设我们通过<code class="highlighter-rouge">socket</code>自己编写了一个<code class="highlighter-rouge">url</code>请求类， 层层封装， 使得客户端能够传入一个url参数， 并获得该url的HTML文本文档。 有时候用户会使用<code class="highlighter-rouge">https</code>开头的网址， 那么在此时我们就需要对SSL证书进行验证。 假设<code class="highlighter-rouge">http</code>与<code class="highlighter-rouge">https</code>这两种服务为两个不同的类实现， 但是它们有共同的接口：</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-28%2012-02-02%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">BaseHttp</span> <span class="o">{</span>
    <span class="cm">/* 这里的返回做简化处理, 直接返回字符串, 不再构建response对象了 */</span>
    <span class="n">String</span> <span class="nf">get</span><span class="o">();</span>
    <span class="n">Boolean</span> <span class="nf">IsCertificateValid</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Http</span> <span class="kd">implements</span> <span class="n">BaseHttp</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"Http Response"</span><span class="o">;</span> <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="cm">/* http服务不需要验证证书， 所以直接返回true */</span>
    <span class="kd">public</span> <span class="n">Boolean</span> <span class="nf">IsCertificateValid</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">Https</span> <span class="kd">implements</span> <span class="n">BaseHttp</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"Https Response"</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Boolean</span> <span class="nf">IsCertificateValid</span><span class="o">()</span> <span class="o">{</span>
        <span class="cm">/*  这里再做一个简化处理, 返回false */</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">HttpFactory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">BaseHttp</span> <span class="nf">create</span><span class="o">(</span><span class="n">String</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">url</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"https"</span><span class="o">))</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Https</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">url</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"http"</span><span class="o">))</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Http</span><span class="o">();</span>
        <span class="cm">/* 就算是以ip为url, 也需要添加协议类型, 所以这里直接抛出异常 */</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Invalid url"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>那么客户端在使用<code class="highlighter-rouge">Http</code>和<code class="highlighter-rouge">Https</code>服务时， 不需要关心URL是什么类型， 传递URL之后由<code class="highlighter-rouge">HttpFactory</code>进行判断， 并返回不同的对象即可。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleFactoryPattern</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/* 客户端调用 */</span>
        <span class="n">BaseHttp</span> <span class="n">http</span> <span class="o">=</span> <span class="n">HttpFactory</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">"http://google.com"</span><span class="o">);</span>
        <span class="n">BaseHttp</span> <span class="n">https</span> <span class="o">=</span> <span class="n">HttpFactory</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">"https://google.com"</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">http</span><span class="o">.</span><span class="na">IsCertificateValid</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">https</span><span class="o">.</span><span class="na">IsCertificateValid</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="9-工厂模式">9. 工厂模式</h4>

<p>通常来讲简单工厂模式能够满足大部分的需求， 但是有一个问题， 那么就是假如又有一个<code class="highlighter-rouge">ftp</code>的服务， 通过传递<code class="highlighter-rouge">ftp://ip</code>来获取远程的文件， 这个时候我们就需要改动<code class="highlighter-rouge">HttpFactory</code>， 再增加一层判断。 这样一来就违反了开放-封闭原则。</p>

<p>注: FTP协议和HTTP协议不是一个东西， FTP协议也不是基于HTTP协议的， 这里这么来写， 完全是出于理解工厂方法。 读者需要注意。</p>

<p>实现开放-封闭原则的一个手段就是再往上抽象一层， 审视简单工厂的UML类图， <code class="highlighter-rouge">BaseHttp</code>已经是一个接口了， 无法再抽象； 而<code class="highlighter-rouge">HttpFactory</code>却是一个实体类， 可以继续进行抽象。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-28%2014-06-05%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>我们将<code class="highlighter-rouge">HttpFactory</code>抽象成为<code class="highlighter-rouge">BaseFactory</code>， 根据该接口(或者是抽象类)实现<code class="highlighter-rouge">HttpFactory</code>， 用于创建<code class="highlighter-rouge">Http</code>对象， <code class="highlighter-rouge">HttpsFactory</code>创建<code class="highlighter-rouge">Https</code>对象， <code class="highlighter-rouge">FtpFactory</code>创建<code class="highlighter-rouge">Ftp</code>对象。 这样一来如果我们再增加一个服务， 我们只需要再实现一个工厂， 然后创建该服务即可。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">BaseFactory</span> <span class="o">{</span>
    <span class="cm">/* 将原有的工厂类抽象化 */</span>
    <span class="n">BaseHttp</span> <span class="nf">create</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">HttpFactory</span> <span class="kd">implements</span> <span class="n">BaseFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="cm">/* 在具体的实现类直接创建出相对应的服务对象 */</span>
    <span class="kd">public</span> <span class="n">BaseHttp</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Http</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FactoryPattern</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/* 客户端使用 */</span>
        <span class="n">BaseFactory</span> <span class="n">httpFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HttpFactory</span><span class="o">();</span>
        <span class="n">BaseHttp</span> <span class="n">http</span> <span class="o">=</span> <span class="n">httpFactory</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">http</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>工厂模式要比简单工厂模式稍微复杂一点点， 唯一的区别就是将工厂类进行了抽象化， 从而解决添加服务需要修改原有工厂类代码的问题。</p>

<p>但是这样一来又有问题了， 假如我有10个服务类， 均通过每个具体的工厂类创建， 那么客户端的程序员就需要知道这10个工厂类， 并且还需要知道每一个工厂类是干什么的， 加重了客户端程序员的开发难度。 而对于简单工厂模式， 我们只需要知道这个工厂类可以产生我们想要的对象即可， 对客户端coder更加友好。</p>

<p>当我们的服务对象改变并不会特别频繁时， 使用简单工厂模式； 当改动非常频繁， 且为必须的时候， 使用工厂模式， 此时文档的注释需要及时更新。</p>

<h4 id="10-抽象工厂模式">10. 抽象工厂模式</h4>
<p>简单工厂模式用于解决多个相同类型的对象的创建问题， 使得客户端传入一个简单的参数就可以得到想要的对象； 工厂模式在简单工厂模式之上进一步的抽象， 用于实现开放-封闭原则。 而抽象工厂模式是基于工厂模式， 对具体的产类进一步的划分。 看类图就明白了。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-28%2015-16-24%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>可以看到我们的产品类型增加了， 并且相应的工厂类也增加了一个创建对应产品的方法。 我们可以这样来理解：</p>

<p>Apple生产iphone， Airpods以及ipad; 微软生产windowsPhone， Headphones以及Surface， 类图如下：</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-28%2015-29-24%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>我们对工厂模式的代码进行一个简单的修改就可以得到抽象工厂模式的代码， 这里就不再写了， 没有太大的难度。</p>

<p>抽象工厂主要解决的问题就是一个工厂可能会生产多种产品的问题， 将不同产品抽象， 再将不同的工厂进行抽象， 具体的工厂生产所对应的产品， 最终就形成了一个完整的生产链。</p>

<h4 id="11-建造者模式">11. 建造者模式</h4>
<p>建造者模式类似于我们在玩儿RPG游戏时创建角色的过程： 首先角色的攻击类型， 有魔法攻击和物理攻击； 角色的服饰以及颜色， 角色的脸型， 角色的发型以及颜色等等， 然后我们在每个属性中挑一个出来， 就组成了我们的一个角色， 例如物理攻击， 青色汉服， 瓜子脸， 黑色短发。</p>

<p>建造者模式就是这样， 将一个复杂的对象拆开， 一步一步的创建单个对象， 最终再将这些对象组合在一起， 就形成了我们需要的对象。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-28%2016-44-42%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>这里以构建一个汽车为例， 从火花塞的绝缘体开始， 到火花塞， 到引擎， 类图如上所示。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 首先需要定义我们的产品类， 这里有绝缘体， 火花塞以及引擎
 */</span>
<span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">insulator</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="n">sparkPlugs</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="n">engine</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setInsulator</span><span class="o">(</span><span class="n">String</span> <span class="n">insulator</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">insulator</span> <span class="o">=</span> <span class="n">insulator</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSparkPlugs</span><span class="o">(</span><span class="n">String</span> <span class="n">sparkPlugs</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">sparkPlugs</span> <span class="o">=</span> <span class="n">sparkPlugs</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setEngine</span><span class="o">(</span><span class="n">String</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="n">engine</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * 建造者接口, 定义一个产品如何被构建
 */</span>
<span class="kd">interface</span> <span class="nc">Builder</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">buildInsulator</span><span class="o">();</span>

    <span class="kt">void</span> <span class="nf">buildSparkPlugs</span><span class="o">();</span>

    <span class="kt">void</span> <span class="nf">buildEngine</span><span class="o">();</span>

    <span class="n">Product</span> <span class="nf">getProduct</span><span class="o">();</span>
<span class="o">}</span>

<span class="cm">/**
 * 具体的构建者实现类, 因为构建过程由该类实现, 所以在此处实例化一个Product对象
 */</span>
<span class="kd">class</span> <span class="nc">ConcreteBuilder</span> <span class="kd">implements</span> <span class="n">Builder</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Product</span><span class="o">();</span>

    <span class="cm">/* 下面主要是调用Product所提供的setter方法来进行构建 */</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildInsulator</span><span class="o">()</span> <span class="o">{</span> <span class="n">product</span><span class="o">.</span><span class="na">setInsulator</span><span class="o">(</span><span class="s">"insulator"</span><span class="o">);</span> <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildSparkPlugs</span><span class="o">()</span> <span class="o">{</span> <span class="n">product</span><span class="o">.</span><span class="na">setSparkPlugs</span><span class="o">(</span><span class="s">"sparkPlugs"</span><span class="o">);</span> <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildEngine</span><span class="o">()</span> <span class="o">{</span> <span class="n">product</span><span class="o">.</span><span class="na">setEngine</span><span class="o">(</span><span class="s">"engine"</span><span class="o">);</span> <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Product</span> <span class="nf">getProduct</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">product</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Director决定构建顺序
 */</span>
<span class="kd">class</span> <span class="nc">Director</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">construct</span><span class="o">(</span><span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">buildInsulator</span><span class="o">();</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">buildSparkPlugs</span><span class="o">();</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">buildEngine</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BuilderPattern</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Builder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteBuilder</span><span class="o">();</span>
        <span class="n">Director</span><span class="o">.</span><span class="na">construct</span><span class="o">(</span><span class="n">builder</span><span class="o">);</span>

        <span class="n">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getProduct</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>建造者模式不可避免的会造成编写的代码很长， 这是绕不过去的。 如果想要使用建造者模式的话， 就要做好代码很长的准备。</p>

<h4 id="12-外观模式">12. 外观模式</h4>
<p>外观模式有些类似于代理模式， 但是要比代理模式更进一步。 我觉得外观模式就是一个工具箱， 里面儿放着一堆乱七八糟的方法和对象， 在调用方法时实际上是调用了所持有对象的方法， 对外屏蔽了所有的细节。</p>

<p>类图并不是很想画， 因为这个模式从代码层面上来看是非常简单的。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span> <span class="o">}</span>

<span class="kd">class</span> <span class="nc">Human</span> <span class="kd">implements</span> <span class="n">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Human eat"</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Lion</span> <span class="kd">implements</span> <span class="n">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Lion eat"</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">implements</span> <span class="n">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Cat eat"</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * 这里就是我们的百宝箱, 里面保存着各种各样的对象, 以及方法, 傻瓜式方法调用
 */</span>
<span class="kd">class</span> <span class="nc">Tools</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Human</span> <span class="n">human</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Lion</span> <span class="n">lion</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Cat</span> <span class="n">cat</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Tools</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">human</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Human</span><span class="o">();</span> <span class="k">this</span><span class="o">.</span><span class="na">lion</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Lion</span><span class="o">();</span> <span class="k">this</span><span class="o">.</span><span class="na">cat</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cat</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">humanEat</span><span class="o">()</span> <span class="o">{</span> <span class="n">human</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lionEat</span><span class="o">()</span> <span class="o">{</span> <span class="n">lion</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">catEat</span><span class="o">()</span> <span class="o">{</span> <span class="n">cat</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>外观模式怎么说呢， 给人一种奇怪的感觉， 如同一个百宝箱一样， 持有着各种各样的对象， 各种各样的方法， 有一种父亲给儿子在上学前的晚上在书包里面放置各种文具和生活用品的感觉。</p>

<h4 id="13-小结">13. 小结</h4>
<p>在本篇文章中， 介绍了过滤器模式， 简单工厂模式， 工厂模式， 抽象工厂模式， 建造者模式以及最后的外观模式， 加上前一篇文章的6种设计模式， 以及<code class="highlighter-rouge">I/O系统</code>这篇文章中提到的装饰模式和适配器模式， 总计14个。</p>

<p>本想将所有的设计模式一次性码完， 但是有些低估其数量以及编写的demo数量了。 一方面时间有限， 另一方面是剩下的设计模式并没有给我一种很足的”设计”感， 以及其应用并不会很广泛， 并且比较简单， 所以关于设计模式的梳理， 到这里就暂时告一段落， 下面的两篇文章将会着重的对代理模式和观察者模式进行进一步的梳理， 包括<code class="highlighter-rouge">Django</code>源码的重新阅读。</p>

<p>私以为理解设计模式的两个要点为理解面向对象编程以及6大设计原则， 当然在<code class="highlighter-rouge">Python</code>这种支持函数式编程的语言中， 种种设计原则将会进一步的被简化， 甚至被弱化。</p>

<p>在最开始笔者对设计模式可谓是一脸懵逼， 一眼看过去根本不知道在说些什么。 转机发生在我学习了UML类图以及设计原则之后， 如果有小伙伴儿想要开始学习设计模式， 但是不知道从哪儿入手的话， 可以从这两个方面着手。</p>

<p>最后推荐一本关于设计原则的书籍， 作者为 Robert C·Martin：</p>

<blockquote>
  <p>Agile Software Development: Principles, Patterns, and Practices
中文译本为: 敏捷软件开发–原则、模式与实践</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>Java基础编程(04)--常用的设计模式(01)</title>
	  <link>//Java-Design-Pattern</link>
	  <author></author>
	  <pubDate>2018-12-05T10:49:09+00:00</pubDate>
	  <guid>//Java-Design-Pattern</guid>
	  <description><![CDATA[
	     <p>在前面<code class="highlighter-rouge">I/O</code>系统中介绍了装饰模式， 在<code class="highlighter-rouge">接口与抽象类</code>中介绍了适配器模式， 以及设计模式的基础， 设计原则。 设计模式其实并没有那么神秘， 那么复杂， 本质上仍然是六大设计原则的体现。 既然要写， 就把所有的设计模式统统讲完， 才有快感。 另外这篇文章同样也会结合<code class="highlighter-rouge">Python</code>语言中的设计模式一起进行梳理， 这样做会进一步的加深我们对设计模式的理解， 至少在我这里是这样的。</p>

<!---more--->

<h4 id="1-单例模式">1. 单例模式</h4>
<p>在众多的设计模式之中， 单例模式毫无疑问的是使用最为频繁的设计模式， 不管是在<code class="highlighter-rouge">Java</code>， 还是在<code class="highlighter-rouge">Python</code>中。 单例模式的含义是指在全局中仅有某一个对象的唯一实例， 例如日志记录对象。</p>

<h5 id="11-java实现">1.1 Java实现</h5>
<p>在<code class="highlighter-rouge">Java</code>中， 单例模式的实现有很多种， 不过基本上都需要依赖静态变量以及私有的构造方法。</p>

<p>最简单的实现：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonClass</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kd">static</span> <span class="n">SingletonClass</span> <span class="n">singletonClass</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">SingletonClass</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">SingletonClass</span> <span class="nf">getSingletonClass</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">singletonClass</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">singletonClass</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SingletonClass</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">singletonClass</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在这种最简单的实现中， 使用了静态变量仅会被初始化一次的特性， 将对象的实例保存至静态变量中， 并通过静态方法将实例返回。 在静态方法中， 是一个<code class="highlighter-rouge">if-then</code>的结构， 很明显的是该方法是线程不安全的， 所以就有了线程安全版：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="n">SingletonClass</span> <span class="nf">getSingletonClass</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">singletonClass</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">singletonClass</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SingletonClass</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">singletonClass</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>我们对整个方法进行同步， 这样一来既可以保证该方法的线程安全性。 但是<code class="highlighter-rouge">synchronized</code>最为一种重量级的锁， 在并发环境下所有的方法调用均为串行执行， 效率比较低， 所以我们需要尽可能的减少串行执行的线程数量， 采用双重校验锁的方式完成：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span>  <span class="n">SingletonClass</span> <span class="nf">getSingletonClass</span><span class="o">()</span> <span class="o">{</span>
    <span class="cm">/* 第一次校验是让实例已经被初始化之后直接返回 */</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">singletonClass</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/* 如果此时singletonClass == null, 那么就需要线程安全的实例化对象 */</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">SingletonClass</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
            <span class="cm">/* 再次判断, 此时为加锁判断, 保证变量不会被其它线程所修改, 即保持单例*/</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">singletonClass</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">singletonClass</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SingletonClass</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">singletonClass</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>双重校验锁的内容在<code class="highlighter-rouge">Java并发编程--锁</code>中有提到， 可能那篇文章中的描述更容易被理解。 这种方式通常来讲是我使用最多的方式， 既能够保证线程安全性， 同时也有较好的性能。</p>

<p>除此之外， 还有2种较好的实现方式， 一种是使用静态内部类来实现：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">NewSingletonClass</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SingletonContainer</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">NewSingletonClass</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NewSingletonClass</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">NewSingletonClass</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">NewSingletonClass</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">SingletonContainer</span><span class="o">.</span><span class="na">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>由于静态内部类的加载由JVM保证其线程安全性， 并且只有在调用内部类的静态变量时类才被加载， 所以这种写法也是线程安全性的， 并且代码比较简单。</p>

<p>最后一种写法就需要对<code class="highlighter-rouge">Java</code>的枚举类有一个比较深入的理解了， 在这里我们只需要知道创建一个枚举类型是线程安全的即可。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">Foo</span> <span class="o">{</span>
    <span class="n">INSTANCE</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">otherMethod</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Other methods.."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/* 测试 */</span>
        <span class="n">Foo</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
        <span class="n">foo</span><span class="o">.</span><span class="na">otherMethod</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这种写法可能不是那么易懂， 但是的确要比上面所有的方式都简洁， 所以使用枚举类来实现单例已经称为了目前的主流。</p>

<h5 id="12-python实现">1.2 Python实现</h5>
<p>在<code class="highlighter-rouge">Python</code>中， 最简单， 最直接的方式就是使用<code class="highlighter-rouge">.pyc</code>文件的单一初始化来实现， 说白了就是模块儿导入。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Singleton</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="n">singleton_class</span> <span class="o">=</span> <span class="n">Singleton</span><span class="p">()</span>

<span class="c"># other module</span>
<span class="kn">from</span> <span class="nn">singleton</span> <span class="kn">import</span> <span class="n">singleton_class</span>
</code></pre></div></div>

<p>这种方式用的最多(因为真的很简单)， 不过前提是没有特别的定制化需求情况下。</p>

<p>在有定制化的需求之下， 例如一个用于拥有某一个对象的单个实例， 模块的方式无法完成， 此时可以使用装饰器或者是<code class="highlighter-rouge">__new__</code>方法来实现。</p>

<p><code class="highlighter-rouge">__new__</code>方法在<code class="highlighter-rouge">Python</code>中为一个类的构造方法， 默认返回一个类的实例。 而<code class="highlighter-rouge">__init__</code>方法则是在该实例上进行属性的添加。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SimpleSingleton</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">instance_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">username</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance_dict</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">cls</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">username</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance_dict</span><span class="p">:</span>
                    <span class="n">instance</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
                    <span class="n">cls</span><span class="o">.</span><span class="n">instance_dict</span><span class="p">[</span><span class="n">username</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span>
                    <span class="k">return</span> <span class="n">instance</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance_dict</span><span class="p">[</span><span class="n">username</span><span class="p">]</span>
</code></pre></div></div>

<p>这里仍然是使用双重校验锁的方式来创建单例， 只不过我们在这里额外的添加了一个<code class="highlighter-rouge">username</code>标志， 每个用户一个实例。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">singleton_decorator</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="n">instances</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_instance</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">:</span>
            <span class="n">instances</span><span class="p">[</span><span class="n">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instances</span><span class="p">[</span><span class="n">cls</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">get_instance</span>
</code></pre></div></div>

<p>这是一个比较典型的单例模式的装饰器， 很多博客都是这么写的， 装饰器本质上还是一个函数调用， 有函数调用的地方就需要保证线程安全性， 这上面的这一种写法并没有做到这一点， 所以我认为这种写法是错误的， 是非线程安全的。</p>

<p>所以说还是需要加锁， 写法与<code class="highlighter-rouge">__new__</code>方法中的实现基本相同， 也是使用一个双重校验锁：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">singleton_decorator</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="n">instances</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_instance</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">:</span>
                    <span class="n">instances</span><span class="p">[</span><span class="n">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instances</span><span class="p">[</span><span class="n">cls</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">get_instance</span>
</code></pre></div></div>

<p>此外还可以使用<code class="highlighter-rouge">__metaclass__</code>元类的方式来实现， 该加锁还是需要加锁， 没什么区别。</p>

<h4 id="2-原型模式">2. 原型模式</h4>
<p>原型模式的目的在于在创建重复对象时提高性能， 本质上其实是一种内存的拷贝。 在<code class="highlighter-rouge">Java</code>中是通过实现<code class="highlighter-rouge">clonable</code>接口实现， 而在<code class="highlighter-rouge">Python</code>中则是通过标准库的函数所实现的。</p>

<p>提高拷贝， 就不得不提到深拷贝与浅拷贝。 当一个对象包含了另一个对象的引用时， 浅拷贝仅拷贝引用， 深拷贝则拷贝所引用对象的内容。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-10-26%2015-16-16%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<h5 id="21-java实现">2.1 Java实现</h5>
<p>只需要实现<code class="highlighter-rouge">clonable</code>接口即可， 默认实现的是浅拷贝， 如果想要实现深拷贝的话：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="n">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">CloneNotSupportedException</span> <span class="o">{</span>
    <span class="n">MyClass</span> <span class="n">template</span> <span class="o">=</span> <span class="o">(</span><span class="n">MyClass</span><span class="o">)</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
    <span class="cm">/* created即为对象所引用的对象, 深克隆必须对该对象也进行克隆 */</span>
    <span class="n">template</span><span class="o">.</span><span class="na">created</span> <span class="o">=</span> <span class="o">(</span><span class="n">Date</span><span class="o">)</span> <span class="n">template</span><span class="o">.</span><span class="na">created</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">template</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>通常来讲深拷贝不会使用原型模式来实现， 而是使用序列化的方式实现。</p>

<h5 id="22-python实现">2.2 Python实现</h5>
<p><code class="highlighter-rouge">Python</code>实现的话就简单多了， 直接调标准库的函数即可。</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>

<span class="n">information</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">"name"</span><span class="p">:</span> <span class="s">"smart"</span><span class="p">,</span>
    <span class="s">"phones"</span><span class="p">:</span> <span class="p">[</span><span class="s">"136"</span><span class="p">,</span> <span class="s">"138"</span><span class="p">]</span>
<span class="p">}</span>

<span class="n">new_information</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">information</span><span class="p">)</span>
<span class="n">new_information</span><span class="p">[</span><span class="s">"phones"</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">"139"</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">information</span><span class="p">[</span><span class="s">"phones"</span><span class="p">])</span>       <span class="c"># ['136', '138', '139']</span>
<span class="k">print</span><span class="p">(</span><span class="n">new_information</span><span class="p">[</span><span class="s">"phones"</span><span class="p">])</span>   <span class="c"># ['136', '138', '139']</span>


<span class="n">deep_information</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">information</span><span class="p">)</span>
<span class="n">deep_information</span><span class="p">[</span><span class="s">"phones"</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">"137"</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">information</span><span class="p">[</span><span class="s">"phones"</span><span class="p">])</span>       <span class="c"># ['136', '138', '139']</span>
<span class="k">print</span><span class="p">(</span><span class="n">deep_information</span><span class="p">[</span><span class="s">"phones"</span><span class="p">])</span>  <span class="c"># ['136', '138', '139', '137']</span>
</code></pre></div></div>

<p>从上面的示例代码可以很清晰的看出浅拷贝与深拷贝之间的区别， 通常在工程实践中， 浅拷贝只有在我们明确的知道对象中仅包含基本数据类型时才会使用， 否则一律使用深拷贝的方式进行对象的复制。</p>

<h4 id="3-策略模式">3. 策略模式</h4>
<p>策略模式为我们提供了在运行时更改类的行为或者算法的功能， 例如<code class="highlighter-rouge">Python</code>中的<code class="highlighter-rouge">sort</code>， <code class="highlighter-rouge">json</code>函数， 通过传入一个匿名函数来改变排序方式或者是序列化方式。</p>

<h5 id="31-java实现">3.1 Java实现</h5>
<p>这里以JDK源码为例， 在搜索文件时我们可以传入一个<code class="highlighter-rouge">FilenameFilter</code>对象来完成文件的指定搜索：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"."</span><span class="o">);</span>
<span class="n">file</span><span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="k">new</span> <span class="n">FilenameFilter</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">accept</span><span class="o">(</span><span class="n">File</span> <span class="n">dir</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".java"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">list</code>方法所接收的<code class="highlighter-rouge">FilenameFilter</code>对象就是一种策略， 来看一下具体的实现：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">String</span><span class="o">[]</span> <span class="nf">list</span><span class="o">(</span><span class="n">FilenameFilter</span> <span class="n">filter</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">names</span><span class="o">[]</span> <span class="o">=</span> <span class="n">list</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">names</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">filter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">names</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">names</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="cm">/* 调用对象的accept方法， 若为true, 则添加至列表中 */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">filter</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">names</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
            <span class="n">v</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">names</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">v</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">FilenameFilter</code>接口也比较简单：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FilenameFilter</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">accept</span><span class="o">(</span><span class="n">File</span> <span class="n">dir</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>只要实现了该接口的类， 都可以作为一种策略传入至<code class="highlighter-rouge">list</code>方法， 为代码提供了更多的灵活性。</p>

<h5 id="32-python实现">3.2 Python实现</h5>
<p><code class="highlighter-rouge">Python</code>这里以<code class="highlighter-rouge">json</code>函数为例， 我们首先定义2个对象：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">json</span>

<span class="k">class</span> <span class="nc">Phone</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">brands</span><span class="p">,</span> <span class="n">price</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">brands</span> <span class="o">=</span> <span class="n">brands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">price</span> <span class="o">=</span> <span class="n">price</span>

<span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">phone</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>
        <span class="c"># Student对象中持有Phone对象</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phone</span> <span class="o">=</span> <span class="n">phone</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">phone</span> <span class="o">=</span> <span class="n">Phone</span><span class="p">(</span><span class="s">"iphone"</span><span class="p">,</span> <span class="mi">7999</span><span class="p">)</span>
    <span class="c"># 完成Student对象的创建</span>
    <span class="n">student</span> <span class="o">=</span> <span class="n">Student</span><span class="p">(</span><span class="s">"smart"</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="n">phone</span><span class="p">)</span>
    <span class="c"># 尝试进行序列化</span>
    <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">student</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
</code></pre></div></div>

<p>在此时我们对<code class="highlighter-rouge">Student</code>对象直接调用<code class="highlighter-rouge">json.dumps</code>方法时会抛出一个<code class="highlighter-rouge">TypeError</code>， 告诉我们<code class="highlighter-rouge">Phone</code>类型不是可以被JSON序列化的， 所以在这个时候我们就需要传递一个策略进去：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">student</span><span class="o">.</span><span class="n">__dict__</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">json.dumps</code>方法同样可以接受一个策略， 参数名为<code class="highlighter-rouge">default</code>， 这里我们传入了一个匿名函数， 函数返回传入对象的<code class="highlighter-rouge">__dict__</code>属性， 当json在序列化遇到了<code class="highlighter-rouge">TypeError</code>时， 就会使用我们传递的策略尝试重新进行序列化。</p>

<p>策略模式在日常开发中使用的会比较多， 自己编写的机会并不是很多。 一般来说使用策略模式的情景还是比较明显的， 主要是满足客户端的多种定制化需求。</p>

<h4 id="4-责任链模式">4. 责任链模式</h4>
<p>责任链模式有些类似于工作审批， 员工向组长提交审批， 组长向部门经理提交， 部门经理向总经理提交， 总经理直接处理， 不再向下传递。 如果该审批(例如请假2小时)组长能够直接处理， 那么审批不再向下传递。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-27%2014-37-18%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<h5 id="41-java实现">4.1 Java实现</h5>

<p>责任链模式常见的类图如下：</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-27%2014-26-38%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>从这个模式的名称上我们可以大致的猜出应该会有类似于链表的结构存在系统中， 事实上也的确是这样。 通常来讲我们会用一个抽象类来定义一些基本的方法， 例如是否需要将请求提交至下一个处理器， 如何添加下一个处理器等方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Handler</span> <span class="o">{</span>
    <span class="cm">/* 持有下一个处理器对象 */</span>
    <span class="kd">private</span> <span class="n">Handler</span> <span class="n">nextHandler</span><span class="o">;</span>
    <span class="cm">/* level变量通常是用来判断是否需要继续往下执行处理器 */</span>
    <span class="kd">protected</span> <span class="kt">int</span> <span class="n">level</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setNextHandler</span><span class="o">(</span><span class="n">Handler</span> <span class="n">nextHandler</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nextHandler</span> <span class="o">=</span> <span class="n">nextHandler</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="kt">int</span> <span class="n">level</span><span class="o">,</span> <span class="n">String</span> <span class="n">message</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">level</span> <span class="o">==</span> <span class="n">level</span><span class="o">)</span>  <span class="c1">// 这里为了简便处理， 直接用的相等判断</span>
            <span class="n">process</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
            <span class="cm">/* 当一个处理器处理完成之后， 是继续向下处理， 还是直接结束 */</span>
            <span class="c1">// return;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nextHandler</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="cm">/* 执行下一个处理器 */</span>
            <span class="n">nextHandler</span><span class="o">.</span><span class="na">handleMessage</span><span class="o">(</span><span class="n">level</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">String</span> <span class="n">message</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>抽象的<code class="highlighter-rouge">Handler</code>类其实就是核心的设计思想了， 具体的处理器继承该抽象类， 实现抽象方法， 并添加一个接收<code class="highlighter-rouge">level</code>参数的构造器即可。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Handler1</span> <span class="kd">extends</span> <span class="n">Handler</span> <span class="o">{</span>
    <span class="n">Handler1</span><span class="o">(</span><span class="kt">int</span> <span class="n">level</span><span class="o">){</span> <span class="k">this</span><span class="o">.</span><span class="na">level</span> <span class="o">=</span> <span class="n">level</span><span class="o">;</span> <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Handler1"</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>我们还需要为客户端提供一个设置好责任链的<code class="highlighter-rouge">Handler</code>对象， 隐藏细节：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Handler</span> <span class="nf">getChainHandler</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Handler</span> <span class="n">handler1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler1</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">Handler</span> <span class="n">handler2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler2</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="n">handler1</span><span class="o">.</span><span class="na">setNextHandler</span><span class="o">(</span><span class="n">handler2</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">handler1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="42-python实现">4.2 Python实现</h5>
<p>讲实话我在<code class="highlighter-rouge">Python</code>中还真的没见过很明显的责任链模式， 可能是我源码看的还不够多， 但是有一个地方很像责任链， 那就是<code class="highlighter-rouge">Django</code>中的中间件(Middleware)处理。</p>

<p>在1.9.8这个版本中， 中间件还是继承<code class="highlighter-rouge">MiddlewareMixin</code>， 并实现<code class="highlighter-rouge">process_request</code>或者是<code class="highlighter-rouge">process_response</code>方法所实现的， 最新版本情况未知， 想必改动不会太大。</p>

<p>在<code class="highlighter-rouge">Django</code>中， 请求被实例化成为一个请求对象之后， 首先调用配置的中间件的<code class="highlighter-rouge">process_request</code>方法， 做一些事情， 例如安全检测， 获取<code class="highlighter-rouge">Cookie</code>， 获取当前请求用户等等。 在响应时<code class="highlighter-rouge">response</code>对象将会以相反的方向执行<code class="highlighter-rouge">process_response</code>方法。</p>

<p>源代码我就不贴了， 有点儿长。 基本上<code class="highlighter-rouge">Django</code>这种对请求的处理和责任链模式还是有相似之处的。</p>

<h4 id="5-代理模式">5. 代理模式</h4>

<p><code class="highlighter-rouge">Nginx</code>的其中一个作用就是隐藏真实的服务器地址， 向外暴露Nginx服务器的域名以及IP， 这样一来可以提高真实服务器的安全性。 请求首先进入Nginx服务器， 再由负载均衡器转发至对应的真实服务器中， 在这个过程中， Nginx服务器就是一个代理服务器。</p>

<p>代理模式与上面的过程是一样的， 为用户提供一个<code class="highlighter-rouge">Proxy</code>对象， 用户直接与<code class="highlighter-rouge">Proxy</code>对象进行交互， <code class="highlighter-rouge">Proxy</code>对象再与真实对象进行交互。</p>

<h5 id="51-java实现">5.1 Java实现</h5>
<p>静态代理： 类图如下， 首先有一个公共接口， 约束真实对象与代理对象的行为， 然后在代理对象中可以持有一个真实对象的实例， 客户端在调用方法时， 由代理对象调用真实对象方法。 静态代理是在编译器就知道了所代理的对象类型。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-27%2015-47-55%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 代理类和真实类的统一接口 */</span>
<span class="kd">interface</span> <span class="nc">Action</span> <span class="o">{</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">();</span> <span class="o">}</span>

<span class="cm">/* 真实类的实现 */</span>
<span class="kd">class</span> <span class="nc">RealAction</span> <span class="kd">implements</span> <span class="n">Action</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Action!"</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Proxy</span> <span class="kd">implements</span> <span class="n">Action</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">RealAction</span> <span class="n">realAction</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="cm">/* 这里做了一些简化处理, 测试的话不考虑实际使用 */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">realAction</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">realAction</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RealAction</span><span class="o">();</span>
        <span class="cm">/* 调用真实类的相关方法 */</span>
        <span class="n">realAction</span><span class="o">.</span><span class="na">move</span><span class="o">();</span>
        <span class="cm">/* 代理类自己也可以做一些额外的事情 */</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"代理类额外做的事情"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>静态代理可以在不修改原有类对象的前提下， 对类进行功能的拓展。 但是由于公用同一个接口， 使得在修改接口时需要至少修改2个类。</p>

<p>动态代理要比静态代理稍微复杂一些， 但是本质没有改变多少。</p>

<p>首先来看由JDK所提供的基于反射的代理类， <code class="highlighter-rouge">java.lang.reflect.Proxy</code>， 其中有一个很重要的方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">newProxyInstance</span><span class="o">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="o">,</span>
                                      <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">interfaces</span><span class="o">,</span>
                                      <span class="n">InvocationHandler</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div></div>

<p>根据javadoc， <code class="highlighter-rouge">loader</code>为一个类加载器， <code class="highlighter-rouge">interfaces</code>为代理类将要实现的一组接口对象所组成的列表， <code class="highlighter-rouge">h</code>是一个<code class="highlighter-rouge">InvocationHandler</code>对象。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">InvocationHandler</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在解释这些对象之前首先运行一个demo：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ProxyHolder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Object</span> <span class="n">target</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ProxyHolder</span><span class="o">(</span><span class="n">Object</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getProxyInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span>
                <span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span>
                <span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getInterfaces</span><span class="o">(),</span>
                <span class="k">new</span> <span class="nf">InvocationHandler</span><span class="o">()</span> <span class="o">{</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
                        <span class="n">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
                        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"代理类额外做的事情"</span><span class="o">);</span>
                        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
        <span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DynamicProxy</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Action</span> <span class="n">realAction</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RealAction</span><span class="o">();</span>
        <span class="n">Action</span> <span class="n">proxyInstance</span> <span class="o">=</span> <span class="o">(</span><span class="n">Action</span><span class="o">)</span> <span class="k">new</span> <span class="n">ProxyHolder</span><span class="o">(</span><span class="n">realAction</span><span class="o">).</span><span class="na">getProxyInstance</span><span class="o">();</span>
        <span class="n">proxyInstance</span><span class="o">.</span><span class="na">move</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以看到我们在创建代理类的时候完全使用的是反射的机制， 在此期间根本不知道要代理的对象是什么， 而是使用<code class="highlighter-rouge">Object</code>对象来表示的， 并且代理方法是在<code class="highlighter-rouge">invoke</code>方法中所实现的。 上面的代码就是JDK所提供的动态代理。</p>

<p>如果接口中有多个方法需要进行代理的话， 也可以在<code class="highlighter-rouge">invoke</code>方法中集中进行处理。 其中， 传入的<code class="highlighter-rouge">Method</code>对象会包含正在被调用的接口方法。</p>

<p>不管是JDK动态代理， 还是静态代理， 都需要一个类实现一个接口， 那么对于单独的类想要实现动态代理， 该如何去做？</p>

<p><code class="highlighter-rouge">cglib</code>代理通过构建目标对象子类的方式实现动态代理， 从而实现对目标对象功能的拓展。 因为这种方式不属于JDK的设计模式， 所以说将会在<code class="highlighter-rouge">AOP的实现</code>文章中给出。</p>

<h5 id="52-python实现">5.2 Python实现</h5>
<p>由于<code class="highlighter-rouge">Python</code>是一种弱类型语言， 所以说其代理模式的实现就要比<code class="highlighter-rouge">Java</code>灵活的多。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ProxyFactory</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>

    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">"target"</span><span class="p">)</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">attr</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"动态代理做点儿其它事情"</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">Test</span><span class="p">()</span>
    <span class="n">proxy</span> <span class="o">=</span> <span class="n">ProxyFactory</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
    <span class="n">proxy</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
</code></pre></div></div>

<p>首先要说明一点， <code class="highlighter-rouge">__getattr__</code>与<code class="highlighter-rouge">__getattribute__</code>是两个不同的方法， 但是都用于获取类属性或者是方法。 当这两个方法同时被定义时， 仅会调用<code class="highlighter-rouge">__getattribute__</code>方法， 除非显示的使用<code class="highlighter-rouge">instance.__getattr__</code>方法。</p>

<p>一般来说， <code class="highlighter-rouge">__getattr__</code>会在访问类中不存在的属性时调用， 而<code class="highlighter-rouge">__getattribute__</code>方法则属于无条件调用， 不管有没有， 都会调用。 函数， 也算是一种属性， 所以说在调用<code class="highlighter-rouge">proxy.foo</code>方法时， 首先调用<code class="highlighter-rouge">__getattribute__</code>获取函数对象。</p>

<h4 id="6-观察者模式">6. 观察者模式</h4>
<p>观察者模式有些类似于<code class="highlighter-rouge">Redis</code>的发布/订阅， 多个客户端订阅某一个频道， 当频道内的键发生变化时<code class="highlighter-rouge">Redis</code>通知订阅端相应的变化。 主不过观察者模式是在对象层面上的”发布/订阅”， 多个观察者同时监听某一个对象， 当对象发生变化时， 通知所有的观察者， 观察者根据相应的变化做出相应的反应。</p>

<h5 id="61-java实现">6.1 Java实现</h5>

<p>类图如下， 没有什么很复杂的地方， 只需要将<code class="highlighter-rouge">Observer</code>设置成为抽象类即可， 以便于复用。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-27%2018-44-01%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Subject</span> <span class="o">{</span>
    <span class="cm">/* 用于存储所有的观察者 */</span>
    <span class="kd">protected</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Observer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Observer</span><span class="o">&gt;();</span>

    <span class="cm">/* 添加一个观察者 */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addObserver</span><span class="o">(</span><span class="n">Observer</span> <span class="n">observer</span><span class="o">)</span> <span class="o">{</span> <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">observer</span><span class="o">);</span> <span class="o">}</span>

    <span class="cm">/* 通知所有观察者, 在该方法中可以传递更多的参数 */</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">notifyAllObservers</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Observer</span> <span class="n">observer</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">observer</span><span class="o">.</span><span class="na">receive</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeStatus</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"被观察对象发生了改变"</span><span class="o">);</span>
        <span class="n">notifyAllObservers</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Observer</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="n">Subject</span> <span class="n">subject</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">receive</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Observer1</span> <span class="kd">extends</span> <span class="n">Observer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Observer1</span><span class="o">(</span><span class="n">Subject</span> <span class="n">subject</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">subject</span> <span class="o">=</span> <span class="n">subject</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">subject</span><span class="o">.</span><span class="na">addObserver</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">receive</span><span class="o">()</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"观察者1接受到了反馈"</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/* 测试类 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ObserverPattern</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Subject</span> <span class="n">subject</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Subject</span><span class="o">();</span>
        <span class="n">Observer1</span> <span class="n">observer1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Observer1</span><span class="o">(</span><span class="n">subject</span><span class="o">);</span>
        <span class="n">subject</span><span class="o">.</span><span class="na">changeStatus</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里给出了基于上面类图所实现的观察者模式demo， 整体来看比较简单。 但是实际生产中的观察者模式远比这复杂。 首先要考虑的就是线程安全性， 其次观察者模式分为推模式和拉模式， 两种模式的实现有较大的区别。 另外需要考虑的就是对象的引用问题， <code class="highlighter-rouge">GC</code>如何处理， 是否需要使用弱引用。</p>

<p>工程实践中的观察者较为复杂， 代码也比较多， 所以更加完善的分析放于后续的博文中。</p>

<h5 id="62-python实现">6.2 Python实现</h5>
<p>观察者模式最直接的实现是在<code class="highlighter-rouge">Django</code>的信号量中， 具体的源码分析同样会单独写一篇出来。</p>

<h4 id="7-小结">7. 小结</h4>
<p>在最初的计划中是想要一篇文章将所有的设计模式一次性梳理完， 但是一篇写完的话实在是太长， 不方便阅读， 所以还是将其拆分成几篇文章， 每篇写几个。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Java基础编程(03)--容器</title>
	  <link>//Java-Container</link>
	  <author></author>
	  <pubDate>2018-12-01T04:49:09+00:00</pubDate>
	  <guid>//Java-Container</guid>
	  <description><![CDATA[
	     <p><code class="highlighter-rouge">Java</code>中的各种容器类是对基本数据结构， 如顺序表， 链表， 平衡二叉树， 红黑树等最直接的体现， 容器在使用时最重要的就是其在不同的应用场景下的时间复杂度。 例如， 需要一个有序的容器， 需要频繁的向其头部和尾部分别执行删除和插入操作， 此时选择数组所实现的容器就非常的不明智。 所以， 如果想要彻底理解<code class="highlighter-rouge">Java</code>中的容器， 首先要理解计算机世界中的基础数据结构。 另外需要说明的是， 本篇博文没有任何代码， 只对各种容器的原理进行说明。</p>

<!---more--->

<h4 id="1-数组">1. 数组</h4>
<p>毫无疑问， 数组结构是所有软件设计中最为重要的基础数据结构， 具有高效查找的哈希表也从数组结构而来。</p>

<p>数组在底层由顺序表实现， 占据内存的一片连续空间， 结构紧凑， 每一个存储单元的大小固定。 在绝大多数语言中， 数组的下标从0开始。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-23%2014-32-39%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>由于存储单元的大小是固定的(如果存储不同类型的数据， 此时存储单元中可以存放指针)， 所以在顺序表中按照下标查找元素是非常快速的， 假如每个存储空间内存占用为L， 顺序表起始空间地址为C, 则下标为i的元素在内存地址即为：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C<span class="o">(</span>i<span class="o">)</span> <span class="o">=</span> C + L <span class="k">*</span> i
</code></pre></div></div>
<p>这也就促成了使用<code class="highlighter-rouge">a[0], a[10]</code>这样的方式来查找元素拥有极高的效率。 当我们向顺序表头部或者中间删除元素时， 由于需要保持元素的有序性， 所以需要将元素挨个儿的向左移动：</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-23%2014-32-57%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>如果是插入元素， 则该索引后面的元素都需要向右移动。 那么在这种情况下， 我们称为其平均时间复杂度为O(n)。 这里对平均时间复杂度做一个简单的计算。 顺序表中包含n个元素， 向索引为0的存储空间插入元素， 则需要移动n个元素， 向索引为1的存储空间插入元素， 需要移动n-1个元素…向索引为i(i&lt;=n)的存储空间插入元素， 需要移动n-i个元素， 那么平均时间复杂度即为：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>n + <span class="o">(</span>n-1<span class="o">)</span> + <span class="o">(</span>n-2<span class="o">)</span> + ... + 0 <span class="o">)</span> / n <span class="o">=</span> <span class="o">(</span>n + 1<span class="o">)</span> / 2
</code></pre></div></div>
<p>当n无限大的时候， 系数所带来的影响微乎其微， 更为关键的是其增长趋势， 所以我们说其平均时间复杂度为O(n)。 有平均复杂度， 就会有最好和最坏的复杂度： 最坏的情况当然是索引为0的元素进行插入/删除操作， 复杂度为O(n); 最好情况则是在尾部插入/删除， 时间复杂度为O(1)。</p>

<p>当我们像上图中声明了5个元素的数组， 并且顺序表以满时， 顺序表就需要进行扩容。 通常来讲每一次扩容都是当前顺序表容量的2倍， 在每次扩容时都需要在内存中新开辟一段连续空间， 然后将原有的元素挨个的复制到新表中。 这个过程的时间复杂度为O(n), 很浪费时间， 能不能不要？这里需要注意的一点就是： 并不是每一个的插入操作都会触发扩容操作， 比如操作100次才会触发扩容， 此时也就是复制100次元素数据而已， 均摊到每一次的操作上， 时间复杂度即为O(1)， 这种复杂度的计算称为均摊复杂度。</p>

<h4 id="2-链表">2. 链表</h4>
<p>链表也是顺序表的一种实现方式， 是一种最基础的动态数据结构。 链表的每一个节点都会保存着指向下一个节点的引用(指针)， 最后一个节点的引用为<code class="highlighter-rouge">null</code>或者<code class="highlighter-rouge">None</code>。 这样的结构使得链表完全不需要连续的存储空间， 只要有空闲的内存， 都可以作为节点进行存储， 只需要让上一个节点的引用指向自己， 并且自己的引用指向下一个节点即可。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-23%2014-33-20%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>所以链表的下标查找是非常缓慢的， 因为必须要通过一个节点一个节点的查找， 才能找到我们想要的那个节点。 在单向链表中， 如果想要在链表的最后插入一个节点， 那么需要遍历整个链表， 为了优化这一场景， 我们可以在链表的头部添加一个引用， 使其指向最后一个节点。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-23%2014-33-47%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>为了优化单向链表的下标查找效率， 就有了双向链表， 每一个节点都包含对上一个和下一个节点的引用。 如果查找的下标大于链表容量的1/2， 则可以从后往前进行查找：</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-23%2014-34-09%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>链表这种数据结构最大的意义就在于它不需要占用连续的内存空间， 删除节点和添加节点的操作不需要进行元素的平移(但是定位节点花费的时间要比顺序表多)， 能够最大化的利用内存空间， 这一点是顺序表无法做到的。</p>

<h4 id="3-二分搜索树">3. 二分搜索树</h4>
<p>二分搜索树(Binary Tree)是平衡二分搜索树以及红黑树的基础， 是一种有序的树结构。 二分搜索树的每一个节点都包一个左子节点和一个右子节点， 其中左子节点的值均小于根节点， 右子节点的值均大于根节点。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-23%2015-02-19%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>当我们要查找值为17的元素时， 首先与根节点8进行比较， 发现大于8， 则移动到其右子节点10， 比较后发现仍大于该节点， 再次移动至其右子节点， 找到元素17。</p>

<p>我们可能会有一个疑问， 既然数组已经是有序的了， 我使用二分搜索算法也能够很快的找到元素17， 那为什么还需要构建一颗树呢， 不是自找麻烦？ <strong>二分搜索树其实是一种基础数据结构， 主要用于构建更为高层的数据结构， 如集合， 字典等。</strong></p>

<p>集合是一种数学概念， 为一个或多个没有重复元素所组成的一组数值。 如果使用二分搜索树来实现集合， 我们可以将元素的值保存在节点中， 并依照二分搜索树的规则建立一颗树， 当有重复元素插入时， 我们可以在O(logn)的时间复杂度上知道这是一个重复元素， 并放弃插入。</p>

<p>字典是一种Key-Value的映射结构， 我们将key用以节点比较， value则存储在节点中， 同样地， 我们可以在O(logn)的时间复杂度上通过key来查找value。</p>

<p>普通的平衡二叉树会有平衡失调的问题， 即其中一个子树非常高， 造成元素的查找为线性查找， 即O(n)， 平衡二叉搜索树以及红黑树则是专门用于解决平衡问题所产生的数据结构， 其元素特性与二分搜索树相同。</p>

<h4 id="4-字典与集合的哈希表实现">4. 字典与集合的哈希表实现</h4>
<p>哈希表是一种以空间换时间的抽象数据类型， 用于实现集合以及字典等高级数据结构， 其本质上仍为数组。</p>

<p>散列技术， 将无限的数值映射到有限的空间中， 使其均匀分布。 评价一个哈希策略的好坏， 就是审视其散列是否均匀。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-23%2015-43-14%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>如上图所示， 我们需要将17个数字均匀的散列到下面的8个存储空间中， 这样一来， 一个存储空间就至少需要保存2个数字， 这种情况我们称为哈希冲突。 为了尽可能的避免哈希冲突， 我们需要在一开始分配比较大的数组空间， 这就是以空间换时间的第一层含义。</p>

<p>那么为什么是用空间来换时间， 而不是换其它的东西呢？ 在第一节的顺序表梳理中我们知道顺序表的下标查找是非常之快的， 那么假如我们的哈希函数较好， 映射比较均匀， 当我们对元素调用哈希函数之后的值， 就是元素的下标会发生什么？</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-23%2015-55-44%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>如上图所示， 我们开辟了拥有12个存储空间的数组， 并将5个数字使用散列的方式放置于数组中， 散列的函数我们可以不管， 只需要知道对一个数字调用散列函数之后， 结果就是数组的下标即可。 此时我们查找元素就只需要执行两个步骤： 计算该元素的哈希结果， 将结果作为数组下标查找元素。</p>

<p>这个过程非常快， 理论上的平均时间复杂度为O(1)， 即不管有多少个元素， 都能够在相同的时间内找到该元素。 这就是以空间换时间的第二层含义。</p>

<h4 id="5-java中的容器类">5. Java中的容器类</h4>
<p>其实在了解了数组， 链表， 平衡二叉树这些基础数据结构之后， <code class="highlighter-rouge">Java</code>中的容器类不说能达到”化境”的水平， 但至少随便一个类能搞清楚它可以应用于什么场景， 读写效率是什么样的， 对内存会有什么影响。</p>

<p>甚至其它语言的高级数据类型， 例如<code class="highlighter-rouge">Python</code>, <code class="highlighter-rouge">Go</code>， 在彻底搞清楚了基础数据结构之后， 也是信手拈来， 这就是那20%的核心知识， 用于解决80%的问题。 所以这些基础知识， 是非常值得花大力气去突破和提高的。</p>

<h4 id="6-list">6. List</h4>
<p>在<code class="highlighter-rouge">Java</code>中， <code class="highlighter-rouge">List</code>的实现有<code class="highlighter-rouge">ArrayList</code>， 以及<code class="highlighter-rouge">LinkedList</code>， 底层分别由数组和链表实现。 下面对其优缺点以及使用场景进行分析：</p>

<p><code class="highlighter-rouge">ArrayList</code>适用于频繁使用下标查找元素， 以及在列表的尾部进行插入和删除操作， 基于此特性， 使用<code class="highlighter-rouge">ArrayList</code>来实现一个栈最为合适。 由于数组所占用的内存空间必须连续的特性， 不适合存储大量的数据， 在存储大量的数据之后会对系统的内存空间分配造成一定影响。</p>

<p><code class="highlighter-rouge">LinkedList</code>适用于对列表的头部， 尾部执行插入和删除操作， 基于此特性， 可以用来实现队列或者是双端队列。 链表所实现的列表不适合频繁的使用下标来查找元素。 由于链表不需要连续的内存空间， 所以链表在存储大量数据时要比数组具有更高的系统性能。</p>

<h4 id="7-set">7. Set</h4>
<p><code class="highlighter-rouge">Set</code>的实现要比<code class="highlighter-rouge">List</code>更为丰富， 一共有3种<code class="highlighter-rouge">Set</code>类：</p>

<p><code class="highlighter-rouge">HashSet</code>在无特殊需求的情况下为首选集合类， 底层由哈希表实现， 也就是数组。 基本上数组的优缺点就是<code class="highlighter-rouge">HashSet</code>的优缺点， 查找速度非常快， 平均时间复杂度为<code class="highlighter-rouge">O(1)</code>，  但是会占据比<code class="highlighter-rouge">ArrayList</code>更多的内存空间， 用来降低哈希冲突。 另外， <code class="highlighter-rouge">HashSet</code>在产生哈希冲突时， 首先采用”拉链法”来解决， 当某一个数组节点所挂载的冲突节点过多时， 将会把链表转为红黑树以提高查找速率。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-23%2017-23-02%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p><code class="highlighter-rouge">TreeSet</code>由红黑树所实现， 特点是能够保证插入元素的顺序， 插入元素的平均时间复杂度为<code class="highlighter-rouge">O(logn)</code>， 最坏情况下也是<code class="highlighter-rouge">O(logn)</code>， 因为是由树结构实现的， 所以不依赖连续的存储空间， 能够存放更多的元素。</p>

<p><code class="highlighter-rouge">LinkedHashSet</code>是基于<code class="highlighter-rouge">HashSet</code>所实现的， 使用了链表来维护元素插入的次序， 但是底层仍然由哈希数组实现， 所以查询效率与<code class="highlighter-rouge">HashSet</code>相同， 缺点也与<code class="highlighter-rouge">HashSet</code>相同， 不再赘述。</p>

<h4 id="8-map">8. Map</h4>
<p><code class="highlighter-rouge">HashMap</code>在无特殊需求的情况下为首选字典类， 底层由哈希数组实现， 优缺点与<code class="highlighter-rouge">HashSet</code>相同。</p>

<p><code class="highlighter-rouge">TreeMap</code>由红黑树所实现， 与<code class="highlighter-rouge">TreeSet</code>特点相同。</p>

<p><code class="highlighter-rouge">LinkedHashMap</code>基于<code class="highlighter-rouge">HashMap</code>所实现， 同样维护了一个链表来保存元素的插入次序， 特点与<code class="highlighter-rouge">LinkedHashSet</code>相同。</p>

<p><code class="highlighter-rouge">ConcurrentHashMap</code>为并发安全Map， 内部采用哈希数组以及分段锁的方式来实现其线程安全性以及查找/插入的高效性， 具体实现见本站<code class="highlighter-rouge">Java并发编程</code>系列。</p>

<p><code class="highlighter-rouge">WeakHashMap</code>同样由哈希数组实现， 主要目的在于解决对象的垃圾收回问题。 <code class="highlighter-rouge">WeakHashMap</code>中键为弱键， 当映射之外没有引用指向某个弱键时， 该键将会被回收。</p>

<h4 id="9-小结">9. 小结</h4>
<p>在这篇文章中没有任何数据结构的代码实现， 仅讲述了每种数据结构的基本特性， 以及基于此所实现的<code class="highlighter-rouge">Java</code>容器类。 从<code class="highlighter-rouge">Set</code>和<code class="highlighter-rouge">Map</code>这两个小节可以看出， 这两个容器类是非常相似的， 理解了其中一个， 另一个也就随之理解了。</p>

<p>笔者想在这里借助上面的比较过程传达一个观点： 软件的世界中很多知识都是相通的， 虽然看起来有无数种技术需要学习， 无数种框架需要会使用。 但是最最核心的知识真的只有20%， 在理解了这些知识之后， 足以解决开发以及生产中80%的问题， 而剩下的， 只不过是一些经验以及最佳实践而已。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Java基础编程(02)--接口与抽象类</title>
	  <link>//Java-Interface-and-abstract-class</link>
	  <author></author>
	  <pubDate>2018-11-30T02:49:09+00:00</pubDate>
	  <guid>//Java-Interface-and-abstract-class</guid>
	  <description><![CDATA[
	     <p>在<code class="highlighter-rouge">Java</code>中， 我认为接口和抽象类是能够让”匠人”充分发挥其想象力和创造力的地方， 这两个类结构使得软件大师们能够编写出精美， 优雅和巧妙的代码。 而在我这种低端程序员手中， 它仅仅只是一个结构而已， 离品尝到其设计精髓不知还隔着多少座大山。</p>

<!---more--->

<h4 id="1-抽象类">1. 抽象类</h4>
<p>抽象类不能被实例化， 仅作为一个通用接口来操纵一系列的导出类。 在<code class="highlighter-rouge">Java</code>中提供了抽象方法： 仅有声明而没有方法体。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">();</span>
</code></pre></div></div>
<p>包含抽象方法的类叫做抽象类， 如果一个类包含一个或多个抽象方法， 那么该类必须定义为抽象类(否则， 编译器会教你重新写代码)。</p>

<p>如果从一个抽象类继承， 并想创建新类的对象， 那么就必须为基类中的所有抽象方法提供方法定义。 如果不这样做的话， 导出类也是抽象类， 并且编译器会强制的要求使用<code class="highlighter-rouge">abstract</code>关键字来限定导出类。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Shape</span> <span class="o">{</span>
    <span class="c1">// 可以定义成员变量</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"biubiu"</span><span class="o">;</span>

    <span class="c1">// 可以定义静态变量</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">color</span> <span class="o">=</span> <span class="s">"blue"</span><span class="o">;</span>

    <span class="c1">// 这是我们的抽象方法，没有函数体，只有函数定义</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">();</span>

    <span class="c1">// 成员方法</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 构造方法也可以有</span>
    <span class="n">Shape</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Shape...."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>除了不能实例化以外， 抽象类和普通的类并没有什么区别， 成员变量， 静态变量以及构造函数等等， 都可以在抽象类中进行定义， 并且子类也能够对其进行访问。</p>

<p>实现一个抽象类的方式是继承该抽象类， 并实现该抽象类中的所有抽象方法。</p>

<h4 id="2-接口">2. 接口</h4>
<p>接口在抽象化这个层面上比抽象类走的更远， 接口中只允许完全抽象的函数。在接口中可以添加一些字段(field)， 只不过这些字段均为<code class="highlighter-rouge">static</code> &amp; <code class="highlighter-rouge">final</code> 。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Men</span> <span class="o">{</span>

    <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span><span class="o">;</span>

    <span class="n">String</span> <span class="nf">getName</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SuperMen</span> <span class="kd">implements</span> <span class="n">Men</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// name = "keyerror"; 不能够改变interface中的Field</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printName</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SuperMen</span> <span class="n">superMen</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SuperMen</span><span class="o">();</span>
        <span class="n">superMen</span><span class="o">.</span><span class="na">printName</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>接口的定义极其简单， 将<code class="highlighter-rouge">class</code>替换成<code class="highlighter-rouge">interface</code>， 声明函数的定义即可。</p>

<p>接口表示”所有实现了该特定接口的类看起来都这样”，  并且我们可以通过实现不同的接口来达到多重继承的目的。</p>

<p>这里对接口和抽象类做一个比较：</p>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>接口</th>
      <th>抽象类</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>方法实现</td>
      <td>无任何方法实现</td>
      <td>可以有自己的方法实现</td>
    </tr>
    <tr>
      <td>实现</td>
      <td>子类使用implements来实现接口， 需要实现接口中的所有方法</td>
      <td>子类extends抽象类， 实现父类的抽象方法即可。</td>
    </tr>
    <tr>
      <td>构造器</td>
      <td>不允许有构造器</td>
      <td>可以有构造器</td>
    </tr>
    <tr>
      <td>访问修饰符</td>
      <td>只允许public修饰符存在</td>
      <td>可以有private, public以及protected修饰符</td>
    </tr>
    <tr>
      <td>类变量的定义</td>
      <td>只有静态final变量可以进行定义</td>
      <td>可以定义静态变量， 也可以定义成员变量</td>
    </tr>
    <tr>
      <td>与普通类的区别</td>
      <td>完全不同</td>
      <td>除了不能实例化以外， 其余于普通类完全相同</td>
    </tr>
    <tr>
      <td>多重继承</td>
      <td>允许某一个类实现多个接口</td>
      <td>只允许单根继承</td>
    </tr>
    <tr>
      <td>添加新方法</td>
      <td>接口添加新方法之后，所有实现了该接口的类都必须修改</td>
      <td>抽象类可以提供一个默认的实现方式， 不必改变所有子类代码。</td>
    </tr>
  </tbody>
</table>

<h4 id="3-软件设计的原则">3. 软件设计的原则</h4>
<p>既然在开篇提到了抽象类和接口的一个主要目的是用于软件设计， 那么不可避免就需要了解软件设计中有哪些常用的原则。</p>

<p>在<code class="highlighter-rouge">敏捷软件开发：原则、模式与实践</code>一书中， 列举了诸多被业界所公认的设计原则， 分别为： 单一职责原则， 开放-封闭原则， 里氏替换原则， 依赖倒置原则， 接口隔离原则。 本文将会对这5种设计原则进行理解和拓展。</p>

<h4 id="4-单一职责原则">4. 单一职责原则</h4>
<p>单一职责原则与我们常说的：”一个函数或者一个类， 只做一件事情”有相似的地方：</p>

<blockquote>
  <p>就一个类而言， 应该仅有一个引起它变化的原因。</p>
</blockquote>

<p>比如在获取一个url的html页面的函数中， 我们将所有的代码都写到里面：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">getUrl</span><span class="o">(</span><span class="n">String</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
    <span class="cm">/* 构建请求对象 */</span>
    <span class="cm">/* 发起请求 */</span>
    <span class="cm">/* 得到请求结果 */</span>
    <span class="cm">/* 对请求结果进行解码， 以及一些清洗 */</span>
    <span class="cm">/* 将结果保存至DB中 */</span>
<span class="o">}</span>
</code></pre></div></div>

<p>由于业务是多变的， 那么该函数可能会经常的发生变动， 在每次该代码的时候都需要理解这一行代码和下一行代码做了什么， 到后面代码会被改的非常混乱。 有人说我们可以加注释嘛， 文字注释不是注释代码的， 而是注释业务的， 代码才是最好的注释， 这一点非常重要。</p>

<p>将这一整个函数拆分为不同的函数， 每一个函数只做一件事情， 并给予恰当的函数名称， 函数名称还拥有解释代码的副作用， 一眼就能知道这个函数做了什么。</p>

<p>我们把视角从函数上升到一个类时也是一样的， 一个类不应该又是爬虫类， 又是获取代理IP的类， 应该将其拆分。</p>

<h4 id="5-开放-封闭原则">5. 开放-封闭原则</h4>

<blockquote>
  <p>软件实体(类， 模块， 函数等)应该对拓展开放， 而对修改关闭。</p>
</blockquote>

<p>简单的来说就是当我们新增一个功能时， 不能对原有的代码直接进行修改， 而是对其进行拓展。 如果读者有接触过<code class="highlighter-rouge">Python</code>这门语言的话， 那么装饰器就是直接的体现了开放-封闭原则。</p>

<p>要想实现开放-封闭原则， 最为关键的一点就是抽象。 客户端在调用底层的方法时， 不直接持有底层的具体实现， 而是持有其抽象类或者接口。</p>

<p>在<code class="highlighter-rouge">Java</code>中， 装饰模式是对开放-封闭原则较为直接的体现， 该模式的具体实现请见<code class="highlighter-rouge">Java基础编程--I/O系统</code>。</p>

<h4 id="6-里氏替换原则">6. 里氏替换原则</h4>
<p>里氏替换原则的原有声明非常的绕口， 所以这里就不再贴原有的声明， 放出我对其的理解。 里氏替换原则， 我认为就是子类对象能够随意的替换父类对象， 而程序逻辑不变。</p>

<p>首先举一个不符合里氏替换原则的例子：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"Biu"</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Child2</span> <span class="kd">extends</span> <span class="n">Parent</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Po"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LSP</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Child2</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">==</span> <span class="s">"Biu"</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"True"</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"False"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里不是一个特别恰当的例子， <code class="highlighter-rouge">Child2</code>继承自<code class="highlighter-rouge">Parent</code>， 并覆盖了父类的<code class="highlighter-rouge">getValue</code>方法， 返回了一个与父类完全不同的字符串。 当我们的业务代码如同<code class="highlighter-rouge">main</code>方法中时(实际上该方法仅用于举例， 实际生产中没人会这么写)， 子类和父类的实例没有办法进行替换， 也就违背了里氏替换原则。</p>

<p>通常来讲我们使用继承， 一是为了代码的复用， 而是利用多态机制。</p>

<p>在使用代码复用时， 子类不应该覆盖父类的方法， 而应该使用其余的方法进行拓展， 这种情况下自然就不会出现问题。</p>

<p>在利用多态机制时， 更重要的是类的类型， 而不是类中的方法， 所以此时父类应该被定义为抽象类或者是接口， 具体选择哪一个视业务情况而定。</p>

<h4 id="7-依赖倒置原则">7. 依赖倒置原则</h4>
<p>依赖倒置原则， 其核心思想就是将代码划分成不同的层次， 使高层次模块不依赖于低层次模块， 两者应依赖其抽象。 抽象不应该依赖具体实现， 而是相反， 具体实现应该依赖抽象。</p>

<blockquote>
  <ol>
    <li>High-level modules should not depend on low-level modules. Both should depend on abstractions.</li>
    <li>Abstractions should not depend on details. Details should depend on abstractions.</li>
  </ol>
</blockquote>

<p>原则的原有声明很绕口， 又是依赖又是抽象的， 提取一些细节出来。 当高层次模块对低层次模块有依赖时(持有实例， 或者调用方法， 都称为依赖)， 高层次模块通常就是我们的主要业务逻辑代码， 需要有较强的复用性。 当产生上述依赖时， 应该将这种依赖进行拆分， 使这两个模块均依赖于同一个抽象。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-24%2016-53-36%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>图示就是这么个意思， 举一个现实生活中的例子： 程序员喜欢买键盘， 比如我， 就喜欢cherry轴的， 有时候会用红轴， 有时候会用黑轴， 都会拿来打代码：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Coder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">RedSwitch</span> <span class="n">redSwitch</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">BlackSwitch</span> <span class="n">blackSwitch</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">RedSwitch</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"红轴"</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">BlackSwitch</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"黑轴"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>最开始我们使用直接实现的方式， <code class="highlighter-rouge">coder</code>类直接依赖轴体键盘的具体实现。 那么问题就来了， 我怎么能够进行任意的切换键盘？ 每一个键盘的特性是不一样的， 如何体现？ 这个时候直接依赖的问题就出现了， 因为耦合的非常严重， 导致灵活性大大降低， 所以我们对其进行分离。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Coder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Switch</span> <span class="n">aSwitch</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Switch</span> <span class="nf">getaSwitch</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">aSwitch</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setaSwitch</span><span class="o">(</span><span class="n">Switch</span> <span class="n">aSwitch</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">aSwitch</span> <span class="o">=</span> <span class="n">aSwitch</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Switch</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">RedSwitch</span> <span class="kd">extends</span> <span class="n">Switch</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"红轴"</span><span class="o">;</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">BlackSwitch</span> <span class="kd">extends</span> <span class="n">Switch</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"黑轴"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>我们在中间添加一个抽象类， 让<code class="highlighter-rouge">Coder</code>对象依赖该抽象类， 具体的轴体实现去继承该抽象类， 那么此时的灵活性就大大增强， 不管有多少种具体的实现， 上述代码都可以完成特定对象的注入。</p>

<p>这个其实就是依赖倒置原则， 我们也可以说是面向接口编程， 面向约定编程， 等等。</p>

<p>适配器模式可以说比较完整的体现了依赖倒置原则的内容， 适配器模式的主要核心概念就是在新接口和老接口之间进行适配， 让其协同完成工作。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-26%2011-16-03%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p><code class="highlighter-rouge">services</code>和<code class="highlighter-rouge">NewService</code>是两个不同的接口， 但是现在我们需要使用新的实现来实现原有的功能， 而在<code class="highlighter-rouge">Application</code>类中依赖的是<code class="highlighter-rouge">services</code>接口， 所以适配器接口也要实现该接口， 然后使用代理的方式进行方法的覆盖， 最终达到方法改写的目的。</p>

<p>适配器模式同样也是依赖其接口， 而不依赖具体的实现。 所以说适配器模式对依赖倒置原则有一个较好的表达。</p>

<h4 id="8-接口隔离原则">8. 接口隔离原则</h4>
<p>接口隔离原则与单一职责原则非常相似， 只不过该原则针对的对象是接口。 接口隔离原则说白了就是不要让一个接口太过于臃肿， 把接口设计成一个所有类方法的并集， 这样一来系统的耦合性就会非常的高， 而且是无意义的耦合。</p>

<p>一个接口只对应一个类， 或者是一小部分类， 剩余的类由一个或多个接口进行定义。</p>

<h4 id="9-小结">9. 小结</h4>
<p>在本篇文章中， 首先是对抽象类和接口进行了一个简单的介绍和比较， 后续又对5种设计原则进行了介绍和demo的演示， 而掌握这些设计原则仅仅只是摸到了设计的门槛而已， 还有根据这些设计原则所衍生的设计模式。 不管是设计原则也好， 还是设计模式也罢， 都需要根据不同的业务场景来进行选择。</p>

<p>讲实话， 这一部分关于设计的内容， 实操性和经验占了非常大的比重， 见的多了， 写的多了， 自然也就理解了。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Java基础编程(01)--I/O系统</title>
	  <link>//Java-IO</link>
	  <author></author>
	  <pubDate>2018-11-29T02:49:09+00:00</pubDate>
	  <guid>//Java-IO</guid>
	  <description><![CDATA[
	     <p><code class="highlighter-rouge">Java</code>中的I/O系统相较于<code class="highlighter-rouge">Python</code>要复杂许多， 不管是从设计上还是实现上。 这一块儿的内容也是我在学习<code class="highlighter-rouge">Java</code>时遇到的最大的困难(并发包都比这个好理解)， 经过了持(san)之(tian)以(da)恒(yu)的学习之后， 算是对Java I/O系统有一个基本的认识和理解。</p>

<!---more--->

<h4 id="1-python语言下的io系统">1. Python语言下的I/O系统</h4>
<p>作为一个PythonCoder， 首先当然是要对Python I/O系统做一个详细的梳理， 在比较中理解和提高。 在<code class="highlighter-rouge">Python</code>中， 所有的文件操作， 不管是读还是写， 都以打开一个文件起手， 同时为了更好的管理文件资源， 可以使用上下文管理器<code class="highlighter-rouge">with</code>语句：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 读文件</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">,</span> <span class="s">"rt"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c"># 写文件(覆盖写)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">,</span> <span class="s">"wt"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">"hello</span><span class="se">\n</span><span class="s">world</span><span class="se">\n</span><span class="s">!"</span><span class="p">)</span>
</code></pre></div></div>

<p>不得不说， 是真的简单…那么我们就需要彻底的理解<code class="highlighter-rouge">Python</code>对文件的操作， 越是简单的内容， 越是不能掉以轻心。 最佳的参考文献就是<code class="highlighter-rouge">builts.py</code>中的文档注释。</p>

<p>首先来看<code class="highlighter-rouge">open</code>函数中的模式选择， 一共有8种操作模式， 其中<code class="highlighter-rouge">U</code>模式并不建议使用：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">字符</th>
      <th>含义</th>
      <th style="text-align: center">字符</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">r</td>
      <td>打开一个文件并进行读取</td>
      <td style="text-align: center">w</td>
      <td>打开一个文件并进行写入(覆盖原有文件内容)</td>
    </tr>
    <tr>
      <td style="text-align: center">x</td>
      <td>创建一个新的文件， 并将其打开准备写入</td>
      <td style="text-align: center">a</td>
      <td>打开一个文件并以追加的方式进行写入</td>
    </tr>
    <tr>
      <td style="text-align: center">b</td>
      <td>以二进制的格式打开文件</td>
      <td style="text-align: center">t</td>
      <td>以文本的格式打开文件</td>
    </tr>
    <tr>
      <td style="text-align: center">+</td>
      <td>打开一个文件并进行更新， 可读可写</td>
      <td style="text-align: center"> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>文档描述的非常清楚， 举几个非常常见的例子： <code class="highlighter-rouge">rb</code>， 以二进制的方式读取文件， 在读取文件时将会得到<code class="highlighter-rouge">bytes</code>类型； <code class="highlighter-rouge">wt</code>， 以文本的方式对文件进行清空写入， 不管写不写内容， 文件内容在调用<code class="highlighter-rouge">open</code>函数时就直接被清空； 如果以<code class="highlighter-rouge">ab</code>模式写入字符类型， 将会抛出异常， 如果想要已字节模式写入中文， 需要对字符进行<code class="highlighter-rouge">encode("utf-8")</code>操作， 将其转换为字节。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">,</span> <span class="s">"ab"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">"你好"</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">"utf-8"</span><span class="p">))</span>
</code></pre></div></div>

<p>Emoji既可以以字符写入， 也可以以byts写入， 读取的话进行一个编码的转换即可：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">,</span> <span class="s">"ab"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c"># 以bytes模式打开， 那么需要写入bytes</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">"😍 😱"</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">"utf-8"</span><span class="p">))</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c"># 得到的data为bytes</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="c"># 打印字符串需要对其进行解码</span>
    <span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">"utf-8"</span><span class="p">))</span>
</code></pre></div></div>

<p>在文档的末尾有这样一段话： <code class="highlighter-rouge">open</code>方法将会返回一个<code class="highlighter-rouge">file</code>对象， 当我们使用<code class="highlighter-rouge">t</code>模式打开一个文件时， 将会返回<code class="highlighter-rouge">TextIOWrapper</code>对象； 当使用<code class="highlighter-rouge">b</code>模式， 并且读文件时， 返回<code class="highlighter-rouge">BufferedReader</code>对象， 写文件时返回<code class="highlighter-rouge">BufferedWriter</code>对象； 当使用<code class="highlighter-rouge">+</code>模式时， 将会返回一个<code class="highlighter-rouge">BufferedRandom</code>对象。</p>

<p>不管是以什么样的方式去读取或者写入文件， <code class="highlighter-rouge">buffer</code>对象是跑不掉的。 之所以有buffer存在， 是因为内存和磁盘之间的读写速度差距过大， 添加buffer可以调节两者之间的速度差， 对I/O操作进行优化。 在文档中也说明了每一种模式下的buffer大小。</p>

<p>在Ubuntu下进行测试时， 使用<code class="highlighter-rouge">rb</code>模式buffer大小为4096， 使用<code class="highlighter-rouge">rt</code>模式buffer大小为8192。 之所以是4096， 一方面是因为在<code class="highlighter-rouge">ext4</code>磁盘文件格式下， 其默认的<code class="highlighter-rouge">block size</code>即为4096， 另一方面当超过4096时， 其效率并没有显著的提高(具体的测试数据在<code class="highlighter-rouge">unix环境高级编程</code>有给出)。  在<code class="highlighter-rouge">Python</code>中， 使用buffer去装填数据的过程由语言底层帮我们完成， 而在<code class="highlighter-rouge">Java</code>中， 这个过程由我们自己完成。</p>

<p>基本上这些就是<code class="highlighter-rouge">Python</code>中对文件的读写操作了， 可以看到语言将一些细节封装到了底层， 使用者可以不用关心这些细节， 专注于自己的业务场景。 但是在<code class="highlighter-rouge">Java</code>语言中， I/O就没有那么简单了。</p>

<h4 id="2-file类">2. File类</h4>
<p>在<code class="highlighter-rouge">Python</code>中， 可以直接在<code class="highlighter-rouge">open</code>方法返回的<code class="highlighter-rouge">file</code>对象上对文件的内容进行读取和写入， 但是在<code class="highlighter-rouge">Java</code>中， <code class="highlighter-rouge">File</code>类仅表示一个文件对象， 或者说是对系统磁盘文件的操作， 包括创建一个空文件， 查看文件的创建日期， 大小以及权限等。</p>

<p>常用的构造器：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">File</span><span class="o">(</span><span class="n">String</span> <span class="n">path</span><span class="o">)</span>
<span class="n">File</span><span class="o">(</span><span class="n">File</span> <span class="n">parent</span><span class="o">,</span> <span class="n">String</span> <span class="n">child</span><span class="o">)</span>
<span class="n">File</span><span class="o">(</span><span class="n">String</span> <span class="n">parent</span><span class="o">,</span> <span class="n">String</span> <span class="n">child</span><span class="o">)</span>
</code></pre></div></div>

<p>归根结底就是需要传入一个文件的路径， 该路径可以使用字符串表示， 也可以将路径拆分成2个字符串或者是一个文件对象和一个字符串。 那么创建一个文件就有了很多种写法：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CreateFileTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"/home/smartkeyerror/JavaProjects/LearningJava/hello.txt"</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">isCreated</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">createNewFile</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isCreated</span><span class="o">);</span>

        <span class="n">File</span> <span class="n">file1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"/home/smartkeyerror/JavaProjects/LearningJava"</span><span class="o">,</span> <span class="s">"hello1.txt"</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">isCreated1</span> <span class="o">=</span> <span class="n">file1</span><span class="o">.</span><span class="na">createNewFile</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isCreated1</span><span class="o">);</span>

        <span class="n">File</span> <span class="n">file2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"."</span><span class="o">),</span> <span class="s">"hello2.txt"</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">isCreated2</span> <span class="o">=</span> <span class="n">file2</span><span class="o">.</span><span class="na">createNewFile</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isCreated2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>并不是很复杂， 此外<code class="highlighter-rouge">File</code>类还提供了<code class="highlighter-rouge">mkdir</code>以及<code class="highlighter-rouge">mkdirs</code>方法来创建目录， 其中<code class="highlighter-rouge">mkdir</code>如果在文件路径中有文件并不存在， 则会抛出异常； 而<code class="highlighter-rouge">mkdirs</code>则会帮我们创建该路径下所有的文件目录， 如果该目录在磁盘中不存在的话。</p>

<p><code class="highlighter-rouge">list</code>方法将会返回路径下所有的文件和目录的名称所形成的字符数组， <code class="highlighter-rouge">listFiles</code>将会返回目录下所有的文件对象：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">File</span> <span class="n">fileNew</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"."</span><span class="o">);</span>
<span class="n">File</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="n">fileNew</span><span class="o">.</span><span class="na">listFiles</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="n">File</span> <span class="n">file3</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file3</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>  <span class="c1">// 获取文件或目录名称</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file3</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span>  <span class="c1">// 判断是否为目录</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file3</span><span class="o">.</span><span class="na">isFile</span><span class="o">());</span>  <span class="c1">// 判断是否为文件</span>
<span class="o">}</span>
</code></pre></div></div>

<p>比较值得一提的就是文件查找时策略模式的应用： 当我们想要找到目录中所有以<code class="highlighter-rouge">.txt</code>结尾的文件时， 固然可以使用循环遍历在进行判断， 同时也可以使用<code class="highlighter-rouge">FilenameFilter</code>这个”策略”对象来实现：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"."</span><span class="o">);</span>
<span class="n">String</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="k">new</span> <span class="n">FilenameFilter</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">accept</span><span class="o">(</span><span class="n">File</span> <span class="n">dir</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".txt"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div></div>

<p>我们可以看一下<code class="highlighter-rouge">list</code>方法的源码：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">String</span><span class="o">[]</span> <span class="nf">list</span><span class="o">(</span><span class="n">FilenameFilter</span> <span class="n">filter</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">names</span><span class="o">[]</span> <span class="o">=</span> <span class="n">list</span><span class="o">();</span>
    <span class="cm">/** 当filter为null时直接返回names数组 */</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">names</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">filter</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">names</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
            <span class="n">v</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">names</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">v</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以看到具体的实现还是一个循环遍历， 但是这个循环遍历交给了JDK去处理， 我们只需要定义一个<code class="highlighter-rouge">filter</code>对象并赋予其相关规则即可， 简化开发人员代码编写的数量(当然， 按行数算工资的当我没说)。</p>

<h4 id="3-stream类">3. Stream类</h4>
<p>当我们使用<code class="highlighter-rouge">new File</code>创建了一个文件对象， 紧随其后的就是读取或者向文件写入内容， 那么此时就有了2种选择：以字符的方法读取/写入， 以字节的方式进行读取/写入。 基于此， <code class="highlighter-rouge">Java</code>才会有4个抽象类， 来对应不同模式的读和写。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-20%2011-32-30%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>我们可以使用不同的组合来实现不同模式的读取和写入， 例如使用<code class="highlighter-rouge">InputStream</code>读取bytes， 然后使用<code class="highlighter-rouge">Writer</code>将bytes转换成字符之后写入， 或者以相反的方式来对文件内容进行操作。 在涉及具体的实现类之前， 首先要理解读文件和写文件的基本模式：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 读/写数据的逻辑：</span>
open a stream
<span class="k">while </span>more information
    <span class="nb">read</span>/write information
close stream
</code></pre></div></div>

<p>文件操作在开发中最为常见， 所以就以<code class="highlighter-rouge">FileInputStream</code>和<code class="highlighter-rouge">OutputStream</code>为例， 进行梳理。 首先来看<code class="highlighter-rouge">read</code>方法， 最完整的参数列表如下：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">(</span><span class="kt">byte</span> <span class="n">b</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">off</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span>
</code></pre></div></div>

<p>其中的<code class="highlighter-rouge">b[]</code>即为一个buffer数组， 用于接受文件数据； <code class="highlighter-rouge">off</code>为读取文件时的偏移量， 即从哪个地方开始读取； <code class="highlighter-rouge">len</code>表示每一次的读取最多读多少数据， 该参数的最大值不能超过buffer数组的大小减去偏移量的大小， 如果偏移量为0， 那么该值最大为数组大小。 通常来讲4096就好， 参考第一小节的解释。</p>

<p>该函数将会返回每次读到的bytes数量， 如果说已经读到了<code class="highlighter-rouge">EOF</code>， 即文件末尾， 将会返回-1， 该值会作为我们判断文件是否读完的标志。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileReadTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="cm">/* 创建文件对象 */</span>
        <span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"."</span><span class="o">,</span> <span class="s">"hello.txt"</span><span class="o">);</span>
        <span class="cm">/* 创建buffer数组， 大小为4096 */</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">4096</span><span class="o">];</span>
        <span class="cm">/* 传入文件文对象， 打开一个流 */</span>
        <span class="n">FileInputStream</span> <span class="n">fileInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="cm">/* 当文件没有读完时， 将所读取到的数据转换成为字符并向控制台输出 */</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">length</span> <span class="o">=</span> <span class="n">fileInputStream</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">4096</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">string</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">string</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="cm">/* 最后需要关闭这个流 */</span>
        <span class="n">fileInputStream</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>写文件的话要稍微简单一些， 流程与读文件基本类似：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileOutputTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>

        <span class="n">FileOutputStream</span> <span class="n">fileOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="s">"hello.txt"</span><span class="o">);</span>

        <span class="n">StringBuilder</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"hello World~ \n"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">fileOutputStream</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">getBytes</span><span class="o">());</span>

        <span class="n">fileOutputStream</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>针对于输入的来源， 还有<code class="highlighter-rouge">ByteArrayInputStream</code>, 将字节数组作为输入源； <code class="highlighter-rouge">StringBufferInputStream</code>， 将String对象作为输入源； <code class="highlighter-rouge">SequenceInputStream</code>将多个输入流合并成一个输入流。 此外还有<code class="highlighter-rouge">FilterInputStream</code>这个抽象类作为装饰者对输入流进行装饰， 具体的内容在后面梳理。</p>

<p>有输入那么自然就会有输出， 除了<code class="highlighter-rouge">FileOutputStream</code>向文件中输出以外， 还有<code class="highlighter-rouge">ByteArrayOutputStream</code>， 在内存中创建一个缓冲区， 数据写入该缓冲区； <code class="highlighter-rouge">PipedOutputStream</code>， 实现管道化的概念。 以及<code class="highlighter-rouge">FilterOutputStream</code>对输出流进行装饰。</p>

<h4 id="4-randomaccessfile类">4. RandomAccessFile类</h4>
<p><code class="highlighter-rouge">RandomAccessFile</code>提供了与<code class="highlighter-rouge">Python</code>非常类似的文件读写方式， 但是前提是我们对文件的结构有一个清晰的了解， 例如要记录数据的大小以及位置。</p>

<p>首先来看构造参数， 第一个参数可以是<code class="highlighter-rouge">String</code>或者是<code class="highlighter-rouge">File</code>对象， 表示文件路径； 第二个参数表示模式的选择， 一共有4种模式：</p>

<table>
  <thead>
    <tr>
      <th>字符</th>
      <th>含义</th>
      <th>字符</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>r</td>
      <td>只读模式打开文件</td>
      <td>rw</td>
      <td>以读/写的方式打开文件， 若文件不存在则尝试创建</td>
    </tr>
    <tr>
      <td>rws</td>
      <td>以读/写的方式打开文件, 并且内容或源数据更新时将数据立即同步到磁盘中</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>rwd</td>
      <td>与rws非常类似， 内容数据更新时将数据立即同步到磁盘中</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><code class="highlighter-rouge">RandomAccessFile</code>包含了一个指针对象，用于标识当前流的读写位置， 并为该对象提供了<code class="highlighter-rouge">get</code>和<code class="highlighter-rouge">set</code>方法， 只不过名称是<code class="highlighter-rouge">getFilePoint</code>和<code class="highlighter-rouge">seek</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RandomAccessFileDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">RandomAccessFile</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RandomAccessFile</span><span class="o">(</span><span class="s">"hello.txt"</span><span class="o">,</span> <span class="s">"rw"</span><span class="o">);</span>

        <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">4096</span><span class="o">];</span>

        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">((</span><span class="n">length</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">length</span><span class="o">));</span>
            <span class="cm">/* 记录已经读取的字节数 */</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">length</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="cm">/* 跳过已读取字节数个字节 */</span>
        <span class="n">file</span><span class="o">.</span><span class="na">skipBytes</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
        <span class="cm">/* 相当于文件末尾追加数据 */</span>
        <span class="n">file</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"append"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>

        <span class="n">file</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>没有使用任何的<code class="highlighter-rouge">InputStream</code>以及<code class="highlighter-rouge">OutputStream</code>， 就对同一个文件进行了读写操作。 上面演示的为向文件末尾进行追加， 使用了自定义的<code class="highlighter-rouge">count</code>来记录已读的数据， 实际上可以直接使用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">file</span><span class="o">.</span><span class="na">seek</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
<span class="n">file</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"\nappend"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">file.length</code>将会返回当前文件的字节大小， 我们直接使用<code class="highlighter-rouge">seek</code>方法将指针定位到末尾， 进行追加写入即可。</p>

<h4 id="5-filter装饰类">5. Filter装饰类</h4>
<p><code class="highlighter-rouge">Filter</code>装饰类是对”流”进行装饰的类， 同样分为字节装饰和字符装饰， 并且根据输入/输出的不同也存在着不同的实现结构。</p>

<p>首先来看字节的相关装饰类：</p>

<table>
  <thead>
    <tr>
      <th>类</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>DataInputStream， DataOutputStream</td>
      <td>允许读取/写入Java基本类型数据</td>
    </tr>
    <tr>
      <td>BufferedInputStream， BufferedOutputStream</td>
      <td>使用缓冲区的方式读取/写入数据， 减少I/O次数</td>
    </tr>
    <tr>
      <td>PushbackInputStream</td>
      <td>主要由编译器使用， 业务开发基本不会用到</td>
    </tr>
    <tr>
      <td>PrintStream</td>
      <td>属于输出装饰， 用于格式化的输出</td>
    </tr>
  </tbody>
</table>

<p>字符相关装饰类：</p>

<table>
  <thead>
    <tr>
      <th>类</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BufferedReader， BufferedWriter</td>
      <td>以缓冲区的方式进行读写， 减少I/O次数</td>
    </tr>
    <tr>
      <td>LineNumberReader</td>
      <td>可以使用<code class="highlighter-rouge">readLine</code>方法逐行读取</td>
    </tr>
    <tr>
      <td>PrintWriter</td>
      <td>格式化输出</td>
    </tr>
    <tr>
      <td>PushbackReader</td>
      <td>通过缓存机制， 进行预读</td>
    </tr>
    <tr>
      <td>InputStreamReader， OutputStreamWriter</td>
      <td>字节流和字符流的相互转换</td>
    </tr>
  </tbody>
</table>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">FileInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">"hello.txt"</span><span class="o">);</span>
        <span class="n">BufferedInputStream</span> <span class="n">bufferedInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedInputStream</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
        <span class="n">InputStreamReader</span> <span class="n">inputStreamReader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">bufferedInputStream</span><span class="o">);</span>

        <span class="cm">/* 首先我们先将其读出来, 此时已经是字符流 */</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">chunk</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">4096</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="n">inputStreamReader</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">chunk</span><span class="o">);</span>

        <span class="cm">/* 新建输出流 */</span>
        <span class="n">FileWriter</span> <span class="n">fileWriter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileWriter</span><span class="o">(</span><span class="s">"hello1.txt"</span><span class="o">);</span>
        <span class="n">BufferedWriter</span> <span class="n">bufferedWriter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedWriter</span><span class="o">(</span><span class="n">fileWriter</span><span class="o">);</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">data</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">chunk</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">data</span><span class="o">));</span>
            <span class="n">bufferedWriter</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">chunk</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
            <span class="cm">/* 写入数据 */</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">inputStreamReader</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">chunk</span><span class="o">);</span>

        <span class="o">}</span>

        <span class="cm">/* 关闭资源 */</span>
        <span class="n">inputStreamReader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">bufferedWriter</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="51-装饰模式">5.1 装饰模式</h5>
<p>在看<code class="highlighter-rouge">Java</code>的装饰模式之前， 首先来看<code class="highlighter-rouge">Python</code>中的装饰器：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">wrapper_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">inner_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">func</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"function cost time: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">inner_func</span>

<span class="n">wrapper_func</span>
<span class="k">def</span> <span class="nf">do_something</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="s">"""
    do_something useful
    """</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"This is main function"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">do_something</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
</code></pre></div></div>

<p>没有什么很复杂的地方， <code class="highlighter-rouge">@</code>是一个语法糖， 本质上其实会调用：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">do_something</span> <span class="o">=</span> <span class="n">wrapper_func</span><span class="p">(</span><span class="n">do_something</span><span class="p">)</span>
</code></pre></div></div>

<p>在<code class="highlighter-rouge">Java</code>中的装饰模式调用方式也是这样的， 由于存在着强制类型声明， 所以在<code class="highlighter-rouge">Java</code>中实现装饰模式要稍微复杂一些。 <code class="highlighter-rouge">do_something</code>对象类型与<code class="highlighter-rouge">wrapper_func</code>函数所返回的对象类型应该一致， 那么将函数往上提一层， 就到了<code class="highlighter-rouge">类</code>这个层面， 所以说， <code class="highlighter-rouge">do_something</code>和<code class="highlighter-rouge">wrapper_func</code>必须是同一个对象。</p>

<p>所以就有了统一的接口， 应用类和装饰类均实现该接口， 并且在装饰类中需要注入一个应用类的实例， 并通过类似代理的方式调用应用类对象的方法以及自己实现的方法。 下面就写一个最简单的装饰模式：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Work</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">work</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">HomeWork</span> <span class="kd">implements</span> <span class="n">Work</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"做家庭作业"</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">Decorator</span> <span class="kd">implements</span> <span class="n">Work</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Work</span> <span class="n">work</span><span class="o">;</span>

    <span class="n">Decorator</span><span class="o">(</span><span class="n">Work</span> <span class="n">work</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">work</span> <span class="o">=</span> <span class="n">work</span><span class="o">;</span> <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">work</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"做其它的作业"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleDecorator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">HomeWork</span> <span class="n">homeWork</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HomeWork</span><span class="o">();</span>
        <span class="n">Decorator</span> <span class="n">decorator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Decorator</span><span class="o">(</span><span class="n">homeWork</span><span class="o">);</span>
        <span class="n">decorator</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在这里我将<code class="highlighter-rouge">Decorator</code>类直接做为了一个装饰类， 本来这里应该是一个抽象类， 让具体的装饰类实现继承该抽象类， 已达到更好的复用效果。 嘛， 测试嘛， 洒洒水啦～ I/O包里面所有的装饰模式都是以这样的结构来实现的， 具体的类图就不贴了。</p>

<h4 id="6-nio">6. NIO</h4>
<p>在文件操作上， 我更倾向于将NIO解释为New-IO， 即新的I/O方式； 在<code class="highlighter-rouge">Reactor</code>模型中， 更倾向于将其解释为<code class="highlighter-rouge">No-Blocking I/O</code>， 即同步非阻塞I/O。</p>

<p>在NIO中， 不再面向”流”编程， 而是面向缓冲区编程。 NIO最重要的两个概念就是<code class="highlighter-rouge">channel</code>和<code class="highlighter-rouge">buffer</code>， 借鉴Thinking in Java中的举例， 可以将磁盘比作一个煤矿， 将通道(channel)包含煤层(数据)， 缓冲区(buffer)就是运煤的卡车。 卡车从煤矿中满载而归， 煤块加工处负责将煤块从车上取出， 在这个过程中我们没有和煤矿直接打交道， 而是和卡车打交道。 这也是NIO的基本原理， 我们只能向buffer中读取或者写入数据， 再由buffer向channel读取或者写入数据。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FileInputStream</span> <span class="n">inputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">"hello.txt"</span><span class="o">);</span>
<span class="cm">/* 获取Channel对象 */</span>
<span class="n">FileChannel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">inputStream</span><span class="o">.</span><span class="na">getChannel</span><span class="o">();</span>
<span class="cm">/* 声明Buffer对象 */</span>
<span class="n">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">4096</span><span class="o">);</span>
<span class="cm">/* 将数据从channel写入至buffer中 */</span>
<span class="n">channel</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
<span class="cm">/* 将buffer相关变量还原 */</span>
<span class="n">buffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>

<span class="k">while</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">hasRemaining</span><span class="o">())</span> <span class="o">{</span>
    <span class="kt">byte</span> <span class="n">b</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"character: "</span> <span class="o">+</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span><span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">channel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>

<p>这是一个不那么严谨的demo， 因为只能读取4096个字节的数据， 但是不妨碍我们对<code class="highlighter-rouge">channel</code>和<code class="highlighter-rouge">buffer</code>的理解。 首先获取<code class="highlighter-rouge">FileInputStream</code>对象的<code class="highlighter-rouge">FileChannel</code>对象， 之所以可以这样做是因为该文件输入流已经以使用NIO的方式进行重写了， 然后我们使用<code class="highlighter-rouge">ByteBuffer</code>的静态方法声明了一个有界的缓冲区， 将数据通过channel装填至buffer中， 并对buffer进行翻转， 以及数据的读取。</p>

<h5 id="61-buffer原理">6.1 buffer原理</h5>
<p>在上面我们简单的使用buffer的方式对文件进行了读取， 在本小节中对buffer进行更深入的理解。</p>

<p>根据Javadoc， buffer是一个线性的有界序列， 保存着特定的基本数据类型， 除去保存的内容， 最核心的属性就是<code class="highlighter-rouge">capacity</code>, <code class="highlighter-rouge">limit</code>以及<code class="highlighter-rouge">position</code>。</p>

<p><code class="highlighter-rouge">capacity</code>指定buffer的容量， 一经定义无法修改， 且该值不允许为负数； <code class="highlighter-rouge">limit</code>表示在一个buffer中， 不允许读取或写入的第一个元素的索引； <code class="highlighter-rouge">position</code>表示下一个将要读取或写入的元素的索引。 听起来非常的绕口， 以图示进行解释：</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-10%2016-36-13%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>图示与上面的代码没有直接关联。</p>

<p>初始化： position = 0, capacity与limit值相同， 值为数组大小， 可以认为其指向最后一个元素的下一个元素</p>

<p>向buffer中写数据： 也就是调用<code class="highlighter-rouge">channel.read(buffer)</code>， 假设写了4个元素， 那么position向后移动4位， 其余值不变</p>

<p>准备读取元素： 此时必须调用<code class="highlighter-rouge">flip</code>方式使得position置0， 而limit则指向原来position的位置</p>

<p>读取元素： 在读取元素时， position的位置会不断的向后移动， 直至移动到与limit相同的位置。 此时元素已经读取完毕， position再向后移动就没有了意义。</p>

<p>从上面的过程可以看出， 假设我们的buffer大小为4096， 但是文件只有20个字节的数据， 向buffer中写数据和读数据都不会造成空间和时间上的浪费， 基于此的设计使得NIO要比旧IO有更高的效率。</p>

<p>在有了buffer之后， 我们进行文件内容的拷贝就变得非常简单了：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NIOCopyFile</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>

        <span class="n">FileChannel</span> <span class="n">inChannel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">"hello.txt"</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>

        <span class="n">FileChannel</span> <span class="n">outChannel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="s">"hello1.txt"</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>

        <span class="n">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">4096</span><span class="o">);</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">inChannel</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">buffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>  <span class="c1">// 翻转buffer, 准备进行buffer的读操作</span>
            <span class="n">outChannel</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
            <span class="n">buffer</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>  <span class="c1">// 将buffer的position, limit置为最初状态, 以便接收后续数据</span>
        <span class="o">}</span>

        <span class="n">inChannel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">outChannel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="62-bytebuffer源码分析">6.2 ByteBuffer源码分析</h5>
<p>在我们敲下：<code class="highlighter-rouge">ByteBuffer buffer = ByteBuffer.allocate(4096);</code>， 中间发生了什么？</p>

<p><code class="highlighter-rouge">allocate</code>是一个静态方法， 返回一个<code class="highlighter-rouge">HeapByteBuffer</code>对象实例， 里面的方法倒是没什么好说的， 比较重要的一点就是该buffer中的数组是位于堆内存中的。 那么也就意味着数据需要从堆内存拷贝到 OS拷贝空间当中， 会有一定的性能损耗。</p>

<p>所以， NIO还提供了一个直接缓冲区， 即<code class="highlighter-rouge">DirectByteBuffer</code>， 该buffer的行为与堆buffer基本类似， 只不过直接缓冲区将buffer的内存直接声明在了堆外， 并使用一个<code class="highlighter-rouge">long</code>变量来指向这块儿内存。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/2018-11-12%2011-24-10%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="" /></p>

<p>虽然看起来<code class="highlighter-rouge">DirectByteBuffer</code>能够加快数据的访问， 但是这与操作系统的类型直接相关， 所以在使用直接缓冲区时， 需要对其进行基本的性能测试， 保证确实要比堆缓冲区更快。</p>

<h4 id="7-小结">7. 小结</h4>
<p><code class="highlighter-rouge">Java</code>的I/O系统看起来设计的非常复杂， 但是对其抽丝剥茧， 一层一层的将其展开， 理解起来也并不会特别的复杂。 在本篇文章中对一些常用的类以及技术做了比较粗略的介绍和demo， 在工程实践中要比这更加的复杂， 但是万变不离其宗， 原理性的知识的确只有一少部分。 当我们理解了应用层序和操作系统之间的关系以及相关操作逻辑， 一些困扰我们的问题也就自然迎刃而解了。</p>


	  ]]></description>
	</item>


</channel>
</rss>
