<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description>Keep coding, Keep curiosity</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Kubernetes-Informer</title>
	  <link>//Kubernetes-Informer</link>
	  <author></author>
	  <pubDate>2020-08-26T07:50:25+00:00</pubDate>
	  <guid>//Kubernetes-Informer</guid>
	  <description><![CDATA[
	     <p>Kubernetes 声明式API的核心就在于用户提交的YAML文件表示期望状态，Kubernetes 需要根据该期望状态与集群实际状态进行对比，并根据对比的结果作出相应的操作。期望状态由 APIServer 保存在 Etcd 中，Kubernetes 对资源进行调谐时，是否均需要通过 APIServer 查询 Etcd 来获取期望状态呢?</p>

<!---more--->

<h3 id="1-listandwatch机制">1. ListAndWatch机制</h3>

<p>在 Kubernetes 中，集群的状态、用户提交的YAML文件均保存在Etcd数据库中，而获取这些数据的唯一方法就是通过 APIServer。APIServer 与 Etcd 通过 RPC 进行通信，对外则暴露需要鉴权的 REST API 接口，用户可通过这些API接口间接地获取集群状态。例如<code class="highlighter-rouge">kubectl</code>工具就是通过封装 APIServer 的 REST API 进行工作的。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Kubernetes/Informer/client-apiserver-etcd-communicate.png" alt="" /></p>

<p>除了通用的<code class="highlighter-rouge">GET</code>、<code class="highlighter-rouge">POST</code>的API以外，APIServer 还提供了可用于持续监听的 Watch API。顾名思义，Watch API 本质上就是一种 APIServer 主动向客户端推送 Kubernetes 资源修改、创建的一种机制，默认采用 HTTP/1.1 的分块传输实现，同时也可以使用 websocket 协议进行信息接收。</p>

<p>以获取Pod事件为例，通过调用<code class="highlighter-rouge">/api/v1/watch/namespaces/{namespace}/pods?watch=yes</code>可使得客户端与 APIServer 建立HTTP长连接，每当集群中出现了 Pod 的相关事件(创建、更新等)，APIServer 将会通过该连接将对应的事件推送至客户端。实际上，Watch API 就是一种增量更新，如同MySQL主从复制中的Binlog数据传输。</p>

<p>当然，在进行资源的增量更新之前，首先要获取到当前集群中资源的存量信息，可通过 List API 获得: <code class="highlighter-rouge">/api/v1/namespaces/{namespace}/pods</code>。通过 List API 获取集群当前某资源的全部信息，以及通过 Watch API 获取资源的增量信息，在 Kubernetes 中称为 ListAndWatch 机制，是 APIServer 的核心机制之一。</p>

<blockquote>
  <p>关于kubernetes-api的更多信息可查看官网:
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#-strong-api-overview-strong-">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#-strong-api-overview-strong-</a></p>
</blockquote>

<h3 id="2-informer工作原理">2. Informer工作原理</h3>

<p>既然客户端可以使用 ListAndWatch 机制来实时地同步 Kubernetes 中某类资源的状态，那么在 Kubernetes 内部，同样可以使用该机制从 APIServer 中接收资源的变化，从而建立本地缓存减轻 APIServer 与 Etcd 的负载，并且实现 Kubernetes 中的控制器模式。该内部组件称之为 Informer，中文译为通知器。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Kubernetes/Informer/informer-ar.png" alt="" /></p>

<p>首先，Reflector 包会和 APIServer 建立长连接，并使用 ListAndWatch 方法获取并监听某一个资源的变化。List 方法将会获取某个资源的所有实例(如ReplicaSet、Deployment等)，Watch 方法则监听资源对象的创建、更新以及删除事件，获取到的事件称之为一个增量(Delta)，该增量会被放进一个称之为 Delta FIFO Queue，即增量先进先出队列中。</p>

<p>而后，Informer会不断的从 Delta FIFO Queue 中 pop 增量事件，并根据事件的类型来决定新增、更新或者是删除本地缓存，也就是 Local Key-Value Sotrage。<strong>根据集群中某资源的事件来更新本地缓存是Informer的第一个职责，同时也是最重要的职责。</strong></p>

<p>Informer 的另外一个职责就是根据事件类型来触发事先注册好的 Event Handler。在回调函数中通常只会做一些简单的过滤处理，然后将该事件丢到 Work Queue 这个工作队列中。工作队列的主要作用就是平衡 Informer 和 Controller 之间的速度差，避免 Controller 处理速度过慢而影响 Informer 的工作。</p>

<p>接下来就是 Controller 的表演时间了，也就是上图中的 Processer。控制器从 Work Queue 中取出一个事件并根据自身的业务逻辑对其进行处理，不同的控制器会有不同的处理逻辑。如 ReplicSet 控制器在收到某一个 Pod 被删除的事件时将会重新创建一个 Pod，以保证 Pod 的数量。</p>

<h3 id="3-informer代码编写流程">3. Informer代码编写流程</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="p">(</span><span class="x">
	</span><span class="s">"log"</span><span class="x">

	</span><span class="n">v1</span><span class="x"> </span><span class="s">"k8s.io/api/core/v1"</span><span class="x">
	</span><span class="s">"k8s.io/apimachinery/pkg/labels"</span><span class="x">
	</span><span class="s">"k8s.io/client-go/informers"</span><span class="x">
	</span><span class="s">"k8s.io/client-go/kubernetes"</span><span class="x">
	</span><span class="s">"k8s.io/client-go/tools/cache"</span><span class="x">
	</span><span class="s">"k8s.io/client-go/tools/clientcmd"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="c">// 简单起见硬编码相关配置</span><span class="x">
	</span><span class="n">configPath</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="s">"/home/smartkeyerror/.kube/config"</span><span class="x">
	</span><span class="n">masterURL</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="s">"https://10.39.35.19:6443"</span><span class="x">

	</span><span class="c">// 初始化config</span><span class="x">
	</span><span class="n">config</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">clientcmd</span><span class="o">.</span><span class="n">BuildConfigFromFlags</span><span class="p">(</span><span class="n">masterURL</span><span class="p">,</span><span class="x"> </span><span class="n">configPath</span><span class="p">)</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="c">// 初始化client</span><span class="x">
	</span><span class="n">kubeClient</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">kubernetes</span><span class="o">.</span><span class="n">NewForConfig</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="c">// 获取工厂实例, 通过这个工厂实例可获取到所有资源的 Informer</span><span class="x">
	</span><span class="n">factory</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">informers</span><span class="o">.</span><span class="n">NewSharedInformerFactory</span><span class="p">(</span><span class="n">kubeClient</span><span class="p">,</span><span class="x"> </span><span class="m">0</span><span class="p">)</span><span class="x">
	</span><span class="c">// 创建Pod Informer</span><span class="x">
	</span><span class="n">podInformer</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">factory</span><span class="o">.</span><span class="n">Core</span><span class="p">()</span><span class="o">.</span><span class="n">V1</span><span class="p">()</span><span class="o">.</span><span class="n">Pods</span><span class="p">()</span><span class="x">
	</span><span class="n">informer</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">podInformer</span><span class="o">.</span><span class="n">Informer</span><span class="p">()</span><span class="x">

	</span><span class="n">stopCh</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="k">struct</span><span class="p">{})</span><span class="x">
	</span><span class="k">defer</span><span class="x"> </span><span class="nb">close</span><span class="p">(</span><span class="n">stopCh</span><span class="p">)</span><span class="x">
	</span><span class="k">go</span><span class="x"> </span><span class="n">factory</span><span class="o">.</span><span class="n">Start</span><span class="p">(</span><span class="n">stopCh</span><span class="p">)</span><span class="x">

	</span><span class="k">if</span><span class="x"> </span><span class="o">!</span><span class="n">cache</span><span class="o">.</span><span class="n">WaitForCacheSync</span><span class="p">(</span><span class="n">stopCh</span><span class="p">,</span><span class="x"> </span><span class="n">informer</span><span class="o">.</span><span class="n">HasSynced</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="s">"sync failed"</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="c">// 注册定义处理函数(偷懒, 不使用队列, 直接print)</span><span class="x">
	</span><span class="n">informer</span><span class="o">.</span><span class="n">AddEventHandler</span><span class="p">(</span><span class="n">cache</span><span class="o">.</span><span class="n">ResourceEventHandlerFuncs</span><span class="p">{</span><span class="x">
		</span><span class="n">AddFunc</span><span class="o">:</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">obj</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="n">pod</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">obj</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">v1</span><span class="o">.</span><span class="n">Pod</span><span class="p">)</span><span class="x">
			</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Get a pod:"</span><span class="p">,</span><span class="x"> </span><span class="n">pod</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span><span class="x">
		</span><span class="p">},</span><span class="x">
		</span><span class="n">UpdateFunc</span><span class="o">:</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">oldObj</span><span class="p">,</span><span class="x"> </span><span class="n">newObj</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"update pod"</span><span class="p">)},</span><span class="x">
		</span><span class="n">DeleteFunc</span><span class="o">:</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"delete pod"</span><span class="p">)},</span><span class="x">
	</span><span class="p">})</span><span class="x">

	</span><span class="c">// 创建Lister</span><span class="x">
	</span><span class="n">podLister</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">podInformer</span><span class="o">.</span><span class="n">Lister</span><span class="p">()</span><span class="x">
	</span><span class="c">// 获取所有标签的pod</span><span class="x">
	</span><span class="n">podList</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">podLister</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">Everything</span><span class="p">())</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">podList</span><span class="p">)</span><span class="x">

	</span><span class="o">&lt;-</span><span class="x"> </span><span class="n">stopCh</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>这是一个最简单的使用 Informer 的代码示例，其作用就是通过<code class="highlighter-rouge">List</code>方法打印出当前集群中所有的 Pod，以及在创建、删除和更新 Pod 资源时打印出相关的信息。</p>

<p>首先我们通过集群的地址以及<code class="highlighter-rouge">config</code>认证文件生成一个基本的<code class="highlighter-rouge">config</code>对象，并且根据该对象初始化了一个<code class="highlighter-rouge">kubeClient</code>对象，然后使用<code class="highlighter-rouge">kubeClient</code>创建了一个工厂实例。这个工厂实例中包含了 Kubernetes 中所有资源的 Informer，例如 Pod，Node，Network，RBAC等等。</p>

<p>剩下的代码内容就是按照上述的原理图按部就班的编写和执行了。实际上，对上述代码进行稍加改造即可以得到一个自定义控制器(CRD)的简易版本。控制器模式本质上就是用户期望状态和集群实际状态之间的对比、调谐，使得集群实际状态在某个时刻之后与用户期望状态一致，保存在 Informer 本地缓存的资源状态，其实就是用户的期望状态。</p>

<h3 id="4-小结">4. 小结</h3>

<p>Kubernetes 可以说是一个由事件驱动的分布式对象管理中心，而 Informer 则正是提供驱动事件的发动机。从设计模式的角度来看，Informer 本质上就是一个观察者，Controller 和本地缓存就是基于该观察者所观察的结果进行相应的处理。</p>

	  ]]></description>
	</item>

	<item>
	  <title>VXLAN—构建Overlay容器网络</title>
	  <link>//VXLAN</link>
	  <author></author>
	  <pubDate>2020-08-06T09:06:25+00:00</pubDate>
	  <guid>//VXLAN</guid>
	  <description><![CDATA[
	     <p>由于 VLAN 实现中的 VLAN ID 仅有12位，只能划分4096个虚拟局域网网段，对于云计算等领域而言，其用户远远不止4096个。并且，VLAN 依赖于交换机等物理设备的实现，一旦升级物理设备，集群网络可能需要重新配置。因此，基于上述的限制，VMware、Cisco 等大型网络企业推出了 VXLAN 解决方案。</p>

<!---more--->

<p>VXLAN 全称为 Virtual eXtensible Local Area Network，可拓展虚拟局域网，不依赖于硬件实现，而是在三层网络(网络层)的基础之上构建出一个虚拟的二层网络(链路层)。也就是说，只要主机间 IP 地址可达，就可以使用 VXLAN 的方式构建一个 Overlay 网络。</p>

<blockquote>
  <p>Overlay: 可以理解为覆盖网络，属于一种虚拟网络的实现，依赖于物理网络，而物理网络又可称之为 Underlay。</p>
</blockquote>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/virtual-machine-communicate-problems.png" alt="" /></p>

<p>在实际的介绍 VXLAN 之前，先来看一个集群中虚拟机通讯的问题。如上图所示，虚拟机-A(<code class="highlighter-rouge">192.19.2.2</code>)想要和虚拟机-C(<code class="highlighter-rouge">192.16.2.6</code>)进行通信，要如何实现?</p>

<p>由于节点<code class="highlighter-rouge">10.168.4.3</code>和<code class="highlighter-rouge">10.168.9.3</code>能够实现通信，那么是否能够将虚拟机间通讯的数据包封装在节点间的通讯包之上，抵达目的地之后再进行解包、分发呢? 就好像特洛伊木马一样。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/virtual-machine-solution.png" alt="" /></p>

<p>如上图所示，虚拟机-A发送给虚拟机-C的数据包，首先经过一个工具进行封包，暂且称之为Tool，封包的结果就是将该数据包放置在节点间通讯数据包的 Body 中，作为数据发送给节点B。节点B收到该数据包之后，经过某种过滤规则，检查 Body，发现这是一个发送给虚拟机-C的数据包，那么将数据包发送给节点C，单向通讯完成。</p>

<p>上述的过程其实就是 VXLAN 的基本原理组成，本质上就是对虚拟机间通讯数据包的封装和解封，乘着节点间通讯这条大船抵达目的地。</p>

<h3 id="1-vxlan协议原理">1. VXLAN协议原理</h3>

<p>在 VXLAN 协议中，负责封包、解包的组件称之为 VTEP(VXLAN Tunnel Endpoints，VXLAN 隧道端点)，可以简单的认为就是运行在各个节点上的一个进程。</p>

<p>每一个 VTEP 都有一个唯一的标志符，称之为 VNI(VXLAN Network Identifier，VXLAN 网络标识符)，其实就是拓展的 VLAN ID。VNI 被设计成24位，可以容纳16777216个不同的虚拟局域网，相较于 VLAN 是一个非常大的提升。</p>

<p>VXLAN 在节点中的传输协议选择了 UDP 协议，而不是 TCP 协议。原因在于 UDP 协议相较于 TCP 协议速度更快，无需连接的建立与拆除，数据包的可靠传输则由虚拟机间的传输协议保证。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/VXLAN-package.png" alt="" /></p>

<p>其中，VXLAN Header 由 VTEP 添加，其中包含了24位 VNI 的值。可以看到，VXLAN 其实就是对原有网络添加了一层拓展: VTEP。当数据包到达主机时，内核将 MAC 头和 IP 头取下，将 UDP 报文段发送给主机上的 VTEP 进程，VTEP 进程首先检查 VNI 的值是否匹配(是不是给自己的包)，然后根据 Inner IP Header 决定发送给哪一个具体的虚拟机。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/VXLAN-Transfer.png" alt="" /></p>

<p>现在，我们对 VXLAN 协议的基本原理已经很清楚了，现在再来看一些细节问题。<strong>首先，虚拟机-A发出的数据帧的目标 MAC 地址，也就是目标 VTEP 的 MAC 地址该如何获取?</strong> 两种方式，一种是通过广播的方式，另外一种，则是由外部进程自动的添加至各节点的 ARP 表中。<strong>其次，IP 地址为192.16.2.6这台虚拟机所在节点的IP地址如何获取?</strong> 该 IP 地址则是通过 Linux 内核中的 FDB(Forwarding Database) 获取的，在该表中，会记录 VTEP 的 MAC 地址与节点 IP 地址的映射关系，该映射关系同样可以通过广播学习获取，或者由外部进程维护。</p>

<blockquote>
  <p>经典的”外部进程”有 flannel、Weave 等容器网络框架</p>
</blockquote>

<h3 id="2-使用-vagrant-构建-vxlan-点对点通信">2. 使用 Vagrant 构建 VXLAN 点对点通信</h3>

<p>Vagrant 环境如下:</p>
<ul>
  <li>node-1: 网卡接口-enp0s8，IP地址-192.168.2.15/24</li>
  <li>node-2: 网卡接口-enp0s8，IP地址-192.168.2.16/24</li>
</ul>

<p>首先，在node-1上添加 vxlan interface:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span><span class="nb">sudo </span>ip link add vxlan0 <span class="nb">type </span>vxlan <span class="se">\</span>
    id 1024 <span class="se">\</span>
    dstport 4789 <span class="se">\</span>
    remote 192.168.2.15 <span class="se">\</span>
    dev enp0s8
</code></pre></div></div>

<p>上述命令将创建出一个名称为<code class="highlighter-rouge">vxlan0</code>、类型为 vxlan 的网络接口，并且指定 VNI 为<code class="highlighter-rouge">1024</code>，vtep 通信端口为<code class="highlighter-rouge">4789</code>，并且手动地指出了对端 VTEP 的 IP 地址(<code class="highlighter-rouge">192.168.2.16</code>)。</p>

<p>其次，为 vxlan0 网络接口添加一个 IP 地址，该 IP 地址可以是任意值:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span><span class="nb">sudo </span>ip addr add 10.100.1.15/24 dev vxlan0
vagrant@node-1:~<span class="nv">$ </span><span class="nb">sudo </span>ip link <span class="nb">set </span>vxlan0 up
</code></pre></div></div>

<p>那么此时所有目标地址为<code class="highlighter-rouge">10.100.1.10/24</code>网段的数据包均会通过 vxlan0 接口处理，可以从路由表上查看此信息:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span>ip route
10.100.1.0/24 dev vxlan0 proto kernel scope link src 10.100.1.15
</code></pre></div></div>

<p>并且，如果此时查看 Linux FDB 表的话会发现，此时表项中的 MAC 地址为空值:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span>bridge fdb
00:00:00:00:00:00 dev vxlan0 dst 192.168.2.16 via enp0s8 self permanent
</code></pre></div></div>

<p>即所有经过 vxlan0 处理的数据包都会发到<code class="highlighter-rouge">192.168.2.16</code>，其原因在于在创建 vxlan0 时，手动地指定了对端 IP 地址。</p>

<p>用同样的方式在另一台虚拟机上创建 vxlan0 接口，并配置相应的 IP 地址，即可测试连通性。</p>

<p>通过上面的实验用例，我们可以看到几个非常关键的步骤:</p>

<ul>
  <li><strong>在路由表中添加 vtep 设备网络段的路由信息</strong></li>
  <li><strong>在 ARP 表中添加 vtep 设备的 MAC 地址与 vtep 的 IP 地址映射</strong></li>
  <li><strong>在 FDB 表中添加 vtep 设备的 MAC 地址与 vtep 所在节点的 IP 地址映射</strong></li>
</ul>

<p>实际上，<code class="highlighter-rouge">Flannel</code>这一经典的 Kubernetes 容器网络解决方案的 VXLAN 模式就是这么实现的，VXLAN 模式所组建的覆盖网络，其实就是一个由不同宿主机上的 VTEP 设备所组成的虚拟二层网络。</p>

<h3 id="reference">Reference</h3>

<ul>
  <li><a href="https://www.kernel.org/doc/Documentation/networking/vxlan.txt">https://www.kernel.org/doc/Documentation/networking/vxlan.txt</a></li>
  <li><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100087027">https://support.huawei.com/enterprise/zh/doc/EDOC1100087027</a></li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
