<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description>Keep coding, Keep curiosity</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Coin Change——自顶向下思考，自底向上实现</title>
	  <link>//Coin-Change</link>
	  <author></author>
	  <pubDate>2021-04-06T08:50:25+00:00</pubDate>
	  <guid>//Coin-Change</guid>
	  <description><![CDATA[
	     <p><a href="https://leetcode.com/problems/coin-change/">Coin Change</a> 是一道动态规划问题中一道非常经典的题目，这是因为只要对原有的 Coin Change 问题稍加修改，就可以得到更复杂的动态规划问题，甚至是回溯问题。</p>

<!---more--->

<h3 id="1-无限硬币">1. 无限硬币</h3>

<h4 id="11-存在型动态规划">1.1 存在型动态规划</h4>

<p>首先来看最简单的问题:</p>

<blockquote>
  <p>给定不同面额的硬币 coins 和一个总金额 amount，每一种硬币的数量是无限的，这些硬币能否组合成 amount? 若能组合，返回 true，否则返回 false。</p>
</blockquote>

<p>类似于上面的问题，诸如求是否有某条路径/某个解决方案到达目标的问题，都可以被称之为存在型动态规划。再来看原问题，因为每一种面额的硬币数量是无限的，所以我们不知道能够组合成 amount 的方案中到底一共有多少个硬币。<strong>也就是说，这个问题与硬币数量无关，只和硬币的面额有关。</strong></p>

<p>绝大部分的 DP 问题都是“自顶向下思考，自底向上实现”的。什么意思呢? 相较于第一枚硬币而言，我们更关注组成 amount 的最后一枚硬币，也就是拼成完整拼图的最后一块儿。假设硬币面额为 <code class="highlighter-rouge">[2, 3, 5]</code>，amount 为 11，并且组成 amount 的最后一枚硬币面额为 <code class="highlighter-rouge">K</code>。那么如果我们知道了 <code class="highlighter-rouge">amount-K</code> 能不能被 coins 拼出来，也就知道了整个问题的答案。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/coin-change/1615207097202.png" alt="Alt text" /></p>

<p>在最后一枚硬币面额为 <code class="highlighter-rouge">K</code> 的情况下，如果我们能拼出 <code class="highlighter-rouge">amount-K</code> 的话，那么再加上最后一枚硬币 <code class="highlighter-rouge">K</code>，总金额刚好为 amount，结果为 true。反之，如果我们不能拼出 <code class="highlighter-rouge">amount-K</code> 的话，结果为 false。可以看到，本来题目是要求能不能拼出 amount，但是现在需要知道能不能拼出 <code class="highlighter-rouge">amount-K</code>，这就是一个规模更小的问题，也就是子问题。代码实现如下:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

    <span class="c1">// 当总金额为 0 时我们一个硬币都不选，所以为 true
</span>    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="c1">// 计算金额为 1、2、3...amount 能否由 coins 拼出，sub 即为子金额
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sub</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">sub</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">sub</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 每一枚硬币都作为最后一枚硬币，看能不能拼出 sub - coin 
</span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">coin</span> <span class="o">:</span> <span class="n">coins</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 简单的来看，sub - coin 必须大于等于 0，才能作为数组下标
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">&gt;=</span> <span class="n">coin</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span> <span class="o">||</span> <span class="n">dp</span><span class="p">[</span><span class="n">sub</span> <span class="o">-</span> <span class="n">coin</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="12-最值型动态规划">1.2 最值型动态规划</h4>

<p>接下来看最值型的动态规划问题，仍然是硬币找零，这次使用 LeetCode 上的原题: <a href="https://leetcode.com/problems/coin-change/">322. Coin Change</a>，问题描述如下:</p>

<blockquote>
  <p>给定不同面额的硬币 coins 和一个总金额 amount，你可以认为每种硬币的数量是无限的。写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
</blockquote>

<p>这个问题在第一个问题之上难度增加了一点点，问凑成 amount 需要的最少硬币数，硬币仍然是无限供应。同样的，由于硬币是无限供应的，所以我们不能考虑硬币数量，而是要考虑最后一个硬币的情况。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/coin-change/1615207194641.png" alt="Alt text" /></p>

<p>仍然假设最后一枚硬币面额为 <code class="highlighter-rouge">K</code>，那么现在如果我们知道了凑成 <code class="highlighter-rouge">amount-K</code> 所需要的最少硬币数的话，也就知道了当最后一枚硬币为 <code class="highlighter-rouge">K</code> 时凑出 amount 所需要的最少硬币数。这同样是一个规模更小的问题，也就是子问题。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>

    <span class="c1">// 当金额为 0 时一枚硬币都不需要，所以 dp[0] = 0
</span>    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sub</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">sub</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">sub</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">coin</span> <span class="o">:</span> <span class="n">coins</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">&gt;=</span> <span class="n">coin</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="p">[</span><span class="n">sub</span> <span class="o">-</span> <span class="n">coin</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">sub</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">sub</span> <span class="o">-</span> <span class="n">coin</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="13-组合数型动态规划">1.3 组合数型动态规划</h4>

<p>组合数型的动态规划通常需要求达成某一个目标的所有方案数，比如说凑够 amount 一共有多少种凑法。这类问题的关键点不在于状态转移方程如何思考，而是在于明确到底是组合数还是排列数。</p>

<p>例如 <code class="highlighter-rouge">1 + 2 + 1</code> 和 <code class="highlighter-rouge">1 + 1 + 2</code> 到底是算一种组合方式，还是两种。有的题目会明确告知是计算排列数还是组合数，有的题目则会在 Example 中通过具体的案例告诉我们到底是组合还是排列。</p>

<p>首先来看排列问题，因为 <code class="highlighter-rouge">1 + 2 + 1</code> 和 <code class="highlighter-rouge">1 + 1 + 2</code> 是两种不同的方式，所以这和<strong>最后一个硬币到底是谁有关系</strong>。假如最后一个硬币面值为 1、且 amount = 4 的排列方式有 3 种，最后一个硬币面值为 2、且 amount = 4 的排列方式有 2 种，加起来一共 5 种。此时我们就可以说当 <code class="highlighter-rouge">coins = [1, 2]</code> 且 amount 为 4 时总的方案数为 5。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/coin-change/1615297442917.png" alt="Alt text" /></p>

<p>所以说，排列问题仍然是让每一枚硬币都作为 Last Coin，然后看 <code class="highlighter-rouge">amount-K</code> 有多少种凑法，实现如下:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// 哪个硬币都不要，也是一种排列方式
</span>    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sub</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">sub</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">sub</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 每一种不同面额的硬币作为 Last Coin 计算方案数
</span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">coin</span> <span class="o">:</span> <span class="n">coins</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">&gt;=</span> <span class="n">coin</span><span class="p">)</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">sub</span> <span class="o">-</span> <span class="n">coin</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>LeetCode 中的 <a href="https://leetcode.com/problems/combination-sum-iv/">377. Combination Sum IV</a> 其实就是一道求排列总方案的 Coin Change 问题。题干中并没有直接的使用 “permutation” 一词，而是在 Example 中说明了该题其实是一道排列型问题。</p>

<p>再来看组合问题，也就是 <code class="highlighter-rouge">1 + 1 + 2</code> 和 <code class="highlighter-rouge">2 + 1 + 1</code> 属于同一种凑法，所以<strong>只和金额有关系，谁是最后一个硬币 Who Care。</strong>那么此时我们就需要金额作为最后一块儿拼图，硬币面值作为已有的拼图。也就是说，我们计算的是当我们只有面额为 <code class="highlighter-rouge">[1]</code> 的硬币时凑成 amount 的方案数，只有面额为 <code class="highlighter-rouge">[1, 2]</code> 时凑成 amount 的方案数，只有面额为 <code class="highlighter-rouge">[1, 2, ...]</code> 的硬币凑成 amount 的方案数。实现如下:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// 同样的，哪个硬币都不选，也是一种组合方式
</span>    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">coin</span> <span class="o">:</span> <span class="n">coins</span><span class="p">){</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sub</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">sub</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">sub</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">&gt;=</span> <span class="n">coin</span><span class="p">)</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">sub</span> <span class="o">-</span> <span class="n">coin</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-有限硬币">2. 有限硬币</h3>

<p>对于无限硬币的 DP 问题来说，当我们假设最后一枚硬币为 K 时，凑齐 <code class="highlighter-rouge">amount-K</code> 时依然可以使用最后一枚硬币的面值，所以在计算子问题时对于硬币是怎么排列的，使用过了哪些硬币完全可以忽略。但是，当每一种面额的硬币均只有一枚时，情况将截然不同。当我们以 K 作为最后一枚硬币时，前面的 <code class="highlighter-rouge">target-K</code> 将不能再使用该枚硬币，也就是说，我们需要关心使用了哪些硬币。</p>

<h4 id="21-存在型动态规划">2.1 存在型动态规划</h4>

<blockquote>
  <p>给定不同面额的硬币 coins 和一个总金额 amount，每一种硬币只能使用一次，这些硬币能否组合成 amount? 若能组合，返回 true，否则返回 false。</p>
</blockquote>

<p>前面提到过，当我们失去“无限硬币”这个外挂以后，我们便不能将子问题定义成“能否拼出<code class="highlighter-rouge">amount-K</code>”了，因为在计算 <code class="highlighter-rouge">amount-K</code> 时完全有可能将最后一枚面额为 K 的硬币也算进去，但实际上面额为 K 的硬币可能只有一枚。</p>

<p>对于 coins 中的每一枚硬币，状态其实只有两种: <strong>选择该枚硬币和不选该枚硬币</strong>。也就是对于最后一枚 K 来说，我可以选择这一枚硬币，然后看前 n-1 枚硬币能不能拼出 <code class="highlighter-rouge">amount-K</code>出来。或者说我们不选择该枚硬币，那么就得看前 n-1 枚硬币能不能拼出 amount 了。</p>

<p>本来我们是要求 coins 这 n 枚硬币能否拼出 amount，现在我们从 coins 的最后一枚硬币出发，得到了一个“二分选择”，也就是看<strong>前 n-1 枚硬币能不能拼出 <code class="highlighter-rouge">amount-K</code> 或者是拼出 amount</strong>。如果这两种情况都是 false 的话，那么整个问题就是无解的，也就是应该返回 false。这样我们就得到了一个规模更小的问题（n 枚硬币变成了 n-1 枚硬币），也就是子问题。</p>

<p>这其实就是 0-1 背包的核心思想: 选还是不选，这是一个问题。</p>

<p>好了，我们使用“前 n-1 枚硬币能否…”这样的方式来杜绝我们对同一枚硬币的重复选取，所以说硬币的数量也将作为我们的状态，当然，还有 amount。所以，我们使用 <code class="highlighter-rouge">dp[i][sub]</code> 来表示<strong>前 i 枚</strong>硬币能否凑出金额 sub。实现如下:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">coins</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>

    <span class="c1">// 前 0 枚硬币当然可以组成金额 0，因为一枚硬币都没有
</span>    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sub</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">sub</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">sub</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 前 i 枚硬币的最后一枚硬币为 i-1，面额为 coins[i-1]
</span>            <span class="kt">int</span> <span class="n">lastCoin</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">&gt;=</span> <span class="n">lastCoin</span><span class="p">)</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sub</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">sub</span><span class="p">]</span> <span class="o">||</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">sub</span><span class="o">-</span><span class="n">lastCoin</span><span class="p">];</span>
            <span class="k">else</span>
                <span class="c1">// 当最后一枚硬币的面值比金额还要大时候，我们肯定不能选择该枚硬币
</span>                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sub</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">sub</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">amount</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在继续往下之前我们先来看一个 DP 问题非常重要的组成: 空间优化。当我们需要使用二维数组才能解决问题时，第一个反应就是能不能使用一维数组进行优化。如下面这条核心语句:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sub</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">sub</span><span class="p">]</span> <span class="o">||</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">sub</span><span class="o">-</span><span class="n">lastCoin</span><span class="p">];</span>
</code></pre></div></div>

<p>如果将 <code class="highlighter-rouge">dp[i][sub]</code> 想象成一个二维矩阵的话，第 i 行只与第 i-1 行有关系，那么我们完全可以只使用 2 行来进行<strong>滚动更新</strong>。比如说我们可以用第一行来计算当 i 为奇数时的情况，第二行来计算当 i 为偶数的情况，如下图所示:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/coin-change/1615295914672.png" alt="Alt text" /></p>

<p>我们只需要将原来的 <code class="highlighter-rouge">dp[i]</code> 换成 <code class="highlighter-rouge">dp[i%2]</code> ，将 <code class="highlighter-rouge">dp[i-1]</code> 换成 <code class="highlighter-rouge">dp[(i-1)%2]</code> 即可，其它的逻辑照抄，就能实现只使用两行空间完成计算。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">coins</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>

    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sub</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">sub</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">sub</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">lastCoin</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">&gt;=</span> <span class="n">lastCoin</span><span class="p">)</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="p">][</span><span class="n">sub</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">][</span><span class="n">sub</span><span class="p">]</span> <span class="o">||</span> <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">][</span><span class="n">sub</span><span class="o">-</span><span class="n">lastCoin</span><span class="p">];</span>
            <span class="k">else</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="p">][</span><span class="n">sub</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">][</span><span class="n">sub</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">][</span><span class="n">amount</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>更丧心病狂一些，我们也可以只使用一行空间来进行覆盖更新，将这个一维数组分成新值和旧值，当利用完旧值计算好了新值以后，用新值直接覆盖掉旧值，俗称过河拆桥。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/coin-change/1615296379763.png" alt="Alt text" /></p>

<p>如上图所示，在二维空间中 <code class="highlighter-rouge">dp[i][sub]</code> 的值依赖于其正上方的值以及其左上方的值。所以说，当我们使用一维数组进行覆盖更新时，<code class="highlighter-rouge">sub</code> 需要从右向左遍历，这样一来 <code class="highlighter-rouge">dp[i-1][j]</code> 和 <code class="highlighter-rouge">dp[i-1][j-lastCoin]</code> 的值才不会被新值所覆盖。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">coins</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 覆盖更新必须从右向左，因为左边儿的值还得用到呢
</span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">sub</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">sub</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">lastCoin</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">&gt;=</span> <span class="n">lastCoin</span><span class="p">)</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span> <span class="o">||</span> <span class="n">dp</span><span class="p">[</span><span class="n">sub</span><span class="o">-</span><span class="n">lastCoin</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Leetcode 中 <a href="https://leetcode.com/problems/partition-equal-subset-sum/">416. Partition Equal Subset Sum</a> 就是一道有限硬币的存在型问题。只不过题目描述的比较隐晦，问一个数组能不能被分成两个元素和相等的子集，其实就是在问一个数组能不能找到一个子集，使其和为 sum(nums) / 2。</p>

<p>值得一提的是，动态规划并不适用于所有的存在性硬币问题，这和我们需要解决问题的数据规模，准确的来说，和 amount 以及 coins 的分布相关。当 amount 较小时，例如 5000、100000，由于 C++ 底层对于 <code class="highlighter-rouge">vector&lt;bool&gt;</code> 进行特殊的内存分配管理，使得我们开大小为 10 万的 <code class="highlighter-rouge">vector&lt;bool&gt;</code> 代价不是很高。</p>

<p>但是，一旦 amount 的值变得巨大，例如 10^9，并且 coins 的取值范围跨度非常之大，例如 <code class="highlighter-rouge">[1, 2, 45256, 2014896]</code>，这个时候不应该使用动态规划的思想来求解存在型问题，而应该使用回溯+剪枝的方式实现。<a href="https://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/">1780. Check if Number is a Sum of Powers of Three</a>，这道题目就是一个典型，amount 的取值达到了 10^7（原题目为 n，可以看作是 amount）。但是 coins 的数量却很少，因为 3^20 其实就已经远超出了 amount 的范围。</p>

<p>关于这道问题的题解可参考:</p>

<blockquote>
  <p><a href="https://github.com/SmartKeyerror/Snorlax/blob/master/leetcode/backtracking/1780-Check-if-Number-is-a-Sum-of-Powers-of-Three.cpp">1780-Check-if-Number-is-a-Sum-of-Powers-of-Three.cpp</a></p>
</blockquote>

<h4 id="22-最值型动态规划">2.2 最值型动态规划</h4>

<blockquote>
  <p>给定不同面额的硬币 coins 和一个总金额 amount，每一种硬币只能使用一次，组合成 amount 最少需要几枚硬币? 如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
</blockquote>

<p>分析过程和存在型动态规划一样，由于每一种面额的硬币只能使用一次，所以硬币的数量需要考虑在内。设 <code class="highlighter-rouge">dp[i][sub]</code> 表示<strong>前 i 枚</strong>硬币凑成金额 sub 所需要的最少硬币数，要么是前 i-1 枚硬币凑成 sub，要么是前 i-1 枚硬币凑出了 <code class="highlighter-rouge">sub-coins[i-1]</code> ，再加上最后一枚硬币凑成了 sub。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sub</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">sub</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">sub</span><span class="o">-</span><span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>优化过程类似，首先我们使用二维数组求解，然后用滚动数组将空间优化至两行，进而使用一维数组进行覆盖更新，优化后代码如下:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">coins</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>

    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">sub</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">sub</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">lastCoin</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">&gt;=</span> <span class="n">lastCoin</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="p">[</span><span class="n">sub</span><span class="o">-</span><span class="n">lastCoin</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">)</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">sub</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">sub</span><span class="o">-</span><span class="n">lastCoin</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到，只需要对存在型问题的解稍加修改即可得到最值型问题的答案。<strong>在使用一维数组进行覆盖更新时，一定要准确的理解为什么第二层循环要从右向左遍历。</strong></p>

<h4 id="23-组合数型动态规划">2.3 组合数型动态规划</h4>

<p>和存在型与最值型问题基本类似，对状态的定义稍加修改即可，故不再赘述。</p>

<h3 id="3-小结">3. 小结</h3>

<p>Coin Change 类问题既可以看作是 0-1 背包问题，也可以看作是完全背包问题，不过他们的本质都是一样的: 对于第 K 个硬币/物品来说，在无限硬币中我们可以选择一个都不放和放多个，在单一使用硬币中我们可以选择放和不放，动态规划中一大类问题都可以使用 Coin Change 以及 0-1 背包问题解决。</p>

<p>动态规划和回溯是一对好兄弟，有时候不适合使用动态规划解决的问题，使用回溯法或许能有意外之喜。不过，这通常与输入数据的规模与分布有关。</p>

<p>Leetcode 上 Coin Change 类问题:</p>

<p>(1) 无限硬币</p>

<ul>
  <li><a href="https://leetcode.com/problems/coin-change/">322. Coin Change</a></li>
  <li><a href="https://leetcode.com/problems/perfect-squares/">279. Perfect Squares</a></li>
  <li><a href="https://leetcode.com/problems/coin-change-2/">518. Coin Change 2</a></li>
  <li><a href="https://leetcode.com/problems/combination-sum-iv/">377. Combination Sum IV</a></li>
</ul>

<p>(2) 有限硬币</p>

<ul>
  <li><a href="https://leetcode.com/problems/partition-equal-subset-sum/">416. Partition Equal Subset Sum</a></li>
</ul>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/coin-change/1615381012229.png" alt="Alt text" /></p>

	  ]]></description>
	</item>

	<item>
	  <title>BFS与图论问题建模</title>
	  <link>//BFS</link>
	  <author></author>
	  <pubDate>2021-01-01T08:50:25+00:00</pubDate>
	  <guid>//BFS</guid>
	  <description><![CDATA[
	     <p>在 DP 问题中我们将会着重的关注状态转移方程，同样地，在使用 BFS 对某些问题进行图论模型建模时，我们同样会关注状态转移。</p>

<!---more--->

<p>BFS（Breadth-first Search），即广度优先遍历，在二叉树相关领域的题目中可能会经常碰到，Leetcode 中也有非常多关于二叉树层序遍历的问题，例如</p>

<ul>
  <li><a href="https://leetcode.com/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a></li>
  <li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></li>
  <li><a href="https://leetcode.com/problems/find-bottom-left-tree-value/">513. Find Bottom Left Tree Value</a></li>
  <li><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">515. Find Largest Value in Each Tree Row</a></li>
  <li>……</li>
</ul>

<p>这些问题都可以借助队列这一数据结构使用层序遍历的方式解决。但是，这些问题并没有揭示 BFS 的一个非常重要的特性: <strong>无权图最短路径求解方式</strong>。假定给你一棵二叉树，二叉树中部分节点中有专门“刀人”的邪恶机器人，再给定一个终止节点，问在该二叉树中是否存在一条从根节点到终止节点的最短路径。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/bfs/1609296538426.png" alt="Alt text" /></p>

<p>如上图所示，起点和终点使用绿色进行标识，我们也能够非常轻松的找到一条能到达终止节点的路径。在一棵二叉树中，只要能找到一条路径，那么它一定就是最短路径，因为再也没有其它路径能够到达该节点了。但是，一旦我们将这棵二叉树添加几条边，将其转换成一张图的话，事情就变得微妙了起来:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/bfs/1609297337905.png" alt="Alt text" /></p>

<p>如上图所示，我们可以找到 3 条从根节点到终止节点的最短路径，也就是无权图的最短路径。那么为什么 BFS 就天然地能够解决无权图最短路径问题呢? 这是因为 BFS 的遍历过程中，是一层一层的进行遍历的，就像剥洋葱一样。当我们遍历到某一层找到了终止节点时，那么其余的最短路径一定在这一层，而不是下一层。这就好比我们下楼梯找东西，我们明明在第 4 层就找到了我们想要的，那么绝对不会再去第 3 层寻找。</p>

<h3 id="1-bfs-的基本框架">1. BFS 的基本框架</h3>

<p>相较于二叉树的层序遍历而言，图的 BFS 没有什么太大的区别，都需要借助队列这一数据结构实现，只不过因为图的 BFS 过程中可能会出现对节点重复访问的问题，所以我们需要添加一个 <code class="highlighter-rouge">visited</code> 数组，来帮助我们标记哪些已经遍历过的节点，从而避免重复访问:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">levelQueue</span><span class="p">;</span>

	<span class="n">visited</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">levelQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">levelQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">levelQueue</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

        <span class="c1">// 非常实用的小技巧，取出每一层的数据
</span>		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">levelQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
			<span class="n">levelQueue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">neighbor</span><span class="o">:</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
				<span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="c1">// do something for child
</span>				<span class="n">levelQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在上面的伪代码中，<code class="highlighter-rouge">visited</code> 数组使用 <code class="highlighter-rouge">bool</code> 型表示，我们同样也可以使用 <code class="highlighter-rouge">int</code> 来表示。例如 <code class="highlighter-rouge">-1</code> 则表示当前节点未曾访问过，大于 <code class="highlighter-rouge">-1</code> 则表示当前节点距离 <code class="highlighter-rouge">src</code> 节点的距离。如此一来我们不仅使用 <code class="highlighter-rouge">visited</code> 表示了节点是否被访问，同时也记录了每一个节点到 <code class="highlighter-rouge">src</code> 节点的距离，一举两得。</p>

<h3 id="2-直白的-bfs-问题">2. 直白的 BFS 问题</h3>

<p>在文章开头所陈列的 Leetcode 上关于二叉树的 BFS 问题，个人更倾向于将其归类为“直白的 BFS 问题”，从题目描述中我们就能够很轻易的看出需要使用 BFS 进行求解。</p>

<p>例如 <a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">1091. Shortest Path in Binary Matrix</a>，求仅包含 <code class="highlighter-rouge">0</code> 和 <code class="highlighter-rouge">1</code> 的二维矩阵中从左上角到右下角的最短路径距离，其中 <code class="highlighter-rouge">1</code> 表示障碍物，<code class="highlighter-rouge">0</code> 表示可行路径。这道题乍一看和 <a href="https://leetcode.com/problems/unique-paths-ii/">63. Unique Paths II</a> 非常之类似，但是和 63 号问题不同的是，1091 号问题里面的“Robot”有 8 个前进方向，并且使用 DP 求解的时间复杂度必然是 O(n^2)，而使用 BFS 求解则只需 O(V+E) 的时间复杂度，其中 V 为顶点个数，E 为边的个数。BFS 的过程如下图所示:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/bfs/1609303685314.png" alt="Alt text" /></p>

<p>求解过程如下:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">delta</span> <span class="o">=</span>  <span class="p">{{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">}};</span> 
    <span class="kt">bool</span> <span class="nf">inGrid</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">shortestPathBinaryMatrix</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">grid</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">levelQueue</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>

        <span class="n">levelQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">visited</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">levelQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">levelQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">levelQueue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

            <span class="kt">int</span> <span class="n">startx</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">starty</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">startx</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">starty</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">inGrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">levelQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
                    <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">visited</span><span class="p">[</span><span class="n">startx</span><span class="p">][</span><span class="n">starty</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="3-图论模型建模状态转移">3. 图论模型建模——状态转移</h3>

<p>在 DP 领域中，有一个非常重要的概念: 状态转移方程，当我们面对一个 DP 问题的时候，只要找到了状态转移方程，基本上我们就认为已经解出了这个问题。在图论建模过程中，也存在状态转移这么个东西，只不过没有状态转移方程。</p>

<p><a href="https://leetcode.com/problems/open-the-lock/">752. Open the Lock</a> 要求我们求打开初始化状态为 <code class="highlighter-rouge">"0000"</code> 的密码锁，并且每次只能对 4 位密码锁中的一位往前拨或者是往后拨，同时存在一组 <code class="highlighter-rouge">deadends</code>，当我们的密码锁被拨到这些数字组合时，该密码锁将再也不能打开，求打开该密码锁所需最少的操作次数。</p>

<p>可以看到，这道题目就只是给了我们一个初始状态和一组“死亡数字”，既没有能够在 8 方向上移动的 Robot，也没有邻接矩阵、邻接表等能够代表图的东西。但是我们知道初始状态和结束状态，假设 <code class="highlighter-rouge">target</code> 为 <code class="highlighter-rouge">"1234"</code>，那么我们就需要找到一条“路径”，从 <code class="highlighter-rouge">"0000"</code> 到 <code class="highlighter-rouge">"1234"</code>，并且在该路径上不包含死亡数字。</p>

<p>对于 <code class="highlighter-rouge">"0000"</code> 来说，我们第一次的操作有 8 种选择: 选择哪一位，以及往前拨还是往后拨，如此一来，我们就可以得到:</p>

<ul>
  <li>往前拨: <code class="highlighter-rouge">"1000"</code>，<code class="highlighter-rouge">"0100"</code>, <code class="highlighter-rouge">"0010"</code>，<code class="highlighter-rouge">"0001"</code></li>
  <li>往后拨: <code class="highlighter-rouge">"9000"</code>，<code class="highlighter-rouge">"0900"</code>，<code class="highlighter-rouge">"0090"</code>，<code class="highlighter-rouge">"0009"</code></li>
</ul>

<p>这样的一共 8 种状态，而得到的这 8 种状态每一种又可以得到 8 种状态，只不过 <code class="highlighter-rouge">"0000"</code> 需要从中剔除，所以是 7 种。如此一来我们就得到了一张图。为什么不是多叉树呢? 因为 <code class="highlighter-rouge">"0000"</code> 能到 <code class="highlighter-rouge">"1000"</code>，<code class="highlighter-rouge">"1000"</code> 也能到达 <code class="highlighter-rouge">"0000"</code>。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/bfs/1609314215174.png" alt="Alt text" /></p>

<p><strong>这其实就是自身状态的表达，每一个状态（例如<code class="highlighter-rouge">"1000"</code>、<code class="highlighter-rouge">"0009"</code>）都是图中的一个顶点，从初始的状态一步一步地到达另外一个状态。本质上仍然可以看做是“Robot千辛万苦寻找家人”的问题</strong>。</p>

<p>题解可参考:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/blob/master/leetcode/bfs/752-Open-the-Lock.cpp</p>
</blockquote>

<p>我们再来看另外一个智力问题:</p>

<blockquote>
  <p>有两个水桶，一个容量为 9 升，另一个容量为 4 升，如何操作能得到 6 升水?</p>
</blockquote>

<p>依然使用状态转移对这个问题进行建模，我们有两个桶，所以初始状态可以表示为 <code class="highlighter-rouge">"00"</code>，最终我们要得到 6 升水，那么结束状态可以表示为 <code class="highlighter-rouge">"6x"</code> 或者是 <code class="highlighter-rouge">"x6"</code>，<code class="highlighter-rouge">x</code> 表示另一个桶有多少水我们并不关心，只要有一个桶里面有 6 升水就好了。</p>

<p>我们可以像上面那道打开密码锁一样，使用字符串的方式来表示状态，但是我们也可以使用 <code class="highlighter-rouge">int</code> 来表示。对于两个桶，使用 <code class="highlighter-rouge">x</code> 表示 9 升桶所容纳的水，<code class="highlighter-rouge">y</code> 则表示 4 升桶所容纳的水，那么状态即为 <code class="highlighter-rouge">10x + y</code>，一个用十位表示，另一个则用个位表示。如果有 3 个桶 <code class="highlighter-rouge">x</code>、<code class="highlighter-rouge">y</code>、<code class="highlighter-rouge">z</code> 的话，那么就可以使用 <code class="highlighter-rouge">100x+10y+z</code> 来进行表示。现在来看状态是如何转移的，假设当前两个桶的水量为 <code class="highlighter-rouge">x</code>、<code class="highlighter-rouge">y</code>。</p>

<p>最简单的两种操作就是将其中一个桶装满，或者是将其中一个桶中的水倒掉，那么状态可以表示为:</p>

<ul>
  <li>装满其中一个桶: <code class="highlighter-rouge">9 * 10 + y</code>（装满 9 升桶），<code class="highlighter-rouge">10x + 4</code>（装满 4 升桶）</li>
  <li>倒掉其中一个桶: <code class="highlighter-rouge">0 * 10 + y</code>（倒掉 9 升桶），<code class="highlighter-rouge">10x + 0</code>（倒掉 4 升桶）</li>
</ul>

<p>另外一个操作就是将一个桶的水倒向另外一个桶内，情况稍微复杂一些:</p>

<ul>
  <li>将 9 升桶的水倒进 4 升桶: <code class="highlighter-rouge">10 * (9 - min(x, 4 - y)) + (y + min(x, 4 - y))</code></li>
  <li>将 4 升桶的水倒进 9 升桶: <code class="highlighter-rouge">10 * (x + min(y, 9 - x)) + (y - min(y, 9 - x))</code></li>
</ul>

<p>正如同状态转移方程之于 DP 问题一样，当我们找到全部的状态转移之后，就已经建立了 BFS 的图论模型，剩下的就只是按部就班的使用 BFS 求解即可。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">bucketPuzzle</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">levelQueue</span><span class="p">;</span>

    <span class="c1">// 使用 hashmap 判定是否访问过, value 为操作次数
</span>    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">;</span>     

    <span class="n">levelQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">visited</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">levelQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">levelQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">levelQueue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">current</span> <span class="o">/</span> <span class="mi">10</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">current</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nextStatuses</span><span class="p">;</span>

        <span class="n">nextStatuses</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">9</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>
        <span class="n">nextStatuses</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>

        <span class="n">nextStatuses</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>
        <span class="n">nextStatuses</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">0</span><span class="p">);</span>

        <span class="n">nextStatuses</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="mi">9</span> <span class="o">-</span> <span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">y</span><span class="p">)));</span>
        <span class="n">nextStatuses</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">9</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">9</span> <span class="o">-</span> <span class="n">x</span><span class="p">)));</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">next</span><span class="o">:</span> <span class="n">nextStatuses</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">levelQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">=</span> <span class="n">visited</span><span class="p">[</span><span class="n">current</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">next</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">visited</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果需要输出详细的操作过程的话，添加一个 <code class="highlighter-rouge">previous</code> 数组即可，在数组中记录当前状态是从哪个状态而来的，而后遍历该数组逆序输出即可。</p>

<p>完整代码可参考:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/blob/master/leetcode/bfs/BucketPuzzle.cpp</p>
</blockquote>

<h3 id="4-小结">4. 小结</h3>

<p>BFS 由于天然地存在“无权图最短路径问题求解”这一特性，被广泛地应用在经典人工智能和搜索领域，包括我们所描述的水桶问题、打开密码锁问题，以及未提及的其它经典人工智能问题，本质上就是路径的搜索。</p>

<p>很多时候，可能我们并不能一眼看出某一个题目需要使用图论模型进行建模，而后使用 BFS 进行处理。但是一般来说，当题目中出现“最短”、“最少”、“最近”等关键词时，我们就可能需要考虑是否能够建立状态转移的模型，从而使用 BFS 进行求解。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/bfs/Sliding-Puzzle.gif" alt="" /></p>

	  ]]></description>
	</item>

	<item>
	  <title>动态规划(01)——从斐波那契到硬币找零</title>
	  <link>//dp(01)</link>
	  <author></author>
	  <pubDate>2020-12-23T15:50:25+00:00</pubDate>
	  <guid>//dp(01)</guid>
	  <description><![CDATA[
	     <p>动态规划是算法中一个非常有趣的 Topic，由于其具有非常强的灵活性，所以在面试时也会被经常提及到。动态规划问题我更喜欢称之为递推，因为其本质就是利用“历史数据”进行下一步的推导。</p>

<!---more--->

<h3 id="1-从斐波那契数列中找到-dp-模板">1. 从斐波那契数列中找到 DP 模板</h3>
<p>斐波那契数列虽然简单，但是却蕴含着求解动态规划问题最基本的“模板”。<strong>经典问题之所以是经典问题，就是因为它足够的简单，并且能够阐述事件的本质。</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 计算第 n 个斐波那契数
</span><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>99% 的程序员闭着眼睛都能写出上面的递归程序，但是如果我们运行这个程序的话，就会发现当 <code class="highlighter-rouge">n</code> 等于 50 的时候，程序需要花费几十秒的时间才能输出结果（有没有兄弟用 Apple M1 试下…）。为什么需要这么长的时间?我们以 <code class="highlighter-rouge">fib(10)</code> 为例，画出递归树:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/dp/1607063524499.png" alt="Alt text" /></p>

<p>如上图所示，仅部分的递归过程我们就进行了大量的重复计算，这些重复计算正是导致 <code class="highlighter-rouge">fib()</code> 函数运行缓慢的根本原因。为了解决这个问题，我们通常会使用缓存的方式避免同一个值计算多次。</p>

<p><strong>上文中的“重复计算”其实就是动态规划问题中的“重叠子问题”，通过缓存的方式避免同一个值被计算多次也有一个专门的名称，称之为“记忆化搜索”。</strong></p>

<p>现在，我们来通过缓存的方式来优化我们的 <code class="highlighter-rouge">fib()</code> 函数。原理非常简单，我们使用一个数组来保存已经计算过的结果值。在递归过程中，如果该值已经被计算了，直接返回，否则进入计算流程:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fibUseMemory</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">memory</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">memory</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">return</span> <span class="n">memory</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">fibUseMemory</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibUseMemory</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">memory</span><span class="p">);</span>
    <span class="n">memory</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当我们加入了记忆化搜索以后，计算结果秒出，因为我们将时间复杂度从 O(2^n) 优化到了 O(n) 级别。<strong>这就是求解动态规划问题的第一种方式: 自顶向下的记忆化搜索</strong>。这种方式常常作为思考动态规划问题的首要方向，有时候我们不能一眼或者短时间内找出递推关系式，那么不妨先使用记忆化搜索的方式给出一个可行解，然后再进一步地优化。</p>

<p>再来看自底向上的递推实现，斐波那契的数学表达式为: <code class="highlighter-rouge">f(x) = f(x-1) + f(x-2)</code>，对于递归实现而言，我们可以认为是“从左至右”的实现，例如如果我们要计算 <code class="highlighter-rouge">f(5)</code>，得先计算 <code class="highlighter-rouge">f(4)</code> 和 <code class="highlighter-rouge">f(3)</code>，结果由操作系统栈帧临时保存，最终再汇总结果。那么同样的，如果我们已知 <code class="highlighter-rouge">f(3)</code> 和 <code class="highlighter-rouge">f(4)</code> 的结果的话，就能够推导出 <code class="highlighter-rouge">f(5)</code> 的值，这种递推的方式其实就是动态规划。</p>

<p><strong>说白了，动态规划就是根据已有的数据，来推导出下一个结果的值。</strong>所以我们必须要明确值和值之间的关联关系。对于斐波那契数列而言，非常简单，毕竟推导式都告诉你了:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fibUseDP</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">memory</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">memory</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>       <span class="c1">// 边界情况处理
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>        <span class="c1">// 递推过程
</span>        <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">memory</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在，我们就可以总结出动态规划问题的解题“四部曲”了:</p>

<ol>
  <li>对于没有头绪的问题首先尝试“自顶向下”的递归实现，使用记忆化搜索的方式优化时间。同样地，“自顶向下”的思考也能够为我们找出递推关系式提供帮助。</li>
  <li>明确我们的题目是使用一维数组还是二维数组递推，这与题目中的变量数相关。然后确切的明白 <code class="highlighter-rouge">memory[i]</code> 或者是 <code class="highlighter-rouge">dp[i]</code> 到底表达了什么。</li>
  <li>明确 <code class="highlighter-rouge">memory[i]</code> 或者是 <code class="highlighter-rouge">dp[i]</code> 和之前数据的关联关系，这是最难的一步，也是动态规划问题灵活多变的根本原因。</li>
  <li>找到了关联关系以后，再处理一下边界情况即可。</li>
</ol>

<p>我们尝试按照上面的步骤来解决一道非常经典的问题: <a href="https://leetcode.com/problems/coin-change/">Coin Change</a>。给定一堆面额不同的硬币，每一种面额的硬币可以使用多次，现在问你如何用最少的硬币数量来凑成 <code class="highlighter-rouge">amount</code>。例如硬币面额有1块、2块和5块，凑够 11 块钱则最少需要3个硬币: 两个5块的，和1个1块的。</p>

<p>当我们什么思路都没有的时候可以先使用一些特定的实例来帮助我们打开思路。所以，我们假设硬币面额为 <code class="highlighter-rouge">[1, 2, 5]</code>，<code class="highlighter-rouge">amount</code> 为 36。</p>

<p>对于 36 块的总额以及三种面额的硬币，我们可以有 3 种方式去凑齐: 35 + 1，34 + 2，31 + 5。这样一来我们使用了一个硬币，换来了一个更小规模的问题，不断地递归下去，就能够得到所有解，然后我们在其中选出最小硬币数量的解即可。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/dp/1606892674971.png" alt="Alt text" /></p>

<p>递归树如上图所示，显然，这是一棵多叉树的遍历，多叉树的遍历模板是什么来着?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">child</span> <span class="n">in</span> <span class="n">node</span><span class="p">.</span><span class="n">childs</span>
        <span class="n">traversal</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>并且，遍历的过程中有许多重复的计算，需要使用记忆化搜索的方式来优化时间，再结合上面的遍历模板，答案就呼之欲出了:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">memorySearch</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">memory</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">memory</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="n">memory</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">coin</span><span class="o">:</span> <span class="n">coins</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">memorySearch</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">coin</span><span class="p">,</span> <span class="n">memory</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">sub</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">memory</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span> <span class="o">==</span> <span class="n">INT_MAX</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们重点关注一下下面的代码片段:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">coin</span><span class="o">:</span> <span class="n">coins</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">memorySearch</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">coin</span><span class="p">,</span> <span class="n">memory</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">sub</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于当前的 <code class="highlighter-rouge">amount</code> 值来说，我们需要把所有的硬币都试一遍，找到最小数量的那一枚硬币面额。如此一来，我们就能够明白递推公式了:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/dp/1606894340039.png" alt="Alt text" /></p>

<p>很好理解，对于总额度为 5 来说，我们能从 4 块钱凑 1 块达到，也可以从 3 块钱凑 2 块达到，同时可以直接掏出一枚 5 块的硬币，在这 3 种可能之间找出最小值即可。所以，<code class="highlighter-rouge">memory[i]</code> 就表示凑够金额为 <code class="highlighter-rouge">i</code> 所需要的最少硬币数量，边界情况当然是 <code class="highlighter-rouge">i == 0</code> 了，此时不需要任何一种硬币，所以为 0。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">coinChange</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">coins</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">coins</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>       <span class="c1">// 排序便于减枝
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">memory</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
    <span class="n">memory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                          <span class="c1">// 边界条件处理
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">coin</span><span class="o">:</span> <span class="n">coins</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">coin</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">coin</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">)</span>
                <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">coin</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">memory</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">memory</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其实，Coin Change 问题本质上就是 <a href="https://leetcode.com/problems/climbing-stairs/">Climbing Stairs</a> 的改版，Climbing Stairs 也就是经典的小青蛙跳台阶问题。如果把 Coin Change 的问题换成“使用这些硬币凑够<code class="highlighter-rouge">amount</code>一共有多少种凑法”的话，就是妥妥的小青蛙跳台阶的多叉树版本（小青蛙跳台阶是一个二叉树遍历问题）。</p>

<p>别说，leetcode 上还真有这样的问题: <a href="https://leetcode.com/problems/combination-sum-iv/">Combination Sum IV</a></p>

<blockquote>
  <p>给定一个 nums 数组，其中的元素可以使用任意多次，输出和为 target 的全部组合数量</p>
</blockquote>

<p>这和硬币找零问题几乎一模一样，只是换了一个问法而已。题解可见:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/blob/master/leetcode/dynamic-programming/377-Combination-Sum-IV.cpp</p>
</blockquote>

<h3 id="2-二维平面的小青蛙跳台阶问题">2. 二维平面的“小青蛙跳台阶”问题</h3>

<p>接下来我们将会看到，“小青蛙跳台阶”这一基本问题能玩儿出多少花样。</p>

<p><a href="https://leetcode.com/problems/unique-paths-ii/">Unique Paths II</a>，有一个机器人从一个二维平面的左上角出发，终点为右下角，机器人每次只能向下或者是向右移动，并且在该平面中存在“专刀机器人的剑”，入者必死，可怜的机器人必须要绕开这些 Sword。问机器人从起点到终点有多少条独特的路径。</p>

<p>既然机器人只能向右或者是向下移动，那么对于一个节点 <code class="highlighter-rouge">grid[i][j]</code> 而言，只有可能从上边或者是左边出现机器人的身影。而对于第 0 行的节点而言，机器人除非一路向右才有可能到达。同样的，第 0 列中的节点机器人必须一路向下才能到达。这种特殊情况就是我们在该题中需要处理的边界情况。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/dp/1606897302445.png" alt="Alt text" /></p>

<p>如上图所示，当我们分析完所有的特殊情况以后，代码的实现将会非常简单。<code class="highlighter-rouge">memory[i][j]</code> 则表示以当前节点为终点的独特的路径总条数。如果没有“专刀机器人的剑”或者是节点不在边界时，有:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>memory[i][j] <span class="o">=</span> memory[i][j-1] + memory[i-1][j]
</code></pre></div></div>

<p>完整实现代码可见:</p>
<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/blob/master/leetcode/dynamic-programming/063-Unique-Paths-II.cpp</p>
</blockquote>

<p>其实，Unique Paths 问题向我们揭露了另外一种非常典型的递推关系式: <strong>对于 memory[i][j] 而言，它的左节点(memory[i][j-1])、上节点(memory[i-1][j]) 以及左上节点(memory[i-1][j-1]) 都有极大的概率称为递推关系式中的一份子</strong>。除开 0-1背包 问题的递推关系以外，绝大多数的二维 DP 问题都能从这 3 个节点上找到正确的递推关系式。</p>

<p>例如 <a href="https://leetcode.com/problems/maximal-square/">Maximal Square</a> 这个问题，给定一个仅包含 ‘0’、’1’ 的二维数组，求出仅包含字符 ‘1’ 的最大正方形。此时，我们可以假定 <code class="highlighter-rouge">memory[i][j]</code> 表示以 <code class="highlighter-rouge">matrix[i][j]</code> 为<strong>右下角</strong>的最大正方形的<strong>边</strong>。当我们这样定义完二维数组的含义之后，分析起来就非常简单了。</p>

<p>如果 <code class="highlighter-rouge">memory[i][j]</code> 为 ‘0’，那么 <code class="highlighter-rouge">memory[i][j]</code> 就等于 0; 如果 <code class="highlighter-rouge">memory[i-1][j]</code>、<code class="highlighter-rouge">memory[i-1][j-1]</code>、 <code class="highlighter-rouge">memory[i][j-1]</code> 其中有一个为 ‘0’ 的话，<code class="highlighter-rouge">memory[i][j]</code> 都不能构成包含 ‘1’ 的正方形。所以，状态转移方程为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>memory[i][j] <span class="o">=</span> min<span class="o">(</span>memory[i-1][j], memory[i-1][j-1], memory[i][j-1]<span class="o">)</span> + 1
</code></pre></div></div>

<p>完整代码为:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">maximalSquare</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">memory</span><span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">));</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            
            <span class="c1">// 初始化第 0 行或第 0 列
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
            
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'1'</span><span class="p">)</span>
                <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            
            <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">*</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>再比如 <a href="https://leetcode.com/problems/edit-distance/">72. Edit Distance</a>，该问题同样可以将 <code class="highlighter-rouge">memory[i][j]</code> 的关系往左边、上边以及左上这 3 个节点的方向上面靠。当我们明确了某个 DP 问题是需要使用二维数组完成，并且又不是 0-1 背包问题的时候，大胆地去找这 3 个节点的“麻烦”。</p>

<p>这一类问题我比较喜欢称之为“Robot Path”，相似题目有:</p>

<ul>
  <li><a href="https://leetcode.com/problems/unique-paths/">062. Unique Paths</a></li>
  <li><a href="https://leetcode.com/problems/minimum-path-sum/">064. Minimum Path Sum</a></li>
  <li><a href="https://leetcode.com/problems/triangle/">120. Triangle</a></li>
  <li><a href="https://leetcode.com/problems/maximal-square/">221. Maximal Square</a></li>
  <li><a href="https://leetcode.com/problems/minimum-falling-path-sum/">931. Minimum Falling Path Sum</a></li>
  <li>……</li>
</ul>

<h3 id="3-小结">3. 小结</h3>

<p>不管是 <a href="https://leetcode.com/problems/coin-change/">Coin Change</a> 还是 <a href="https://leetcode.com/problems/unique-paths/">Unique Paths</a> 问题，本质上最核心的仍然是“小青蛙跳台阶”问题，从一个最基本的问题扩展到稍微复杂一些的问题。对这一类问题，有位老哥总结的非常之到位:</p>

<p>Statement</p>
<blockquote>
  <p>Given a target find minimum (maximum) cost / path / sum to reach the target.</p>
</blockquote>

<p>Approach</p>
<blockquote>
  <p>Choose minimum (maximum) path among all possible paths before the current state, then add value for the current state.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>routes[i] <span class="o">=</span> min<span class="o">(</span>routes[i-1], routes[i-2], ... , routes[i-k]<span class="o">)</span> + cost[i]
</code></pre></div></div>

<p>原文地址为:</p>

<blockquote>
  <p>https://leetcode.com/discuss/general-discussion/458695/Dynamic-Programming-Patterns</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>二叉树与递归: DP、回溯、DFS、BFS，一个通用的算法框架</title>
	  <link>//binary-tree-and-recursive</link>
	  <author></author>
	  <pubDate>2020-12-15T15:50:25+00:00</pubDate>
	  <guid>//binary-tree-and-recursive</guid>
	  <description><![CDATA[
	     <p>二叉树问题在算法领域是一个非常非常重要的话题，”遍历”这一 API 在非线性数据结构中有着举足轻重的地位，可以说 80% 的算法问题都是遍历问题。</p>

<!---more--->

<p>对于一棵二叉树的遍历，相信只要了解过二叉树的程序员都能够用递归的方式写出其前序遍历、中序遍历和后序遍历:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">TreeNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">;</span>

    <span class="c1">// 前序遍历
</span>    <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="c1">// 中序遍历
</span>    <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="c1">// 后序遍历
</span><span class="p">}</span>
</code></pre></div></div>

<p>我们可以使用“递归”这一神奇的机制非常轻松的完成二叉树的深度优先遍历。那么，如果使用递归，又该如何实现呢? 此时，我们就需要借助“栈”这一数据结构来完成。</p>

<p>由于我们在最开始的时候只有根节点，但是深度优先遍历却要求我们最先访问最底层的节点(中序和后序遍历)，并且还需要记录下沿途访问过的节点。而栈是一种先进后出的数据结构，和二叉树的深度优先遍历简直就是天生一对。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/tree/1606099448258.png" alt="" /></p>

<p>上图描述了使用栈实现的中序遍历过程，实际上，递归实现的中序遍历中，操作系统所创建栈帧和销毁栈帧的过程与之完全相同。具体的节点入栈和出栈细节上图已经给出，不再赘述，下面是实现过程:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">depthStack</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>

    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">curRoot</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">depthStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">curRoot</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">depthStack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        
        <span class="k">while</span> <span class="p">(</span><span class="n">curRoot</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">depthStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">curRoot</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="n">curRoot</span> <span class="o">=</span> <span class="n">curRoot</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">depthStack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">depthStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">depthStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="n">curRoot</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>之所以要使用栈来实现二叉树的中序遍历，是因为通过这个过程我们能够对二叉树的深度遍历过程更进一步地熟悉，从而进一步理解递归实现的深度优先遍历执行过程。</p>

<p>自顶向下的DP问题、回溯问题，甚至是归并排序问题，其实都是二叉树以及多叉树的遍历问题。以最经典的小青蛙跳台阶问题为例，当我们不使用记忆化搜索和递推来实现时，它是这个样子的:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">climbStairs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">climbStairs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们对上面的代码进行稍许的修改:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">climbStairs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">climbStairs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到，这个过程实际上就是一棵二叉树的后序遍历。当然，小青蛙跳台阶问题本质上就是斐波那契数列问题，也就是说，自顶向下地求解斐波那切数列其实也是二叉树的后序遍历。</p>

<p>再来看 leetcode 上 <a href="https://leetcode.com/problems/word-break/">139. Word Break</a> 这道 DP 问题，通过分析，我们可以得到这样的一棵树:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/tree/1606101980186.png" alt="" /></p>

<p>本质上就是一棵多叉树求解路径的问题，同样是一个深度优先遍历问题。</p>

<p>最后来看回溯问题中较为经典问题，求解全排列问题: <a href="https://leetcode.com/problems/permutations/">46. Permutations</a>。我们能够轻易地画出求解问题的过程和思路:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/tree/1606102283314.png" alt="" /></p>

<p>这还是一个多叉树深度优先遍历问题，将多叉树的每一条“路径”塞到结果中，就可以得到某一个数组的全排列。</p>

<p><strong>这些看似不同的问题中都隐藏了一个相同的问题: 二叉树与多叉树的深度优先遍历问题。</strong></p>

<h3 id="1-简单地二叉树遍历问题">1. 简单地二叉树遍历问题</h3>

<p>首先来看 <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">230. Kth Smallest Element in a BST</a> 这个问题，给定一棵二分搜索树(Binary Search Tree, BST)，求该树中第 k 小的元素。对于一棵 BST 而言，其中序遍历结果就是一个从小到大排序完成的数组。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/tree/1606111554881.png" alt="" /></p>

<p>也就是说，中序遍历结果的第一个元素就是第 1 小的元素，第二个元素就是第 2 小的元素，以此类推，第 k 个元素就是第 k 小的元素:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        
        <span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
        
        <span class="c1">// 中序遍历访问节点
</span>        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        
        <span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
    <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">kthSmallest</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">midorder_dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p><a href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a>，反转一棵二叉树，使得所有节点的左子节点变成右子节点，右子节点变成左子节点。据说是 Max Howell 未能加入 Google 的直接原因，不过这我是不相信的，个人更倾向于认为是 Max Howell 和 Google 在面试的内容产生了分歧: 反转二叉树有个锤子用? 能反转二叉树的人就能写出 Homebrew 了?</p>

<p>从题目描述中可以看到，需要反转某个节点的左、右子节点，那么必然地，我们得访问到左、右子节点，然后才能对其进行操作，所以这是一个后序遍历的问题。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">invertTree</span><span class="p">(</span><span class="k">struct</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">114. Flatten Binary Tree to Linked List</a>，题目要求将一棵二叉树展开成一个链表形式的树，如下所示:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input:
    1
   / <span class="se">\</span>
  2   5
 / <span class="se">\ </span>  <span class="se">\</span>
3   4   6

Output: 
1
 <span class="se">\</span>
  2
   <span class="se">\</span>
    3
     <span class="se">\</span>
      4
       <span class="se">\</span>
        5
         <span class="se">\</span>
          6
</code></pre></div></div>

<p>从结果上来看，是二叉树前序遍历所得到的结果，但是我们并不能使用前序遍历的方式来完成。这道题本质上和上面那道反转二叉树是一样的: 使用后序遍历的方式首先处理左、右子节点，再将结果返回给根节点。</p>

<p>首先使用临时变量来保存右子节点，然后断开当前节点与右子节点的连接，将左子节点套在右子节点上，再然后把使用临时变量存储的右子节点套在新的右子节点的最后一个右子节点上。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="n">flatten</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="n">flatten</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="c1">// 找到新的右子节点的最后一个右子节点
</span>    <span class="k">while</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-通过-dfs-结果恢复二叉树">2. 通过 DFS 结果恢复二叉树</h3>

<ul>
  <li><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></li>
  <li><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. Construct Binary Tree from Inorder and Postorder Traversal</a></li>
  <li><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. Construct Binary Tree from Preorder and Postorder Traversal</a></li>
</ul>

<p>上面的问题都是从 DFS 的结果中恢复一棵二叉树，不过通过前序遍历和后序遍历的结果所恢复的二叉树可能有多个，因为无法确切的计算出左子树和右子树到底有多少个元素。</p>

<p>以前序遍历和中序遍历结果恢复一棵二叉树为例，对于前序遍历结果而言，数组的第一个元素一定是根节点，根据该根节点我们就可以在中序遍历结果中找到哪些是左子树节点，哪些是右子树节点了。递归地执行这个过程，就能够构建出原有二叉树，如下图所示:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/tree/1606118277976.png" alt="" /></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">traverse</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preLeft</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preRight</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inLeft</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inRight</span><span class="p">,</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">inHashmap</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">preLeft</span> <span class="o">&gt;</span> <span class="n">preRight</span> <span class="o">||</span> <span class="n">inLeft</span> <span class="o">&gt;</span> <span class="n">inRight</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
        
        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="n">preLeft</span><span class="p">]);</span>
        
        <span class="kt">int</span> <span class="n">inRootIndex</span> <span class="o">=</span> <span class="n">inHashmap</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">leftNums</span> <span class="o">=</span> <span class="n">inRootIndex</span> <span class="o">-</span> <span class="n">inLeft</span><span class="p">;</span>

        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">preLeft</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preLeft</span> <span class="o">+</span> <span class="n">leftNums</span><span class="p">,</span> <span class="n">inorder</span><span class="p">,</span> <span class="n">inLeft</span><span class="p">,</span> <span class="n">inRootIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inHashmap</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">preLeft</span> <span class="o">+</span> <span class="n">leftNums</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preRight</span><span class="p">,</span> <span class="n">inorder</span><span class="p">,</span> <span class="n">inRootIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inRight</span><span class="p">,</span> <span class="n">inHashmap</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">inHashmap</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inorder</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">inHashmap</span><span class="p">[</span><span class="n">inorder</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">traverse</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">preorder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inorder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inHashmap</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>可以看到，恢复一棵二叉树的过程仍然是一个二叉树的遍历过程，很明显地，这是一个前序遍历过程。</p>

<h3 id="3-二叉树路径和问题">3. 二叉树路径和问题</h3>

<p>关于二叉树的路径和，例如求从根节点到叶子节点的最大加权路径和(<a href="https://leetcode.com/problems/path-sum/">112. Path Sum</a>)，输出所有根节点到叶子节点的路径(<a href="https://leetcode.com/problems/path-sum-ii/">113. Path Sum II</a>)等问题既可以认为是一个二叉树遍历问题，也可以认为是回溯问题，故不再赘述，可参考:</p>

<blockquote>
  <p><a href="https://github.com/SmartKeyerror/Snorlax/blob/master/algorithm/backtracking/backtracking.md#6-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%9B%9E%E6%BA%AF">二叉树中的回溯</a></p>
</blockquote>

<h3 id="4-二叉树层序遍历问题">4. 二叉树层序遍历问题</h3>

<p>相较于二叉树的深度优先遍历问题，二叉树的层序遍历要简单许多。二叉树的层序遍历又称之为广度优先遍历、宽度优先遍历，此时我们需要借助队列这一先进先出数据结构完成。当然，用栈也能够完成，只是不够直观而已，反正就是需要一个额外的空间进行节点存储。</p>

<p>层序遍历问题并不复杂，所以只给出 leetcode 上关于层序遍历一些问题:</p>

<ul>
  <li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></li>
  <li><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">103. Binary Tree Zigzag Level Order Traversal</a></li>
  <li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. Binary Tree Level Order Traversal II</a></li>
  <li><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">116. Populating Next Right Pointers in Each Node</a></li>
  <li><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">117. Populating Next Right Pointers in Each Node II</a></li>
  <li><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">515. Find Largest Value in Each Tree Row</a></li>
</ul>

<h3 id="4-小结">4. 小结</h3>

<p>对于二叉树的深度优先遍历，我们可以有这样的框架:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
    <span class="c1">// 前序遍历
</span>    <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="c1">// 中序遍历
</span>    <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="c1">// 后序遍历
</span><span class="p">}</span>
</code></pre></div></div>

<p>对于多叉树的遍历深度优先遍历，同样地:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">child</span><span class="o">:</span> <span class="n">TreeNode</span><span class="o">-&gt;</span><span class="n">childs</span><span class="p">)</span>
        <span class="n">traversal</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个通用的框架能够为我们解决自顶向下的 DP 问题，回溯问题，递归等问题提供一个方向，我们只需要理清问题中的一些细节之后，就可以使用这一“模板”进行解决。</p>

<p>leetcode 关于二叉树这一话题的全部题目:</p>

<blockquote>
  <p>https://leetcode.com/tag/tree/</p>
</blockquote>

<p>我个人对其中一些题目的解:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/tree/master/leetcode/tree
https://github.com/SmartKeyerror/Snorlax/tree/master/leetcode/binary-search-tree</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>回溯与剪枝: 《明日边缘》or《源代码》</title>
	  <link>//backtracking</link>
	  <author></author>
	  <pubDate>2020-11-13T07:50:25+00:00</pubDate>
	  <guid>//backtracking</guid>
	  <description><![CDATA[
	     <p>回溯法在 wikipedia 中被解释成一种“暴力搜索法”，相较“暴力”一词我更喜欢称之为“枚举”，枚举一个空间中所有的搜索路径。</p>

<!---more--->

<p>回溯法采用试错的思想，逐步地解决一个问题，就好像我们小时候玩儿的走迷宫一样。我们从一个点出发，选择迷宫中的一条路向前行进，当遇到死胡同时再回到当初进行选择的地方，再往下走，直到将整个迷宫搜索完毕或者是找到一条通往终点的路径。</p>

<p>人生是由多个选择所构成的，我们有时候会忍不住的去假设如果当初我们没有做那个选择现在会是怎么样。人生无法重来，但是回溯法却可以。</p>

<p>在具体的回溯算法实现中，有两个非常重要的事物：已选择的路径和下一次能够进行选择的路径。这也非常贴近现实，毕竟我们自身的存在就可以认为是“已选择的路径”，立足于当下，我们能够做出的所有选择就是剩余的选择路径。</p>

<p>回溯算法有一个非常通用的框架，具体表现为:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 其中 choices 表示我们能做出的选择，selected 表示已选择的路径
</span><span class="kt">void</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">vecotr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">choices</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">selected</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="n">choice</span> <span class="n">in</span> <span class="n">choices</span> <span class="p">{</span>
        <span class="c1">// 进行选择
</span>        <span class="n">selected</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">choice</span><span class="p">);</span>
        
        <span class="c1">// 继续前行
</span>        <span class="n">backtracking</span><span class="p">(</span><span class="n">choices</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>
        
        <span class="c1">// 撤销选择
</span>        <span class="n">selectd</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>下面使用一道非常经典的排列问题来更加具体的描述回溯法，题目如下:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>给定一个没有重复数字的序列，返回其所有可能的全排列

Example:
    Input: nums <span class="o">=</span> <span class="o">[</span>1,2,3]
    Output: <span class="o">[[</span>1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</code></pre></div></div>

<p>即求解给定数组中元素的所有排列，根据高中数学知识，n 个元素所有的排列个数为 n!，只不过题目需要输出所有的具体排列方式。</p>

<p>思考方式也比较简单，以 <code class="highlighter-rouge">[1, 2, 3]</code> 的全排列为例。首先我们先固定第一个元素，来看剩下的元素有哪些排列方式，很明显地，只有两种: <code class="highlighter-rouge">[2, 3]</code> 和 <code class="highlighter-rouge">[3, 2]</code>，所以以 1 开始的全部排列为 <code class="highlighter-rouge">[1, 2, 3]</code>, <code class="highlighter-rouge">[1, 3, 2]</code>。接着我们固定第二个元素，来看剩下的 <code class="highlighter-rouge">[1, 3]</code> 有哪些排列方式，答案是 <code class="highlighter-rouge">[1, 3]</code> 和 <code class="highlighter-rouge">[3, 1]</code>，因此以 2 为起始的全部排列为 <code class="highlighter-rouge">[2, 1, 3]</code> 和 <code class="highlighter-rouge">[2, 3, 1]</code>。以此类推，直到输出数组最后一个元素的全排列，整个搜索过程结束。</p>

<p>如果以一棵树来表示的话，就是下面的样子:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/permutation.png" alt="" /></p>

<p>左图中描述了确切的选择过程，而右图中则描述了选择以及回溯(撤销选择)的过程。现在，我们可以使用代码来解决这个全排列问题了。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>

    <span class="c1">// 保存每一个排列结果
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>

    <span class="c1">// 在每次的选择中，我们不能够再选择哪些已经选择过的元素了
</span>    <span class="c1">// 所以我们使用一个数组来记录已经选择过的元素索引
</span>    <span class="c1">// visted[i] = true 则表示第 i 个元素已经被选择
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visted</span><span class="p">;</span>

    <span class="c1">// 其中 selected 表示我们已经选择过的路径
</span>    <span class="kt">void</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">selected</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">selected</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">selected</span><span class="p">);</span>
            <span class="k">return</span> <span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">visted</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">continue</span><span class="p">;</span>
            
            <span class="c1">// 做出选择
</span>            <span class="n">selected</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">visted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

            <span class="n">backtracking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>   <span class="c1">// 怀揣着当前选择进行下一次选择
</span>
            <span class="c1">// 撤销刚才的选择
</span>            <span class="n">visted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">selected</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">;</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">permute</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

        <span class="c1">// 在最开始，没有元素被访问过, 所以全部初始化为 false
</span>        <span class="n">visted</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">selected</span><span class="p">;</span>
        <span class="n">backtracking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="1-组合问题">1. 组合问题</h3>

<p>除了排列问题以外，组合问题是回溯法的另外一处后花园。对于排列而言，需要元素的排列顺序，例如 <code class="highlighter-rouge">[1, 2, 3]</code> 和 <code class="highlighter-rouge">[1, 3, 2]</code> 属于不同的排列。而组合问题则不关心元素的排列顺序，<code class="highlighter-rouge">[1, 2]</code> 和 <code class="highlighter-rouge">[2, 1]</code> 为同一个组合。</p>

<p>在组合问题中，使用回溯法的整体框架与排列问题几乎一模一样，唯一有差别的就是我们<strong>如何定义剩余的可选路径</strong>。</p>

<p>leetcode 中的 <a href="https://leetcode.com/problems/combinations/">77. Combinations</a> 就是一道非常经典的组合问题。</p>

<blockquote>
  <p>给定两个整数 n 和 k，返回 1 …n 中所有可能的 k 个数的组合</p>
</blockquote>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/combination.png" alt="" /></p>

<p>可以看到，组合问题和排列问题唯一的差别就在于当我们选择了某一个元素之后，在这之前的所有元素均不可被选择，这是因为前面的元素一定已经生成了对应的组合。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>

    <span class="c1">// 从 start...n 中求解组合问题, selected为已选择路径
</span>    <span class="kt">void</span> <span class="nf">combination</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">selected</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">selected</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">selected</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">selected</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">selected</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>                  <span class="c1">// 选择
</span>            <span class="n">combination</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>
            <span class="n">selected</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>                    <span class="c1">// 撤销选择
</span>        <span class="p">}</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">combine</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">);</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">selected</span><span class="p">;</span>
        <span class="n">combination</span><span class="p">(</span><span class="n">n</span> <span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>注意到在 <code class="highlighter-rouge">for</code> 循环中我们并没有让 <code class="highlighter-rouge">i</code> 自增到 <code class="highlighter-rouge">n</code>，而是自增到 <code class="highlighter-rouge">n - (k - selected.size()) + 1</code>。这是因为当我们已经选择了 <code class="highlighter-rouge">selected.size()</code> 这么多个元素之后，还剩下 <code class="highlighter-rouge">k - selected.size()</code> 这么多个元素需要被选择。也就是说，在 <code class="highlighter-rouge">[i...n]</code> 之间必须要存在 <code class="highlighter-rouge">k - selected.size()</code> 这么多个元素，所以我们只需要自增到剩下的元素区间无法满足选取 <code class="highlighter-rouge">k - selected.size()</code> 这么多个元素数量即可。</p>

<h3 id="3-剪枝">3. 剪枝</h3>

<p>剪枝听起来是一个很高大上的技巧，但实际上剪枝的概念非常简单，就是让整个递归过程减少无效的计算。在上面的组合问题一解中，我们仅使变量 <code class="highlighter-rouge">i</code> 自增到 <code class="highlighter-rouge">n - (k - selected.size()) + 1</code>，剔除了许多无效的计算，这就是一种剪枝。</p>

<p>一个比较经典的剪枝问题就是求拥有重复元素的全排列问题，在 <a href="https://leetcode.com/problems/permutations-ii/">47. Permutations II</a> 有具体描述。</p>

<blockquote>
  <p>Input: nums = [1,1,2]
Output: [[1, 1, 2], [1, 2, 1], [2, 1, 1]]</p>
</blockquote>

<p>一种解决方案就是不管数组中有没有重复元素，按照原有的流程将所有的排列输出，然后再进行排序去重，这一定是一个可行解。但是，既然我们需要对结果进行排序，为什么不对原有的数组进行排序，然后在回溯的过程中进行去重呢?</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/047-permutations-II-Explain.png" alt="" /></p>

<p>如上图所示，我们首先对原有数组进行排序。而后在每一次选择时都去判断当前元素是否和前一个元素相同，以及在相同的条件下，前一个元素是否被使用。若结果为 <code class="highlighter-rouge">true</code>，将跳过当前元素。</p>

<p>因篇幅限制，这里不再贴源码，感兴趣的小伙伴可以移步:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/blob/master/leetcode/prune/047-Permutations-II.cpp</p>
</blockquote>

<p>同时，剪枝相关的话题整理在:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/tree/master/leetcode/prune</p>
</blockquote>

<h3 id="4-二维平面中的回溯">4. 二维平面中的回溯</h3>

<p>在前面的问题中回溯都在一维数组中进行，在二维数组中回溯法同样有效，并且能够解决的问题也更加有趣。例如 N-皇后问题，求解数独，以及我们开篇就提到的迷宫问题。</p>

<p>在 leetcode 中，关于二维平面中的回溯问题不是很多，以 <a href="https://leetcode.com/problems/word-search/">79. Word Search</a> 为例:</p>

<blockquote>
  <p>在一个 m * n 的字母板中，寻找是否存在某一个单词 word，字母和字母之间可以水平或者垂直连接。</p>
</blockquote>

<p>下面给出分析图示:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/search-string.png" alt="" /></p>

<p>选择树，或者说决策树与排列、组合问题并没有什么不同，只不过选择的方向固定为上、下、左、右。同时我们的 <code class="highlighter-rouge">visited</code> 数组也需要设置成一个二维数组。</p>

<p>题解:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/blob/master/leetcode/backtracking/079-Word-Search.cpp</p>
</blockquote>

<h3 id="5-flood-fill">5. Flood fill</h3>

<p>Flood fill 算法又称为漫水填充算法，在扫雷游戏中用于计算需要被清除的区域。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/Recursive_Flood_Fill_4_%28aka%29.gif" /></p>

<p>上图为 wikipedia 对 Flood fill 的 GIF 示例。其中白色部分我们需要对其进行着色，黑色部分为着色的边界，从中心点开始向下滴一滴墨水，墨水所散开的区域就是我们需要着色的区域。</p>

<p>在 <a href="https://leetcode.com/problems/number-of-islands/">200. Number of Islands</a> 该题中我们就可以使用 Flood fill 算法来完成。相较于排列和组合问题有着明显的递归终止条件，Flood fill 算法则需要确保所有选择过的元素的 4 个方向上的元素均被访问并标记过，除非遇到边界。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/island.png" alt="" /></p>

<p>题解:</p>
<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/blob/master/leetcode/depth-first-search/200-Number-of-Islands.cpp</p>
</blockquote>

<p>不过，Flood fill 严格意义上来来说应该是一种深度优先遍历(DFS)算法，但是说是回溯法的一种也没太大毛病。</p>

<h3 id="6-二叉树中的回溯">6. 二叉树中的回溯</h3>

<p>有时候我们会默认为回溯法的选择路径是一棵多叉树，而忽略了最基本的情况: 二叉树。相较于二叉树的遍历，回溯在其中的应用并不是很多，一个比较典型的问题就是输出二叉树从根节点到所有叶子节点的路径，例如:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/binary-paths.png" alt="" /></p>

<p>代码也非常简单:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">TreeNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">treePaths</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">selected</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">;</span>
    
    <span class="n">selected</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">selected</span><span class="p">);</span>
        <span class="n">selected</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="k">return</span> <span class="p">;</span>
    <span class="p">}</span>

    <span class="n">treePaths</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>
    <span class="n">treePaths</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>

    <span class="n">selected</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 <a href="https://leetcode.com/problems/path-sum-ii/">Path Sum II</a>，<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">Sum Root to Leaf Numbers</a>，<a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/">Smallest String Starting From Leaf</a> 这些问题中都涉及到了二叉树的回溯。</p>

<h3 id="7-小结">7. 小结</h3>

<p>回溯法是一种相当实用的算法，思想也非常简单，许多问题都可以使用回溯的方式来“暴力”解决，其中就包括数独、图着色、N-Queens 等非常有意思的问题。在具体的实现过程中，可以使用剪枝这一技巧来提高算法的运行效率，除去多余的、重复的、不必要的计算。</p>

<p>leetcode 关于回溯这一话题的全部题目:</p>

<blockquote>
  <p>https://leetcode.com/tag/backtracking/</p>
</blockquote>

<p>我个人对其中一些题目的解:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/tree/master/leetcode/backtracking
https://github.com/SmartKeyerror/Snorlax/tree/master/leetcode/prune</p>
</blockquote>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/forerver-maze.gif" alt="" /></p>


	  ]]></description>
	</item>


</channel>
</rss>
