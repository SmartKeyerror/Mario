<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description>Keep coding, Keep curiosity</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Golang中的interface</title>
	  <link>//Golang-interface</link>
	  <author></author>
	  <pubDate>2019-12-25T08:25:25+00:00</pubDate>
	  <guid>//Golang-interface</guid>
	  <description><![CDATA[
	     <p>Golang除了方便使用的协程以外，最令我感到惊讶的就是<code class="highlighter-rouge">interface</code>，接口。在其它语言中，接口承担的主要作用为解耦和协议，但是在Golang中，<code class="highlighter-rouge">interface</code>还作为一种”通用”类型广泛使用于标准库和第三方库中。</p>

<!---more--->

<h4 id="1-面向接口编程">1. 面向接口编程</h4>

<p>面向接口编程的核心就在于将接口和实现分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口编程而非面向实现编程，不依赖不稳定的实现细节，当实现发生变化时，上游系统可不做或者只需进行少量的修改，从而降低耦合性，提高拓展性。 换句话说，面向接口编程是一种可随时拔插替换的编程方法。</p>

<p>以图片存储服务为例，图片经过一系列的处理之后上传至阿里云OSS中保存。 以Java代码为例，为了代码复用，将其封装成一个类对外使用:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AliyunOssImageStore</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createBucketIfNotExist</span><span class="o">(</span><span class="n">string</span> <span class="n">bucketName</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="c1">// OSS通过bucket来划分整块OSS存储空间</span>
        <span class="c1">// 当所需要的bucket不存在时，进行创建，创建失败则抛出异常</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="n">String</span> <span class="nf">generateAccessToken</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 通过appKey以及appSecret生成access_token, 内部方法</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">uploadToOss</span><span class="o">(</span><span class="n">Image</span> <span class="n">image</span><span class="o">,</span> <span class="n">string</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 将图片上传至oss，返回图片URL地址</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 使用</span>
<span class="kd">class</span> <span class="nc">OssProcess</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">bucketName</span> <span class="o">=</span> <span class="s">"user_thumbnail_image"</span><span class="o">;</span>
        <span class="n">AliyunOssImageStore</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AliyunOssImageStore</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">createBucketIfNotExist</span><span class="o">(</span><span class="n">bucketName</span><span class="o">);</span>
        <span class="n">Image</span> <span class="n">image</span> <span class="o">=</span> <span class="o">...</span> <span class="c1">// 生成图片</span>
        <span class="n">store</span><span class="o">.</span><span class="na">uploadToOss</span><span class="o">(</span><span class="n">image</span><span class="o">,</span> <span class="n">bucketName</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">AliyunOssImageStore</code>就是一个具体的实现类，实现了将图片上传至阿里云OSS的功能，在绝大多数时候，代码都能完好的工作。现在由于采购部门不满阿里云的价格，想要更换图片存储供应商，比如七牛。现在开发人员需要添加<code class="highlighter-rouge">QiniuImageStore</code>，并替换掉原有的实现方式，如此一来，必将会涉及到大面积的代码改动，包括业务代码以及重新编写测试用例。</p>

<p>更换一个OSS服务就需要大面积的更改业务代码，违反了开放-封闭原则，从而引入了额外的工作量以及风险，上游系统直接依赖具体的实现是不妥当的，因为具体的实现很有可能发生变化，一旦发生变化，波及的范围可能是整个系统。</p>

<p>解决该问题的一种方式是添加代理类，即在业务代码和具体实现之间额外添加一层抽象，或者说函数，假设叫<code class="highlighter-rouge">imageStoreProxy</code>。业务代码调用<code class="highlighter-rouge">imageStoreProxy</code>方法，而该方法调用具体的OSS实现，当OSS实现发生变动时，只需修改<code class="highlighter-rouge">imageStoreProxy</code>一处即可。但是这么做的后果就是降低了系统的灵活性并增加了系统的复杂度，<code class="highlighter-rouge">imageStoreProxy</code>需要满足上游系统所有的需求，该方法到后期将会变得非常臃肿而难以维护，最可能出现的情况就是该方法存在乱七八糟的<code class="highlighter-rouge">if-else</code>。</p>

<p>一个更好的方式就是使用接口，上游系统依赖接口，具体实现根据接口定义的方法进行实现，并在运行时选择具体的实现。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ImageStore</span> <span class="o">{</span>
    <span class="n">String</span> <span class="nf">upload</span><span class="o">(</span><span class="n">Image</span> <span class="n">image</span><span class="o">,</span> <span class="n">String</span> <span class="n">bucket</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AliyunOssImageStore</span> <span class="kd">implements</span> <span class="n">ImageStore</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">upload</span><span class="o">(</span><span class="n">Image</span> <span class="n">image</span><span class="o">,</span> <span class="n">String</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 阿里云OSS的具体实现</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">QiniuImageStore</span> <span class="kd">implements</span> <span class="n">ImageStore</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">upload</span><span class="o">(</span><span class="n">Image</span> <span class="n">image</span><span class="o">,</span> <span class="n">String</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 七牛云的具体实现</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 使用</span>
<span class="kd">class</span> <span class="nc">OssProcess</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ImageStore</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AliyunOssImageStore</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">upload</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span> <span class="c1">// 使用阿里云OSS</span>
        
        <span class="n">ImageStore</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QiniuImageStore</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">upload</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span> <span class="c1">// 使用七牛云</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>合理的使用接口可以完全屏蔽具体的实现细节，当具体实现发生变化时，上游系统只需改动少量的代码即可适应该变化。 例如底层数据存储，MySQL与MongoDB在实现上完全不同，数据的CRUD有着非常大的区别，但是通过定义合理的接口，再根据接口封装MySQL与MongoDB的具体实现，上游系统则可以完全忽略其细节的区别，只关注自身的业务逻辑，从而实现耦合的解除。</p>

<p>常见ORM就是做的，例如Python中的<code class="highlighter-rouge">SQLAlchemy</code>，只需在配置文件或者是定义文件中进行少量的修改，即可实现底层数据存储应用的替换。</p>

<h4 id="2-作为接口定义的interface">2. 作为接口定义的interface</h4>

<p>Golang中的<code class="highlighter-rouge">interface</code>承担的主要作用之一就是解耦与多态，与Java中的接口没有什么区别，只是在语法格式上不同而已。Golang中的接口实现不需要显式地使用<code class="highlighter-rouge">implements</code>关键字，某个类型只需要实现了接口中的所有方法，就说该类型实现了该接口。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">OperationLog</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Timestamp</span><span class="x"> </span><span class="kt">int32</span><span class="x">    </span><span class="c">// 时间戳</span><span class="x">
	</span><span class="n">Operation</span><span class="x"> </span><span class="kt">string</span><span class="x">   </span><span class="c">// 操作类型, create/update/delete</span><span class="x">
	</span><span class="c">// Other need fields</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">OperationLogService</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">InsertOne</span><span class="p">(</span><span class="n">log</span><span class="x"> </span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x">      </span><span class="c">// 单个日志记录</span><span class="x">
	</span><span class="n">InsertMany</span><span class="p">(</span><span class="n">logs</span><span class="x"> </span><span class="p">[]</span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x">  </span><span class="c">// 批量日志记录</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">ElasticLogService</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">EsClient</span><span class="x"> </span><span class="o">*</span><span class="n">ElasticClient</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">svc</span><span class="x"> </span><span class="o">*</span><span class="n">ElasticLogService</span><span class="p">)</span><span class="x"> </span><span class="n">InsertOne</span><span class="p">(</span><span class="n">log</span><span class="x"> </span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">svc</span><span class="o">.</span><span class="n">EsClient</span><span class="o">.</span><span class="n">PostOne</span><span class="p">(</span><span class="c">/*参数省略*/</span><span class="p">)</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">svc</span><span class="x"> </span><span class="o">*</span><span class="n">ElasticLogService</span><span class="p">)</span><span class="x"> </span><span class="n">InsertMany</span><span class="p">(</span><span class="n">logs</span><span class="x"> </span><span class="p">[]</span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">svc</span><span class="o">.</span><span class="n">EsClient</span><span class="o">.</span><span class="n">PostMany</span><span class="p">(</span><span class="c">/*参数省略*/</span><span class="p">)</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">MySQLLogService</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Db</span><span class="x"> </span><span class="o">*</span><span class="n">MySQLClient</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">svc</span><span class="x"> </span><span class="o">*</span><span class="n">MySQLLogService</span><span class="p">)</span><span class="x"> </span><span class="n">InsertOne</span><span class="p">(</span><span class="n">log</span><span class="x"> </span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">svc</span><span class="o">.</span><span class="n">Db</span><span class="o">.</span><span class="n">InsertToLogTable</span><span class="p">(</span><span class="c">/*参数省略*/</span><span class="p">)</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">svc</span><span class="x"> </span><span class="o">*</span><span class="n">MySQLLogService</span><span class="p">)</span><span class="x"> </span><span class="n">InsertMany</span><span class="p">(</span><span class="n">logs</span><span class="x"> </span><span class="p">[]</span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">svc</span><span class="o">.</span><span class="n">Db</span><span class="o">.</span><span class="n">InsertManyToLogTable</span><span class="p">(</span><span class="c">/*参数省略*/</span><span class="p">)</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">var</span><span class="x"> </span><span class="n">logService</span><span class="x"> </span><span class="n">OperationLogService</span><span class="x">
	</span><span class="c">// 使用MySQL作为data storage</span><span class="x">
	</span><span class="n">logService</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">ElasticLogService</span><span class="p">{</span><span class="c">/*...*/</span><span class="p">}</span><span class="x">
	</span><span class="n">logService</span><span class="o">.</span><span class="n">InsertOne</span><span class="p">(</span><span class="c">/*...*/</span><span class="p">)</span><span class="x">

	</span><span class="c">// 使用ES作为data storage</span><span class="x">
	</span><span class="n">logService</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">MySQLLogService</span><span class="p">{</span><span class="c">/*...*/</span><span class="p">}</span><span class="x">
	</span><span class="n">logService</span><span class="o">.</span><span class="n">InsertOne</span><span class="p">(</span><span class="c">/*...*/</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>这是一个简单的操作日志服务demo，可以看到，操作日志具体的实现有Elasticsearch以及MySQL两种方式，而这两种DB对数据的CURD有着非常大的差异，前者使用http API，而后者则采用SQL语句。由于系统本身的复杂性既需要存储容量大、支持全局搜索但数据易失的ES，又需要存储容量有限、不支持全局搜索但数据持久化要求程度高的MySQL。</p>

<p>在有了接口对相关方法进行强约束以后，<code class="highlighter-rouge">ElasticLogService</code>以及<code class="highlighter-rouge">MySQLLogService</code>可以无差别的对外提供服务，需要切换服务时，只需进行非常小的改动即可满足需求。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/golang/interface/log_service.png" alt="" /></p>

<h4 id="3-作为类型的interface">3. 作为类型的interface</h4>

<p>当使用</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">MyInterface</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{}</span><span class="x">
</span></code></pre></div></div>

<p>时，我们定义了一个接口，当接口中不存在任何方法时，称之为empty interface，通常写做<code class="highlighter-rouge">interface{}</code>。由于Golang并没有显式的<code class="highlighter-rouge">implements</code>关键字，而所有的类型至少包含零个个方法，所以Golang中所有的类型都隐式地实现了<code class="highlighter-rouge">interface{}</code>，也就意味着，当我们定义如下方法时:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">DoSomething</span><span class="p">(</span><span class="n">v</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>函数将能够接收任意的数据类型，不管是<code class="highlighter-rouge">int</code>还是<code class="highlighter-rouge">int64</code>，或者是自定义的结构体。以內建函数<code class="highlighter-rouge">Printf</code>为例，其原型为:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">Printf</span><span class="p">(</span><span class="n">format</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">a</span><span class="x"> </span><span class="o">...</span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">(</span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>其中的<code class="highlighter-rouge">a</code>即为任意类型的任意数量的参数，如</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"human eat %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">food</span><span class="p">)</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"The T-shirt price is %.2f, %s"</span><span class="p">,</span><span class="x"> </span><span class="m">9.15</span><span class="p">,</span><span class="x"> </span><span class="s">"nine fifteen"</span><span class="p">)</span><span class="x">
</span></code></pre></div></div>

<p>回到<code class="highlighter-rouge">DoSomething</code>方法，在函数内部，<code class="highlighter-rouge">v</code>的类型是什么?假如传入的参数类型为<code class="highlighter-rouge">int</code>，<code class="highlighter-rouge">v</code>的类型是否就是<code class="highlighter-rouge">int</code>?答案是<code class="highlighter-rouge">interface{}</code>，不管传入的参数是什么类型，Go都会在必要时对其进行类型转换，转换成<code class="highlighter-rouge">interface{}</code>类型，而<code class="highlighter-rouge">interface{}</code>类型，是有值的。</p>

<p>接口的值分为两部分，一个指向底层方法表的指针，和指向保存着具体值的指针。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">MyInterface</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">PrintSelf</span><span class="p">()</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">MyInt</span><span class="x"> </span><span class="kt">int</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">this</span><span class="x"> </span><span class="n">MyInt</span><span class="p">)</span><span class="x"> </span><span class="n">PrintSelf</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"The value is: %d"</span><span class="p">,</span><span class="x"> </span><span class="n">this</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">s</span><span class="x"> </span><span class="n">MyInterface</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>此时<code class="highlighter-rouge">s</code>无具体的类型，也无具体的值，两个指针均指向nil:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/golang/interface/nil-interface.png" alt="" /></p>

<p>当执行:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">MyInt</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="x">
</span><span class="n">s</span><span class="o">.</span><span class="n">PrintSelf</span><span class="p">()</span><span class="x">
</span></code></pre></div></div>

<p>时, <code class="highlighter-rouge">s</code>拥了的具体的类型和确切的值:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/golang/interface/not%20nil%20interface.png" alt="" /></p>

<p>虽然<code class="highlighter-rouge">interface{}</code>作为参数时可以接收任何类型的参数，但是并不代表参数的类型是任意类型，变量在运行时的某一时刻，永远有一个具体的类型。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">DoSomething</span><span class="p">(</span><span class="n">v</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>在<code class="highlighter-rouge">DoSomething</code>方法内部，如果想要获取变量<code class="highlighter-rouge">v</code>的类型，可以使用类型分支(<code class="highlighter-rouge">switch-case</code>)来进行类型检查，也可以使用反射直接获取变量类型:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">DoSomething</span><span class="p">(</span><span class="n">v</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="c">// 使用类型分支</span><span class="x">
	</span><span class="k">switch</span><span class="x"> </span><span class="n">v</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">case</span><span class="x"> </span><span class="no">nil</span><span class="o">:</span><span class="x">
		</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"nil"</span><span class="p">)</span><span class="x">
	</span><span class="k">case</span><span class="x"> </span><span class="kt">string</span><span class="o">:</span><span class="x">
		</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"string"</span><span class="p">)</span><span class="x">
	</span><span class="k">case</span><span class="x"> </span><span class="kt">int</span><span class="o">:</span><span class="x">
		</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"int"</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	
	</span><span class="c">// 使用反射</span><span class="x">
	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"v'type is: %T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">v</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<h4 id="4-作为契约协议的interface">4. 作为契约(协议)的interface</h4>

<p>Golang语言本身并不支持泛型，尽管函数参数可以使用<code class="highlighter-rouge">interface{}</code>来接收任意类型的变量，但是对于<code class="highlighter-rouge">slice</code>而言，我们无法定义一个<code class="highlighter-rouge">[]interface{}</code>来接收任意类型的<code class="highlighter-rouge">[]T</code>，原因在于<code class="highlighter-rouge">T</code>和<code class="highlighter-rouge">interface{}</code>在存储空间中有着截然不同的表现形式。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">PrintSlice</span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="p">[]</span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">v</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">s</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">var</span><span class="x"> </span><span class="n">s</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="m">10</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">s</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="x"> </span><span class="n">i</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="n">PrintSlice</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>在编译时期就会抛出异常:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cannot use s <span class="o">(</span><span class="nb">type</span> <span class="o">[]</span>int<span class="o">)</span> as <span class="nb">type</span> <span class="o">[]</span>interface <span class="o">{}</span> <span class="k">in </span>argument to PrintSlice
</code></pre></div></div>

<p>尽然可以通过代码将<code class="highlighter-rouge">[]T</code>转换成<code class="highlighter-rouge">[]interface{}</code>，但是会带来一些效率上的损耗，并且很丑陋。解决此类问题的通用方法就是使用<code class="highlighter-rouge">interface</code>，如<code class="highlighter-rouge">sort.Interface</code>。</p>

<p>sort包提供了针对任意类型序列根据任意排序函数原地排序的功能，使用<code class="highlighter-rouge">sort.Interface</code>接口来指定通用排序算法和每个具体类型之间的协议。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">Interface</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Len</span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="x">            </span><span class="c">// 获取集合中元素个数的方法</span><span class="x">
	</span><span class="n">Less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">bool</span><span class="x">  </span><span class="c">// 排序的依据</span><span class="x">
	</span><span class="n">Swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x">       </span><span class="c">// 如何在集合中交换两个元素</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>简单地来说，只要类型实现了<code class="highlighter-rouge">sort.Interface</code>接口，就可以使用Golang内部提供的排序算法(根据元素排布动态地选择排序方式)，而无需自行实现。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">Employee</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Name</span><span class="x"> </span><span class="kt">string</span><span class="x">
	</span><span class="n">Salary</span><span class="x"> </span><span class="kt">int</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">Employees</span><span class="x"> </span><span class="p">[]</span><span class="n">Employee</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">em</span><span class="x"> </span><span class="n">Employees</span><span class="p">)</span><span class="x"> </span><span class="n">Len</span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">em</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">em</span><span class="x"> </span><span class="n">Employees</span><span class="p">)</span><span class="x"> </span><span class="n">Less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">bool</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Salary</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">Salary</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">em</span><span class="x"> </span><span class="n">Employees</span><span class="p">)</span><span class="x"> </span><span class="n">Swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">em</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">employees</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">Employees</span><span class="p">{</span><span class="x">
		</span><span class="n">Employee</span><span class="p">{</span><span class="s">"smart"</span><span class="p">,</span><span class="x"> </span><span class="m">5000</span><span class="p">},</span><span class="x">
		</span><span class="n">Employee</span><span class="p">{</span><span class="s">"Aelam"</span><span class="p">,</span><span class="x"> </span><span class="m">4500</span><span class="p">},</span><span class="x">
		</span><span class="n">Employee</span><span class="p">{</span><span class="s">"Lin"</span><span class="p">,</span><span class="x"> </span><span class="m">8500</span><span class="p">},</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="n">sort</span><span class="o">.</span><span class="n">Sort</span><span class="p">(</span><span class="n">employees</span><span class="p">)</span><span class="x">
	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">employees</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p><code class="highlighter-rouge">sort.Sort</code>接收一个<code class="highlighter-rouge">sort.Interface</code>类型参数，而<code class="highlighter-rouge">Employees</code>实现了该接口，故在<code class="highlighter-rouge">sort.Sort</code>内部，可以完全不用管<code class="highlighter-rouge">Employees</code>的具体类型是什么，只需调用接口中定义好的方法，是接口和实现类型之间的契约。</p>

	  ]]></description>
	</item>


</channel>
</rss>
