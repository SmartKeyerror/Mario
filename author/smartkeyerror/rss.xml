<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>数据变更操作日志设计</title>
	  <link>//change-log-system-design</link>
	  <author></author>
	  <pubDate>2019-08-10T21:39:25+00:00</pubDate>
	  <guid>//change-log-system-design</guid>
	  <description><![CDATA[
	     <p>当系统的某些行为涉及到资金与资产的数据变更时，常常会为其增加操作日志， 便于后续的问题排查。 例如红包的使用明细， 银行转账的详细记录等等。 操作日志记录这个需求看起来很简单， 但是深挖下去， 依然能找到很有趣的东西。</p>

<!---more--->

<h4 id="1-需求">1. 需求</h4>
<p>既然是操作日志， 势必要记录<strong>谁对什么进行了怎样的操作</strong>， 抽象出来的字段就有<code class="highlighter-rouge">operator</code>(操作人)， <code class="highlighter-rouge">action</code>(创建、修改等行为)， <code class="highlighter-rouge">entry</code>(实体, 通常会用实体id来代替)。</p>

<p>MySQL-binlog的日志格式有<code class="highlighter-rouge">FULL</code>和<code class="highlighter-rouge">MINIMAL</code>两种， 前者记录了所有的字段， 后者只记录了更新的部分字段。 那么对于操作日志而言， 同样需要考虑是记录更新前后的所有数据字段， 还是只记录更新的字段。 操作日志的数据当然是越详细越好， 既然都要做这个需求了， 那就一步到位。</p>

<p>所以说， 本篇文章的日志格式即为数据库数据的增量版， 并且在原有数据字段上进行稍许拓展， 进行更加详细的记录。 也可以认为这就是记录了所有的数据版本库， 此时添加一个版本号即可。</p>

<h4 id="2-实现">2. 实现</h4>
<p>理论上来讲实现有两种， 一种是业务层面实现， 一种是使用日志解析工具来解析二进制日志， 但是该实现方式非常依赖具体的存储实现， 像MySQL和Oracle的解析策略是不一样的， 如果使用了MongoDB作为主库存储， 数据文件解析起来就更费劲了。</p>

<p>从项目维护的角度来看， 业务层实现在编码完成之后， 几乎不需要花太多的精力维护。 但是日志解析或者是数据文件解析工具， 却需要花大量的人力和时间来维护(看看<code class="highlighter-rouge">canal</code>)。</p>

<p>从易拓展的角度来看， 业务层的实现只需要稍加抽象， 就可以随意的更换或者添加数据存储源。 而日志分析的实现如果需要更换数据源的话， 迁移的工作量可能相当庞大。</p>

<p>从效率的角度来看， 业务层的实现效率确实会低于日志解析的实现。</p>

<p>综上考虑， 业务层实现是最佳的方式， 方便维护， 方便拓展， 在效率上虽然会对原有系统造成影响， 但是可以通过其它的方式进行补偿。</p>

<h4 id="3-实现细节">3. 实现细节</h4>

<p>在具体的实现之前， 首先来看一下常见Web请求的基本流程， 当然， 这里只针对创建、修改和删除操作:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/operation-log/data-stream.png" alt="" /></p>

<p>当对创建请求进行操作日志记录时， 完全可以将经过表单验证以及逻辑处理后的数据直接写入到日志记录库， 并添加一些附属信息， 如操作人， 操作的动作(create)， 来源IP等等。</p>

<p>但是对于更新操作呢? 通常只会进行部分字段的更新， 而后直接使用</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">update</span> <span class="p">...</span> <span class="k">set</span> <span class="n">field</span> <span class="o">=</span> <span class="n">value</span> <span class="k">where</span> <span class="p">...;</span>
</code></pre></div></div>

<p>进行部分字段或者是批量更新。 但是为了记录更新后的完整数据， 那么就需要在更新后再将数据取出， 添加附属信息， 并插入日志记录库。 如此一来相比原来，多了一次查询操作。</p>

<p>如果不使用<code class="highlighter-rouge">update</code>语句， 使用<code class="highlighter-rouge">instance.save</code>方式呢? 即先将数据取出， 而后更新数据， 将更新的数据写回DB并插入操作日志。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/operation-log/get-and-update.png" alt="" /></p>

<p>在使用ORM的应用中， 这样的代码其实很常见， 一个最大的问题就是并发时的数据问题， 先更新的语句可能会覆盖掉另外一条后更新的语句， 导致数据混乱。</p>

<p>原因就在于取出数据-更新数据不是一个原子性的操作， 底层的数据库因为并发执行导致多条语句的执行顺序并不受程序控制。 所以我们要么寻找一种能够原子性执行的方式， 要么对数据添加行锁。 首先来看行锁的方式:</p>

<p>使用<code class="highlighter-rouge">select for update</code>对数据添加行锁， 在一个事务内， 只能由当前事务对其进行更新，  这样一来就不会有并发问题了。 但是这种方式相比于第一种方式， 额外的增加了行锁的持有时间， 在大量的并发更新时， 很有可能产生雪崩效应。</p>

<p>如果使用版本控制的乐观锁实现， 虽然也可以达到目的， 但是在大量并发的情况下可能会导致许多的更新都会失败， 而后全部进行重试流程， 导致恶性循环。</p>

<h4 id="4-事务隔离">4. 事务隔离</h4>

<p>在上面的讨论中， 不管是先更新， 还是先取出数据再更新， 都面临着同一个问题: 并发。 并发导致了SQL语句并不会向我们预期的那样执行， 前脚取出的数据可能后脚就被更新了。 所以我们需要一个机制来协助我们对抗并发， 事务。</p>

<p>单纯的事务仅具有原子性， 即要么全部成功， 要么全部失败的特性。 想要满足我们的需求还需要一定的事务隔离级别。</p>

<p><code class="highlighter-rouge">REPEATABLE READ</code>该事务隔离级别保证了在同一个事务内， 所读取到的数据不受其它事务语句的影响，  同样也是MySQL默认的事务隔离级别。</p>

<p>所以不管是先更新还是先取数据， 只要在同一个事务内执行， 就不会存在数据污染问题， 保证了数据的准确与完整性。</p>

<h4 id="5-aop的实现">5. AOP的实现</h4>
<p>面向切面编程更进一步地理解其实就是函数式编程， 纵观Spring Boot AOP以及Python中的装饰器， 都是函数的注册与调用， 只是语言间的具体实现不同而已。 Python存在<code class="highlighter-rouge">@</code>语法糖， 更加的灵活和方便。 而对于Golang和Java而言， 就需要自己进一步的进行函数封装和调用了。</p>

<p>包括像<code class="highlighter-rouge">hook</code>(钩子)一类的技术实现， 最终也是函数的注册与调用。 比如Django中的<code class="highlighter-rouge">singal</code>(信号量)， 虽然说是发布-订阅模式， 但是本质仍是函数的调用。 只不过没有把具体的逻辑写在一个地方， 而是使用某种其它方式进行解耦了而已。</p>

<p>所以， 写一个简单的AOP是一件非常easy的事情， 处理好异常和重试机制就好。</p>

<h4 id="6-日志存储源">6. 日志存储源</h4>

<p>一个系统中对数据处理优先程度是不同的， 类似于转账记录、红包使用记录等数据， 必须进行完备的数据持久化， 并且能够在灾难时进行迅速恢复。 此时可使用可靠性较强的关系型数据库， 如MySQL， PG等。</p>

<p>当数据的要求较低， 并且数量比较庞大时， 可采用Elasticsearch进行存储和查询。</p>

<p>那么业务层在具体实现时， 就需要能够支持多种日志存储源， 此时面向接口编程又是最佳的选择。</p>

<h4 id="7-持续优化">7. 持续优化</h4>

<p>前面提到了由于需要记录数据操作日志的原因， 需要在更新、删除等操作后多一次额外的数据查询， 并且需要将完整的日志数据持久化至日志存储源， 相当于多了两次网络传输。</p>

<p>如何将这两次网络传输所花费的时间降至最低， 是本小结要讨论的内容。</p>

<p>数据库数据组织形式分为聚集索引和非聚集索引， 聚集索引的组织方式使得B+Tree的叶子节点即数据， 而非聚集索引的叶子节点仍然是索引节点， 需要多一个I/O操作找到该索引节点的数据节点。 所以说， 使用主键查询是非常快的。</p>

<p>对于常见的更新操作， 通常不会使用主键来作为查找条件， 这是由业务系统所决定的。 所以说如果使用<code class="highlighter-rouge">更新-查询</code>的方式， 无法使用主键进行查询来提高系统效率。 相反， 使用<code class="highlighter-rouge">查询-更新</code>的方式却可以。 查询时使用非聚集索引进行查询， 而后使用主键来进行数据定位和更新。</p>

<p>日志持久化可使用消息队列完成， 重试机制可使用消息队列本身携带的重试实现， 或者是对其进行封装， 自行实现。</p>

<h4 id="8-批量更新问题">8. 批量更新问题</h4>
<p>如果需要更新的行数不止一条， 而是有很多条时又该如何处理? 取出数据后遍历更新并生成操作日志吗?</p>

<p>在业务端写SQL一个比较忌讳的事情就是在for循环中对数据库进行操作， 如此一来必定会有N次网络传输， 跑起来的效率令人发指。</p>

<p>可以采用<code class="highlighter-rouge">查询-业务端组装操作日志-更新</code>的方式完成， 伪代码如下:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 开启事务</span>
<span class="n">begin</span>

<span class="n">result_list</span> <span class="o">=</span> <span class="n">Model</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="c"># 生成批量日志</span>
<span class="n">log_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">result_list</span><span class="p">:</span>
    <span class="n">ins_dict</span> <span class="o">=</span> <span class="n">Serialize</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="c"># 填充ip, 操作人等信息</span>
    <span class="n">log_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ins_dict</span><span class="p">)</span>

<span class="c"># 对多条数据进行更新</span>
<span class="n">Model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="n">commit</span> <span class="ow">or</span> <span class="n">rollback</span>

<span class="c"># 事务成功提交后将日志提交至存储层</span>
</code></pre></div></div>

<h4 id="9-小结">9. 小结</h4>

<p>记录操作日志这个需求看起来很小， 但是仔细的审视每一个操作内的细节， 会发现这真是一个有趣的需求。 涉及了数据库事务， 事务隔离， 索引， NoSQL与搜索引擎， 消息队列， 等等技术细节。</p>

	  ]]></description>
	</item>

	<item>
	  <title>那些有趣的数据结构与算法(05)--限流</title>
	  <link>//limits</link>
	  <author></author>
	  <pubDate>2019-07-20T21:54:55+00:00</pubDate>
	  <guid>//limits</guid>
	  <description><![CDATA[
	     <p>有时候限流也可以称为防刷， 这两者的界定并不是很明显， 常用的限流算法包括固定窗口， 滑动窗口， 漏桶以及令牌桶算法， 它们都有各自的优势与最适合的使用场景， 算法不分好坏， 之分场景。</p>

<!---more--->

<h4 id="1-固定窗口">1. 固定窗口</h4>
<p>固定窗口属于最简单但是也最容易出现问题的限流策略， 假设某接口限制请求频率为<code class="highlighter-rouge">10000/minute</code>， 则统计一分钟内接口请求的总次数， 若次数大于10000， 则请求失败， 开始限流， 直到下一个一分钟开始。</p>

<p>使用Redis可以非常轻松的实现该功能:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 该功能可用Lua优化，详见Lua模块</span>
<span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span>
<span class="n">redis</span> <span class="o">=</span> <span class="n">Redis</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">6379</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">hit_user_access</span><span class="p">(</span><span class="n">api</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">redis_key</span> <span class="o">=</span> <span class="s">"restrict_access:"</span><span class="o">+</span><span class="n">api</span>
        <span class="n">access_number</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="n">redis_key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">access_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">redis</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">redis_key</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">access_number</span> <span class="o">&gt;</span> <span class="n">MAX_ACCESS_NUMBER</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c"># 日记记录</span>
        <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</code></pre></div></div>

<p>借助于Redis的expire-key功能来实现”当前一分钟”和”下一个一分钟”， 若键过期， 则重新进行计数， 表示下一个一分钟开始了。</p>

<p>固定窗口用来做小流量的防刷比较适合， 但是并不适合作为整体系统的限流。 其原因就在于在这一分钟内接收流量并不一定是平均的。 攻击方可以在每一个一分钟开始的前1秒或几秒中疯狂攻击接口， 使得接口的请求数量在一开始就达到上限， 这样一来后续的正常用户将无法访问。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/limit/fixed.png" alt="" /></p>

<p>但是在一些简单的场景下， 例如单个用户的验证码发送条数限制， 当天密码输入失败的最大次数等等， 使用Redis实现的固定窗口不失为一个最佳选择。</p>

<h4 id="2-滑动窗口">2. 滑动窗口</h4>
<p>固定窗口很像一步接着一步的走路， 两步之间没有间隙， 但是每一步之间不会重叠。 而滑动窗口则是”拖着脚”在走路， 下一步会部分的覆盖前一步所走过的路径。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/limit/moving-window.png" alt="" /></p>

<p>如上图所示， 窗口大小为60s， 每过一秒向前移动一小步， 60s过后将会移动一整个窗口， 此时就像固定窗口移动一样。</p>

<p>滑动窗口在限流上其实使用的不是很多， 原因就在于滑动窗口也无法处理1s内请求过载的问题，  但是在监控告警上却是不二之选。</p>

<p>滑动窗口的最大优势就在于”重叠”， 因为窗口在滑动过程中， 势必会跨越前一分钟和后一分钟， 使得控制更加精细。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/limit/moving-window-alert.png" alt="" /></p>

<p>在具体的实现上， 通常会使用计算的方式来模拟窗口的向右滑动， 也可以说是”薛定谔的滑动”。 这里不考虑限流的滑动窗口实现， 而是转而实现监控告警的功能。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">key</span> <span class="o">=</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="kd">local</span> <span class="n">now_timestamp</span> <span class="o">=</span> <span class="nb">tonumber</span><span class="p">(</span><span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="kd">local</span> <span class="n">window_size</span> <span class="o">=</span> <span class="nb">tonumber</span><span class="p">(</span><span class="n">ARGV</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="kd">local</span> <span class="n">limit</span> <span class="o">=</span> <span class="nb">tonumber</span><span class="p">(</span><span class="n">ARGV</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

<span class="kd">local</span> <span class="n">should_clear</span> <span class="o">=</span> <span class="n">now_timestamp</span> <span class="o">-</span> <span class="n">window_size</span>
<span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s2">"ZREMRANGEBYSCORE"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">should_clear</span><span class="p">)</span>

<span class="kd">local</span> <span class="n">amount</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s2">"ZCARD"</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="k">if</span> <span class="n">amount</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="k">then</span>
    <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s2">"ZADD"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">now_timestamp</span><span class="p">,</span> <span class="n">now_timestamp</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s2">"EXPIRE"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">window_size</span><span class="p">)</span>

<span class="k">return</span> <span class="n">amount</span> <span class="o">&lt;</span> <span class="n">limit</span>
</code></pre></div></div>

<p>在熔断器里面会有这样的技术细节: 5分钟内失败率达到某个阈值时进行熔断， 像这样的需求完全可以使用滑动窗口很好的实现， 不管是使用简单的单机实现， 还是使用Redis的分布式实现。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MovingWindow</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
        <span class="s">"""
        :param window: 窗口大小
        :param rate: 移动速率
        """</span>
        <span class="k">assert</span> <span class="n">window</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"window and rate should more than zero value"</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s">"window and rate should be a Integer"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">=</span> <span class="n">rate</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__window</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__last_moving</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="s">"""
        :param step: 窗口向右滑动的距离
        """</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__window</span><span class="p">[</span><span class="n">step</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">step</span>

    <span class="k">def</span> <span class="nf">__clock_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        计算窗口应当滑动的距离
        """</span>
        <span class="n">now</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
        <span class="n">expire</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__last_moving</span>
        <span class="n">step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">expire</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__shift</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__last_moving</span> <span class="o">=</span> <span class="n">now</span>

    <span class="k">def</span> <span class="nf">incr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c"># 首先将窗口滑动至正确位置</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__clock_shift</span><span class="p">()</span>
        <span class="c"># 将值添加至窗口最后一个元素上即可</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__window</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        :return: 返回当前窗口计数总数
        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__clock_shift</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__window</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__window</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">"window: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__window</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="3-令牌桶">3. 令牌桶</h4>
<p>令牌桶算法可能是生产用使用的较为广泛的限流算法， 一方面可以限制瞬时流量， 一方面也可以限制一段时间内的流量， 算是比较两全的算法。</p>

<p>令牌桶引入缓冲区， 按照一定的速率生成令牌， 并将其置于令牌桶中。 每一个请求首先尝试从令牌桶中获取令牌， 若无令牌可用， 则直接返回失败。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TokenBucket</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
        <span class="s">"""
        :param capacity: 桶的容量
        :param rate: 生成令牌的速率
        """</span>
        <span class="k">assert</span> <span class="n">capacity</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"capacity and rate should more than zero"</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s">"capacity and rate should be integer"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">=</span> <span class="n">rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__last_clock</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
        <span class="c"># 初始令牌数为0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__bucket</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">hit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># 非并发安全的实现</span>
        <span class="n">now</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__bucket</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">capacity</span><span class="p">,</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__last_clock</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bucket</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__bucket</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__last_clock</span> <span class="o">=</span> <span class="n">now</span>
            <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<h4 id="4-小结">4. 小结</h4>
<p>无论是最简单的固定窗口， 还是稍微复杂一些的滑动窗口与令牌桶， 都有其适用的场景。 比如固定窗口适合限制具体的接口某个ip的访问次数， 滑动窗口用于记录一段时间内错误次数， 令牌桶用于秒杀场景下的限流。 在一个系统中综合运用这三种算法完全有可能， 只不过可能会根据业务场景的不同而进行稍加变动而已。</p>


	  ]]></description>
	</item>

	<item>
	  <title>那些有趣的数据结构与算法(04)--B-Tree与B+Tree</title>
	  <link>//B+Tree-and-B-Tree</link>
	  <author></author>
	  <pubDate>2019-06-23T16:01:47+00:00</pubDate>
	  <guid>//B+Tree-and-B-Tree</guid>
	  <description><![CDATA[
	     <p>树型结构由于其良好的递归特性， 高效的查询效率， 在软件系统设计中有着非常广泛的使用。 IO多路复用的epoll实现采用红黑树组织和管理sockfd， 以支持快速的增删改查； Golang中的Timer采用多叉堆实现； Java中的TreeMap以及TreeSet同样采用红黑树实现…而在MySQL中， 索引的构建同样采用树结构实现。</p>

<!---more--->

<h4 id="1-什么是b-tree">1. 什么是B-Tree</h4>
<p>B-Tree简单的来讲就是一颗矮胖的多叉平衡树， 通常不会超过3层。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/index/B-Tree.png" alt="" /></p>

<p>如上图所示， 每一层均由指针， 索引值以及卫星数据组成。 进行搜索时， 同样采用二分查找的方式进行搜索， 所以搜索效率与树的高度直接相关， 这也是为什么B-Tree的树高非常少的原因， 其目的就在于提高搜索效率。</p>

<p>那么既然降低树高能够提高搜索效率， 为什么不干脆使用有序列表呢?</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/index/sorted-list.png" alt="" /></p>

<p>现在树高只有1， 搜索的平均时间复杂度即为<code class="highlighter-rouge">O(logn)</code>， 不是比B-Tree更快吗？ 有一个很关键的点就是， B-Tree是为了构建存储数据的索引而生， 数据量庞大且将会被持久化至磁盘或者SSD上。 如果说某一张表拥有过亿的数据量， 且服务器只有4G的内存， 根本无法将列表形式的索引完全载入内存， 二分查找也就无从说起。</p>

<h4 id="2-为硬盘存储而生的b-tree">2. 为硬盘存储而生的B-Tree</h4>
<p>已经9102年了， 服务器使用HDD作为持久层已经成为了一个过去式， 目前均采用SSD， 即固态硬盘作为持久层， 其读写效率约为HDD的10倍左右。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/index/ssd-block.png" alt="" /></p>

<p>SSD简单的来看是由很多个Block(块)组成， 而Block又由很多个Page(页)所组成。 Page的大小通常为4K或者是8K， Blcok的大小通常为512K。</p>

<p>由于SSD没有向磁盘一样的悬臂， 所以不需要磁头的机械运动， 在读取数据时， 只需要找到数据所在的Block即可。 由于SSD特殊的组成方式， 在进行数据读取时， 其最小单位为Page， 也就是一次最小读取为4K或者是8K。 而对于删除数据来说， 其最小单位为Block， 因为需要进行加压擦除。</p>

<p>B-Tree之所以适合作为数据库索引结构的存储， 就是因为其矮胖的树型结构。 如果我们将索引树改为红黑树或者是AVL树这种二叉树的话， 会发生什么？</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/index/AVL-IO.png" alt="" /></p>

<p>假设树高为4， 所需的数据刚好位于AVL树的叶子节点， 那么在最坏的情况下(数据分散在不同的Page中)， 想要取出这条数据， 就需要4次的IO操作。 而IO操作， 相较于CPU的计算， 可以说慢如龟爬。 随着层高的增加， IO次数随线性增长， 这是我们不能接受的。</p>

<p>而对于B-Tree来讲， 就不会存在这样的问题， 因为其树高也就只有3、4层， 无论数据位于叶子节点还是非叶子节点， 其IO次数最多也只是4次而已。</p>

<h4 id="3-btree">3. B+Tree</h4>
<p>B+Tree是B-Tree的进化版， 目的在于进一步减少磁盘IO次数， 提供稳定的查询效率以及优化范围查找。</p>

<p>首先来看B+Tree的基本结构， 与B-Tree最大的不同就是: B+Tree的所有数据均保存在叶子节点， 非叶子节点只保存指针以及索引值。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/index/Tree.png" alt="" /></p>

<p>如上图所示， 所有的数据均保存在B+Tree的叶子节点， 非叶子节点不保存数据， 这样一来使得在4K/Page的容量限制下， 能够保存更多的索引数量。 运气好的话原来使用B-Tree需要4层树高， 使用B+Tree的话可能只需要3层树高， 磁盘IO次数进一步降低了。</p>

<p>并且由于B+Tree只在叶子节点保存数据， 所以每一次查询都需要遍历至树底， 而所有叶子节点均处于同一层， 所以所有的查询时间复杂度都是相同的。</p>

<p>除此之外， 在叶子节点所有的数据均使用指针进行相连接， 也就是一个有序链表， 在进行范围查找时拥有极高的效率。 并不需要像B-Tree一样进行前序或者后序遍历。</p>

<h4 id="4-哈希索引">4. 哈希索引</h4>
<p>其实到这里有关B-Tree和B+Tree的内容就结束了， 但是还是忍不住再BB两句。</p>

<p>Hash Table是一种以空间换时间的数据结构， 底层由数组实现， 其平均查询时间复杂度为<code class="highlighter-rouge">O(1)</code>。 而B+Tree的平均查询时间复杂度为<code class="highlighter-rouge">O(logn)</code>， 那么索引为什么不使用哈希表， 而要使用B+Tree呢？</p>

<p>因为在数据库查询这一场景， 取出单一的一条数据这种需求占比并不会特别大， 更多的是使用某一种规则取出符合该规则的多条数据。 如果只是单一的一条数据， 那么哈希索引的效率确实要优于B+Tree。 但如果取出多条数据， 或者对数据进行排序的话， 那么B+Tree为更好的选择。</p>

<p>MySQL的InnoDB存储引擎只允许用户定义B+Tree索引， 不允许用户定义哈希索引， 就是因为无法判断用户是否能正确使用哈希索引。 但是InnoDB会根据实际情况自动地为某些数据添加哈希索引， 以增加查询速度。</p>

<h4 id="5-小结">5. 小结</h4>
<p>从B-Tree以及B+Tree的使用场景上来看， 没有适用于一切场景的数据结构， 只有最适合某些场景的数据结构。 在学习数据结构的过程中， 有时候不仅要关注它的原理， 更需要关注它的设计初衷以及适用场景。</p>

	  ]]></description>
	</item>

	<item>
	  <title>DevOps基础(1)--Shell脚本编程</title>
	  <link>//shell-programing</link>
	  <author></author>
	  <pubDate>2019-06-17T09:31:51+00:00</pubDate>
	  <guid>//shell-programing</guid>
	  <description><![CDATA[
	     <p>由于Docker容器以及Kubernetes容器编排服务的蓬勃发展， 服务器以及业务服务的运维不再是运维工程师的专属， 业务的开发工程师也必须加入到运维的领域之中， 与运维工程师合作， 形成一套完整、高效的自动化运维与部署的系统。 而在我看来， 传统的运维工程师将会逐渐被应用开发工程师所取代， 因为Kubernetes赋予了开发人员强大的负载均衡、自动横向拓展以及高效管理的相关功能。 而在这些宏大的系统建设之前， Shell编程是无论如何都离不开的话题。</p>

<!---more--->

<h4 id="1-shell变量">1. Shell变量</h4>
<p>作为一个后台开发人员， Shell脚本既陌生由熟悉， 毕竟Linux命令哪个后台开发不会接触呢？ 将一个又一个的Linux命令收集起来， 并使用一些粘合剂进行组合， 最终就得到了Shell脚本。</p>

<p>Shell和Python语言一样， 是一个弱类型语言， 也就是说一个变量可以对其进行任意的类型赋值:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smart@Zero:~<span class="nv">$ foo</span><span class="o">=</span><span class="s2">"bar"</span>
smart@Zero:~<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$foo</span>
bar
smart@Zero:~<span class="nv">$ foo</span><span class="o">=</span>10
smart@Zero:~<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$foo</span>
10
</code></pre></div></div>

<p>在Terminal中， Shell命令就是一个天然的类似于Python的IPython环境， 如果我们想要对Python的某些语法进行测试的话， 需要进入Python或者IPython环境中， 而对于Shell而言， 打开Terminal就是自己工作的海洋。</p>

<p>在Shell中， 变量的赋值与其它语言没什么区别， 只不过获取变量的方式稍有不同而已。 我们可以认为<code class="highlighter-rouge">foo</code>变量是值<code class="highlighter-rouge">"bar"</code>的一个引用， 而要获取变量值， 需要借助引用名加上<code class="highlighter-rouge">$</code>符号， 非常类似C的指针。</p>

<p>在Shell编程的推荐使用方法中， 使用<code class="highlighter-rouge">${foo}</code>的方式获取变量内容， 多加一个大括号， 这样一来能够更加清楚的界定变量名称的范围， 不至于出现一些奇奇怪怪的问题。</p>

<p>除了我们自己定义的变量以外， 在Linux运行时， 还会预先定义一系列的环境变量。 环境变量说的简单一些就是定义在某一个文件中， 供整个Linux使用的变量， 可以认为是一种最高层的全局变量。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smart@Zero:~<span class="nv">$ </span>env
...
<span class="nv">WORKON_HOME</span><span class="o">=</span>/home/smart/.virtualenvs
<span class="nv">HOME</span><span class="o">=</span>/home/smart
<span class="nv">PATH</span><span class="o">=</span>/home/smart/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/go/bin/
</code></pre></div></div>

<p>获取当前系统的环境变量也简单， 敲<code class="highlighter-rouge">env</code>即可。 在上面的结果中， <code class="highlighter-rouge">WORKON_HOME</code>是virtualenvwrapper的工作目录， 是我定义在<code class="highlighter-rouge">~/.bashrc</code>中的， 而<code class="highlighter-rouge">HOME</code>和<code class="highlighter-rouge">PATH</code>变量， 则是Linux操作系统定义的。</p>

<p>获取系统的环境变量和获取自己定义的变量一样， <code class="highlighter-rouge">$</code>符+变量名:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smart@Zero:~<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$HOME</span>
/home/smart
</code></pre></div></div>

<p>值得一提的就是<code class="highlighter-rouge">PATH</code>变量， 在安装一些软件时， 例如Java， Go时， 都需要将一些变量加入到<code class="highlighter-rouge">PATH</code>中， 为什么这么做？ Linux系统会在<code class="highlighter-rouge">PATH</code>变量值的路径中寻找可执行的二进制文件， 而当我们把诸如<code class="highlighter-rouge">GOPATH</code>的变量值假如到<code class="highlighter-rouge">PATH</code>变量中以后， 在任何的目录下， 都可以使用Go的相关命令， 这就是<code class="highlighter-rouge">PATH</code>变量的作用。</p>

<h4 id="2-获取系统函数的返回值">2. 获取系统函数的返回值</h4>
<p>诸如<code class="highlighter-rouge">cat</code>, <code class="highlighter-rouge">du</code>, <code class="highlighter-rouge">date</code>等命令， 实际上就是函数， 只不过是由C编写并通过某种方式暴露给用户而已。</p>

<p><code class="highlighter-rouge">date</code>函数用以获取当前时区的时间:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smart@Zero:~<span class="nv">$ </span>date
2019年 05月 12日 星期日 10:43:48 CST
</code></pre></div></div>

<p>在编写Shell脚本时， 很多时候都需要将函数的运行结果保存在某一个变量中， 所以Shell提供了两种方式进行结果的赋值:</p>
<ol>
  <li>使用variable=&amp;#96date&amp;#96</li>
  <li>使用variable=$(date)</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smart@Zero:~<span class="nv">$ foo</span><span class="o">=</span><span class="sb">`</span>date<span class="sb">`</span>
smart@Zero:~<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$foo</span>
2019年 05月 12日 星期日 10:49:21 CST
smart@Zero:~<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$foo</span>
2019年 05月 12日 星期日 10:49:21 CST
</code></pre></div></div>

<p>如果查看<code class="highlighter-rouge">date</code>的manual手册的话， 会发现它还支持日期的格式化:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smart@Zero:~<span class="nv">$ foo</span><span class="o">=</span><span class="sb">`</span>date +%y%m%d%H%M%S<span class="sb">`</span>
smart@Zero:~<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$foo</span>
190512105105
</code></pre></div></div>

<p>此外， Shell还提供了对上一个命令所执行结果的获取， 使用<code class="highlighter-rouge">$?</code>进行获取。 这是什么意思？ 在Shell中， 一条命令如果正常执行的话， 返回值将会是0， 如果命令执行时出现了某些错误的话， 返回值将会大于0， 且小于255。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 执行一条正常的命令</span>
smart@Zero:~<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"Hello World"</span>
Hello World
smart@Zero:~<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
0

<span class="c"># 执行一条会抛出错误的命令</span>
smart@Zero:~<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-alh</span> NotExistFile
<span class="nb">ls</span>: cannot access <span class="s1">'NotExistFile'</span>: No such file or directory
smart@Zero:~<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
2
</code></pre></div></div>

<p>由于NotExistFile是一个不存在的文件， 所以<code class="highlighter-rouge">ls</code>命令会产生一个标准错误并输出至屏幕中， 此时的退出状态码将会为2。 一些常见的退出状态码如下:</p>

<table>
  <thead>
    <tr>
      <th>状态码</th>
      <th>描述</th>
      <th>状态码</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>命令成功结束</td>
      <td>126</td>
      <td>命令不可执行</td>
    </tr>
    <tr>
      <td>1</td>
      <td>一般性未知错误</td>
      <td>127</td>
      <td>没找到命令</td>
    </tr>
    <tr>
      <td>2</td>
      <td>不合适的shell命令</td>
      <td>130</td>
      <td>通过Ctrl+C退出的命令</td>
    </tr>
  </tbody>
</table>

<h4 id="3-流程控制">3. 流程控制</h4>
<p>既然是一种语言， 又怎么能少的了流程控制。 在Shell脚本中， 使用最为广泛的恐怕就是<code class="highlighter-rouge">if-then</code>判断了。</p>

<h5 id="31-if-then">3.1 if-then</h5>
<p>条件语句的基本模板:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span>command-1
<span class="k">then
  </span>command-2
<span class="k">else
  </span>command-3
<span class="k">fi</span>
</code></pre></div></div>

<p>需要特别注意的是， 这里的条件判断是command-1这条命令的执行结果: 如果command-1执行的退出状态码为0的话， 执行then语句块的内容， 否则退出。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="k">if </span><span class="nb">ls</span> <span class="nt">-alh</span> NotExistFile
<span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"The ls command exec successed"</span>
<span class="k">else
  </span><span class="nb">echo</span> <span class="s2">"Some error happened when exec ls"</span>
<span class="k">fi</span>
</code></pre></div></div>

<p>由于<code class="highlighter-rouge">ls -alh NotExistFile</code>的退出状态码为2， 所以将会输出”Some error happened when exec ls”。 如果我们想要true/false的条件语句， 使用<code class="highlighter-rouge">[[  ]]</code>。 例如， 如果变量<code class="highlighter-rouge">foo</code>的值为”bar”的话， 打印一条语句， 否则什么都不做:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="nv">bar</span><span class="o">=</span><span class="s2">"foo"</span>
<span class="k">if</span> <span class="o">[[</span> <span class="k">${</span><span class="nv">bar</span><span class="k">}</span> <span class="o">=</span> <span class="s2">"foo"</span> <span class="o">]]</span>
<span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Right"</span>
<span class="k">fi</span>
</code></pre></div></div>

<p>与传统的语言都不同的是， 判断两个变量是否相等使用的是单个<code class="highlighter-rouge">=</code>号， 而不是<code class="highlighter-rouge">==</code>， 需要注意。</p>

<p>Shell也提供了一些参数来帮助我们进行条件判断， 例如<code class="highlighter-rouge">-n str</code>表示检查str的长度是否大于0， <code class="highlighter-rouge">-z str</code>表示检查str的长度是否为0， <code class="highlighter-rouge">-d file</code>用以检测file是否存在并且是一个目录, <code class="highlighter-rouge">-e file</code>判断file是否存在…</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">bar</span><span class="k">}</span> <span class="o">]]</span>
<span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"The length of the bar is not zero"</span>
<span class="k">fi

if</span> <span class="o">[[</span> <span class="nt">-d</span> <span class="s2">"/home/smart"</span> <span class="o">]]</span>
<span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"/home/smart exist, and it's a directory"</span>
<span class="k">fi</span>
</code></pre></div></div>

<h5 id="32-case语句">3.2 case语句</h5>
<p>有时候变量的值会有多种， 如果一个一个的写<code class="highlighter-rouge">if</code>的话太麻烦了， 所以就有了<code class="highlighter-rouge">case</code>语句， 基本模板:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> variable <span class="k">in
</span>A <span class="p">|</span> B<span class="p">)</span> command-1 <span class="p">;;</span>
C<span class="p">)</span> command-2 <span class="p">;;</span>
D<span class="p">)</span> command-3 <span class="p">;;</span>
<span class="k">*</span><span class="p">)</span> default-command <span class="p">;;</span>
<span class="k">esac</span>
</code></pre></div></div>

<p>注意一下语法格式就好， 没有什么特别复杂的地方。</p>

<h5 id="33-while语句">3.3 while语句</h5>
<p>while语句的基本模板:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while </span>condition
<span class="k">do
  </span><span class="nb">command
</span><span class="k">done</span>
</code></pre></div></div>

<p>condition的种类与<code class="highlighter-rouge">if-then</code>语法相同， 既可以判断命令的退出状态码， 也可以使用<code class="highlighter-rouge">[[  ]]</code>的形式来进行true/false判断:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 一个无限循环</span>
<span class="k">while</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">bar</span><span class="k">}</span> <span class="o">]]</span><span class="p">;</span> <span class="k">do
    </span><span class="nb">echo</span> <span class="s2">"The length of bar is not zero"</span>
<span class="k">done</span>
</code></pre></div></div>

<h5 id="34-for循环">3.4 for循环</h5>
<p><code class="highlighter-rouge">for</code>循环的语法格式更贴近于Python， 其模板为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>var <span class="k">in </span>list
<span class="k">do
  </span><span class="nb">command
</span><span class="k">done</span>
</code></pre></div></div>

<p>例如使用通配符来生成文件列表， 然后遍历， 当遍历的文件是一个目录时， 打印它:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>file <span class="k">in</span> /home/smart/<span class="k">*</span>
<span class="k">do
  if</span> <span class="o">[[</span> <span class="nt">-d</span> <span class="k">${</span><span class="nv">file</span><span class="k">}</span> <span class="o">]]</span>
  <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">file</span><span class="k">}</span><span class="s2"> is a directory"</span>
  <span class="k">fi
done</span>
</code></pre></div></div>

<p>也可以使用C语言风格的循环语句:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">((</span> i <span class="o">=</span> 0<span class="p">;</span> i &lt; 10<span class="p">;</span> i++ <span class="o">))</span><span class="p">;</span> <span class="k">do
    </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">i</span><span class="k">}</span><span class="s2">"</span>
<span class="k">done</span>
</code></pre></div></div>

<h4 id="4-处理用户输入与重定向">4. 处理用户输入与重定向</h4>
<p>向脚本传递用户的参数是一个shell脚本最基本的操作， 脚本获取参数的方式也与其它语言不同。 诸如Java， 参数是以字符数组的方式传递给main函数的。</p>

<p>在shell中， 使用<code class="highlighter-rouge">$1</code>来获取第一个参数， <code class="highlighter-rouge">$2</code>获取第二个参数, …， <code class="highlighter-rouge">$n</code>获取第n个参数。 而<code class="highlighter-rouge">$0</code>比较特殊， 代表了执行该脚本的路径名称。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="c"># test.sh</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">0</span><span class="k">}</span>, <span class="k">${</span><span class="nv">1</span><span class="k">}</span>, <span class="k">${</span><span class="nv">2</span><span class="k">}</span>, <span class="k">${</span><span class="nv">3</span><span class="k">}</span>
</code></pre></div></div>

<p>在赋予了普通用户对该脚本的执行权限后， 执行该脚本: <code class="highlighter-rouge">./test.sh A B C</code>， 将会得到输出:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./test.sh, A, B, C
</code></pre></div></div>

<p>对于<code class="highlighter-rouge">$0</code>， 如果只想要获取脚本名称的话， 可以使用<code class="highlighter-rouge">$(basename ${0})</code>。 获取参数个数使用<code class="highlighter-rouge">$#</code>， 获取所有参数使用<code class="highlighter-rouge">$*</code>或者是<code class="highlighter-rouge">$@</code>， 前者如果使用<code class="highlighter-rouge">"$*"</code>进行引用的话， 将会作为一个字符整体对待， 而<code class="highlighter-rouge">$@</code>不管在何种情况下， 都是参数所组成的列表， 所以<code class="highlighter-rouge">$@</code>更多的用于参数的迭代。</p>

<p>提到参数处理， 就不得不提及<code class="highlighter-rouge">shift</code>关键字。在使用<code class="highlighter-rouge">shift</code>命令时,默认情况下它会将每个参数变量向左移动一个位置。所以,变量$3的值会移到$2中,变量$2的值会移到$1中,而变量$1的值则会被删除。</p>

<p><code class="highlighter-rouge">shift</code>的测试也很简单， 非常清楚的就能够知道它到底做了什么:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="nb">echo</span> <span class="s2">"All param: </span><span class="nv">$@</span><span class="s2">"</span>
<span class="nb">shift
echo</span> <span class="s2">"The first shift: </span><span class="nv">$@</span><span class="s2">"</span>
<span class="nb">shift
echo</span> <span class="s2">"The second shift: </span><span class="nv">$@</span><span class="s2">"</span>
<span class="nb">shift
echo</span> <span class="s2">"The third shift: </span><span class="nv">$@</span><span class="s2">"</span>
</code></pre></div></div>

<p>这次多传递一些参数进入该脚本， 得到的输出:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smart@Zero:~<span class="nv">$ </span>./test.sh A B C D E F
All param: A B C D E F
The first <span class="nb">shift</span>: B C D E F
The second <span class="nb">shift</span>: C D E F
The third <span class="nb">shift</span>: D E F
</code></pre></div></div>

<p>每执行一次shift， 参数列表的首个参数都会被弹出， 如果执行<code class="highlighter-rouge">shift 2</code>的话， 将会弹出2个参数。</p>

<p>在<code class="highlighter-rouge">Ansible</code>的ad-hoc模式中， 通常我们会这样执行命令:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 将ansible所管理的所有主机进行文件拷贝, 并发数为10</span>
ansible all <span class="nt">-m</span> copy <span class="nt">-a</span> <span class="s2">"src=/home/smart/monitor/ dest=/home/monitor"</span> <span class="nt">-f</span> 5
</code></pre></div></div>

<p>在有了shift之后， 就可以很轻松的编写出对应的shell脚本了:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>
<span class="c"># simulate_ansible.sh</span>
<span class="c"># 运行: ./simulate_ansible.sh all -m copy -a "src=/home/smart/monitor/ dest=/home/monitor" -f 5</span>

<span class="nb">echo</span> <span class="s2">"Get params: </span><span class="nv">$@</span><span class="s2">"</span>
<span class="k">while</span> <span class="o">[[</span> <span class="nv">$# </span><span class="nt">-gt</span> 0 <span class="o">]]</span><span class="p">;</span> <span class="k">do
  case</span> <span class="nv">$1</span> <span class="k">in
  </span>all<span class="p">)</span>
    <span class="nb">echo</span> <span class="s2">"The process host group: </span><span class="k">${</span><span class="nv">1</span><span class="k">}</span><span class="s2">"</span>
    <span class="nb">shift</span> <span class="p">;;</span>
  <span class="nt">-m</span><span class="p">)</span>
    <span class="nb">echo</span> <span class="s2">"Get module name: </span><span class="k">${</span><span class="nv">2</span><span class="k">}</span><span class="s2">"</span>
    <span class="nb">shift </span>2 <span class="p">;;</span>
  <span class="nt">-a</span><span class="p">)</span>
    <span class="nb">echo</span> <span class="s2">"Get parameter: </span><span class="k">${</span><span class="nv">2</span><span class="k">}</span><span class="s2">"</span>
    <span class="nb">shift </span>2 <span class="p">;;</span>
  <span class="nt">-f</span><span class="p">)</span>
    <span class="nb">echo</span> <span class="s2">"The fork number is: </span><span class="k">${</span><span class="nv">2</span><span class="k">}</span><span class="s2">"</span>
    <span class="nb">shift </span>2 <span class="p">;;</span>
  <span class="k">*</span><span class="p">)</span>
    <span class="nb">echo</span> <span class="s2">"Bad params"</span>
    <span class="nb">exit </span>2
  <span class="k">esac
done</span>
</code></pre></div></div>

<p>在Linux I/O中， 标准输入使用0表示， 标准输出使用1表示， 标准错误使用2表示。 什么是标准输出/错误? 使用<code class="highlighter-rouge">ls</code>命令得到的结果就是标准输出， 使用<code class="highlighter-rouge">ls NotExistFile</code>命令得到的结果就是标准错误。</p>

<p>Shell脚本在执行时， 许多时候都是边缘触发或者是定时执行的， 其标准输出与错误我们是看不到的， 所以就需要有日志进行记录。 一个记录标准输出， 一个记录标准错误:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-alh</span> NotExistFile 1&gt;~/monitor/stdout.log 2&gt;~/monitor/stderror.log
</code></pre></div></div>

<p>有时候想偷个懒， 不管是输出还是错误， 都重定向到同一个文件:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-alh</span> &amp;&gt;~/homo/monitor/ls.log
</code></pre></div></div>

<h4 id="5-函数">5. 函数</h4>
<p>shell中的函数并没有很强大的功能， 更像是一个小型的shell脚本。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 定义</span>
funcname<span class="o">()</span> <span class="o">{</span>...<span class="o">}</span>
<span class="c"># 调用与参数传递</span>
funcname <span class="s2">"foo"</span> <span class="s2">"bar"</span>
</code></pre></div></div>

<h4 id="6-常见的shell脚本头设置">6. 常见的shell脚本头设置</h4>
<p>有时会看到在某些shell脚本中有这样的语句:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span> <span class="nt">-e</span>
<span class="nb">set</span> <span class="nt">-x</span>
<span class="nb">exec</span> &amp;&gt; test.log
</code></pre></div></div>

<p><code class="highlighter-rouge">set</code>以及<code class="highlighter-rouge">exec</code>主要是对当前脚本的一些全局设置， 所以会放到脚本开始的地方。</p>

<p><code class="highlighter-rouge">set -e</code>表示如果当前的脚本在执行某一条命令时的退出状态码不为0时， 则整个脚本退出。 有些类似于异常的抛出与进程终止。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">set</span> <span class="nt">-e</span>
<span class="nb">ls</span> <span class="nt">-alh</span>
<span class="nb">ls</span> <span class="nt">-alh</span> NotExistFile
<span class="nb">echo</span> <span class="s2">"Done"</span>  <span class="c"># 永远不会执行到该行命令</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">set -x</code>则主要用于进行DEBUG， 在脚本执行时将会打印出每一行命令执行的详细信息。</p>

<p><code class="highlighter-rouge">exec &amp;&gt; test.log</code>则表示将当前脚本执行时所产生的所有标准输出与错误均重定向至test.log文件。</p>

<h4 id="7-子shell">7. 子shell</h4>
<p>假如我们编写了这样的一个shell脚本:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">cd</span> /home/smart/monitor
</code></pre></div></div>

<p>然后执行该脚本， 会发现当前的目录并没有发生改变， 为什么? 这是因为不管是使用<code class="highlighter-rouge">bash script.sh</code>执行还是使用<code class="highlighter-rouge">./script.sh</code>来执行脚本， 脚本的执行都在一个名为子shell的shell环境中执行。 子shell中执行<code class="highlighter-rouge">cd</code>命令， 并不会影响到当前的shell状态。</p>

<h4 id="8-小结">8. 小结</h4>
<p>从我的工作经验上来看， 如果是开发来兼职做运维工作的话， 以上的内容完全能够解决日常中需要的运维场景。 Shell脚本语言本身比较简单， 其核心仍然是一个又一个的Linux系统命令， Shell语言只是作为粘合剂将这些命令组合起来形成一个整体而已。</p>

<p>PS: 留一张思维导图作为自己的复习参考</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/ShellScript.png" alt="" /></p>

	  ]]></description>
	</item>

	<item>
	  <title>DevOps基础(2)--Ansible自动化运维工具</title>
	  <link>//Ansible</link>
	  <author></author>
	  <pubDate>2019-06-17T08:33:42+00:00</pubDate>
	  <guid>//Ansible</guid>
	  <description><![CDATA[
	     <p>Shell脚本能够为我们提供一部分的系统运维功能， 例如定时任务， 由Jenkins所管理的边缘触发任务等等， 但是如果想要对多台服务器进行管理和运维， 就需要Ansible来协助完成。</p>

<!---more--->

<h4 id="1-ansible是什么">1. Ansible是什么?</h4>

<p>Ansible是一个由Python语言编写的自动化运维工具， 底层基于SSH框架， 帮助运维以及开发人员进行批量的服务器管理。</p>

<p>假设我们有10台服务器， 需要查看当前每台服务器的磁盘使用状况， 如果说采用传统的SSH登录， 然后输入密码， 进入远程服务器， 使用<code class="highlighter-rouge">df -h</code>来查看磁盘的使用状态的话， 这个过程需要持续10次。 就算我们将客户端的公钥上传至服务器使得我们可以免密登录远程服务器， 这个过程仍然是很花时间的。</p>

<p>此时Ansible就发挥其作用了， 由于Ansible是基于SSH框架所实现的， 所以Ansible可以批量的进行远程服务器的SSH连接， 在该连接之上执行<code class="highlighter-rouge">df -h</code>， 并将结果返回给客户端。 而且Ansible还提供了多进程的方式进行工作， 进一步的提升执行效率以及节省运维人员的时间。</p>

<h4 id="2-ansible的安装与配置">2. Ansible的安装与配置</h4>
<p>正如前面所提到的， Ansible是由Python所编写的工具， 那么自然需要相应的Python环境或者是Python的虚拟环境。 在Linux操作系统中， 本身就包含了python2.7以及python3.6+的环境， 所以如果不使用虚拟环境的话， 可以直接使用</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install ansible
</code></pre></div></div>

<p>进行安装。 在安装完成后， 目录<code class="highlighter-rouge">/etc/ansible</code>即会生成。 在该目录下， 只有两个文件:</p>
<ul>
  <li>ansible.cfg: ansible的全局配置文件</li>
  <li>hosts: ansible默认的服务器配置文件， 有时又称为资产清单文件</li>
</ul>

<p>两个文件的配置都很简单且易懂。 对于hosts文件， 定义的格式以及具体的实例如下:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>group-name]
server-ip/server-domain <span class="nv">ansible_ssh_user</span><span class="o">=</span>USERNAME

<span class="o">[</span>local_server]
192.168.1.106 <span class="nv">ansible_ssh_user</span><span class="o">=</span>smart
</code></pre></div></div>

<p>在上面的实例中， 定义了<code class="highlighter-rouge">local_server</code>这个主机组， 在该组下只有一台主机， IP地址为192.168.1.106， 并定义了ansible在当前主机执行任务时的用户名称为smart。</p>

<p>而对于ansible.cfg文件， 更多的是定义默认的服务器配置文件路径， 执行的并发数， 以及客户端的公钥等。</p>

<p>为了能够使用公钥登录服务器， 得先将客户端的公钥上传至服务器的authorized_keys文件中， 这个过程可以交给ssh来自动完成:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh-copy-id user@server-ip
输入密码即可
</code></pre></div></div>

<p>将当前客户端的公钥地址配置在ansible.cfg中， 其余的配置保持默认即可:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">ansible_ssh_private_key_file</span><span class="o">=</span>/home/smart/.ssh/id_rsa.pub
</code></pre></div></div>

<h4 id="3-ansible的模块">3. ansible的模块</h4>

<p>对于一个任务而言， 需要的要素就是谁在哪儿做什么。 在Ansible自动化管理中， 当然是由Ansible来做了， 任务执行的范围即定义在hosts服务器配置文件之中， 剩下的就是定义具体的任务了。</p>

<p>Ansible提供了两种任务定义的方式， 一种叫ad-hoc， 一种叫playbooks。 ad-hoc就像是我们在Terminal中执行shell命令一样， 是一种临时的、无法保存成文件的任务执行方式。 而playbooks则是永久的、能够多次执行并保存成文件的任务， 相当于Shell脚本。</p>

<p>在前一篇Shell脚本的文章有提到， Shell脚本的核心是一条一条的Linux命令， Shell语言只是提供粘合剂将它们组合形成一个整体。 对于Ansible而言， 其核心就是模块， 而playbook则是将多个模块组合在一起。</p>

<p>那么Ansible模块又是什么? Ansible模块其实就是一个又一个的Python脚本， 为用户提供各种各样功能的脚本。 例如使用最为广泛的<code class="highlighter-rouge">copy</code>模块， 其作用是将本地的文件拷贝至服务器的目标目录中。</p>

<p>如果我们自己来完成文件拷贝的需求， 可以使用</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp file_path user@server-ip:server_path
</code></pre></div></div>

<p>如果是对很多台服务器进行文件拷贝的话， 可以使用一个Shell脚本来完成:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">set</span> <span class="nt">-xe</span>
<span class="nb">exec</span> &amp;&gt; /home/smart/shell/file-copy.log

<span class="nv">USER</span><span class="o">=</span><span class="s2">"admin"</span>
<span class="nv">LOCAL_PATH</span><span class="o">=</span><span class="s2">"/home/smart/monitor"</span>
<span class="nv">SERVER_PATH</span><span class="o">=</span><span class="s2">"/home/monitor"</span>

<span class="k">for </span>server <span class="k">in </span>server_list
<span class="k">do
  </span>scp <span class="nt">-R</span> <span class="k">${</span><span class="nv">LOCAL_PATH</span><span class="k">}</span> <span class="k">${</span><span class="nv">USER</span><span class="k">}</span>@<span class="k">${</span><span class="nv">server</span><span class="k">}</span>:<span class="k">${</span><span class="nv">SERVER_PATH</span><span class="k">}</span>
<span class="k">done</span>
</code></pre></div></div>

<p>而这么多行的Shell脚本， Ansible使用一个<code class="highlighter-rouge">copy</code>模块就可以完成， 这就是Ansible模块的威力。</p>

<p>如果使用Ansible命令行的模式来完成文件拷贝的任务， 只需要一行命令:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ansible all <span class="nt">-m</span> copy <span class="nt">-a</span> <span class="s2">"src=/home/smart/monitor dest=/home/monitor"</span> <span class="nt">-f</span> 6
</code></pre></div></div>

<p><code class="highlighter-rouge">all</code>表示对hosts文件中的所有主机执行任务， 也可以执行组名， 例如<code class="highlighter-rouge">local_server</code>。 <code class="highlighter-rouge">-m</code>指定模块名称， 这里选用<code class="highlighter-rouge">copy</code>模块。 <code class="highlighter-rouge">-a</code>添加模块所需要的参数， 而<code class="highlighter-rouge">-f</code>则指定并行的数量， 通常会和客户端的CPU核心数相同。</p>

<p>回到文章开始的地方， 对10台服务器执行<code class="highlighter-rouge">df -h</code>命令该怎么做? 由于这是一个Shell命令， 所以理所当然的使用<code class="highlighter-rouge">shell</code>模块， 传递给该模块的参数就是所要执行的命令:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ansible local_server <span class="nt">-m</span> shell <span class="nt">-a</span> <span class="s2">"df -h"</span>
</code></pre></div></div>

<p>将会得到这样的结果:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.1.106 | SUCCESS | <span class="nv">rc</span><span class="o">=</span>0 <span class="o">&gt;&gt;</span>
Filesystem      Size  Used Avail Use% Mounted on
udev            7.8G     0  7.8G   0% /dev
tmpfs           1.6G  2.2M  1.6G   1% /run
/dev/sdb3        95G   34G   57G  38% /
tmpfs           7.9G  265M  7.6G   4% /dev/shm
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           7.9G     0  7.9G   0% /sys/fs/cgroup
</code></pre></div></div>

<p>Ansible和Shell一样， 提供了非常多封装了各种各样功能的模块， 到目前为止， Ansible大概提供了约2100个模块， 几乎涵盖了服务器运维的所有方面。 所以我认为这进一步地印证了在Ansible中， 最为重要的并不是如何编写playbooks， 而是如何在这2100个模块中找到自己想要的， 并正确的使用它。</p>

<blockquote>
  <p>Ansible所有模块文档地址: <a href="https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html">ansible list of modules</a></p>
</blockquote>

<h4 id="4-ansible-playbooks">4. Ansible playbooks</h4>
<p>通常来讲ad-hoc模式常常拿来做测试， 例如:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ansible all <span class="nt">-m</span> ping
</code></pre></div></div>

<p>来测试服务器的配置以及服务器的可达状态， 或者是说批量的添加用户并分配用户组等小功能。 在自动化部署这一需求下， 仍然会使用playbooks来组合测试、QA以及生产环境的相关任务。</p>

<p>在playbooks下有两个很重要的概念: roles， tasks。 roles是一个或多个任务(task)的集成， 表示当前的任务所运行的环境。 通常都会分为dev， test， QA， prod， 主要用于环境区分。 而tasks则是变量列表和具体的任务列表的集成， 代表了真正要执行的任务。 所以， 一个playbooks的结构往往是这样的:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>├── dev.yaml
├── inventory.cfg
├── prod.yaml
├── roles
│   ├── dev
│   │   ├── tasks
│   │   │   └── main.yaml
│   │   └── vars
│   │       └── main.yaml
│   ├── prod
│   │   ├── tasks
│   │   │   └── main.yaml
│   │   └── vars
│   │       └── main.yaml
│   └── <span class="nb">test</span>
│       ├── tasks
│       │   └── main.yaml
│       └── vars
│           └── main.yaml
└── test.yaml
</code></pre></div></div>

<p>看起来会很复杂， 其实非常的简单。 在根目录下， <code class="highlighter-rouge">dev|test|prod.yaml</code>是playbooks的主要入口文件， 而reoles目录下的<code class="highlighter-rouge">dev|test|prod</code>目录中则保存着对应环境的环境变量以及所要执行的任务。 <code class="highlighter-rouge">inventory.cfg</code>则保存着当前项目所设计的服务器资产清单， 包括开发， 测试， QA以及生产服务器的分组和ip。</p>

<h5 id="41-入口文件testyaml">4.1 入口文件test.yaml</h5>
<p>这里以<code class="highlighter-rouge">test.yaml</code>入口文件为例， 该配置文件其实非常的简单:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">hosts</span><span class="pi">:</span> <span class="s">test</span>
  <span class="na">roles</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">test</span>
</code></pre></div></div>

<p>没有更多内容了， 首先指定测试环境所用到的服务器组名， 其次指定测试环境的roles目录。 playbooks的运行是从入口文件开始的:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ansible-playbook <span class="nt">-i</span> inventory.cfg test.yaml
</code></pre></div></div>

<h5 id="42-任务列表文件">4.2 任务列表文件</h5>
<p>对于一个task.yaml而言， 也非常简单: 组合多个模块。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">print current date</span>
  <span class="na">shell</span><span class="pi">:</span> <span class="s">date</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">copy file</span>
  <span class="na">copy</span><span class="pi">:</span>
    <span class="na">src</span><span class="pi">:</span> <span class="s">/home/monitor/test.log</span>
    <span class="na">dest</span><span class="pi">:</span> <span class="s">/home/monitor</span>
</code></pre></div></div>

<p>只不过是将ad-hoc模式下变量传递的方式改写成yaml文件的格式而已， 本质上仍然是对模块的应用。 但是这种任务编写的方式提供了额外的拓展功能， 例如<code class="highlighter-rouge">chdir</code>改变当前任务的工作目录， <code class="highlighter-rouge">register</code>将当前任务的执行结果保存至某一个变量中， 可以用于后续的DEBUG。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">print current date</span>
  <span class="na">shell</span><span class="pi">:</span> <span class="s">date</span>
  <span class="na">args</span><span class="pi">:</span>
    <span class="na">chdir</span><span class="pi">:</span> <span class="s">/home/monitor</span>
  <span class="na">register</span><span class="pi">:</span> <span class="s">date_result</span>
<span class="s">-debug</span><span class="pi">:</span> <span class="s">var=date_result</span>
</code></pre></div></div>

<h5 id="43-变量列表文件">4.3 变量列表文件</h5>
<p>出于编码的最佳规范， 一些变量或者是常量最好是保存至某一个文件中， 而后进行引用。 在playbooks中， 我们只需要将变量写入<code class="highlighter-rouge">vars/main.yaml</code>， 以及在<code class="highlighter-rouge">tasks/main.yaml</code>中使用即可， 至于中间是怎么工作的， 可以完全不用关心。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># vars/main.yaml</span>
<span class="na">home_path</span><span class="pi">:</span> <span class="s">/home/smartkeyerror</span>

<span class="c1"># tasks/main.yaml</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">ls home_path</span>
  <span class="na">shell</span><span class="pi">:</span> <span class="s">ls ""</span>
  <span class="c1"># 如果使用进行变量引用的话， 必须添加""</span>
</code></pre></div></div>

<p>既然变量文件使用yaml的数据格式进行写入， 那么就可以使用dict数据结构来进行变量引用:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 定义</span>
<span class="na">foo</span><span class="pi">:</span>
  <span class="na">field1</span><span class="pi">:</span> <span class="s">A</span>
  <span class="na">field2</span><span class="pi">:</span> <span class="s">B</span>

<span class="c1"># 引用</span>
<span class="s">foo["field1"]</span>
<span class="s">foo.field1</span>
</code></pre></div></div>

<p>这种引用方式更多的是在模板(Template)中进行使用， <code class="highlighter-rouge">task.yaml</code>更多的是直接引用简单的变量。</p>

<h4 id="5-jinja2模板">5. Jinja2模板</h4>
<p>如果使用过Django或者是Flask等Python Web框架的小伙伴对Jinja2模板一定不会很陌生。</p>

<p>Ansible中的Jinja2模板并不是用于HTML文件的数据填充与渲染， 而是当做配置文件的模板进行远程配置文件的填充。</p>

<p>举一个并不是很恰当的例子， 但是能够说明问题。</p>

<p>假设有如下Nginx配置文件:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server <span class="o">{</span>
    listen 80<span class="p">;</span>
    server_name gitlab.zero.com<span class="p">;</span>
    location / <span class="o">{</span>
        proxy_pass http://127.0.0.1:8181<span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>一个非常简单gitlab端口转发配置， 现在我想要将<code class="highlighter-rouge">server_name</code>配置项的值放入到变量文件中， 然后将该配置文件上传至服务器中。 当然我们可以使用<code class="highlighter-rouge">copy</code>模块来完成， 但是copy模块没有办法在拷贝的文件中填充变量， 这个时候就需要使用到模板。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># nginx.gitlab.j2</span>

server <span class="o">{</span>
    listen 80<span class="p">;</span>
    server_name <span class="p">;</span>
    location / <span class="o">{</span>
        proxy_pass http://127.0.0.1:8181<span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">generate gitlab nginx config to server</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">src</span><span class="pi">:</span> <span class="s">./templates/nginx.gitlab.j2</span>
    <span class="na">dest</span><span class="pi">:</span> <span class="s">/etc/nginx/conf.d/gitlab.conf</span>
</code></pre></div></div>

<p>模板文件通常置于playbooks/templates目录中。 当执行完该playbooks之后， Ansible将会把填充好变量数据的Nginx配置文件置于应有的服务器目录下。</p>

<p>当然， Jinja2模板的功能远不止于此， 还可以在模板文件中添加条件判断以及数据的迭代:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="p">{</span><span class="o">%</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">environment</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="o">%</span><span class="p">}</span>
    <span class="p">{{</span><span class="n">key</span><span class="p">}}:</span> <span class="s">"{{value}}"</span>
<span class="p">{</span><span class="o">%</span> <span class="n">endfor</span> <span class="o">%</span><span class="p">}</span>

<span class="p">{</span><span class="o">%</span> <span class="k">if</span> <span class="n">used_kafka</span> <span class="o">%</span><span class="p">}</span>
    <span class="o">...</span>
<span class="p">{</span><span class="o">%</span> <span class="n">endif</span> <span class="o">%</span><span class="p">}</span></code></pre></figure>

<h4 id="6-ansible-vault对变量文件进行加密">6. Ansible Vault对变量文件进行加密</h4>

<p>有时为了保证变量文件的安全性， 以及在网络传输时的隐蔽性， 通常都需要对变量文件进行加密， 只有在使用变量文件时才对其进行解密。</p>

<p><code class="highlighter-rouge">ansible-vault</code>命令就是Ansible提供给我们对文件进行加密的工具。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 变量文件只有一个变量配置</span>
smart@Zero:~<span class="nv">$ </span><span class="nb">cat </span>main.yaml
server_name: gitlab.zero.com

<span class="c"># 使用ansible-vault encrypt file进行加密</span>
smart@Zero:~<span class="nv">$ </span>ansible-vault encrypt main.yaml
New Vault password:
Confirm New Vault password:
Encryption successful

<span class="c"># 再次查看main.yaml</span>
smart@Zero:~<span class="nv">$ </span><span class="nb">cat </span>main.yaml

<span class="nv">$ANSIBLE_VAULT</span><span class="p">;</span>1.1<span class="p">;</span>AES256
31356236643435613539353331383734376438373966393064666538636635643934663736636437
3961316333633462376234386437346462333539393039310a663932663832306464316435646539
36636665366233343266386466313831343165303238623163373237313764333363373662303862
3561646430623230620a663964363462366435386139383666356330333336343535373336346232
36386236373639666633666130653861636530613034623635626135313130366632
</code></pre></div></div>

<p>在这里使用了手工输入密码的方式进行加密与解密， 除此之外还可以将密码写入文件， 在进行加密解密时执行文件:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 生成密码文件</span>
smart@Zero:~<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"mypassword"</span> <span class="o">&gt;</span> .password.conf

<span class="c"># 修改文件权限以及所属用户组</span>
smart@Zero:~<span class="nv">$ </span><span class="nb">sudo </span>chmod 600 .password.conf
smart@Zero:~<span class="nv">$ </span><span class="nb">sudo </span>chmod 600 .password.conf

<span class="c"># 加密</span>
smart@Zero:~<span class="nv">$ </span><span class="nb">sudo </span>ansible-vault encrypt <span class="nt">--vault-id</span> .password.conf main.yaml

<span class="c"># 解密</span>
smart@Zero:~<span class="nv">$ </span><span class="nb">sudo </span>ansible-vault decrypt <span class="nt">--vault-id</span> .password.conf main.yaml
</code></pre></div></div>

<h4 id="7-小结">7. 小结</h4>

<p>以上就是Ansible的核心内容， 不会特别的复杂， 但是由于模块众多的原因， 还是需要花时间去阅读具体的模块文档。</p>

<p>可以看到， Ansible真的就只是一个能够在多台主机上执行同一个任务的运维工具而已。 而在我看来， 运维最重要的并不是工具， 而是运维的体系。</p>

<p>在接下来的文章中可以看到， 当我们使用了Docker容器以后， 一个真正的自动化运维体系才算刚刚开始。 如果更进一步地使用Kubernetes的话， 甚至可以不需要Ansible。</p>

	  ]]></description>
	</item>

	<item>
	  <title>操作系统原理(01)-I/O</title>
	  <link>//operation-system-with-IO</link>
	  <author></author>
	  <pubDate>2019-04-15T10:17:46+00:00</pubDate>
	  <guid>//operation-system-with-IO</guid>
	  <description><![CDATA[
	     <p>在写了许多代码， 搭建了一些分布式服务之后， 越发觉得一个大型的高并发系统就是一个操作系统。 在分布式系统中， 我们会讲数据一致性， 如何做到缓存和DB的一致性， 这也是操作系统需要解决的问题: 内核高速页缓存如何与磁盘文件数据一致。 又比如对于一些耗时且非必需的任务， 在分布式系统中很有可能采用消息队列来进行异步处理， 例如邮件的发送， 而在操作系统中， I/O也是一个非常耗时的任务， 同样采用了异步处理的方式来最大化的利用系统资源， 只不过并不是采用消息队列而已。</p>

<!---more--->

<h4 id="1-uninx操作系统架构方式">1. Uninx操作系统架构方式</h4>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/IO/Uninx%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%96%B9%E5%BC%8F.png" alt="" /></p>

<p>如上图所示， 由于本篇文章只关心I/O， 所以只对I/O相关的内容进行了高亮处理。 操作系统的作用之一就是帮助用户管理硬件设备， 给程序员提供良好， 清晰， 优雅和一致的抽象接口。 所以， 在User Space和Hardware之间， 是由操作系统(即Kernel)进行协调的。</p>

<h4 id="2-io硬件原理">2. I/O硬件原理</h4>

<h5 id="21-io设备">2.1 I/O设备</h5>

<p>对于I/O设备而言， 通常可以分为两类: 块设备(block device)和字符设备(character device)。 块设备将信息存储在固定大小的块中， 每个块有自己的地址， 例如硬盘， U盘。 字符设备以字符为单位发送或者接收一个字符流， 不考虑任何块结构。 字符设备是不可寻址的， 也没有任何的寻道操作， 例如网卡。</p>

<h5 id="22-io设备硬件组成">2.2 I/O设备硬件组成</h5>
<p>I/O设备通常会由机械部件和电子部件组成。 机械部件为数据存储或者是数据暂存的物理介质。 电子部件我们更喜欢称之为设备控制器或者是适配器。</p>

<p>设备控制器的任务是把串行的位流转换为字符串， 并进行必要的错误校正工作。 字节块通常首先在控制器内部的一个缓冲区中按位进行组装， 然后在对校验和进行校验并证明字节快没有错误后， 再将其复制到主存中。</p>

<p>在TCP/UDP协议中， 都会有校验和来对网络传输过来的数据进行校验， 这是最低级别的校验， 通常就会在网卡， 或者说网络适配器中进行校验。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/IO/%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.png" alt="" /></p>

<h5 id="23-直接存储器存取">2.3 直接存储器存取</h5>
<p>当CPU采用内存映射I/O的方式找到了与之交换数据的控制器之后， 剩下的就是数据的存取了。</p>

<p>如果不借助任何外部硬件设备， 那么整个读取数据的过程为: CPU发出指令， 将磁盘中的某一块数据读入内存中。 磁盘的设备控制器接收到指令之后， 对磁盘进行磁臂调度， 并读取数据至设备缓冲区中进行校验， 校验通过后通过总线将数据传输至内存中。 由于CPU， 内存和磁盘之间的处理速度存在着巨大差异， 从发出指令开始， 到数据写入内存， 对于CPU而言可能觉得过了几年之久。</p>

<p>也就是说， 在CPU眼中， 处理指令只需要泡杯咖啡的时间， 而硬盘却花了几年的时间去完成。 这是CPU无法忍受的， 并且计算机系统也无法忍受， 因为在这个过程中， CPU就干等着， 什么事都做不了。</p>

<p>如果对CPU和磁盘之间的速度差仍然没有直观的感受的话， 不妨做一个数学题。 就博主电脑而言， CPU为I5 9400f， 一般运行时的频率为3.8GHZ， 也就是说在一秒的时间内能够处理<code class="highlighter-rouge">3.8*10^9</code>个指令， 每个指令平均耗时0.26纳秒。 SSD使用三星970 evo， 读取速度大概在2500M/S， 所以读取10M的数据需要0.004s,  <code class="highlighter-rouge">4*10^6</code>纳秒。 一个是0.26纳秒， 一个是4000000纳秒。 即使是三星970 evo， 读取速度达到2500M/S， 和CPU之间的差距依然是巨大的， 更不要提传统的机械硬盘了。</p>

<p>因此， 为了提高CPU的使用率， 硬件开发者为CPU找了一个帮手: 直接存储器(Direct Memory Access, DMA)。 DMA能够独立于CPU工作， 在有了DMA之后， I/O操作真正的实现了异步处理。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/IO/DMA.png" alt="" /></p>

<ol>
  <li>当CPU要读取文件时， 对DMA控制器中的寄存器进行编程， 将要读的文件地址， 字节数等数据传入DMA控制器寄存器中。 此时CPU进行进程或者是线程切换， 调度其它任务的执行。</li>
  <li>DMA控制器接收指令后向磁盘设备控制器请求数据， 并要求磁盘将数据写入到内存的一块区域内。</li>
  <li>磁盘设备控制器调用磁盘驱动程序进行数据读取， 在磁盘缓冲区组装并检验完成后， 通过总线将数据写入内存中。</li>
  <li>写入完成后磁盘设备控制器通过总线向DMA发送信号， 告之以完成相关操作。</li>
  <li>DMA控制器发起硬件中断， 如果CPU此时能够处理中断， 则处理该中断， 并完成文件读操作。</li>
</ol>

<p>通常来讲DMA控制器会直接集成至主板中， 不需要额外的热拔插。 在有了DMA协助之后， CPU无需等待整个I/O过程的结束， 而是发出一条指令后去做其它的事情， 实现了真正的并行处理。</p>

<h5 id="24-中断异常机制">2.4 中断/异常机制</h5>
<p>在上面使用了DMA的I/O中， DMA控制器是通过中断来通知CPU事件的， 而中断机制， 正是操作系统的一个非常非常重要的组成部分。</p>

<p>正是因为有了中断/异常机制， 才能够使得CPU与设备之前的并行操作。 并且， 用户在使用计算机操作系统时， 许多行为都是不可预测的， 操作系统不知道什么时候会读写文件， 什么时候会有网络数据的到来， 什么时候用户会从键盘中进行输入。 所以， 操作系统从某些方面而言， 是由中断或者是驱动的。</p>

<p>当设备(磁盘， 网卡， 键盘等)发起中断后， 如果CPU能够处理中断， 那么它就会暂停正在执行的程序， 保留现场后自动转去执行相应事件的处理程序， 处理完成后返回断点继续执行被打断的程序。</p>

<p>中断通常是由外部事件所触发， 例如DMA控制器的中断， 时钟中断或者是硬件故障产生的中断。 而异常往往是由正在执行的指令触发， 例如系统调用(用户态转为内核态, 0x80指令)， 缺页故障， 断点指令(例如程序员的断点调试)等。</p>

<h4 id="3-io软件原理">3. I/O软件原理</h4>
<p>在硬件上， 有DMA协助CPU完成并行处理， 那么软件层面的I/O又是如何实现的?</p>

<h5 id="31-c标准io库">3.1 C标准I/O库</h5>
<p>在第一小节”Uninx操作系统架构方式”一图中可以看到， 用户想要调用系统函数有两种方式， 第一种就是调用C标准库函数， 第二种就是直接进行系统调用。 简单的来讲， 在所有支持C语言的平台上， 都可以调用C标准库函数， 也就是调用方式是完全相同的， 并不区分是Unix系统还是Windows系统。 而直接进行系统调用时， 由于操作系统实现的区别， 在Uninx操作系统中使用<code class="highlighter-rouge">read/write</code>函数， 而在Windows操作系统中， 则是使用<code class="highlighter-rouge">ReadFile/WriteFile</code>函数。 所以说， 直接进行系统调用会有平台移植的问题。</p>

<p>由于本篇文章着重于原理的解释， 所以对于与I/O相关的C标准库函数不会做过多介绍。 感兴趣的读者可以参阅《Uninx环境高级编程》。</p>

<p><code class="highlighter-rouge">fgets</code>函数从制定的文件中读一行字符到调用者提供的缓冲区中:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># include&lt;stdio.h&gt;
</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">fgets</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</code></pre></div></div>

<p>参数s是缓冲区的首地址， 就是一个数组指针， size是缓冲区的长度， 该函数从stream所指的文件中读取以<code class="highlighter-rouge">\n</code>结尾的一行(包括<code class="highlighter-rouge">\n</code>)到缓冲区s内， 并且在该行末尾添加一个<code class="highlighter-rouge">\0</code>组成的完整字符串。</p>

<h5 id="32-c标准io库的缓冲区">3.2 C标准I/O库的缓冲区</h5>
<p>再来说说C标准库的I/O缓冲区， 当用户程序调用C标准I/O库函数读写文件或者是设备， 这些库函数要通过系统调用把读写请求传送给内核， 最终由内核驱动磁盘或者是设备完成I/O操作。</p>

<p>以<code class="highlighter-rouge">fgets</code>函数为例， 当用户程序第一次调用<code class="highlighter-rouge">fgets</code>函数读取一行数据时， <code class="highlighter-rouge">fgets</code>函数可能通过系统调用进入内核读取1k字节到I/O缓冲区中， 然后返回I/O缓冲区的第一行给用户， 把读写位置指向I/O缓冲区的第二行， 以后用户再调用<code class="highlighter-rouge">fgets</code>， 就直接从I/O缓冲区中读取， 而不需要再陷入内核进行读取。 当用户把这1K字节全部读完之后， 再次调用<code class="highlighter-rouge">fgets</code>时才会进入内核读取。</p>

<p>C标准库的I/O缓冲区也在用户空间， 直接从用户空间读取数据要比进入内核读取数据快得多。 另外， 如果用户调用<code class="highlighter-rouge">fputs</code>函数进行数据写入的话， 数据也只需要写到I/O缓冲区， <code class="highlighter-rouge">fputs</code>函数可以很快返回。 如果I/O缓冲区已经满了的话， <code class="highlighter-rouge">fputs</code>通过系统调用将缓冲区中的数据传入内核缓冲区中， 由内核决定何时将数据持久化至磁盘中。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/IO/C%E6%A0%87%E5%87%86%E5%BA%93%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="" /></p>

<h5 id="33-unbuffered-io函数">3.3 Unbuffered I/O函数</h5>
<p>需要注意的是， Unbuffered I/O函数是由操作系统所提供的， 位于C标准库的I/O缓冲区的底层， 也就是说， C标准I/O库函数是调用操作系统所提供的无缓冲I/O工作的。 在Uninx中， 常见的无缓冲I/O函数为<code class="highlighter-rouge">open</code>, <code class="highlighter-rouge">read</code>, <code class="highlighter-rouge">write</code>, <code class="highlighter-rouge">close</code>等。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/IO/UnbufferedIO .png" alt="" /></p>

<p>另外需要注意的是， 这里的无缓冲I/O函数指的是没有在用户空间开辟I/O缓冲区， 并不代表不使用缓冲区。 因为不管使用带缓冲的I/O函数， 还是Unbuffered I/O函数， 在内核空间中都会有I/O缓冲区。</p>

<p>现在问题来了， 用户什么时候应该选用C标准I/O库函数， 什么时候又该使用Unbuffered I/O函数呢?</p>

<ol>
  <li>使用Unbuffered I/O函数每次文件的读写都会进入内核， 调用一个系统函数要比调用一个用户空间的函数更为耗时， 所以在用户空间开辟I/O缓冲区还是很有必要的， 使用C标准I/O库函数非常的方便， 省去了自己管理I/O缓冲区的麻烦。</li>
  <li>在使用C标准I/O函数时， 由于数据是首先写入I/O缓冲区， 当缓冲区满时才会写入内核缓冲区， 所以会出现与实际文件数据不一致的情况， 在必要时调用<code class="highlighter-rouge">fflush</code>将数据强制刷入内核缓冲区中。</li>
  <li>在向网络设备写数据时我们希望数据能够通过网络及时的发送出去， 当设备接收到数据时应用程序也希望第一时间被通知到， 所以在网络编程中通常直接调用Unbuffered I/O函数。</li>
</ol>

<h4 id="4-内存映射文件">4. 内存映射文件</h4>
<p>内存映射， 简而言之就是将内核空间的一段内存区域映射到用户空间。 映射成功后， 用户对这段内存区域的修改可以直接反映到内核空间。 相反， 内核空间对这段区域的修改也直接反映用户空间。 那么对于内核空间与用户空间两者之间需要大量数据传输等操作的话效率是非常高的。 当然， 也可以将内核空间的一段内存区域同时映射到多个进程， 这样还可以实现进程间的共享内存通信。</p>

<p>系统调用<code class="highlighter-rouge">mmap()</code>就是用来实现上面所说的内存映射。 最常见的就是文件的操作， 可以将某文件映射至内存(进程空间)， 然后就可以把对文件的操作转为对内存的操作， 以此避免更多的<code class="highlighter-rouge">lseek()</code>与<code class="highlighter-rouge">read()</code>、<code class="highlighter-rouge">write()</code>操作， 因此， 在操作大文件或者是需要频繁的访问某一个文件时， 内存映射文件尤为高效。</p>

<p>这里给出一段python程序实例， 其实就是《Python Cookbook》中的例子:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">mmap</span>

<span class="k">def</span> <span class="nf">memory_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="n">mmap</span><span class="o">.</span><span class="n">ACCESS_WRITE</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDWR</span><span class="p">)</span>  <span class="c"># O_RDWR即ReadWrite</span>
    <span class="k">return</span> <span class="n">mmap</span><span class="o">.</span><span class="n">mmap</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="n">access</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">memory_map</span><span class="p">(</span><span class="s">"data.txt"</span><span class="p">)</span>
    <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="s">"Hello World"</span>
    <span class="n">m</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>

<p>需要注意的是， 对某个文件进行内存映射并不会导致整个文件被读入内存， 也就是说， 文件并不会拷贝到某种内存缓冲区或者是数组上。 操作系统仅仅只是为文件内容保留一段虚拟内存而已(虚拟内存: 磁盘与内存的交换技术)。 当程序访问文件的不同区域时， 文件的这些区域将被读取并按照需要映射到内存区域中。 但是， 文件中从未访问过的部分会简单的留在磁盘上， 并不会进入内存区域。</p>

<p>所以说， <code class="highlighter-rouge">mmap</code>拥有处理大文件的高效能力， 因为数据不再需要从内核空间拷贝至用户空间， 而是进行数据的映射。</p>

<h4 id="5-sendfile">5. sendfile</h4>
<p>关于<code class="highlighter-rouge">sendfile</code>函数的内容， 在<a href="https://smartkeyerror.com/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-04-Nginx.html">分布式系统基础学习(04)–Nginx</a>这一博文中已有描述， 此处不再赘述。</p>

<h4 id="6-阻塞与非阻塞">6. 阻塞与非阻塞</h4>
<p>为了引出事件驱动I/O模型， 关于阻塞和非阻塞的概念仍然有必要再次进行整理。</p>

<p>首先需要明确阻塞(Block)的概念。 当进程调用一个阻塞的系统函数时， 该进程被置于睡眠(Sleep)状态， 此时内核调度其它进程运行， 直到该进程的事件发生了(例如DMA发起网络传输包到来的中断， 时钟发起中断)它才<strong>有可能</strong>继续运行。</p>

<p>与睡眠状态相对的是运行(Running)状态和就绪状态(Ready)。运行状态是指进程正在被调度执行， CPU处于该进程的上下文环境中， 程序计数器里保存着该进程的指令地址， 通用寄存器里保存着该进程运算的中间结果， 正在执行该进程的指令， 正在读写该进程的地址空间。</p>

<p>就绪状态是指该进程不需要等待什么事情发生， 随时都可以执行， 只不过此时CPU还在执行另一个进程， 所以该进程在一个就绪队列中等待被内核调度。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/IO/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="" /></p>

<p>通常来讲， 调用系统函数<code class="highlighter-rouge">read</code>读取终端或者是网络设备数据时， 会被阻塞。 但是在<code class="highlighter-rouge">open</code>一个设备时指定了<code class="highlighter-rouge">O_NONBLOCK</code>标识， <code class="highlighter-rouge">read/write</code>就不会阻塞。 以<code class="highlighter-rouge">read</code>为例， 如果设备暂时没有数据可读就返回-1， 同时设置<code class="highlighter-rouge">errno</code>为<code class="highlighter-rouge">EWOULDBLOCK</code>， 表示本来应该阻塞在这里， 但是实际上并没有阻塞而是直接返回错误， 调用者应该试着再读一次， 这种方式称为轮询(Poll)。</p>

<p><strong>非阻塞I/O通常被用来监视多个设备的数据读取， 单独的I/O读取意义不大， 除非读取的内容与程序下文没有直接的联系</strong>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">非阻塞</span><span class="n">read</span><span class="p">(</span><span class="err">设备</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="err">设备</span><span class="mi">1</span><span class="err">有数据到达，</span> <span class="err">处理数据</span><span class="p">);</span>

    <span class="err">非阻塞</span><span class="n">read</span><span class="p">(</span><span class="err">设备</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="err">设备</span><span class="mi">2</span><span class="err">有数据到达，</span> <span class="err">处理数据</span><span class="p">);</span>

    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这种方式有一个比较大的缺点就是当所有的设备都没有数据到达时， 调用者反复查询做无用功， 白白浪费CPU资源。 如果说加上延时， 例如:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">非阻塞</span><span class="n">read</span><span class="p">(</span><span class="err">设备</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="err">设备</span><span class="mi">1</span><span class="err">有数据到达，</span> <span class="err">处理数据</span><span class="p">);</span>

    <span class="err">非阻塞</span><span class="n">read</span><span class="p">(</span><span class="err">设备</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="err">设备</span><span class="mi">2</span><span class="err">有数据到达，</span> <span class="err">处理数据</span><span class="p">);</span>

    <span class="p">...</span>

    <span class="n">sleep</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>虽然能够解决一些CPU资源问题， 但是<code class="highlighter-rouge">n</code>如何选取? 并且如果程序刚刚进入睡眠， 设备1的数据就准备完毕了， 那么程序也要至少等待n秒才能处理， 此时处理的延迟将会非常之大。 所以， 才会有<code class="highlighter-rouge">select</code>, <code class="highlighter-rouge">poll</code>以及<code class="highlighter-rouge">epoll</code>函数的诞生。</p>

<p><code class="highlighter-rouge">select</code>, <code class="highlighter-rouge">poll</code>以及<code class="highlighter-rouge">epoll</code>的内容将会在未来的文章中进行详细描述， 这里只是写一个引子。</p>

<h4 id="7-小结">7. 小结</h4>
<p>在本篇文章中， 主要是通过磁盘， 网卡等硬件设备的组成， 以及DMA直接存储器的原理来对操作系统的磁盘I/O进行了梳理， 列举了一些常见的函数， 例如C标准库中的<code class="highlighter-rouge">fgets</code>， C标准库底层的<code class="highlighter-rouge">read/write</code>函数。</p>

<p>需要明确一点的是， I/O操作的确是一个非常耗时的操作， 但是这是相对于应用程序而言。 而对于操作系统而言， 通过DMA以及内存映射文件等技术手段， 已经充分利用了系统资源， 只不过在执行I/O操作时， CPU在执行其余的进程， 而并非I/O应用进程。</p>

<p>对于应用程序而言， 想要提高应用的负载能力以及运行效率， 要么采用多线程的方式使得CPU在执行某一个线程的I/O操作时进行线程切换， 执行其余线程的非I/O操作， 要么采用<code class="highlighter-rouge">select</code>, <code class="highlighter-rouge">poll</code>, <code class="highlighter-rouge">epoll</code>函数来对大量非阻塞文件或者Socket的读写进行管理。</p>


	  ]]></description>
	</item>

	<item>
	  <title>分布式系统基础学习(05)--分布式缓存设计</title>
	  <link>//distributed-cache</link>
	  <author></author>
	  <pubDate>2019-04-01T10:17:46+00:00</pubDate>
	  <guid>//distributed-cache</guid>
	  <description><![CDATA[
	     <p>在单机缓存中， 并发的安全性问题与语言的并发安全问题完全可以归为一类， 缓存的穿透问题可以采用巧妙的数据结构进行处理， 很多问题本质上仍然是一些基础问题。</p>

<!---more--->

<h4 id="1-cache-aside单机缓存模式">1. Cache Aside单机缓存模式</h4>
<p>在业务应用中， Cache Aside是最常用的缓存模式。 其主要逻辑为当请求未命中缓存时， 从DB中取出数据并将其置于缓存中， 当数据发生更新时， 删除该数据所对应的缓存。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/distributed-cache/cache-aside.png" alt="" /></p>

<p>以Django框架为例， 其伪代码为:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">redis</span> <span class="o">=</span> <span class="n">Redis</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">6379</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SomeView</span><span class="p">(</span><span class="n">APIView</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="c"># 尝试获取缓存</span>
        <span class="n">response_data</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"some_key"</span><span class="p">)</span>
        <span class="c"># 缓存未命中</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">original_data</span> <span class="o">=</span> <span class="n">SimpleModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">SimpleModelSerializers</span><span class="p">(</span><span class="n">original_data</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
                <span class="n">response_data</span> <span class="o">=</span> <span class="p">{</span><span class="s">"code"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"message"</span><span class="p">:</span> <span class="s">"success"</span><span class="p">,</span> <span class="s">"data"</span><span class="p">:</span> <span class="n">data</span><span class="p">}</span>
                <span class="c"># DB数据写入缓存， 并给予15分钟的过期时间</span>
                <span class="n">redis</span><span class="o">.</span><span class="nb">set</span><span class="p">(</span><span class="s">"some_key"</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">response_data</span><span class="p">)</span><span class="err">，</span> <span class="mi">15</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
            <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c"># 标准错误处理流程</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">response_data</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SimpleModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_insert</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">force_update</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">using</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">update_fields</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># 重写Model.save方法, 在数据更新时删除失效缓存</span>
        <span class="n">redis</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s">"some_key"</span><span class="p">)</span>
</code></pre></div></div>

<p>这看起来似乎很简单， 而且Cache Aside模式能够最大程度的减少由于并发所带来的脏数据问题， 但是不能完全避免脏数据问题。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/distributed-cache/cache-aside%E8%84%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98.png" alt="" /></p>

<p>如上图所示， 更新请求和查询请求先后发出， 由于更新操作需要进行表单验证等步骤， 操作时间要长一些， 在还没有删除掉失效缓存之前， 查询请求就从缓存中取到了脏数据并返回了。 这种情况出现的概率比较低， 受到影响的也仅仅只有紧跟更新请求的几个查询操作。 尽管如此， 仍然需要对这种情况进行处理， 目前比较好的实现就是为缓存添加过期时间。</p>

<h4 id="2-高并发下带来的缓存问题">2. 高并发下带来的缓存问题</h4>
<p>仍然是使用Cache Aside模式进行缓存的设计， 考虑这样一个场景: 两个查询请求并发执行, 并且此时缓存中没有对应的数据， 那么两个查询请求很有可能会将缓存数据重复写入， 如下图所示:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/distributed-cache/%E7%BC%93%E5%AD%98%E9%87%8D%E5%A4%8D%E5%86%99%E5%85%A5.png" alt="" /></p>

<p>2个查询请求并发执行， 缓存数据很有可能被重复写入2次。 那么N个查询请求并发执行， 缓存数据也有可能被重复的写入N次。</p>

<p>对于以json数据格式作为value的缓存数据来说， 重复写入问题也不大， 无非是将前一个结果覆盖了而已。 但是对于列表对象而言， 重复写入的问题就不得不去处理了。 列表的<code class="highlighter-rouge">lpush</code>或者是<code class="highlighter-rouge">rpush</code>操作并不会覆盖原有的数据， 而是直接追加， 这样一来就会造成严重的缓存数据重复问题，  并且多次的DB查询也会对系统整体的吞吐量造成影响。</p>

<p>限制资源的请求速率以及保证资源的唯一使用， 该怎么做？ 加锁。 在Python或者是Java语言层面， 为了保证操作的原子性以及并发安全性， 通常都会使用各种各样的互斥锁， 那么在这里也不例外， 只不过此时必须使用分布式锁。 因为Web服务要么是多进程多线程并行运行， 要么是多服务器组成的集群运行， 操作层面都在进程这一层， 只能使用分布式锁。</p>

<p>分布式锁的基本思想也很简单， 多个进程在对某个资源进行修改时， 先向第三方服务申请一下， 申请通过了才能用， 没通过就等着(轮询)。 这里无意扩展分布式锁的内容， 所以就简单的使用Redis的<code class="highlighter-rouge">setnx</code>命令实现。 此时我们只需要简单的修改一下设置缓存的部分代码即可:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 从DB中获取数据并对其进行序列化操作</span>
<span class="n">original_data</span> <span class="o">=</span> <span class="n">SimpleModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">SimpleModelSerializers</span><span class="p">(</span><span class="n">original_data</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
<span class="n">response_data</span> <span class="o">=</span> <span class="p">{</span><span class="s">"code"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"message"</span><span class="p">:</span> <span class="s">"success"</span><span class="p">,</span> <span class="s">"data"</span><span class="p">:</span> <span class="n">data</span><span class="p">}</span>


<span class="k">if</span> <span class="n">redis</span><span class="o">.</span><span class="nb">set</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"some_key_lock"</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s">"1"</span><span class="p">,</span> <span class="n">ex</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">redis</span><span class="o">.</span><span class="nb">set</span><span class="p">(</span><span class="s">"some_key"</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">response_data</span><span class="p">)</span><span class="err">，</span> <span class="mi">15</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c"># 虽然对分布式锁添加了1秒的过期时间, 但是为了提高系统吞吐量, 在这里手动删除该锁</span>
        <span class="n">redis</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s">"some_key_lock"</span><span class="p">)</span>
</code></pre></div></div>

<p>是不是这样就可以了？ 并不是， 这样写在某些情况下仍然会出现问题。 我们把两个查询操作的时间稍微错开几十毫秒， 就有可能出现下图的情况:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/distributed-cache/%E7%BC%93%E5%AD%98%E9%87%8D%E5%A4%8D%E5%86%99%E5%85%A52.png" alt="" /></p>

<p>缓存数据依然被写入了两次。 其实这个问题在很多的并发场景下都会有出现， 不单单只是缓存的设计。 例如不采用枚举类所实现的单例模式， 在文章<a href="https://smartkeyerror.com/Java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B-04-%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-01.html">Java基础编程(04)–常用的设计模式(01)</a>中采用了双重校验锁的方式解决此类问题:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span>  <span class="n">SingletonClass</span> <span class="nf">getSingletonClass</span><span class="o">()</span> <span class="o">{</span>
    <span class="cm">/* 第一次校验是让实例已经被初始化之后直接返回 */</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">singletonClass</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/* 如果此时singletonClass == null, 那么就需要线程安全的实例化对象 */</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">SingletonClass</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
            <span class="cm">/* 再次判断, 此时为加锁判断, 保证变量不会被其它线程所修改, 即保持单例*/</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">singletonClass</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">singletonClass</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SingletonClass</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">singletonClass</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在这个问题中， 依然可以使用同样的方式来处理， 即在获取分布式锁之后， 更新缓存之前， 再进行一次判断。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">redis</span><span class="o">.</span><span class="nb">set</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"some_key_lock"</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s">"1"</span><span class="p">,</span> <span class="n">ex</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c"># 再次判断缓存数据是否不存在</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">redis</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"some_key"</span><span class="p">):</span>
            <span class="n">redis</span><span class="o">.</span><span class="nb">set</span><span class="p">(</span><span class="s">"some_key"</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">response_data</span><span class="p">)</span><span class="err">，</span> <span class="mi">15</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">redis</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s">"some_key_lock"</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="3-缓存穿透问题">3. 缓存穿透问题</h4>
<p>缓存穿透是指查询一个根本不存在的数据， 缓存层和存储层都不会命中， 而在通常情况下， 空数据是不会做缓存的， 基于Restful-API来讲， 此时应该直接返回404。 这样一来， 大量的无效请求都会透到DB存储层， 会给存储层带来比较大的压力。</p>

<p>这个问题的解决办法还是蛮多的， 最简单的就是缓存空数据。 依然使用上面的代码， 目光主要聚集在无效数据的处理上:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span><span class="p">:</span>
    <span class="n">original_data</span> <span class="o">=</span> <span class="n">SimpleModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">SimpleModelSerializers</span><span class="p">(</span><span class="n">original_data</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
    <span class="n">response_data</span> <span class="o">=</span> <span class="p">{</span><span class="s">"code"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"message"</span><span class="p">:</span> <span class="s">"success"</span><span class="p">,</span> <span class="s">"data"</span><span class="p">:</span> <span class="n">data</span><span class="p">}</span>
    <span class="c"># DB数据写入缓存， 并给予15分钟的过期时间</span>
    <span class="n">redis</span><span class="o">.</span><span class="nb">set</span><span class="p">(</span><span class="s">"some_key"</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">response_data</span><span class="p">)</span><span class="err">，</span> <span class="mi">15</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="c"># 标准错误处理流程</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</code></pre></div></div>

<p>在Django中， <code class="highlighter-rouge">Model.objects.get</code>操作在数据不存在时会抛出<code class="highlighter-rouge">DoesNotExist</code>的异常， 此时就可以在异常处理中将空数据进行缓存。 遗留的问题就是如果缓存中空数据非常多的话， 非常占用服务器内存， 而且这些key是能够无限增长的。 比如网站攻击， 假如用户id最大值为1000， 而攻击方生成10亿个大于1000的id进行请求， 并限制请求速率以及使用代理服务器。 那么一段时间后服务器就会有10亿个无效数据key， 这时候内存崩没崩都不好说， 系统运行效率一定是降低的。</p>

<p>为这些key设置一个较短的过期时间(比如5秒)能够解决一部分问题， 但是总的来说还是会浪费一部分内存空间。</p>

<p>另一个解决方案就是使用Bitmap。 将所有存在的key通过哈希或者其它算法写入到Bitmap数组中， 作为第一道缓存过滤器。 当请求无效数据时， 发现Bitmap中没有这个key(时间复杂度为O(1))， 直接返回空结果即可。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/distributed-cache/Bitmap%E8%BF%87%E6%BB%A4.png" alt="" /></p>

<p>只不过这种方式维护起来比较费劲， 因为需要保存所有的有效key， 如果是大规模集群缓存的话， 其复杂度以及维护成本都会相应增加。</p>

<h4 id="4-雪崩问题">4. 雪崩问题</h4>
<p>缓存雪崩问题是指当缓存层为存储层分担了绝大部分压力时， 缓存层因为服务器宕机， 网络连接异常等问题导致的崩溃， 使得所有请求全部压向存储层的现象。 此时存储层由于大量的查询而造成线程数量飙升， 连接数飙升， 内存和CPU使用率飙升， 很有可能发生系统崩溃， 导致服务大面积停机。</p>

<p>雪崩问题没有办法从代码层面去很好的解决， 只能通过高可用设计处理。 例如Redis-sentinel高可用架构， MySQL高可用架构等等， 保证系统能够及时、自动地切换节点。</p>

<h4 id="5-复制">5. 复制</h4>
<p>在分布式系统中， 由于种种原因， 例如机房故障， 负载均衡， 读写分离等， 需要将数据复制到多个副本部署到其它的机器上， 因此， Redis也提供了主从复制功能。</p>

<p>与MySQL的主从复制相比， Redis的复制功能要简单许多。 通常在主从复制的模型下， 如何发现和处理主从数据的延迟， 以及主/从节点的身份转换， 是需要我们去着重处理的。</p>

<h5 id="51-建立主从复制过程">5.1 建立主从复制过程</h5>
<p>Redis建立主从复制的方式有多种， 可以在从节点配置文件中进行配置， 也可以在从节点的客户端中进行配置。 命令只有一个:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slaveof masterHost masterPort
</code></pre></div></div>

<h5 id="52-断开复制">5.2 断开复制</h5>
<p>断开复制的命令为<code class="highlighter-rouge">slaveof no one</code>， 在从节点执行完该命令之后， 复制过程终止， 此时从节点仍然会保留原有的数据， 但是无法获取主节点的数据变化。</p>

<p>当我们在一个从节点断开复制之后， 可以与另一个节点建立主从复制的关系， 这个过程称为”切主操作”。 如果一个从节点与当前主节点断开复制关系， 与另外一个节点建立复制关系的话， 此时从节点的数据将会被完全清空。</p>

<p>举个不恰当的例子， 某一天你在网上认了一个干妹妹， 跟她分享了很多有趣的事情。 突然有一天她不想做你妹妹了， 单方面切断了这个联系， 并删除了你的微信， 所以你更新的朋友圈她是不知道的。 然后她又找了一个新的干哥哥， 抛弃了与你所有的记忆(扎不扎心， 老铁)。</p>

<p>所以， 在生产环境的切主操作要慎重进行， 避免因操作不当带来的数据损失。</p>

<h5 id="53-复制过程">5.3 复制过程</h5>
<p>Redis主从复制过程大致可以分为:</p>
<ol>
  <li>从节点保存主节点信息</li>
  <li>从节点内部的定时任务发现新的主节点， 尝试与主节点建立连接</li>
  <li>从节点发送PING命令， 检测网络是否正常连接， 主节点是否可用</li>
  <li>权限验证</li>
  <li>首次同步时进行全量数据复制</li>
  <li>数据持续复制</li>
</ol>

<p>当主节点需要密码登录时， 从节点必须设置<code class="highlighter-rouge">masterauth</code>配置项进行密码登录。 下面贴一个在建立复制时主节点的日志记录:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1060:M 16 Mar 16:05:17.727 <span class="k">*</span> Slave 127.0.0.1:6380 asks <span class="k">for </span>synchronization
1060:M 16 Mar 16:05:17.727 <span class="k">*</span> Partial resynchronization not accepted: Replication ID mismatch <span class="o">(</span>Slave asked <span class="k">for</span> <span class="s1">'695874fc4ce12a5de99170a5751f57adf33cc032'</span>, my replication IDs are <span class="s1">'8826a80c2972c469cb65688c899b07ae249f6905'</span> and <span class="s1">'0000000000000000000000000000000000000000'</span><span class="o">)</span>
1060:M 16 Mar 16:05:17.727 <span class="k">*</span> Starting BGSAVE <span class="k">for </span>SYNC with target: disk
1060:M 16 Mar 16:05:17.727 <span class="k">*</span> Background saving started by pid 1570
1570:C 16 Mar 16:05:17.729 <span class="k">*</span> DB saved on disk
1570:C 16 Mar 16:05:17.729 <span class="k">*</span> RDB: 0 MB of memory used by copy-on-write
1060:M 16 Mar 16:05:17.771 <span class="k">*</span> Background saving terminated with success
1060:M 16 Mar 16:05:17.771 <span class="k">*</span> Synchronization with slave 127.0.0.1:6380 succeeded
</code></pre></div></div>

<p>首先就是从节点127.0.0.1:6380要求进行数据同步， 然后验证从节点的Replication ID， 来判断从节点是部分数据复制还是全量数据复制， 由于这是第一个建立复制， 所以必然是全量复制。 而后执行<code class="highlighter-rouge">BGSAVE</code>操作， fork子进程生成dump.rdb文件。 从日志上可以看出， 此时RDB文件是保存在磁盘中的， 并不是直接发送给从节点。 然后， 主节点通过网络传输， 将RDB文件发送给从节点， 从节点读取并写入数据， 复制工作就此开始。</p>

<p>当主节点的子进程开始执行BGSAVE操作时， 主节点仍然会处理写请求。 那么这部分的数据该如何处理？ Redis主节点会建立复制缓冲区， 这一段时间的数据更改都会写入复制缓冲区中， 当从节点加载完RDB文件数据之后， 主节点再将复制缓冲区的内容发送给从节点。 这样一来， 就能够保证数据的完整性。</p>

<p>如果主节点创建和传输RDB的时间过长， 对于高流量写入场景非常容易造成主节点复制缓冲区溢出， 默认配置为<code class="highlighter-rouge">client-output-buffer-limit slave 256MB 64MB 60</code>， 如果在60秒内缓冲区持续大于60MB或者超出了256MB， 主节点将主动关闭与从节点的连接， 全量复制终止。 所以， 开启从节点请选择月黑风高的凌晨。</p>

<h5 id="54-复制延迟">5.4 复制延迟</h5>
<p>在主节点和从节点分别执行<code class="highlighter-rouge">info replication</code>命令可以查看此时数据复制的偏移量。 主节点为<code class="highlighter-rouge">master_repl_offset</code>， 从节点为<code class="highlighter-rouge">slave_repl_offset</code>， 单位为字节量。 使用</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>master_repl_offset - slave_repl_offset
</code></pre></div></div>

<p>能够很轻松的计算出主从复制的延迟。 当这个延迟值很高的时候， 例如20MB， 此时应用程序就需要做出反应， 暂时性的从主节点读取数据， 当延迟降低之后， 再从从节点读取数据。</p>

<h4 id="6-redis-sentinel">6. Redis Sentinel</h4>
<p>哨兵是由Redis官方所提供的高可用架构解决方案， 实现了Redis数据节点的监控， 通知以及自动化的故障转移机制。</p>

<h5 id="61-为什么需要高可用架构">6.1 为什么需要高可用架构</h5>
<p>在一个中型服务中， Redis实例的数量可能不会特别多， 拓扑结构可能为1主1从或者是1主2从。 从库主要用于数据的读取， 主库用于数据的写入， 进行读写分离。 如果此时主节点发生宕机， 那么从节点与主节点断开连接， 复制终止， 并且应用层连接不上主节点， 无法进行数据写入， 造成服务部分功能无法使用。</p>

<p>此时要做的就是将一个从节点设置为主节点， 另一个从节点进行切主操作， 并且需要修改应用的代码， 将Redis主节点ip重新修改。 这样一套流程下来， 如果顺利的话， 也需要15分钟左右。 如果不顺利， 花费的时间将会更久。 并且人为操作还有可能出现错误， 导致数据丢失。</p>

<h5 id="62-redis-sentinel高可用性">6.2 Redis Sentinel高可用性</h5>
<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/distributed-cache/Sentinel.png" alt="" /></p>

<p>如上图所示， Redis Sentinel是一种分布式多机架构， 其中包含了若干个Sentinel节点以及Redis数据节点。 这里的Redis数据节点表示主节点和从节点所组成的集合。 没一个Sentinel节点都会去监控数据节点和Sentinel节点， 当发现服务不可用时， 会对其做下线标识。 如果被标记的是主节点， 那么Sentinel节点将会和其它Sentinel节点进行投票， 当大多数节点都认为主节点不可达时， 它们会推举出一个Sentinel节点来完成自动的故障转移， 并将信息通知给应用服务。</p>

<p>同样以上图为例， 当Master节点不可用并且多数Sentinel节点确认了这个事实， 并且推举Sentinel-2来进行故障转移。 Sentinel-2随机的选取一个从节点作为新的主节点，例如Slave-1， 对其发送<code class="highlighter-rouge">slaveof no one</code>命令， 终止与原有主节点的复制， 并升级为新的主节点。 接着对Slave-2节点发送<code class="highlighter-rouge">slaveof newHost newPort</code>命令， 使其从新的Master节点进行数据复制。</p>

<h4 id="7-如何对数据进行分区">7. 如何对数据进行分区</h4>
<p>在单机缓存模式下， 当我们处理了并发请求时的数据安全性， 解决了缓存穿透以及雪崩问题， 并且对缓存中big-key进行了足够好的优化之后， 剩下面临的问题就是单机内存容量的限制。</p>

<p>首先考虑一个更加具体化的问题， MySQL单表的最佳容量约为1000万数据， 也就是说， 假设有1亿数据， 那么最佳的分表方式就是将其拆分成10个表及以上。</p>

<h5 id="71-基于关键字区间">7.1 基于关键字区间</h5>

<p>一个最简单的算法就是基于关键字区间进行分区， 例如<code class="highlighter-rouge">user_id</code>。 <code class="highlighter-rouge">user_id</code>在0-1000的写入表1， <code class="highlighter-rouge">user_id</code>在1001-200万的数据写入表2， 以此类推。 这样以来能够最大程度的维护单表数据相关性， 其缺点就是为了更均匀的分布数据， 开发人员需要找到适合数据本身分布特征的分区边界。 根据2/8法则， 贡献80%数据的用户只占所有用户的20%。 所以边界如何选取， 是基于关键字区间方法的重要因素。</p>

<h5 id="72-取模算法分区">7.2 取模算法分区</h5>

<p>另一个分区算法就是根据key进行取模。 如果拆分10个表， 就使用<code class="highlighter-rouge">user_id</code>对10进行取模， 再存储到数据对应的表中。</p>

<p>取模算法一个非常致命的问题就在于水平拓展非常复杂， 只能进行垂直拓展。 在项目设计之初， 开发人员预计某一个表中的数据最多能够到达1亿， 于是拆分了20个分区表， 这样一来系统最大能够存储2亿数据。 但是系统上线后用户量日益剧增， 很早的就达到了2亿数据。 此时再对数据进行取模， 单表存储将会超过1000万。 并且， 由于数据采用取模的方式进行存储， 如果增加分区表的话， 势必会打乱原有的存储结构， Web服务也有可能停机进行数据迁移。</p>

<p>解决这个问题也很简单， 在最初设计时， 就对分区表的数量取一个较大值， 例如100。 按照单表1000万的存储， 整体存储数据量为10亿。 我相信对于绝大部分应用而言， 10亿行数据的存储量， 是完全足够的， 再加上目前SSD不值钱， 即使是1TB的固态， 也只需要1000块。 总成本在1万以内可以搞定。</p>

<p>取模算法最大的优点就在于简单， 易操作和维护， 缺点就是水平拓展困难并且数据的分布均匀性较难保证， MySQL的简单分表方式选择取模算法是一个比较好的方法， 但是对分布式缓存来说， 其中会有一些问题出现。</p>

<p>假设目前有10台Redis缓存服务器， 编号0~9， 并使用了取模方式在这10台机上进行了数据缓存。 突然3号机挂掉了， 原本属于3号机的数据服务只能被迫转移到其它机器， 例如1号机。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">key</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
    <span class="c"># 转至1号机服务</span>
</code></pre></div></div>

<p>现在1号机也挂了， 开发人员又不得不再去整理规则， 属于1号机的服务转移至5号机…来来回回， 数据在整体集群中非常混乱， 取模的方式很难建立一个自动化故障转移的机制来处理突发情况。</p>

<h5 id="73-一致性哈希算法分区">7.3 一致性哈希算法分区</h5>
<p>一致性哈希算法能够最大程度上自动的处理数据分布不均匀问题， 并且能够提供自动化的故障转移机制。</p>

<p>通常我们会设计一个处理字符串的32位哈希函数， 当输入某个字符串时， 它会返回一个0和2^32 - 1之间近似随机的数值。 及时输入的字符非常相似， 返回的哈希值也会在上述数字范围内均匀分布。</p>

<p>既然范围限定在0～2^32-1之间， 那么对于一个哈希值， 只能取前4个字节， 这里取md5加密的前4个字节:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_result</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">"utf-8"</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()[:</span><span class="mi">8</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>
</code></pre></div></div>

<p>将需要缓存的key进行哈希操作， 并且对缓存节点的ip地址使用同样的方法进行哈希操作， 并将其置于一个环中， 如下图左侧所示:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/distributed-cache/hash-circle.png" alt="" /></p>

<p>在完成了这一部操作之后， 剩下的就是解决数据归属问题。 一致性哈希算法的思路就是找到某一个key在顺时针方向上最近的节点， 就是该key应该在的节点。 如上图所示， key1顺时针寻找， 离得最近的节点为Node1， 所以key1存储于Node1。 key2, key3存储于Node2， key4存储于Node3， key5, key6存储于Node4。</p>

<p>当我们在Node3和Node4之间新增一个节点Node5时， 受到影响的key只有Node3和Node5之间的少部分节点:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/distributed-cache/add-node.png" alt="" /></p>

<p>原本key5归属于Node4， 但是由于新增节点的缘故， 在顺时针方向上离key5最近的节点为Node5， 所以key5被重新分配了。 而在缓存这个场景下， 由于key存在过期时间， 再加上缓存数据的非相关性， 系统能够快速的将这些数据重新缓存至新的节点中， 并且只有一小部分的数据会收到影响。</p>

<p>删除节点同样只会影响一小部分的数据分布。 当删除图中的Node2节点之后,  顺时针方向上离的最近的节点为Node3， 那么缓存数据将会被重新分配至Node3节点, 如下图所示:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/distributed-cache/remove-node.png" alt="" /></p>

<p>有的时候系统中节点数据比较少， 在进行顺时针寻找节点时， 很有可能发生绝大多数key都去了同一个节点:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/distributed-cache/%E5%88%86%E5%B8%83%E4%B8%8D%E5%9D%87%E5%8C%80.png" alt="" /></p>

<p>在系统中一种有6个缓存数据， 其中有5个数据均存储在了Node2节点， 分布非常的不均匀。 解决方法为引入虚拟节点， 其实就是将一个节点的ip， 使用字符串后缀的方法哈希多个值， 产生虚拟节点， 数据在顺时针寻找节点时如果结果是虚拟节点的话， 程序做额外的处理工作， 将其存储至虚拟节点的真实节点上。</p>

<p>假如Node3的ip为<code class="highlighter-rouge">172.15.243.16</code>， 通过添加字符串后缀的方式来添加虚拟ip， 例如<code class="highlighter-rouge">172.15.243.16@1</code>, <code class="highlighter-rouge">172.15.243.16@2</code>， 目的就是让同一个节点能够产生多个哈希值， 从而使得数据分布均匀:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/distributed-cache/visual-node.png" alt="" /></p>

<p>以上就是一致性哈希算法的大致内容， 在实现上节点的存储可以采用AVL数或者是红黑树， 如果节点数量很少的话， 有序链表结构都可以。</p>

<p>一致性哈希算法在缓存设计中应用要更多一些， 一方面是因为缓存数据之间没有强关联性， 并且没有类似于关系型数据库的二级索引结构， 怎么分都可以。 更重要的是数据分布均匀性以及自动化的故障转移。</p>

<h4 id="8-一致性哈希算法的热点key问题">8. 一致性哈希算法的热点key问题</h4>
<p>虽然一致性哈希算法在引入虚拟节点后能够最大程度上的解决分区平衡问题， 但是很难处理热点数据。 一个非常极端的例子就是系统中所有缓存的读/写都是针对同一个关键字， 那么最终所有的请求都将被路由到同一个节点， 造成该节点负载急剧增加。</p>

<p>举个不恰当的例子， 微博声称目前的系统支持8位明星同时出轨(然而不能支持宣布结婚, hiahia)。 如果系统采用用户id或者是事件id作为缓存key， 几秒内的对同一个数据的读/写流量是非常巨大的。</p>

<p>热点key问题并没有一个非常好的解决方案， 只能通过应用层的scatter/gather来解决。 即对于热点的用户id或者是事件id进行随机数的添加， 将其分配至不同的分区上， 读取时再进行合并。</p>

<p>例如原本的热点key为<code class="highlighter-rouge">user_marriage_9527_list</code>, value为一个列表对象。 应用层生成[0-50)的随机数， 添加至<code class="highlighter-rouge">user_marriage_9527_list</code>的尾部， 每次的写操作都进行随机数的追加， 那么得到的key就有<code class="highlighter-rouge">user_marriage_9527_list0</code>, <code class="highlighter-rouge">user_marriage_9527_list1</code>…将这些list数据写入至不同的节点中。 在读取时， 从0到50遍历所有热点key， 结果进行合并， 去重， 返回。</p>

<p>因为读取时的额外操作， 所以通常只对极少数热点key添加随机数才有意义。</p>

<h4 id="9-小结">9. 小结</h4>
<p>分布式缓存设计是一个相当庞大的话题， 单靠一篇博文没有办法将其完整的描述， 以及对各种问题给出确切的解决方法， 所以本文也仅是在宏观角度上去分析一些最为常见的问题。</p>

<p>对于中小型服务而言， 我认为将缓存设计成为分布式并不是一个很好的选择， 能够进行垂直拓展的服务尽量先进行垂直拓展， 当垂直拓展满足不了需求之后， 再考虑分布式服务设计。</p>

	  ]]></description>
	</item>

	<item>
	  <title>一文理解Flask Web开发</title>
	  <link>//Flask-Web</link>
	  <author></author>
	  <pubDate>2019-03-31T09:49:09+00:00</pubDate>
	  <guid>//Flask-Web</guid>
	  <description><![CDATA[
	     <p>Flask作为Python语言中最为轻量的Web框架， 由于其核心内容的简洁以及良好的可拓展性， 一直受到广泛的开发者所喜爱。 对比于Django， Flask并没有”我给你的就是最好的， 别管那么多， 拿着用就好”的思想， 而是让开发者自己做出选择， 自己设计开发一个组件， 或者挑选一个你喜欢的第三方库。</p>

<!---more--->

<h4 id="1-标准web开发流程">1. 标准Web开发流程</h4>
<p>不管开发人员使用什么样的语言， Python也好， Java也好， 又或者什么样的Web框架， 从宏观上来看， 它们的开发流程都是基本相同的。</p>

<p>当服务器收到一个请求时， 首先做的就是对HTTP请求中的参数进行解析， 包括请求的URL， 请求方法， 参数以及Cookie等参数， 将其置于框架的一个内部数据结构中， 便于后续的使用。 在处理完请求参数后， 会在请求正式进入视图函数之前做一些额外处理， 例如验证CSRF-Token， 验证用户Cookie是否合法， 请求的IP是否处于白名单中， 如果验证信息未通过， 则直接返回相应的HTTP状态码以及相关信息， 增强网站的安全性。 在所有的验证通过之后， Web框架根据URL找到对应的视图函数并进行处理， 在处理过程中可能会涉及数据库， Redis以及消息队列的使用， 并很可能存在异步任务的触发。</p>

<p>在视图函数处理过程中， 很有可能因为某些操作而导致异常的产生， 此时Web应用应该判断异常产生的由来， 并进行统一的异常处理。 不管是数据库连接异常， 还是用户表单验证未通过， 都应该给出一个统一的应答， 这样便于前端的数据处理， 也能够让用户知道到底发生了什么。</p>

<p>很多时候为了便于开发人员的错误筛查， 都会在请求返回时添加日志的输出， 包括请求的URL， 请求方法， 参数， 服务器处理该请求的总时间， 请求响应状态码等信息。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/Flask/%E6%A0%87%E5%87%86Web%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="" /></p>

<h4 id="2-一个最简单的flask-demo">2. 一个最简单的Flask Demo</h4>
<p>在了解了一般性的标准Web开发流程之后， 接下来就是使用Flask来完整构建这个流程。 项目是由简入繁的， 博客也同样如此。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>                                 <span class="c"># ①</span>

<span class="n">app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/api/hello"</span><span class="p">)</span>                              <span class="c"># ②</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">"Hello World~"</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">8080</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># ③</span>
</code></pre></div></div>

<p>①: 通过传入当前<code class="highlighter-rouge">.py</code>文件的名称构建Flask核心对象， 此时app对象就有了Flask所有的核心功能， 包括添加视图函数， 添加额外的处理函数等。</p>

<p>②: 通过app对象的<code class="highlighter-rouge">route</code>方法， 使用语法糖对视图函数进行了装饰， 并传入<code class="highlighter-rouge">/api/hello</code>这个URI作为参数。 简单的理解就是当我们请求<code class="highlighter-rouge">/api/hello</code>路径时， 请求会使用<code class="highlighter-rouge">hello</code>函数作为视图函数进行处理。</p>

<p>③: 运行Flask框架， 并绑定本地<code class="highlighter-rouge">127.0.0.1:8080</code>， 以调试模式运行。</p>

<p>不管是路由注册， 还是以本地运行Flask， 都需要Flask核心对象的参与， 在Demo中也就是app对象。 在大型的Flask应用中， 同样如此， Flask核心对象将会作为中间枢纽， 由各种组件向其进行注册。</p>

<h4 id="3-blueprint">3. Blueprint</h4>
<p>对于一个中型应用而言， 通常会对各种接口进行业务上的分类。 例如一个商城， 会有user模块， product模块， order模块， coupon模块等等。 除了这些业务需要， 还有一些内部调用的接口， 比如用户分析， 订单分析等。 如果将这些接口都写在同一个文件中， 可以预见的是， 文件长度将会达到上万行。</p>

<p>所以， 不管我们使用什么样的标准来对接口进行分类， 分类都是必须要做的。 在解释Flask蓝图之前， 以Django为例， 这样更加便于理解。</p>

<p>在Django中， 模块的区分是采用app来实现的。 用户Cookie的处理是一个app， 订单是一个app， 商品相关的接口也将组成一个app。 Django在<code class="highlighter-rouge">settings.py</code>中提供了<code class="highlighter-rouge">INSTALLED_APPS</code>来帮我们自动地管理这些app， 当我们使用<code class="highlighter-rouge">django-admin startapp app_name</code>来创建一个app时， 实际上是创建了一个python package， 而在Django中， 正是通过管理python package来完成对app的管理。</p>

<p>我们只需要将package的名称添加至<code class="highlighter-rouge">INSTALLED_APPS</code>列表中即可， 剩下的模块查找工作由Django处理。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">INSTALLED_APPS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">'django.contrib.admin'</span><span class="p">,</span>
    <span class="s">'django.contrib.auth'</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="s">'user'</span><span class="p">,</span>
    <span class="s">'order'</span><span class="p">,</span>
    <span class="s">'product'</span><span class="p">,</span>
    <span class="s">'cupon'</span>
<span class="p">]</span>
</code></pre></div></div>

<p>而在Flask中， 虽然也提供了类似的机制， 但是其实现方式远没有Django这么直观， 相反的， 这也是Flask中比较难以理解的部分。</p>

<p>Blueprint就是Flask中协助我们将接口拆分成不同app的工具， 并由Flask核心对象完成对这些app的收集。 <strong>在Flask中， 并不是使用package这一粒度进行管理， 而是单一的<code class="highlighter-rouge">py</code>文件</strong>。 正是因为粒度从package缩小至了单独的<code class="highlighter-rouge">py</code>文件， 所以Blueprint的使用才看起来很复杂。</p>

<p>在有了这一基本的理解之后， 使用Blueprint就非常的简单了。 假如在<code class="highlighter-rouge">user</code>模块中， 有两个视图函数文件， 分别命令为<code class="highlighter-rouge">auth.py</code>和<code class="highlighter-rouge">info.py</code>， 其文件组织如下:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">—</span> <span class="n">user</span>
 <span class="o">|--</span> <span class="n">__init__</span><span class="o">.</span><span class="n">py</span>
 <span class="o">|--</span> <span class="n">auth</span><span class="o">.</span><span class="n">py</span>
 <span class="o">|--</span> <span class="n">info</span><span class="o">.</span><span class="n">py</span>
</code></pre></div></div>

<p>在<code class="highlighter-rouge">auth.py</code>以及<code class="highlighter-rouge">info.py</code>中均包含了一些视图函数， 由于我们对接口进行的功能拆分， 所以此时Flask核心对象就需要由Blueprint对象代替:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># auth.py</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Blueprint</span>

<span class="n">bp</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s">"auth"</span><span class="p">,</span> <span class="n">__name__</span><span class="p">,</span> <span class="n">url_prefix</span><span class="o">=</span><span class="s">"/api/auth"</span><span class="p">)</span>

<span class="n">bp</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/login"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">"POST"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="o">...</span>

<span class="n">bp</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/logout"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">"GET"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">logout</span><span class="p">():</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>同样地， 对<code class="highlighter-rouge">info.py</code>如法炮制:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># info.py</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Blueprint</span>

<span class="n">bp</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s">"info"</span><span class="p">,</span> <span class="n">__name__</span><span class="p">,</span> <span class="n">url_prefix</span><span class="o">=</span><span class="s">"/api/info"</span><span class="p">)</span>

<span class="n">bp</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/nick_name"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">"GET"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">get_nick_name</span><span class="p">():</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>现在对<code class="highlighter-rouge">user.py</code>和<code class="highlighter-rouge">info.py</code>进行了Blueprint方式地重写， 那么如何将其与Flask核心对象产生挂接? 答案是在user模块的<code class="highlighter-rouge">__init__.py</code>中对其进行注册:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># user.__init__.py</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">auth</span><span class="p">,</span> <span class="n">info</span>

<span class="k">def</span> <span class="nf">register_user</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">auth</span><span class="o">.</span><span class="n">bp</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">bp</span><span class="p">)</span>
</code></pre></div></div>

<p>此后， 只需要在创建Flask核心对象的文件中将<code class="highlighter-rouge">register_user</code>函数导入， 并传入核心对象进行调用即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># app.py</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>

<span class="kn">from</span> <span class="nn">myFlaskDemo.user</span> <span class="kn">import</span> <span class="n">register_user</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="n">register_user</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</code></pre></div></div>

<p>无论有多少个<code class="highlighter-rouge">app</code>， 都可以通过这样的方式将其注册进Flask核心对象之中， 只不过因为Blueprint是对单一的<code class="highlighter-rouge">py</code>文件进行管理的， 所以就需要比Django做更多的工作来完成这件事情， 其本质上， 都是让Flask核心对象发现这些视图函数而已。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/Flask/Blueprint%E5%AE%9E%E9%99%85%E4%BD%9C%E7%94%A8.png" alt="" /></p>

<h4 id="4-请求的参数处理">4. 请求的参数处理</h4>
<p>在使用<code class="highlighter-rouge">POST</code>方法进行请求时， 通常是使用JSON的方式进行参数传递， 那么如果我们想要取出相应的数据的话， 就势必需要对JSON数据进行<code class="highlighter-rouge">json.loads</code>操作， 转换成Python字典。 这个过程每个处理<code class="highlighter-rouge">POST</code>请求的视图函数都需要进行， 非常的麻烦， 所以我们需要想办法在请求进入视图函数之前就将数据保存在某一个地方。</p>

<p>这个时候就需要用到<code class="highlighter-rouge">before_request</code>这个函数， 同样是由Flask核心对象所提供。 <code class="highlighter-rouge">before_request</code>接收一个函数， 并在每次请求到达视图函数之前执行它。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">request</span>
<span class="kn">from</span> <span class="nn">werkzeug.datastructures</span> <span class="kn">import</span> <span class="n">ImmutableMultiDict</span><span class="p">,</span> <span class="n">CombinedMultiDict</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_request_params_from_json</span><span class="p">():</span>
    <span class="n">json_data</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">get_json</span><span class="p">(</span><span class="n">silent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">json_data</span> <span class="o">=</span> <span class="n">ImmutableMultiDict</span><span class="p">(</span><span class="n">json_data</span><span class="p">)</span>
    <span class="n">request</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">CombinedMultiDict</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="p">[</span><span class="n">json_data</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="p">]))</span>

<span class="n">app</span><span class="o">.</span><span class="n">before_request</span><span class="p">(</span><span class="n">get_request_params_from_json</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="5-约定返回格式">5. 约定返回格式</h4>
<p>数据返回格式的统一与否是检验一个Web API是否合格的最低标准， 这是一个对前端， 自己以及同事都有利的东西， 所以目前已经成为了一种标准。</p>

<p>就目前来说， 用的最多的格式就是<code class="highlighter-rouge">code, message, data</code>， 即:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"code"</span><span class="p">:</span><span class="w"> </span><span class="err">成功码</span><span class="w"> </span><span class="err">or</span><span class="w"> </span><span class="err">错误码</span><span class="p">,</span><span class="w">
    </span><span class="s2">"message"</span><span class="p">:</span><span class="w"> </span><span class="err">错误信息</span><span class="w"> </span><span class="err">or</span><span class="w"> </span><span class="err">''</span><span class="p">,</span><span class="w">
    </span><span class="s2">"data"</span><span class="p">:</span><span class="w"> </span><span class="err">...</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>以<code class="highlighter-rouge">RESTful API</code>而言， 通过HTTP响应的状态码来判断当前访问的结果， 但是呢， 部分的前端程序员对此非常不感冒， 觉得处理HTTP-code相当麻烦。 所有的请求， 不管是表单验证我失败， 还是用户未登录而访问受保护的资源， 这些情况统统给我返回200， 然后在<code class="highlighter-rouge">message</code>字段中标明原因。</p>

<p>很多时候系统出现的问题， 真的就不是技术问题， 而是眼界问题。 通常我们需要定义两个函数， <code class="highlighter-rouge">success</code>以及<code class="highlighter-rouge">fail</code>函数， 接收<code class="highlighter-rouge">code, message, data</code>参数， 调用方根据情况进行参数传递即可:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">success</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="p">{</span><span class="s">'code'</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="s">'message'</span><span class="p">:</span> <span class="s">''</span><span class="p">,</span> <span class="s">'data'</span><span class="p">:</span> <span class="n">data</span><span class="p">}</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">http_code</span><span class="p">,</span> <span class="n">mimetype</span><span class="o">=</span><span class="s">'application/json'</span><span class="p">})</span>

<span class="k">def</span> <span class="nf">fail</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="p">{</span><span class="s">'code'</span><span class="p">:</span> <span class="n">code</span><span class="p">,</span> <span class="s">'message'</span><span class="p">:</span> <span class="n">message</span><span class="p">,</span> <span class="s">'data'</span><span class="p">:</span> <span class="n">data</span><span class="p">}</span>
</code></pre></div></div>

<h4 id="6-请求日志的记录">6. 请求日志的记录</h4>
<p>这部分内容是我认为最有价值的一小节， 无数个被产品打断的瞬间， 告知某个用户的某次操作异常， 而又没有准确日志的记录， 无从排查的教训。 所以在写这部分内容时， 坐在轮椅上的我格外激动…</p>

<p>血一样的教训告诉我， 日志记录一定要全面， 谁请求了哪个URL， 请求方法是什么， 请求参数是什么， 请求响应时间多多少， 这些通通都要记录， 少一个都不行。</p>

<p>下面给出一个示例:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">record_request_log</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">now_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">request_start_time</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="s">'request_start_time'</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">user_id</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="s">'user_id'</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="n">format_str</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">'</span><span class="si">%(remote_addr)</span><span class="s">s request: [</span><span class="si">%(status)</span><span class="s">s] </span><span class="si">%(method)</span><span class="s">s, url: </span><span class="si">%(url)</span><span class="s">s, '</span>
        <span class="s">'args: </span><span class="si">%(args)</span><span class="s">s, json: </span><span class="si">%(json)</span><span class="s">s, '</span>
        <span class="s">'request_start_time: </span><span class="si">%(request_start_time)</span><span class="s">s, response_time: </span><span class="si">%(response_time)</span><span class="s">s, '</span>
        <span class="s">'user_id: </span><span class="si">%(user_id)</span><span class="s">s, '</span>
    <span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">remote_addr</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">remote_addr</span><span class="p">,</span>
        <span class="n">status</span><span class="o">=</span><span class="n">response</span><span class="o">.</span><span class="n">status</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">method</span><span class="p">,</span>
        <span class="n">url</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">url</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="p">,</span>
        <span class="n">json</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">get_json</span><span class="p">(</span><span class="n">silent</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
        <span class="n">request_start_time</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">"</span><span class="si">%</span><span class="s">Y-</span><span class="si">%</span><span class="s">m-</span><span class="si">%</span><span class="s">d </span><span class="si">%</span><span class="s">H:</span><span class="si">%</span><span class="s">M:</span><span class="si">%</span><span class="s">S"</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">())),</span>
        <span class="n">response_time</span> <span class="o">=</span> <span class="n">now_time</span> <span class="o">-</span> <span class="n">request_start_time</span> <span class="k">if</span> <span class="n">request_start_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="s">""</span>
        <span class="n">user_id</span><span class="o">=</span><span class="n">user_id</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">'response'</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">format_str</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>

<span class="n">app</span><span class="o">.</span><span class="n">after_request</span><span class="p">(</span><span class="n">record_request_log</span><span class="p">)</span>
</code></pre></div></div>

<p>同时， 为了让日志的记录更加完整， 例如ERROR日志记录到文件， 或者是通过Kafka发送给ELK日志分析平台， 所以需要对日志的格式进行额外的配置:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># log_config.py</span>

<span class="n">DEFAULT_LOGGING_CONFIGS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'version'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s">'disable_existing_loggers'</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
    <span class="s">'formatters'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'standard'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'format'</span><span class="p">:</span> <span class="s">'</span><span class="si">%(asctime)</span><span class="s">s [</span><span class="si">%(threadName)</span><span class="s">s] [</span><span class="si">%(name)</span><span class="s">s:</span><span class="si">%(funcName)</span><span class="s">s] '</span>
                      <span class="s">'[line:</span><span class="si">%(lineno)</span><span class="s">d] [</span><span class="si">%(levelname)</span><span class="s">s]- </span><span class="si">%(message)</span><span class="s">s'</span><span class="p">}</span>
    <span class="p">},</span>
    <span class="s">'handlers'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'error'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'level'</span><span class="p">:</span> <span class="s">'ERROR'</span><span class="p">,</span>
            <span class="s">'class'</span><span class="p">:</span> <span class="s">'logging.handlers.RotatingFileHandler'</span><span class="p">,</span>
            <span class="s">'filename'</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BASE_DIR</span><span class="p">,</span> <span class="s">'log'</span><span class="p">,</span> <span class="s">'error.log'</span><span class="p">),</span>
            <span class="s">'maxBytes'</span><span class="p">:</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">5</span><span class="p">,</span>
            <span class="s">'backupCount'</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s">'formatter'</span><span class="p">:</span> <span class="s">'standard'</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s">'console'</span><span class="p">:{</span>
            <span class="s">'level'</span><span class="p">:</span> <span class="s">'INFO'</span><span class="p">,</span>
            <span class="s">'class'</span><span class="p">:</span> <span class="s">'logging.StreamHandler'</span><span class="p">,</span>
            <span class="s">'formatter'</span><span class="p">:</span> <span class="s">'standard'</span>
        <span class="p">},</span>
    <span class="p">},</span>
    <span class="s">'loggers'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'root'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'handlers'</span><span class="p">:</span> <span class="p">[</span><span class="s">'error'</span><span class="p">,</span> <span class="s">'console'</span><span class="p">],</span>
            <span class="s">'level'</span><span class="p">:</span> <span class="s">'INFO'</span><span class="p">,</span>
            <span class="s">'propagate'</span><span class="p">:</span> <span class="bp">False</span>
        <span class="p">},</span>
        <span class="s">'response'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'handlers'</span><span class="p">:</span> <span class="p">[</span><span class="s">'error'</span><span class="p">,</span> <span class="s">'console'</span><span class="p">],</span>
            <span class="s">'level'</span><span class="p">:</span> <span class="s">'INFO'</span><span class="p">,</span>
            <span class="s">'propagate'</span><span class="p">:</span> <span class="bp">False</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c"># app.py</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">logging.config</span>

<span class="k">def</span> <span class="nf">create_app</span><span class="p">():</span>
    <span class="o">...</span>

    <span class="n">init_log</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">app</span>

<span class="k">def</span> <span class="nf">init_log</span><span class="p">():</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">dictConfig</span><span class="p">(</span><span class="n">DEFAULT_LOGGING_CONFIGS</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="7-flask中的应用上下文与请求上下文">7. Flask中的应用上下文与请求上下文</h4>
<p>在<code class="highlighter-rouge">AppContext</code>以及<code class="highlighter-rouge">RequestContext</code>中， 使用最多的仍然是<code class="highlighter-rouge">RequestContext</code>， 意思为请求上下文。 那么请求上下文是个什么东西?</p>

<p>在SpringBoot以及Django框架中， request对象是通过函数参数进行传递的， 比如在Django中， 通常会有这样的代码:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SomeUsefulAPIView</span><span class="p">(</span><span class="n">APIView</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span><span class="err">；</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">data</span>
        <span class="o">...</span>
</code></pre></div></div>

<p>然而在Flask中， 却不是这样的:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask_restful</span> <span class="kn">import</span> <span class="n">Resource</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="k">class</span> <span class="nc">SomeUsefulAPIView</span><span class="p">(</span><span class="n">Resource</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>

<p>request对象是通过import进行导入的， 而不是通过参数进行传递的， 这里其实就是请求上下文的表现形式。 在当前的请求线程中， Flask会保存request对象， 并能够在任意文件中通过导入的方式进行使用， 其底层依赖于werkzeug第三方库的<code class="highlighter-rouge">LocalStack</code>。</p>

<p>更进一步地， <code class="highlighter-rouge">LocalStack</code>封装底层的<code class="highlighter-rouge">Local</code>实现， 而<code class="highlighter-rouge">Local</code>对象， 其实就是一个大字典。 首先来看现象:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">werkzeug.local</span> <span class="kn">import</span> <span class="n">Local</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">Local</span><span class="p">()</span>

<span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">15</span>

<span class="k">def</span> <span class="nf">another_threading</span><span class="p">():</span>
    <span class="c"># 开启线程对foo对象的属性进行修改</span>
    <span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">20</span>

    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c"># 确保主线程打印出变量</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"another_thread: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">bar</span><span class="p">))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">another_threading</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">())</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c"># 确保t线程执行完毕</span>
    <span class="c"># 打印主线程变量值</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"main thread: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">bar</span><span class="p">))</span>  <span class="c"># 15</span>
    <span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">25</span>
</code></pre></div></div>

<p>可以看到， 在主线程中， <code class="highlighter-rouge">foo.bar</code>的值并没有受到另外一个线程的影响， 而在t线程中， 也没有受到主线程的影响， 这就是<code class="highlighter-rouge">Local</code>对象的作用: 同一个对象， 在不同的线程中拥有完全独立自主权， 并且其值不会受到其它线程的影响。</p>

<p>现在来看<code class="highlighter-rouge">Local</code>类的源码， 主要是使用Python类字典的功能， 重写<code class="highlighter-rouge">__getattr__</code>以及<code class="highlighter-rouge">__setattr__</code>方法:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Local</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">"__storage__"</span><span class="p">,</span> <span class="s">"__ident_func__"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">"__storage__"</span><span class="p">,</span> <span class="p">{})</span>  <span class="c"># 初始化__storage__变量为字典结构</span>
        <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">"__ident_func__"</span><span class="p">,</span> <span class="n">get_ident</span><span class="p">)</span>
        <span class="c"># get_ident为Python内置的函数， 其作用为获取当前线程的线程id</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__storage__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__ident_func__</span><span class="p">()][</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">ident</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ident_func__</span><span class="p">()</span>  <span class="c"># 函数调用， 获取id值</span>
        <span class="n">storage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__storage__</span>  <span class="c"># storage其实就是一个dict</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># 适用于 {"140672512972544": {"bar": "25"}}的结构</span>
            <span class="n">storage</span><span class="p">[</span><span class="n">ident</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
            <span class="n">storage</span><span class="p">[</span><span class="n">ident</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>
</code></pre></div></div>

<p>所以说， 在上面的测试代码中， <code class="highlighter-rouge">storage</code>变量的内容为:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="s">"线程id-1"</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">"foo"</span><span class="p">:</span> <span class="mi">25</span>
    <span class="p">},</span>
    <span class="s">"线程id-2"</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">"foo"</span><span class="p">:</span> <span class="mi">20</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>那么<code class="highlighter-rouge">LocalStack</code>就很好理解了， 这是一个先进后出的栈结构， 并且栈内容在不同的线程中也是不同的。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/1526973096301.png" alt="" /></p>

<p>如上图所示， 每一个请求在进入时， 都会将request对象压入当前线程的栈中， 那么在该请求的生命周期内， 任意地方都可以将该对象从栈中获取， 并且保证在当前线程中， request请求对象不会被其它线程对象所污染。</p>

<p>所以， 基于此特性， Flask只能使用多线程+协程的方式进行部署， 而不能使用以epoll为底层实现的Reactor模型部署。 所以从这方面来讲的话， 使用Flask解决C10K的问题几乎不能实现。</p>

<h4 id="8-flask-aop的使用">8. Flask AOP的使用</h4>
<p>经常听到别人搞Java的说SpringBoot的AOP多么多么NB， 多么多么厉害， 然而写Python的却是微微一笑， 这东西我们都用烂了。</p>

<p>AOP， 全称Aspect Oriented Programming， 面向切面编程， 在Python中， 装饰器就是一个最佳的面向切面编程的实现。 面向切面编程的含义就是抽离相似逻辑， 将相似的逻辑进行封装并复用， 说白了， 其实就是函数的调用:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">aspect_function</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"在f函数调用之前要做的事情"</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span>  <span class="c"># 调用函数</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"在f函数调用之后要做的事情"</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"调用f函数时出现异常时的处理逻辑"</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">aspect_function</code>函数接收一个函数对象， 并且在其调用之前， 调用之后以及调用出现异常时均作出相同的操作， 那么这些内容其实就是一个切面， 一个所有<code class="highlighter-rouge">f</code>函数调用之前， 之后都需要做的事情。</p>

<p>上面的例子稍加改动， 就是一个装饰器， 可以通过语法糖的形式来实现复用。 不管是在Django的全局异常处理， 还是在Flask中， 模型都是这样的。</p>

<p>AOP在Web框架中最常见的场景就是全局异常处理。 在视图函数中， 经常会有一些意想不到的异常抛出， 如果直接返回给用户500的话会很不友好， 所以尽量的将异常使用日志的方式记录下来， 并且返回给用户可读的内容。 而针对每一个视图函数都写一个大大的<code class="highlighter-rouge">try..except</code>太累了， 此时就有了<code class="highlighter-rouge">errorhandler</code>函数。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">setup_error_handler</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>

    <span class="nd">@app.errorhandler</span><span class="p">(</span><span class="nb">Exception</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">error_exception</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Wrong"</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">"Some wrong happened"</span>

<span class="n">setup_error_handler</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</code></pre></div></div>

<p>一个最简单的全局异常处理就此诞生， 并且由于我们传入了所有异常的爹， 即<code class="highlighter-rouge">Exception</code>类， 所以所有的Python异常都能够捕捉， 再结合前面的统一返回格式， 初步的全局异常处理就成型了。</p>

<h4 id="9-flask-migrate的使用">9. Flask-migrate的使用</h4>
<p>在日常的业务开发中， 数据库的模型不可能一成不变， 总会有新的需求导致数据模型的更改。 而在有ORM模型的Web框架中， 数据库的模型是应该随着应用层的模型代码而变动的。 也就是说， 当我们想要添加/删除某一个字段时， 不能直接在数据库中进行<code class="highlighter-rouge">alter table</code>操作， 而是修改应用层代码， 而后通过某种方式将这些改变映射到数据库中。</p>

<p>在Django中， 提供了内置的<code class="highlighter-rouge">python manage.py makemigrations/migrate</code>帮助我们完成这件事， 而在Flask中， 需要使用第三方库<code class="highlighter-rouge">flask-migrate</code>以及<code class="highlighter-rouge">flask-scrip</code>。</p>

<p>首先来定义一个简单的模型:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TimeMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">created</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">DateTime</span><span class="p">(),</span> <span class="n">default</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>
    <span class="n">updated</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">DateTime</span><span class="p">(),</span> <span class="n">default</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">onupdate</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">deleted</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Boolean</span><span class="p">(),</span> <span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span> <span class="n">TimeMixin</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">autoincrement</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">nickname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">24</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">phone_number</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div></div>

<p>当然， 在首次部署项目时， 可以在代码中直接使用<code class="highlighter-rouge">db.create_all(app)</code>的方式来完成数据模型的写入， 但是这种方式过于僵硬， 无法回滚， 也无法添加新的字段。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pip</span> <span class="n">install</span> <span class="n">flask</span><span class="o">-</span><span class="n">sqlalchemy</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">flask</span><span class="o">-</span><span class="n">migrate</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">flask</span><span class="o">-</span><span class="n">script</span>
</code></pre></div></div>

<p>创建<code class="highlighter-rouge">manage.py</code>文件， 并写入以下内容:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask_script</span> <span class="kn">import</span> <span class="n">Manager</span>
<span class="kn">from</span> <span class="nn">flask_migrate</span> <span class="kn">import</span> <span class="n">Migrate</span><span class="p">,</span> <span class="n">MigrateCommand</span>

<span class="kn">from</span> <span class="nn">app</span> <span class="kn">import</span> <span class="n">create_app</span><span class="p">,</span> <span class="n">db</span>

<span class="n">migrate</span> <span class="o">=</span> <span class="n">Migrate</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>

<span class="n">manager</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
<span class="n">manager</span><span class="o">.</span><span class="n">add_command</span><span class="p">(</span><span class="s">'db'</span><span class="p">,</span> <span class="n">MigrateCommand</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">manager</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div></div>

<ul>
  <li>初始化migrations package:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">python</span> <span class="n">manage</span><span class="o">.</span><span class="n">py</span> <span class="n">db</span> <span class="n">init</span>
</code></pre></div></div>

<ul>
  <li>创建migration文件(相当于Django中的makemigrations)</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">python</span> <span class="n">manage</span><span class="o">.</span><span class="n">py</span> <span class="n">db</span> <span class="n">migrate</span> <span class="o">-</span><span class="n">m</span> <span class="s">"initial migrate"</span>
</code></pre></div></div>

<ul>
  <li>将migration文件映射至数据库中(相当于Django中的migrate)</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">python</span> <span class="n">manage</span><span class="o">.</span><span class="n">py</span> <span class="n">db</span> <span class="n">upgrade</span>
</code></pre></div></div>

<p>此后对模型的修改， 只需要执行<code class="highlighter-rouge">python manage.py db migrate -m "Some useful message"</code>以及<code class="highlighter-rouge">python manage.py db upgrade</code>即可。</p>

<h4 id="10-小结">10. 小结</h4>
<p>其实Web开发讲究的就是一个套路， 当把一个Web框架理解清楚了之后， 其余的都大同小异， 当然这里指的是同步类Web框架， 诸如Tornado,  Netty则不属于此列， 它们由于底层机制的不同， 要更为复杂一些。</p>

<p>有时候看待Web框架也需要使用AOP的思想， 抽离相似的逻辑， 并用此逻辑去学习各种各样的框架， 这种方式在我看来比首先深入了解细节要更加高效， 因为实现细节必定有所差异， 而本质原理却基本类似。</p>

	  ]]></description>
	</item>

	<item>
	  <title>那些有趣的数据结构与算法(03)--并查集</title>
	  <link>//UnionFind</link>
	  <author></author>
	  <pubDate>2019-03-25T15:02:02+00:00</pubDate>
	  <guid>//UnionFind</guid>
	  <description><![CDATA[
	     <p>在《算法》(第四版)的第一章最后一小节中， 也就是”案例研究: union-find算法”这一小节， 我看到了并查集。 在我完整的阅读了所有的算法内容之后， 脑子里只剩下两个字: 优美。</p>

<!---more--->

<h4 id="1-为什么需要union-find算法">1. 为什么需要union-find算法</h4>
<p>小A的人际关系非常之广， 拥有非常多的朋友， 同时， 他的朋友也有很多朋友。 如果两个人是朋友关系的话就记为a-b。</p>

<p>小A的人际关系可以表示为： A-C A-E A-F A-P A-M A-O A-K…而他的一些朋友的人际关系可以表示为 S-W M-I M-O M-T O-Y O-C E-G…小A朋友的朋友的人际关系可以表示为 K-P K-B X-U Z-O…</p>

<p>通过这样的方式整理出了小A的所有人际关系连接， 以及小A的朋友的人际关系连接。 现在我想要知道， 某一位同学能不能推荐给小A。 例如A-C C-F， 小C是A, F的共同好友， 尽管A, F两人不是朋友关系， 但是由于小C这层枢纽的存在， 很有可能使得他们成为朋友。 也就是说， 需要判断A， F两者之间的连通性， 从而生成推荐朋友的功能。</p>

<p>在一个大型网络系统中， 如果节点A与节点C连接， 记为A-C。 如果节点A既与节点C由于节点B连接的话， 我们可以说节点B和节点C是连接的。 给定相当数量节点连接情况， 判断出系统中任意两个节点是否连接。</p>

<p>很明显的， union-find算法就是解决这一类问题的: 动态连接问题。 连接问题在上面已经描述过了， 那么动态是什么意思？ 人和人之间的人际关系不是一成不变的， 系统中节点的连接状态也不是一成不变的。 在某些情况下， 两个完全不相关的人成为了朋友， 此时我们就需要处理这些连接， 并重新判断连接性， 这就是动态性。</p>

<h4 id="2-设计union-find算法">2. 设计union-find算法</h4>
<p>既然是解决系统中的连接性， 那么最基本的API就是判断两个元素是否处于连接状态， 如果两个元素的标识位是相同的， 我们就可以判断它们是连通的， 所以需要额外的一个查找API。 此外， 还要提供将两个元素连接的API。</p>

<p>那么整体的API设计就是这样:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UnionFind</span><span class="o">:</span>
    <span class="n">UnionFind</span><span class="o">(</span><span class="kt">int</span> <span class="n">N</span><span class="o">)</span>                  <span class="c1">// 初始化节点</span>
    <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span>          <span class="c1">// 连接p, q</span>
    <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">)</span>                   <span class="c1">// 查找p的标志位</span>
    <span class="kt">boolean</span> <span class="nf">connected</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span>   <span class="c1">// 判断p, q是否连接</span>
</code></pre></div></div>

<p>整体的算法基于什么样的基本数据结构呢？ 数组， 链表还是树？ 数组的下标以及数组中所存储的元素会有一种对应。 例如<code class="highlighter-rouge">data[0] = 1</code>， 我们可以认为0这个节点的标识是1。 如果又有<code class="highlighter-rouge">data[12] = 1</code>， 节点12的标识位也是1， 此时可以判断节点0和节点12是连接的。</p>

<p>如果采用数组实现， 连接p, q两个节点又该如何操作？ 一个非常简单的做法就是将节点p的标志位设置为节点q的标志位， 使两者的标识位同步即可。</p>

<p>在数组初始化的时候就有:
<img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/union-find/Screenshot%20from%202019-03-12%2009-37-46.png" alt="" /></p>

<p>那么<code class="highlighter-rouge">UnionFind</code>类的初始化过程就非常简单了， 申请容量为N的数组， 逐一赋值即可:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UnionFind</span><span class="o">:</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">data</span><span class="o">;</span>
    <span class="n">UnionFind</span><span class="o">(</span><span class="kt">int</span> <span class="n">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<h5 id="21-quick-find算法">2.1 quick-find算法</h5>
<p>quick-find算法的思路是这样的: 使用数组的索引作为节点， 数组索引所对应的值作为节点标识。 在连接p, q两个节点时， 首先查找p, q两个节点的标识位， 将所有与p连接的节点的标识位改为q的标识位。 图示过程如下:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/union-find/quick-find.png" alt="" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">data</span><span class="o">[</span><span class="n">p</span><span class="o">];</span>  <span class="c1">// 返回节点p的标志位</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">pID</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">qID</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pID</span> <span class="o">==</span> <span class="n">qID</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

    <span class="c1">// 遍历所有与节点q标识位相同的节点, 并将其标识位改为q的标识位</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">pID</span><span class="o">)</span>
            <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">qID</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>为什么这个算法称为quick-find呢？ 因为在查找过程中， 采用的是直接取数组下标的方式， 时间复杂度为O(1)， 而union操作则需要遍历整个数组， 其时间复杂度为O(n)。</p>

<h5 id="22-quick-union算法实现">2.2 quick-union算法实现</h5>
<p>虽然quick-find算法拥有较高的查找效率， 但是其union操作效率较低， 所以通常会使用quick-union算法来实现并查集。</p>

<p>quick-union算法的思路是将每一个元素看成是一个节点， 将数组整理成为一个树结构， 并由孩子节点指向父亲节点。</p>

<p>在初始化数组的时候， 我们说数组的索引代表了节点本身， 而数组的索引值代表了节点的标识位。 而现在， 数组的索引值不再代表节点的标识位了， 而是代表其父节点。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/union-find/Screenshot%20from%202019-03-12%2010-10-29.png" alt="" /></p>

<p>如上图所示， 首先我们将节点3与节点2连接， 按照孩子指向父亲的原则， <code class="highlighter-rouge">data[3] = 2</code>。 再将节点1与节点3进行连接， 此时节点3不直接与节点1进行连接， 而是与节点1的父亲节点进行连接， 也就是节点2， 所以就有<code class="highlighter-rouge">data[1] = 2</code>。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/union-find/Screenshot%20from%202019-03-12%2010-14-17.png" alt="" /></p>

<p>在上图中， 我们让节点8和节点2进行连接， 它们不会直接连接， 因为节点8还有父节点5， 让节点5和节点2进行连接。 由于节点5和节点2都是父节点， 所以节点5可以直接指向节点2。 此时数组内的数据情况为:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/union-find/Screenshot%20from%202019-03-12%2010-20-51.png" alt="" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 循环查找父节点</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">data</span><span class="o">[</span><span class="n">p</span><span class="o">])</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">p</span><span class="o">];</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 此时find操作得到的结果是两个节点的根节点</span>
    <span class="kt">int</span> <span class="n">pRoot</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">qRoot</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">pRoot</span> <span class="o">==</span> <span class="n">qRoot</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

    <span class="n">data</span><span class="o">[</span><span class="n">pRoot</span><span class="o">]</span> <span class="o">=</span> <span class="n">qRoot</span><span class="o">;</span>  <span class="c1">// 使p的父节点指向q的父节点</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="3-quick-union算法的优化">3. quick-union算法的优化</h4>
<h5 id="31-基于树高的优化">3.1 基于树高的优化</h5>
<p>B-Tree之所以非常高效的原因， 是因为其树高最多只有4层(树叶因子如果是500的话， 此时可容纳250T的数据)， 那么对于我们的数组树结构来说， 虽然没有指针， 但是逻辑上仍然是一颗树， 所以对树高的优化非常有必要。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/union-find/Screenshot%20from%202019-03-12%2010-43-00.png" alt="" /></p>

<p>如上图所示， 如果是左侧根节点指向右侧根节点的话， 整体树高为4。 而如果是右侧根节点指向左侧根节点的话， 整体树高为3。 所以我们需要额外的增加一些数据， 来记录每棵树的树高。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UnionFind</span><span class="o">:</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">data</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">rank</span><span class="o">;</span>

    <span class="n">UnionFind</span><span class="o">(</span><span class="kt">int</span> <span class="n">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">N</span><span class="o">]</span>
        <span class="nf">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">rank</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// 初始化时每棵树的高度均为1</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>那么在<code class="highlighter-rouge">union</code>方法中， 就需要进行一些比较。 将树高低的指向树高高的即可。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">pRoot</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">qRoot</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">pRoot</span> <span class="o">==</span> <span class="n">qRoot</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">pRoot</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="o">[</span><span class="n">qRoot</span><span class="o">])</span>
        <span class="n">data</span><span class="o">[</span><span class="n">pRoot</span><span class="o">]</span> <span class="o">=</span> <span class="n">qRoot</span><span class="o">;</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">pRoot</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="o">[</span><span class="n">qRoot</span><span class="o">])</span>
        <span class="n">data</span><span class="o">[</span><span class="n">qRoot</span><span class="o">]</span> <span class="o">=</span> <span class="n">pRoot</span><span class="o">;</span>
    <span class="k">else</span> <span class="o">{</span>  <span class="c1">// 当两棵树的树高相同时， 谁指向谁都一样， 树高必定会增加</span>
        <span class="n">data</span><span class="o">[</span><span class="n">pRoot</span><span class="o">]</span> <span class="o">=</span> <span class="n">qRoot</span><span class="o">;</span>
        <span class="n">rank</span><span class="o">[</span><span class="n">qRoot</span><span class="o">]</span> <span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="32-路径压缩">3.2 路径压缩</h5>
<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/union-find/Screenshot%20from%202019-03-12%2010-56-03.png" alt="" /></p>

<p>图中3种树结构都表达了同一个意思， 节点5， 7， 10， 8互相连接， 且根节点都为5。 虽然表达的意思相同， 但是它们在union和find操作上的效率却不尽相同。 很明显的， 最右侧的树有着最高的操作效率， 这也是路径压缩需要做的事情。</p>

<p>这个过程其实很简单， 只需要执行<code class="highlighter-rouge">data[p] = data[data[p]]</code>即可。 也就是说， 让某一个节点指向父节点的父节点， 这样一来树高就能减少一层。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">data</span><span class="o">[</span><span class="n">p</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">data</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">data</span><span class="o">[</span><span class="n">p</span><span class="o">]];</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">p</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="4-小结">4. 小结</h4>
<p>union-find算法主要是为了解决连通问题， 从实际角度上来讲， 使用频率并不是很高。 但是其利用数组所构建的树结构却是整个算法最为精妙的部分， 同时也体现出了数组这个基本数据结构的强大威力。</p>


	  ]]></description>
	</item>

	<item>
	  <title>那些有趣的数据结构与算法(02)--Bitmap</title>
	  <link>//Bitmap</link>
	  <author></author>
	  <pubDate>2019-03-18T15:02:02+00:00</pubDate>
	  <guid>//Bitmap</guid>
	  <description><![CDATA[
	     <p>在我刚接触Python这门开发语言时， 并没有想用它做Web后端开发， 而是拿来写爬虫。 第一个接触的爬虫框架就是Scrapy。 网络爬虫绕不开的一个话题就是URL去重问题。 在Scrapy原生框架下， 使用的是集合来对URL进行去重的。 集合本身采用哈希表实现， 是一种典型的以空间换时间的数据结构， 当URL数量极为庞大时， 使用这种策略的去重很有可能导致内存溢出而造成服务器宕机的问题。 此时， Bitmap走进了我的视线。</p>

<!---more--->

<h4 id="1-什么是bitmap">1. 什么是Bitmap</h4>
<p>现代计算机使用二进制来作为信息存储和传输的基本单位， 由于计算机是老美发明的， 他们只需要使用A-Z这26个英文字母， 再加上一些字符， 就可以表达所有的文字内容了。 所以就有了ASCII编码， 使用8个bit(位)来表示一个byte(字节)。</p>

<p>例如”Hey”这个字符， 是由3个字节所组成的， 分别是’H’, ‘e’, ‘y’， 所对应的ASCII码分别是72， 101， 121。 将其转换成二进制， 分别为01001000， 01100101， 01111001。 也就是说， “Hey”这个单词， 在底层存储时， 是使用010010000110010101111001来进行存储的。</p>

<p>在了解了这些内容之后， 再来看如何通过Bitmap来进行URL去重。 假如对于<code class="highlighter-rouge">https://smartkeyerror.com/</code>这个URL， 我们对其进行某种编码操作， 让它变成一个数字， 例如12； 对于<code class="highlighter-rouge">https://smartkeyerror.com/categories/</code>这个URL采用同样的编码方式， 将其变为一个数字， 例如7…以此类推， 有10亿个URL， 就有10亿个数字。</p>

<p>在上面我们得到了两个数字， 一个是12， 一个是7， 分别代表了两个URL。 接下来构建一个以位为单位的数组， 将这两个URL所代表的数字作为数组索引， 修改其值为1， 得到的结果就是这样的：</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Blog/BitMap%E7%BC%96%E7%A0%81.png" alt="" /></p>

<p>如果爬虫再次爬取了<code class="highlighter-rouge">https://smartkeyerror.com/</code>这个URL， 通过编码得到了12， 发现这个数组索引为12的元素值为1， 那么就知道这个URL已经被爬取过了， 不会再次进行爬取， 也就达到了去重的作用。</p>

<p>在图中， 位所组成的数组有16个元素， 即能够表示16个URL， 占用空间仅有2个字节。 如果有10亿个URL， 占用空间为 10×10^8 / 8 = 125×10^6字节， 约为125M， 对内存要求非常之低。</p>

<h4 id="2-bitmap的实现">2. Bitmap的实现</h4>
<p>如果是自己使用Python或者是Java来实现Bitmap这种数据结构的话， 还是比较麻烦的， 所以能够捡现成的用最为合适， 如果现成的不符合特定的需求的话， 自己实现也不迟。</p>

<p>Redis所实现的Bitmap接口相当的简单：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 设置值</span>
setbit key offset value
<span class="c"># 获取值</span>
getbit key offect
</code></pre></div></div>

<p>Bitmap除了能够用来进行数据去重以外， 还可以做一些统计功能。 例如用户每天对网站的访问情况， 使用用户id作为Bitmap的偏移量， 如果访问了， 将其值修改为1：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setbit user_access_2019-03-10 15 1
setbit user_access_2019-03-10 25 1
setbit user_access_2019-03-10 1688 1
</code></pre></div></div>

<p>上面的3条命令表示在2019-03-10这天， id为15， 25， 1688的用户访问了网站。 通过使用<code class="highlighter-rouge">bitcount</code>命令可以很方便的统计出当天总访问用户是多少：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bitcount user_access_2019-03-10
</code></pre></div></div>

<p>并且， Redis提供的Bitmap实现支持4种运算操作， 分别是and(交集), or(并集), not(非), xor(异或)， 并将结果保存至destkey中。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bitop option destkey key1 key2 .....
</code></pre></div></div>

<p>例如， 查看2019-03-10和2019-03-09这两天都访问了网站的用户数量：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bitop and user_access_2019-03-09_10 user_access_2019-03-09 user_access_2019-03-10
</code></pre></div></div>

<h4 id="3-利用bitmap实现网站标签统计">3. 利用Bitmap实现网站标签统计</h4>
<p>这几天在拉钩上更新了自己许久未更的简历， 发现多了一个功能: 综合能力。 这一项需要我们从众多的能力标签中选出5个符合自己能力的标签， 例如沟通协调能力， 自驱动， 抗压能力等等。 自然， 我们可以用一个数组列表来对这些标签进行存储并展示， 但是在数据统计时， 就会有些麻烦了。</p>

<p>如果采用列表存储标签的方法来做的话， 想要统计给自己打上”自驱动”标签的用户数量是多少， 或者是哪个标签是用户作为喜爱的标签等等， 这些统计功能很难展开。</p>

<p>这个时候Redis实现的Bitmap就派上用场了， 假如标签有self-driven， communication-skills， work-well-under-pressure等等， 同样采用用户id作为偏移量:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setbit self-driven 15 1
setbit self-driven 2544 1

setbit communication-skills 15 1
setbit communication-skills 268 1

setbit work-well-under-pressure 125 1
</code></pre></div></div>

<p>统计”自驱动”标签的用户数量:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bitcount self-driven
</code></pre></div></div>

<p>统计最热门的标签:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bitcount self-driven
bitcount communication-skills
bitcount work-well-under-pressure
<span class="c"># 得到结果之后将其整理成为一个字典， 扫描该字典即可得到结果</span>
</code></pre></div></div>

<h4 id="4-利用bitmap对大文件进行排序">4. 利用Bitmap对大文件进行排序</h4>
<p>这一小节的应用就比较功利了， 因为对磁盘大文件进行排序， 并且限制了内存使用不能超过50M的情况下， 在日常开发中出现的频次还是极低的。</p>

<p>问题描述: 一个最多包含1000万个正整数的文件， 每个数的大小都小于10000000， 且数据没有重复。 如何在内存使用小于50M的情况下， 对该文件进行排序。</p>

<p>由于内存以及效率的限制(使用归并排序会造成多次磁盘读取)， 这个问题最佳的解决方案就是使用Bitmap。 在内存中建立一个包含有1000万个bit的数组， 依次写入文件中的数字， 而后再顺序输出即可。 伪代码如下:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 初始化bit数组</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">bit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c"># 数据逐行写入bit数组</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">bit</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c"># 数据逐个输出</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">write</span> <span class="n">i</span> <span class="n">on</span> <span class="n">output</span> <span class="nb">file</span>
</code></pre></div></div>

<h4 id="5-小结">5. 小结</h4>
<p>我记得Bitmap这个数据结构在Java中有内置的实现， 并且Guava包也对Bitmap进行了实现和优化， 至于Python,  似乎只有第三方包实现了该结构。 总的来说我们不用从零开始去编写， Redis也为我们提供了丰富的API。</p>

<p>Bitmap最常用的场景依然是海量数据的去重以及判断某一个数是否在海量数据当中， 除此之外就是日常的小功能实现， 例如标签统计， 网站访客信息记录等等。</p>


	  ]]></description>
	</item>


</channel>
</rss>
