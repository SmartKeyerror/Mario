<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description>Keep coding, Keep curiosity</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>动态规划(01)——从斐波那契到硬币找零</title>
	  <link>//dp(01)</link>
	  <author></author>
	  <pubDate>2020-12-23T15:50:25+00:00</pubDate>
	  <guid>//dp(01)</guid>
	  <description><![CDATA[
	     <p>动态规划是算法中一个非常有趣的 Topic，由于其具有非常强的灵活性，所以在面试时也会被经常提及到。动态规划问题我更喜欢称之为递推，因为其本质就是利用“历史数据”进行下一步的推导。</p>

<!---more--->

<h3 id="1-从斐波那契数列中找到-dp-模板">1. 从斐波那契数列中找到 DP 模板</h3>
<p>斐波那契数列虽然简单，但是却蕴含着求解动态规划问题最基本的“模板”。<strong>经典问题之所以是经典问题，就是因为它足够的简单，并且能够阐述事件的本质。</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 计算第 n 个斐波那契数
</span><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>99% 的程序员闭着眼睛都能写出上面的递归程序，但是如果我们运行这个程序的话，就会发现当 <code class="highlighter-rouge">n</code> 等于 50 的时候，程序需要花费几十秒的时间才能输出结果（有没有兄弟用 Apple M1 试下…）。为什么需要这么长的时间?我们以 <code class="highlighter-rouge">fib(10)</code> 为例，画出递归树:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/dp/1607063524499.png" alt="Alt text" /></p>

<p>如上图所示，仅部分的递归过程我们就进行了大量的重复计算，这些重复计算正是导致 <code class="highlighter-rouge">fib()</code> 函数运行缓慢的根本原因。为了解决这个问题，我们通常会使用缓存的方式避免同一个值计算多次。</p>

<p><strong>上文中的“重复计算”其实就是动态规划问题中的“重叠子问题”，通过缓存的方式避免同一个值被计算多次也有一个专门的名称，称之为“记忆化搜索”。</strong></p>

<p>现在，我们来通过缓存的方式来优化我们的 <code class="highlighter-rouge">fib()</code> 函数。原理非常简单，我们使用一个数组来保存已经计算过的结果值。在递归过程中，如果该值已经被计算了，直接返回，否则进入计算流程:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fibUseMemory</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">memory</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">memory</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">return</span> <span class="n">memory</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">fibUseMemory</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibUseMemory</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">memory</span><span class="p">);</span>
    <span class="n">memory</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当我们加入了记忆化搜索以后，计算结果秒出，因为我们将时间复杂度从 O(2^n) 优化到了 O(n) 级别。<strong>这就是求解动态规划问题的第一种方式: 自顶向下的记忆化搜索</strong>。这种方式常常作为思考动态规划问题的首要方向，有时候我们不能一眼或者短时间内找出递推关系式，那么不妨先使用记忆化搜索的方式给出一个可行解，然后再进一步地优化。</p>

<p>再来看自底向上的递推实现，斐波那契的数学表达式为: <code class="highlighter-rouge">f(x) = f(x-1) + f(x-2)</code>，对于递归实现而言，我们可以认为是“从左至右”的实现，例如如果我们要计算 <code class="highlighter-rouge">f(5)</code>，得先计算 <code class="highlighter-rouge">f(4)</code> 和 <code class="highlighter-rouge">f(3)</code>，结果由操作系统栈帧临时保存，最终再汇总结果。那么同样的，如果我们已知 <code class="highlighter-rouge">f(3)</code> 和 <code class="highlighter-rouge">f(4)</code> 的结果的话，就能够推导出 <code class="highlighter-rouge">f(5)</code> 的值，这种递推的方式其实就是动态规划。</p>

<p><strong>说白了，动态规划就是根据已有的数据，来推导出下一个结果的值。</strong>所以我们必须要明确值和值之间的关联关系。对于斐波那契数列而言，非常简单，毕竟推导式都告诉你了:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fibUseDP</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">memory</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">memory</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>       <span class="c1">// 边界情况处理
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>        <span class="c1">// 递推过程
</span>        <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">memory</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在，我们就可以总结出动态规划问题的解题“四部曲”了:</p>

<ol>
  <li>对于没有头绪的问题首先尝试“自顶向下”的递归实现，使用记忆化搜索的方式优化时间。同样地，“自顶向下”的思考也能够为我们找出递推关系式提供帮助。</li>
  <li>明确我们的题目是使用一维数组还是二维数组递推，这与题目中的变量数相关。然后确切的明白 <code class="highlighter-rouge">memory[i]</code> 或者是 <code class="highlighter-rouge">dp[i]</code> 到底表达了什么。</li>
  <li>明确 <code class="highlighter-rouge">memory[i]</code> 或者是 <code class="highlighter-rouge">dp[i]</code> 和之前数据的关联关系，这是最难的一步，也是动态规划问题灵活多变的根本原因。</li>
  <li>找到了关联关系以后，再处理一下边界情况即可。</li>
</ol>

<p>我们尝试按照上面的步骤来解决一道非常经典的问题: <a href="https://leetcode.com/problems/coin-change/">Coin Change</a>。给定一堆面额不同的硬币，每一种面额的硬币可以使用多次，现在问你如何用最少的硬币数量来凑成 <code class="highlighter-rouge">amount</code>。例如硬币面额有1块、2块和5块，凑够 11 块钱则最少需要3个硬币: 两个5块的，和1个1块的。</p>

<p>当我们什么思路都没有的时候可以先使用一些特定的实例来帮助我们打开思路。所以，我们假设硬币面额为 <code class="highlighter-rouge">[1, 2, 5]</code>，<code class="highlighter-rouge">amount</code> 为 36。</p>

<p>对于 36 块的总额以及三种面额的硬币，我们可以有 3 种方式去凑齐: 35 + 1，34 + 2，31 + 5。这样一来我们使用了一个硬币，换来了一个更小规模的问题，不断地递归下去，就能够得到所有解，然后我们在其中选出最小硬币数量的解即可。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/dp/1606892674971.png" alt="Alt text" /></p>

<p>递归树如上图所示，显然，这是一棵多叉树的遍历，多叉树的遍历模板是什么来着?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">child</span> <span class="n">in</span> <span class="n">node</span><span class="p">.</span><span class="n">childs</span>
        <span class="n">traversal</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>并且，遍历的过程中有许多重复的计算，需要使用记忆化搜索的方式来优化时间，再结合上面的遍历模板，答案就呼之欲出了:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">memorySearch</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">memory</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">memory</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="n">memory</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">coin</span><span class="o">:</span> <span class="n">coins</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">memorySearch</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">coin</span><span class="p">,</span> <span class="n">memory</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">sub</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">memory</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span> <span class="o">==</span> <span class="n">INT_MAX</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们重点关注一下下面的代码片段:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">coin</span><span class="o">:</span> <span class="n">coins</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">memorySearch</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">coin</span><span class="p">,</span> <span class="n">memory</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">sub</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于当前的 <code class="highlighter-rouge">amount</code> 值来说，我们需要把所有的硬币都试一遍，找到最小数量的那一枚硬币面额。如此一来，我们就能够明白递推公式了:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/dp/1606894340039.png" alt="Alt text" /></p>

<p>很好理解，对于总额度为 5 来说，我们能从 4 块钱凑 1 块达到，也可以从 3 块钱凑 2 块达到，同时可以直接掏出一枚 5 块的硬币，在这 3 种可能之间找出最小值即可。所以，<code class="highlighter-rouge">memory[i]</code> 就表示凑够金额为 <code class="highlighter-rouge">i</code> 所需要的最少硬币数量，边界情况当然是 <code class="highlighter-rouge">i == 0</code> 了，此时不需要任何一种硬币，所以为 0。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">coinChange</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">coins</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">coins</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>       <span class="c1">// 排序便于减枝
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">memory</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
    <span class="n">memory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                          <span class="c1">// 边界条件处理
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">coin</span><span class="o">:</span> <span class="n">coins</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">coin</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">coin</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">)</span>
                <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">coin</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">memory</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">memory</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其实，Coin Change 问题本质上就是 <a href="https://leetcode.com/problems/climbing-stairs/">Climbing Stairs</a> 的改版，Climbing Stairs 也就是经典的小青蛙跳台阶问题。如果把 Coin Change 的问题换成“使用这些硬币凑够<code class="highlighter-rouge">amount</code>一共有多少种凑法”的话，就是妥妥的小青蛙跳台阶的多叉树版本（小青蛙跳台阶是一个二叉树遍历问题）。</p>

<p>别说，leetcode 上还真有这样的问题: <a href="https://leetcode.com/problems/combination-sum-iv/">Combination Sum IV</a></p>

<blockquote>
  <p>给定一个 nums 数组，其中的元素可以使用任意多次，输出和为 target 的全部组合数量</p>
</blockquote>

<p>这和硬币找零问题几乎一模一样，只是换了一个问法而已。题解可见:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/blob/master/leetcode/dynamic-programming/377-Combination-Sum-IV.cpp</p>
</blockquote>

<h3 id="2-二维平面的小青蛙跳台阶问题">2. 二维平面的“小青蛙跳台阶”问题</h3>

<p>接下来我们将会看到，“小青蛙跳台阶”这一基本问题能玩儿出多少花样。</p>

<p><a href="https://leetcode.com/problems/unique-paths-ii/">Unique Paths II</a>，有一个机器人从一个二维平面的左上角出发，终点为右下角，机器人每次只能向下或者是向右移动，并且在该平面中存在“专刀机器人的剑”，入者必死，可怜的机器人必须要绕开这些 Sword。问机器人从起点到终点有多少条独特的路径。</p>

<p>既然机器人只能向右或者是向下移动，那么对于一个节点 <code class="highlighter-rouge">grid[i][j]</code> 而言，只有可能从上边或者是左边出现机器人的身影。而对于第 0 行的节点而言，机器人除非一路向右才有可能到达。同样的，第 0 列中的节点机器人必须一路向下才能到达。这种特殊情况就是我们在该题中需要处理的边界情况。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/dp/1606897302445.png" alt="Alt text" /></p>

<p>如上图所示，当我们分析完所有的特殊情况以后，代码的实现将会非常简单。<code class="highlighter-rouge">memory[i][j]</code> 则表示以当前节点为终点的独特的路径总条数。如果没有“专刀机器人的剑”或者是节点不在边界时，有:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>memory[i][j] <span class="o">=</span> memory[i][j-1] + memory[i-1][j]
</code></pre></div></div>

<p>完整实现代码可见:</p>
<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/blob/master/leetcode/dynamic-programming/063-Unique-Paths-II.cpp</p>
</blockquote>

<p>其实，Unique Paths 问题向我们揭露了另外一种非常典型的递推关系式: <strong>对于 memory[i][j] 而言，它的左节点(memory[i][j-1])、上节点(memory[i-1][j]) 以及左上节点(memory[i-1][j-1]) 都有极大的概率称为递推关系式中的一份子</strong>。除开 0-1背包 问题的递推关系以外，绝大多数的二维 DP 问题都能从这 3 个节点上找到正确的递推关系式。</p>

<p>例如 <a href="https://leetcode.com/problems/maximal-square/">Maximal Square</a> 这个问题，给定一个仅包含 ‘0’、’1’ 的二维数组，求出仅包含字符 ‘1’ 的最大正方形。此时，我们可以假定 <code class="highlighter-rouge">memory[i][j]</code> 表示以 <code class="highlighter-rouge">matrix[i][j]</code> 为<strong>右下角</strong>的最大正方形的<strong>边</strong>。当我们这样定义完二维数组的含义之后，分析起来就非常简单了。</p>

<p>如果 <code class="highlighter-rouge">memory[i][j]</code> 为 ‘0’，那么 <code class="highlighter-rouge">memory[i][j]</code> 就等于 0; 如果 <code class="highlighter-rouge">memory[i-1][j]</code>、<code class="highlighter-rouge">memory[i-1][j-1]</code>、 <code class="highlighter-rouge">memory[i][j-1]</code> 其中有一个为 ‘0’ 的话，<code class="highlighter-rouge">memory[i][j]</code> 都不能构成包含 ‘1’ 的正方形。所以，状态转移方程为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>memory[i][j] <span class="o">=</span> min<span class="o">(</span>memory[i-1][j], memory[i-1][j-1], memory[i][j-1]<span class="o">)</span> + 1
</code></pre></div></div>

<p>完整代码为:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">maximalSquare</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">memory</span><span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">));</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            
            <span class="c1">// 初始化第 0 行或第 0 列
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
            
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'1'</span><span class="p">)</span>
                <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            
            <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">*</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>再比如 <a href="https://leetcode.com/problems/edit-distance/">72. Edit Distance</a>，该问题同样可以将 <code class="highlighter-rouge">memory[i][j]</code> 的关系往左边、上边以及左上这 3 个节点的方向上面靠。当我们明确了某个 DP 问题是需要使用二维数组完成，并且又不是 0-1 背包问题的时候，大胆地去找这 3 个节点的“麻烦”。</p>

<p>这一类问题我比较喜欢称之为“Robot Path”，相似题目有:</p>

<ul>
  <li><a href="https://leetcode.com/problems/unique-paths/">062. Unique Paths</a></li>
  <li><a href="https://leetcode.com/problems/minimum-path-sum/">064. Minimum Path Sum</a></li>
  <li><a href="https://leetcode.com/problems/triangle/">120. Triangle</a></li>
  <li><a href="https://leetcode.com/problems/maximal-square/">221. Maximal Square</a></li>
  <li><a href="https://leetcode.com/problems/minimum-falling-path-sum/">931. Minimum Falling Path Sum</a></li>
  <li>……</li>
</ul>

<h3 id="3-小结">3. 小结</h3>

<p>不管是 <a href="https://leetcode.com/problems/coin-change/">Coin Change</a> 还是 <a href="https://leetcode.com/problems/unique-paths/">Unique Paths</a> 问题，本质上最核心的仍然是“小青蛙跳台阶”问题，从一个最基本的问题扩展到稍微复杂一些的问题。对这一类问题，有位老哥总结的非常之到位:</p>

<p>Statement</p>
<blockquote>
  <p>Given a target find minimum (maximum) cost / path / sum to reach the target.</p>
</blockquote>

<p>Approach</p>
<blockquote>
  <p>Choose minimum (maximum) path among all possible paths before the current state, then add value for the current state.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>routes[i] <span class="o">=</span> min<span class="o">(</span>routes[i-1], routes[i-2], ... , routes[i-k]<span class="o">)</span> + cost[i]
</code></pre></div></div>

<p>原文地址为:</p>

<blockquote>
  <p>https://leetcode.com/discuss/general-discussion/458695/Dynamic-Programming-Patterns</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>二叉树与递归: DP、回溯、DFS、BFS，一个通用的算法框架</title>
	  <link>//binary-tree-and-recursive</link>
	  <author></author>
	  <pubDate>2020-12-15T15:50:25+00:00</pubDate>
	  <guid>//binary-tree-and-recursive</guid>
	  <description><![CDATA[
	     <p>二叉树问题在算法领域是一个非常非常重要的话题，”遍历”这一 API 在非线性数据结构中有着举足轻重的地位，可以说 80% 的算法问题都是遍历问题。</p>

<!---more--->

<p>对于一棵二叉树的遍历，相信只要了解过二叉树的程序员都能够用递归的方式写出其前序遍历、中序遍历和后序遍历:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">TreeNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">;</span>

    <span class="c1">// 前序遍历
</span>    <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="c1">// 中序遍历
</span>    <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="c1">// 后序遍历
</span><span class="p">}</span>
</code></pre></div></div>

<p>我们可以使用“递归”这一神奇的机制非常轻松的完成二叉树的深度优先遍历。那么，如果使用递归，又该如何实现呢? 此时，我们就需要借助“栈”这一数据结构来完成。</p>

<p>由于我们在最开始的时候只有根节点，但是深度优先遍历却要求我们最先访问最底层的节点(中序和后序遍历)，并且还需要记录下沿途访问过的节点。而栈是一种先进后出的数据结构，和二叉树的深度优先遍历简直就是天生一对。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/tree/1606099448258.png" alt="" /></p>

<p>上图描述了使用栈实现的中序遍历过程，实际上，递归实现的中序遍历中，操作系统所创建栈帧和销毁栈帧的过程与之完全相同。具体的节点入栈和出栈细节上图已经给出，不再赘述，下面是实现过程:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">depthStack</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>

    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">curRoot</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">depthStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">curRoot</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">depthStack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        
        <span class="k">while</span> <span class="p">(</span><span class="n">curRoot</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">depthStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">curRoot</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="n">curRoot</span> <span class="o">=</span> <span class="n">curRoot</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">depthStack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">depthStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">depthStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="n">curRoot</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>之所以要使用栈来实现二叉树的中序遍历，是因为通过这个过程我们能够对二叉树的深度遍历过程更进一步地熟悉，从而进一步理解递归实现的深度优先遍历执行过程。</p>

<p>自顶向下的DP问题、回溯问题，甚至是归并排序问题，其实都是二叉树以及多叉树的遍历问题。以最经典的小青蛙跳台阶问题为例，当我们不使用记忆化搜索和递推来实现时，它是这个样子的:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">climbStairs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">climbStairs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们对上面的代码进行稍许的修改:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">climbStairs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">climbStairs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到，这个过程实际上就是一棵二叉树的后序遍历。当然，小青蛙跳台阶问题本质上就是斐波那契数列问题，也就是说，自顶向下地求解斐波那切数列其实也是二叉树的后序遍历。</p>

<p>再来看 leetcode 上 <a href="https://leetcode.com/problems/word-break/">139. Word Break</a> 这道 DP 问题，通过分析，我们可以得到这样的一棵树:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/tree/1606101980186.png" alt="" /></p>

<p>本质上就是一棵多叉树求解路径的问题，同样是一个深度优先遍历问题。</p>

<p>最后来看回溯问题中较为经典问题，求解全排列问题: <a href="https://leetcode.com/problems/permutations/">46. Permutations</a>。我们能够轻易地画出求解问题的过程和思路:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/tree/1606102283314.png" alt="" /></p>

<p>这还是一个多叉树深度优先遍历问题，将多叉树的每一条“路径”塞到结果中，就可以得到某一个数组的全排列。</p>

<p><strong>这些看似不同的问题中都隐藏了一个相同的问题: 二叉树与多叉树的深度优先遍历问题。</strong></p>

<h3 id="1-简单地二叉树遍历问题">1. 简单地二叉树遍历问题</h3>

<p>首先来看 <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">230. Kth Smallest Element in a BST</a> 这个问题，给定一棵二分搜索树(Binary Search Tree, BST)，求该树中第 k 小的元素。对于一棵 BST 而言，其中序遍历结果就是一个从小到大排序完成的数组。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/tree/1606111554881.png" alt="" /></p>

<p>也就是说，中序遍历结果的第一个元素就是第 1 小的元素，第二个元素就是第 2 小的元素，以此类推，第 k 个元素就是第 k 小的元素:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        
        <span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
        
        <span class="c1">// 中序遍历访问节点
</span>        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        
        <span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
    <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">kthSmallest</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">midorder_dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p><a href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a>，反转一棵二叉树，使得所有节点的左子节点变成右子节点，右子节点变成左子节点。据说是 Max Howell 未能加入 Google 的直接原因，不过这我是不相信的，个人更倾向于认为是 Max Howell 和 Google 在面试的内容产生了分歧: 反转二叉树有个锤子用? 能反转二叉树的人就能写出 Homebrew 了?</p>

<p>从题目描述中可以看到，需要反转某个节点的左、右子节点，那么必然地，我们得访问到左、右子节点，然后才能对其进行操作，所以这是一个后序遍历的问题。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">invertTree</span><span class="p">(</span><span class="k">struct</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">114. Flatten Binary Tree to Linked List</a>，题目要求将一棵二叉树展开成一个链表形式的树，如下所示:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input:
    1
   / <span class="se">\</span>
  2   5
 / <span class="se">\ </span>  <span class="se">\</span>
3   4   6

Output: 
1
 <span class="se">\</span>
  2
   <span class="se">\</span>
    3
     <span class="se">\</span>
      4
       <span class="se">\</span>
        5
         <span class="se">\</span>
          6
</code></pre></div></div>

<p>从结果上来看，是二叉树前序遍历所得到的结果，但是我们并不能使用前序遍历的方式来完成。这道题本质上和上面那道反转二叉树是一样的: 使用后序遍历的方式首先处理左、右子节点，再将结果返回给根节点。</p>

<p>首先使用临时变量来保存右子节点，然后断开当前节点与右子节点的连接，将左子节点套在右子节点上，再然后把使用临时变量存储的右子节点套在新的右子节点的最后一个右子节点上。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="n">flatten</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="n">flatten</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="c1">// 找到新的右子节点的最后一个右子节点
</span>    <span class="k">while</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-通过-dfs-结果恢复二叉树">2. 通过 DFS 结果恢复二叉树</h3>

<ul>
  <li><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></li>
  <li><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. Construct Binary Tree from Inorder and Postorder Traversal</a></li>
  <li><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. Construct Binary Tree from Preorder and Postorder Traversal</a></li>
</ul>

<p>上面的问题都是从 DFS 的结果中恢复一棵二叉树，不过通过前序遍历和后序遍历的结果所恢复的二叉树可能有多个，因为无法确切的计算出左子树和右子树到底有多少个元素。</p>

<p>以前序遍历和中序遍历结果恢复一棵二叉树为例，对于前序遍历结果而言，数组的第一个元素一定是根节点，根据该根节点我们就可以在中序遍历结果中找到哪些是左子树节点，哪些是右子树节点了。递归地执行这个过程，就能够构建出原有二叉树，如下图所示:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/tree/1606118277976.png" alt="" /></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">traverse</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preLeft</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preRight</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inLeft</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inRight</span><span class="p">,</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">inHashmap</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">preLeft</span> <span class="o">&gt;</span> <span class="n">preRight</span> <span class="o">||</span> <span class="n">inLeft</span> <span class="o">&gt;</span> <span class="n">inRight</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
        
        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="n">preLeft</span><span class="p">]);</span>
        
        <span class="kt">int</span> <span class="n">inRootIndex</span> <span class="o">=</span> <span class="n">inHashmap</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">leftNums</span> <span class="o">=</span> <span class="n">inRootIndex</span> <span class="o">-</span> <span class="n">inLeft</span><span class="p">;</span>

        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">preLeft</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preLeft</span> <span class="o">+</span> <span class="n">leftNums</span><span class="p">,</span> <span class="n">inorder</span><span class="p">,</span> <span class="n">inLeft</span><span class="p">,</span> <span class="n">inRootIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inHashmap</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">preLeft</span> <span class="o">+</span> <span class="n">leftNums</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preRight</span><span class="p">,</span> <span class="n">inorder</span><span class="p">,</span> <span class="n">inRootIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inRight</span><span class="p">,</span> <span class="n">inHashmap</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">inHashmap</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inorder</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">inHashmap</span><span class="p">[</span><span class="n">inorder</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">traverse</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">preorder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inorder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inHashmap</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>可以看到，恢复一棵二叉树的过程仍然是一个二叉树的遍历过程，很明显地，这是一个前序遍历过程。</p>

<h3 id="3-二叉树路径和问题">3. 二叉树路径和问题</h3>

<p>关于二叉树的路径和，例如求从根节点到叶子节点的最大加权路径和(<a href="https://leetcode.com/problems/path-sum/">112. Path Sum</a>)，输出所有根节点到叶子节点的路径(<a href="https://leetcode.com/problems/path-sum-ii/">113. Path Sum II</a>)等问题既可以认为是一个二叉树遍历问题，也可以认为是回溯问题，故不再赘述，可参考:</p>

<blockquote>
  <p><a href="https://github.com/SmartKeyerror/Snorlax/blob/master/algorithm/backtracking/backtracking.md#6-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%9B%9E%E6%BA%AF">二叉树中的回溯</a></p>
</blockquote>

<h3 id="4-二叉树层序遍历问题">4. 二叉树层序遍历问题</h3>

<p>相较于二叉树的深度优先遍历问题，二叉树的层序遍历要简单许多。二叉树的层序遍历又称之为广度优先遍历、宽度优先遍历，此时我们需要借助队列这一先进先出数据结构完成。当然，用栈也能够完成，只是不够直观而已，反正就是需要一个额外的空间进行节点存储。</p>

<p>层序遍历问题并不复杂，所以只给出 leetcode 上关于层序遍历一些问题:</p>

<ul>
  <li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></li>
  <li><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">103. Binary Tree Zigzag Level Order Traversal</a></li>
  <li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. Binary Tree Level Order Traversal II</a></li>
  <li><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">116. Populating Next Right Pointers in Each Node</a></li>
  <li><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">117. Populating Next Right Pointers in Each Node II</a></li>
  <li><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">515. Find Largest Value in Each Tree Row</a></li>
</ul>

<h3 id="4-小结">4. 小结</h3>

<p>对于二叉树的深度优先遍历，我们可以有这样的框架:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
    <span class="c1">// 前序遍历
</span>    <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="c1">// 中序遍历
</span>    <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="c1">// 后序遍历
</span><span class="p">}</span>
</code></pre></div></div>

<p>对于多叉树的遍历深度优先遍历，同样地:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">child</span><span class="o">:</span> <span class="n">TreeNode</span><span class="o">-&gt;</span><span class="n">childs</span><span class="p">)</span>
        <span class="n">traversal</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个通用的框架能够为我们解决自顶向下的 DP 问题，回溯问题，递归等问题提供一个方向，我们只需要理清问题中的一些细节之后，就可以使用这一“模板”进行解决。</p>

<p>leetcode 关于二叉树这一话题的全部题目:</p>

<blockquote>
  <p>https://leetcode.com/tag/tree/</p>
</blockquote>

<p>我个人对其中一些题目的解:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/tree/master/leetcode/tree
https://github.com/SmartKeyerror/Snorlax/tree/master/leetcode/binary-search-tree</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>回溯与剪枝: 《明日边缘》or《源代码》</title>
	  <link>//backtracking</link>
	  <author></author>
	  <pubDate>2020-11-13T07:50:25+00:00</pubDate>
	  <guid>//backtracking</guid>
	  <description><![CDATA[
	     <p>回溯法在 wikipedia 中被解释成一种“暴力搜索法”，相较“暴力”一词我更喜欢称之为“枚举”，枚举一个空间中所有的搜索路径。</p>

<!---more--->

<p>回溯法采用试错的思想，逐步地解决一个问题，就好像我们小时候玩儿的走迷宫一样。我们从一个点出发，选择迷宫中的一条路向前行进，当遇到死胡同时再回到当初进行选择的地方，再往下走，直到将整个迷宫搜索完毕或者是找到一条通往终点的路径。</p>

<p>人生是由多个选择所构成的，我们有时候会忍不住的去假设如果当初我们没有做那个选择现在会是怎么样。人生无法重来，但是回溯法却可以。</p>

<p>在具体的回溯算法实现中，有两个非常重要的事物：已选择的路径和下一次能够进行选择的路径。这也非常贴近现实，毕竟我们自身的存在就可以认为是“已选择的路径”，立足于当下，我们能够做出的所有选择就是剩余的选择路径。</p>

<p>回溯算法有一个非常通用的框架，具体表现为:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 其中 choices 表示我们能做出的选择，selected 表示已选择的路径
</span><span class="kt">void</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">vecotr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">choices</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">selected</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="n">choice</span> <span class="n">in</span> <span class="n">choices</span> <span class="p">{</span>
        <span class="c1">// 进行选择
</span>        <span class="n">selected</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">choice</span><span class="p">);</span>
        
        <span class="c1">// 继续前行
</span>        <span class="n">backtracking</span><span class="p">(</span><span class="n">choices</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>
        
        <span class="c1">// 撤销选择
</span>        <span class="n">selectd</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>下面使用一道非常经典的排列问题来更加具体的描述回溯法，题目如下:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>给定一个没有重复数字的序列，返回其所有可能的全排列

Example:
    Input: nums <span class="o">=</span> <span class="o">[</span>1,2,3]
    Output: <span class="o">[[</span>1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</code></pre></div></div>

<p>即求解给定数组中元素的所有排列，根据高中数学知识，n 个元素所有的排列个数为 n!，只不过题目需要输出所有的具体排列方式。</p>

<p>思考方式也比较简单，以 <code class="highlighter-rouge">[1, 2, 3]</code> 的全排列为例。首先我们先固定第一个元素，来看剩下的元素有哪些排列方式，很明显地，只有两种: <code class="highlighter-rouge">[2, 3]</code> 和 <code class="highlighter-rouge">[3, 2]</code>，所以以 1 开始的全部排列为 <code class="highlighter-rouge">[1, 2, 3]</code>, <code class="highlighter-rouge">[1, 3, 2]</code>。接着我们固定第二个元素，来看剩下的 <code class="highlighter-rouge">[1, 3]</code> 有哪些排列方式，答案是 <code class="highlighter-rouge">[1, 3]</code> 和 <code class="highlighter-rouge">[3, 1]</code>，因此以 2 为起始的全部排列为 <code class="highlighter-rouge">[2, 1, 3]</code> 和 <code class="highlighter-rouge">[2, 3, 1]</code>。以此类推，直到输出数组最后一个元素的全排列，整个搜索过程结束。</p>

<p>如果以一棵树来表示的话，就是下面的样子:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/permutation.png" alt="" /></p>

<p>左图中描述了确切的选择过程，而右图中则描述了选择以及回溯(撤销选择)的过程。现在，我们可以使用代码来解决这个全排列问题了。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>

    <span class="c1">// 保存每一个排列结果
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>

    <span class="c1">// 在每次的选择中，我们不能够再选择哪些已经选择过的元素了
</span>    <span class="c1">// 所以我们使用一个数组来记录已经选择过的元素索引
</span>    <span class="c1">// visted[i] = true 则表示第 i 个元素已经被选择
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visted</span><span class="p">;</span>

    <span class="c1">// 其中 selected 表示我们已经选择过的路径
</span>    <span class="kt">void</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">selected</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">selected</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">selected</span><span class="p">);</span>
            <span class="k">return</span> <span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">visted</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">continue</span><span class="p">;</span>
            
            <span class="c1">// 做出选择
</span>            <span class="n">selected</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">visted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

            <span class="n">backtracking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>   <span class="c1">// 怀揣着当前选择进行下一次选择
</span>
            <span class="c1">// 撤销刚才的选择
</span>            <span class="n">visted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">selected</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">;</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">permute</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

        <span class="c1">// 在最开始，没有元素被访问过, 所以全部初始化为 false
</span>        <span class="n">visted</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">selected</span><span class="p">;</span>
        <span class="n">backtracking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="1-组合问题">1. 组合问题</h3>

<p>除了排列问题以外，组合问题是回溯法的另外一处后花园。对于排列而言，需要元素的排列顺序，例如 <code class="highlighter-rouge">[1, 2, 3]</code> 和 <code class="highlighter-rouge">[1, 3, 2]</code> 属于不同的排列。而组合问题则不关心元素的排列顺序，<code class="highlighter-rouge">[1, 2]</code> 和 <code class="highlighter-rouge">[2, 1]</code> 为同一个组合。</p>

<p>在组合问题中，使用回溯法的整体框架与排列问题几乎一模一样，唯一有差别的就是我们<strong>如何定义剩余的可选路径</strong>。</p>

<p>leetcode 中的 <a href="https://leetcode.com/problems/combinations/">77. Combinations</a> 就是一道非常经典的组合问题。</p>

<blockquote>
  <p>给定两个整数 n 和 k，返回 1 …n 中所有可能的 k 个数的组合</p>
</blockquote>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/combination.png" alt="" /></p>

<p>可以看到，组合问题和排列问题唯一的差别就在于当我们选择了某一个元素之后，在这之前的所有元素均不可被选择，这是因为前面的元素一定已经生成了对应的组合。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>

    <span class="c1">// 从 start...n 中求解组合问题, selected为已选择路径
</span>    <span class="kt">void</span> <span class="nf">combination</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">selected</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">selected</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">selected</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">selected</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">selected</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>                  <span class="c1">// 选择
</span>            <span class="n">combination</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>
            <span class="n">selected</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>                    <span class="c1">// 撤销选择
</span>        <span class="p">}</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">combine</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">);</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">selected</span><span class="p">;</span>
        <span class="n">combination</span><span class="p">(</span><span class="n">n</span> <span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>注意到在 <code class="highlighter-rouge">for</code> 循环中我们并没有让 <code class="highlighter-rouge">i</code> 自增到 <code class="highlighter-rouge">n</code>，而是自增到 <code class="highlighter-rouge">n - (k - selected.size()) + 1</code>。这是因为当我们已经选择了 <code class="highlighter-rouge">selected.size()</code> 这么多个元素之后，还剩下 <code class="highlighter-rouge">k - selected.size()</code> 这么多个元素需要被选择。也就是说，在 <code class="highlighter-rouge">[i...n]</code> 之间必须要存在 <code class="highlighter-rouge">k - selected.size()</code> 这么多个元素，所以我们只需要自增到剩下的元素区间无法满足选取 <code class="highlighter-rouge">k - selected.size()</code> 这么多个元素数量即可。</p>

<h3 id="3-剪枝">3. 剪枝</h3>

<p>剪枝听起来是一个很高大上的技巧，但实际上剪枝的概念非常简单，就是让整个递归过程减少无效的计算。在上面的组合问题一解中，我们仅使变量 <code class="highlighter-rouge">i</code> 自增到 <code class="highlighter-rouge">n - (k - selected.size()) + 1</code>，剔除了许多无效的计算，这就是一种剪枝。</p>

<p>一个比较经典的剪枝问题就是求拥有重复元素的全排列问题，在 <a href="https://leetcode.com/problems/permutations-ii/">47. Permutations II</a> 有具体描述。</p>

<blockquote>
  <p>Input: nums = [1,1,2]
Output: [[1, 1, 2], [1, 2, 1], [2, 1, 1]]</p>
</blockquote>

<p>一种解决方案就是不管数组中有没有重复元素，按照原有的流程将所有的排列输出，然后再进行排序去重，这一定是一个可行解。但是，既然我们需要对结果进行排序，为什么不对原有的数组进行排序，然后在回溯的过程中进行去重呢?</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/047-permutations-II-Explain.png" alt="" /></p>

<p>如上图所示，我们首先对原有数组进行排序。而后在每一次选择时都去判断当前元素是否和前一个元素相同，以及在相同的条件下，前一个元素是否被使用。若结果为 <code class="highlighter-rouge">true</code>，将跳过当前元素。</p>

<p>因篇幅限制，这里不再贴源码，感兴趣的小伙伴可以移步:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/blob/master/leetcode/prune/047-Permutations-II.cpp</p>
</blockquote>

<p>同时，剪枝相关的话题整理在:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/tree/master/leetcode/prune</p>
</blockquote>

<h3 id="4-二维平面中的回溯">4. 二维平面中的回溯</h3>

<p>在前面的问题中回溯都在一维数组中进行，在二维数组中回溯法同样有效，并且能够解决的问题也更加有趣。例如 N-皇后问题，求解数独，以及我们开篇就提到的迷宫问题。</p>

<p>在 leetcode 中，关于二维平面中的回溯问题不是很多，以 <a href="https://leetcode.com/problems/word-search/">79. Word Search</a> 为例:</p>

<blockquote>
  <p>在一个 m * n 的字母板中，寻找是否存在某一个单词 word，字母和字母之间可以水平或者垂直连接。</p>
</blockquote>

<p>下面给出分析图示:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/search-string.png" alt="" /></p>

<p>选择树，或者说决策树与排列、组合问题并没有什么不同，只不过选择的方向固定为上、下、左、右。同时我们的 <code class="highlighter-rouge">visited</code> 数组也需要设置成一个二维数组。</p>

<p>题解:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/blob/master/leetcode/backtracking/079-Word-Search.cpp</p>
</blockquote>

<h3 id="5-flood-fill">5. Flood fill</h3>

<p>Flood fill 算法又称为漫水填充算法，在扫雷游戏中用于计算需要被清除的区域。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/Recursive_Flood_Fill_4_%28aka%29.gif" /></p>

<p>上图为 wikipedia 对 Flood fill 的 GIF 示例。其中白色部分我们需要对其进行着色，黑色部分为着色的边界，从中心点开始向下滴一滴墨水，墨水所散开的区域就是我们需要着色的区域。</p>

<p>在 <a href="https://leetcode.com/problems/number-of-islands/">200. Number of Islands</a> 该题中我们就可以使用 Flood fill 算法来完成。相较于排列和组合问题有着明显的递归终止条件，Flood fill 算法则需要确保所有选择过的元素的 4 个方向上的元素均被访问并标记过，除非遇到边界。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/island.png" alt="" /></p>

<p>题解:</p>
<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/blob/master/leetcode/depth-first-search/200-Number-of-Islands.cpp</p>
</blockquote>

<p>不过，Flood fill 严格意义上来来说应该是一种深度优先遍历(DFS)算法，但是说是回溯法的一种也没太大毛病。</p>

<h3 id="6-二叉树中的回溯">6. 二叉树中的回溯</h3>

<p>有时候我们会默认为回溯法的选择路径是一棵多叉树，而忽略了最基本的情况: 二叉树。相较于二叉树的遍历，回溯在其中的应用并不是很多，一个比较典型的问题就是输出二叉树从根节点到所有叶子节点的路径，例如:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/binary-paths.png" alt="" /></p>

<p>代码也非常简单:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">TreeNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">treePaths</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">selected</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">;</span>
    
    <span class="n">selected</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">selected</span><span class="p">);</span>
        <span class="n">selected</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="k">return</span> <span class="p">;</span>
    <span class="p">}</span>

    <span class="n">treePaths</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>
    <span class="n">treePaths</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>

    <span class="n">selected</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 <a href="https://leetcode.com/problems/path-sum-ii/">Path Sum II</a>，<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">Sum Root to Leaf Numbers</a>，<a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/">Smallest String Starting From Leaf</a> 这些问题中都涉及到了二叉树的回溯。</p>

<h3 id="7-小结">7. 小结</h3>

<p>回溯法是一种相当实用的算法，思想也非常简单，许多问题都可以使用回溯的方式来“暴力”解决，其中就包括数独、图着色、N-Queens 等非常有意思的问题。在具体的实现过程中，可以使用剪枝这一技巧来提高算法的运行效率，除去多余的、重复的、不必要的计算。</p>

<p>leetcode 关于回溯这一话题的全部题目:</p>

<blockquote>
  <p>https://leetcode.com/tag/backtracking/</p>
</blockquote>

<p>我个人对其中一些题目的解:</p>

<blockquote>
  <p>https://github.com/SmartKeyerror/Snorlax/tree/master/leetcode/backtracking
https://github.com/SmartKeyerror/Snorlax/tree/master/leetcode/prune</p>
</blockquote>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/leetcode/backtracing/forerver-maze.gif" alt="" /></p>


	  ]]></description>
	</item>

	<item>
	  <title>C指针与内存</title>
	  <link>//c-pointers-and-memory</link>
	  <author></author>
	  <pubDate>2020-09-28T07:50:25+00:00</pubDate>
	  <guid>//c-pointers-and-memory</guid>
	  <description><![CDATA[
	     <p>C 语言指针真正精髓的地方在于<strong>指针可以进行加减法</strong>，这一点极大的提升了程序的对指针使用的灵活性，同时也带来了不小的学习负担。正是因为 C 语言指针可运算，才奠定了如今 C 语言的地位。</p>

<!---more--->

<h3 id="1-指针">1. 指针</h3>

<h4 id="11-指针的基本概念">1.1 指针的基本概念</h4>

<p>对于内存，我们可以简单地认为它就是大小相同、连续排布的格子，每一个格子的大小为一字节。为了更方便地找到某一个格子，我们通过对内存进行编号，通过编号来找到某一个具体的内存格子。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/pointer/simple-memory.png" alt="" /></p>

<p>这样的编号通常称之为内存地址，如果程序想要获取某一块内存存放的数据，必须通过内存地址定位，再取出对应内存的数据。</p>

<p>一个指针变量存储着另一块内存的起始地址，相较于直接寻址的方式，如果想要通过一个指针获取指向的内存变量的话，首先需要获取到指针变量存储的内存地址，再通过这个地址来获取变量，所以这种方式又称为间接寻址。</p>

<p>在 C 函数实现中，所传入的参数均为原有变量的一个拷贝，在函数中对参数进行修改是无法影响到原有变量的值的，若需要对参数进行修改，可向函数传递该变量的内存地址。如此一来，即使对参数（地址）进行了拷贝，也可以通过地址对其进行修改，而变量的地址就保存在指针当中。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pointer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如上述代码所示，语句 <code class="highlighter-rouge">int number</code> 声明了一个变量，且其类型为整型。语句 <code class="highlighter-rouge">int *pointer</code> 同样声明了一个变量，只不过 <code class="highlighter-rouge">*pointer</code> 的类型为整型而已。<code class="highlighter-rouge">*</code> 作为一元操作符时表示对间接寻址或者是间接引用，所以变量 <code class="highlighter-rouge">pointer</code> 是一个指针，其中保存了变量的地址。</p>

<p>实际上，<code class="highlighter-rouge">int *pointer</code> 也可以写作为 <code class="highlighter-rouge">int* pointer</code>，对于编译器而言，这两种方式最终的结果都是一样的: 声明一个指针变量。但是，<code class="highlighter-rouge">int*</code> 这一写法会让人产生歧义，认为 <code class="highlighter-rouge">pointer</code> 是一个 <code class="highlighter-rouge">int*</code> 类型，然而 C 语言中并无该类型。<strong>应当将 <code class="highlighter-rouge">*pointer</code> 作为一个整体看待，其类型为 <code class="highlighter-rouge">int</code></strong>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * 所以，当我们将 *pointer 看作是一个整体之后，对于多变量声明就不会再产生疑惑 
 * *pointer 与 number 的类型均为 int
 */</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pointer</span><span class="p">,</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>指针变量中既然存放的是内存单元的地址，那么其大小就与所指向的类型无关了。在 64 位系统指针变量占用 8 个字节，在 32 位系统下占用 4 个字节。</p>

<h4 id="12-指针的初始化">1.2 指针的初始化</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>       <span class="c1">// ①
</span>    <span class="kt">int</span> <span class="o">*</span><span class="n">pointer</span><span class="p">;</span>           <span class="c1">// ②
</span>
    <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="n">number</span><span class="p">;</span>      <span class="c1">// ③
</span><span class="p">}</span>
</code></pre></div></div>

<p>上述代码在前两行中声明了两个变量: 整型变量 <code class="highlighter-rouge">number</code> 与指向整型的指针 <code class="highlighter-rouge">pointer</code>。在第三行中，将 <code class="highlighter-rouge">pointer</code> 指向的内存内容更新为 <code class="highlighter-rouge">number</code> 的值（100）。在运行时却抛出了 <code class="highlighter-rouge">Segmentation fault</code> 错误，这是为什么？</p>

<p>原因在于 <code class="highlighter-rouge">pointer</code> 中保存的值是不确定的，可能是上一个程序中的某一个变量值，也可能恰好是一个地址，我们无法得知变量 <code class="highlighter-rouge">pointer</code> 中的内容到底是什么。这种已经声明但为正确初始化的指针通常称之为“野指针”。</p>

<p>所谓“指针初始化”就是指使得当前指针变量中保存的地址是正确的、合法的，当前进程有权限访问的。因此，对上述代码进行稍加修改即可正确运行：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pointer</span><span class="p">;</span>

    <span class="n">pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">number</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>操作符 <code class="highlighter-rouge">&amp;</code> 表示取一个变量的地址，并将该地址赋给变量 <code class="highlighter-rouge">pointer</code>，由此一来指针中的地址就是正确且合法的。</p>

<h4 id="13-指针的运算">1.3 指针的运算</h4>

<p>C 语言中的指针支持运算，不过仅支持加减法，并不支持乘除法。在前面我们已经提到过了，一元运算符 <code class="highlighter-rouge">*</code> 表示间接寻址，即取出指针的地址，根据该地址找到指针指向的变量。而对于指针的加减法而言，与指针指向的类型密切相关。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pointer</span><span class="p">,</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">number</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"pointer's value is: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pointer</span><span class="p">);</span>

    <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"pointer's value is: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pointer</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// pointer's value is: 0x7ffd0df7f61c 
// pointer's value is: 0x7ffd0df7f620
</span></code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/pointer/pointer-increase.png" alt="" /></p>

<p>可以看到，对一个指向 <code class="highlighter-rouge">int</code> 的指针加 1，其地址增加了 4，正好是一个整型的大小。其原因在于如果仅仅是增加 1 的话，那么指针将会指向该整型的第二个字节，那么此时指针所指向的“整型”值将会变得非常奇怪，因为最后一个字节是其它数据的。</p>

<p>所以，对指针进行自增时，指针将会指向原来指向元素的下一个元素，这就使得我们可以通过指针的加减法来访问数组中的元素了。</p>

<h4 id="14-指针与数组">1.4 指针与数组</h4>

<p>我们经常听到数组名称其实就是一个指针，数组名表示数组的首地址。但是这并不正确，数组名称和指针绝不等价，我们可以认为数组名称具有指针的特性，但不能说数组和指针等价。一个最为典型的例子就是使用 <code class="highlighter-rouge">sizeof</code> 求数组的长度。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="n">number</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"number's size: %ld </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">number</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"pointer's size: %ld </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pointer</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// number's size: 12 
// pointer's size: 8 
</span></code></pre></div></div>

<p>在上述代码中我们明确地表示了 <code class="highlighter-rouge">number</code> 是一个整型数组，表示整型的集合，所以 <code class="highlighter-rouge">sizeof</code> 的结果为数组占用内存的总大小。而 <code class="highlighter-rouge">pointer</code> 仅仅只是一个整型指针，编译器并不知道它到底是指向一个整型，还是一坨整型，那么 <code class="highlighter-rouge">sizeof</code> 的结果自然而然的是指针占用内存空间的大小。</p>

<p>所以，<strong>数组名称所代表的含义要高于指针，但是这并不改变数组名是一个指针的事实</strong>。数组在内存中连续分布，再结合前面所提到的指针的运算，使得我们可以通过指针的方式访问数组中的元素。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="n">number</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">pointer</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>实际上，<code class="highlighter-rouge">array[n]</code> 就相当于 <code class="highlighter-rouge">*(array + n)</code>，所以 <code class="highlighter-rouge">number[2]</code> 也可以用 <code class="highlighter-rouge">[2]number</code> 来表示，这不过后者除了让人感到迷惑以外，没有任何实际价值。</p>

<blockquote>
  <p><code class="highlighter-rouge">[2]number</code> 使用指针的方法展开结果为 <code class="highlighter-rouge">*(2 + number)</code>，仅调换了位置而已</p>
</blockquote>

<p>另外一点需要注意的就是，当数组作为函数参数时，将会“退化”成指针，失去其原有的数组特性：即无法在函数内部获得数组大小。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"number size: %ld"</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="n">bar</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
    
<span class="p">}</span>
</code></pre></div></div>

<p>此时编译器将会给出警告：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>warning: ‘sizeof’ on array <span class="k">function </span>parameter ‘number’ will <span class="k">return </span>size of ‘int <span class="k">*</span>’
</code></pre></div></div>

<p>也就是说，尽管我们在参数中声明了 <code class="highlighter-rouge">number</code> 是一整型数组，在函数内部仍然将其看作为指针。因此，如果想要在函数中对参数中的数组进行遍历的话，必须传入数组的原有大小。</p>

<p>保存着指针的数组称之为指针数组，一个最常见的例子就是字符串数组。字符串在底层由数组实现，并在尾部添加 <code class="highlighter-rouge">\0</code> 表示结尾，而在前面也提到过，数组可以使用指针进行表示，只不过会有所“牺牲”。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Mark Twain"</span><span class="p">,</span> <span class="s">"Victor Marie Hugo"</span><span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"name: %s, length: %ld </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当数组作为函数参数时将会“退化”为指针，那么 <code class="highlighter-rouge">char *name[]</code> 又该如何仅使用指针的形式表示呢？ <code class="highlighter-rouge">char **name</code>，也就是传说中的二级指针，理解起来稍微有一点点绕。由于 <code class="highlighter-rouge">char name[]</code> 在形式上与 <code class="highlighter-rouge">char *name</code> 等价，那么 <code class="highlighter-rouge">char *name[]</code> 就可以写成 <code class="highlighter-rouge">char *(*name)</code>，去掉括号就是 <code class="highlighter-rouge">char **name</code>，二级指针。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/pointer/pointer-to-pointer.png" alt="" /></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">a_pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">**</span><span class="n">a_pointer_pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a_pointer</span><span class="p">;</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"%c"</span><span class="p">,</span> <span class="o">**</span><span class="n">a_pointer_pointer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>把二级指针想象成套娃就行，至于二级指针指向的是一个指针还是一个数组，一级指针指向的是一个字符串还是一个字符，由运行时确定，不过在大多数的函数定义中，<code class="highlighter-rouge">char **</code> 表示一个字符串数组。</p>

<h4 id="15-函数指针">1.5 函数指针</h4>

<p>在函数式编程中我们经常需要将一个函数作为参数传递给另外一个函数，其中比较经典的例子线程的创建与执行。不同于 <code class="highlighter-rouge">fork</code> 或者 <code class="highlighter-rouge">vfork</code> 调用，<code class="highlighter-rouge">pthread_create</code> 调用以一个函数指针作为参数，创建的线程转而执行该函数。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">filterArray</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div></div>

<p>上述代码是一个简单的函数原型，接收一个整型数组和其长度，并返回一个整型。一个函数总是占用一段连续的内存区域，函数名称在某些情况下会被转换成该函数所在内存区域的首地址，这一点和数组非常的相似。也就是说，函数名称 <code class="highlighter-rouge">filterArray</code> 可以被替换成 <code class="highlighter-rouge">(*pointerName)</code>，这样一来就得到了一个指向函数入口的指针：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pointerName</span><span class="p">)(</span><span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div></div>

<p>所以，函数指针其实就是对函数原型的稍加修改而已。</p>

<h4 id="16-对复杂指针的解释">1.6 对复杂指针的解释</h4>

<p>有时候我们会看到诸如 <code class="highlighter-rouge">char *(*name[124])(int **p)</code> 这种看起来非常复杂的指针，对于此类复杂指针，我们只需要牢记两个关键点即可：</p>
<ul>
  <li>对于一个符号定义而言，找到其名称，然后再按照优先级顺序进行解析。</li>
  <li>牢记 C 语言中操作符的优先级。</li>
</ul>

<p>首先来看 C 语言中的操作符优先级，这个非常非常重要：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">操作符</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">()</td>
      <td style="text-align: left">聚组，例如 <code class="highlighter-rouge">5 / (2 + 3)</code>，和数学中的<code class="highlighter-rouge">()</code>语义相同</td>
    </tr>
    <tr>
      <td style="text-align: center">()</td>
      <td style="text-align: left">函数调用，例如 <code class="highlighter-rouge">3 + foo()</code>，首先调用函数，而后执行加法操作</td>
    </tr>
    <tr>
      <td style="text-align: center">[]</td>
      <td style="text-align: left">下标引用，例如 <code class="highlighter-rouge">foo()[2]</code>，首先调用函数，根据函数返回的结果进行下标引用</td>
    </tr>
    <tr>
      <td style="text-align: center">.</td>
      <td style="text-align: left">访问结构体成员，如 <code class="highlighter-rouge">student[1].name</code> 首先获取数组索引为1的元素，而后访问<code class="highlighter-rouge">name</code>成员</td>
    </tr>
    <tr>
      <td style="text-align: center">-&gt;</td>
      <td style="text-align: left">访问结构指针成员，和 <code class="highlighter-rouge">.</code> 作用相同</td>
    </tr>
    <tr>
      <td style="text-align: center">++</td>
      <td style="text-align: left"><strong>后缀</strong>自增，如 <code class="highlighter-rouge">struct.name++</code>，首先获取结构体成员再对其进行自增</td>
    </tr>
    <tr>
      <td style="text-align: center">–</td>
      <td style="text-align: left"><strong>后缀</strong>自减，同后缀自增</td>
    </tr>
    <tr>
      <td style="text-align: center">!</td>
      <td style="text-align: left">逻辑反</td>
    </tr>
    <tr>
      <td style="text-align: center">~</td>
      <td style="text-align: left">按位取反</td>
    </tr>
    <tr>
      <td style="text-align: center">++</td>
      <td style="text-align: left"><strong>前缀</strong>自增</td>
    </tr>
    <tr>
      <td style="text-align: center">–</td>
      <td style="text-align: left"><strong>前缀</strong>自减</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: left">间接访问，如 <code class="highlighter-rouge">*p++</code> 首先对指针 <code class="highlighter-rouge">p</code> 进行自增，然后对自增后的指针进行间接访问</td>
    </tr>
    <tr>
      <td style="text-align: center">&amp;</td>
      <td style="text-align: left">取变量地址</td>
    </tr>
  </tbody>
</table>

<p>可以看到，<code class="highlighter-rouge">*</code> 间接访问操作的优先级要远远低于 <code class="highlighter-rouge">()</code>、<code class="highlighter-rouge">[]</code>、<code class="highlighter-rouge">++</code> 以及 <code class="highlighter-rouge">.</code> 等常用操作符，也就是说，<code class="highlighter-rouge">*</code> 在复杂指针中就是个弟弟。</p>

<p>接下来就对 <code class="highlighter-rouge">char *(*name[124])(int **p)</code> 这个指针做一个具体的分析。首先得找到变量名称，上面有两个： <code class="highlighter-rouge">name</code> 以及 <code class="highlighter-rouge">p</code>，结合外面两对括号可知这是个函数指针，<code class="highlighter-rouge">p</code> 为函数参数。再来看 <code class="highlighter-rouge">*name[124]</code>，<code class="highlighter-rouge">[]</code> 的优先级高于 <code class="highlighter-rouge">*</code>，所以 <code class="highlighter-rouge">name</code> 是一个数组，数组中保存了某种类型的指针。将所有的信息整合起来，就可以得到：<code class="highlighter-rouge">name</code> 是一个指针数组，保存了原型为 <code class="highlighter-rouge">char *funcName(int **p)</code> 的函数指针。</p>

<p>复杂指针的解析其实就是小学时代做的 <code class="highlighter-rouge">()</code> 类计算题，牢记运算符优先级，再仔细的一层一层解析。</p>

<h4 id="17-指针与字符串">1.7 指针与字符串</h4>

<p>C 语言中字符串并非像其它语言一样，将其设置为基本数据类型，而是构建于数组之上，并在数组末尾添加 <code class="highlighter-rouge">\0</code> 表示结尾，这也是为什么数组和字符串经常成对出现的原因。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">hello</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Hello"</span><span class="p">};</span>
    <span class="kt">char</span> <span class="n">world</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"World"</span><span class="p">};</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"hello: %s </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hello</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"world: %s </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">world</span><span class="p">);</span>
    
<span class="p">}</span>
</code></pre></div></div>

<p>如上述代码所示，我们既可以使用数组初始化一个字符串，也可以使用字符指针来初始化一个字符串，只不过<strong>使用字符指针初始化的字符串具有只读特性，使用数组初始化的字符串具有读写特性</strong>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">hello</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Hello"</span><span class="p">};</span>
    <span class="kt">char</span> <span class="n">world</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"World"</span><span class="p">};</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"hello: %s </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hello</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"world: %s </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">world</span><span class="p">);</span>
    
    <span class="n">world</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'w'</span><span class="p">;</span>     <span class="c1">// 正确执行
</span>    <span class="n">hello</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'h'</span><span class="p">;</span>     <span class="c1">// Segmentation fault
</span><span class="p">}</span>
</code></pre></div></div>

<h4 id="18-null-指针">1.8 NULL 指针</h4>

<p>标准定义了 NULL 指针，它作为一个特殊的指针变量，表示<strong>不指向任何东西</strong>，当我们在定义一个指针变量，并且不知道该指针指向何处时，就应该将其初始化为 NULL。其次，当我们使用 <code class="highlighter-rouge">free</code> 函数释放堆内存时，也应该将指针指向为 NULL，防止出现内存访问错误。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对 NULL 指针进行解引用是非法的，因为 NULL 指针从定义上来看不指向任何东西。因此，当我们对指针进行解引用时应该对其进行检查，能显著减少 DEBUG 的时间。</p>

<h4 id="19-指针作为函数参数">1.9 指针作为函数参数</h4>

<p>首先，C 语言函数调用中的参数使用<strong>按值传递</strong>，也就是说，函数会对传入的相关参数进行拷贝。<strong>当使用指针作为函数参数时，实际拷贝的是指针中的地址</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">change_name</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"hello"</span><span class="p">};</span>
    <span class="n">change_name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"name is: %s"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上述代码的输出结果为 <code class="highlighter-rouge">name is: hello</code>，而并非期望中的 <code class="highlighter-rouge">world</code>。这是因为在 <code class="highlighter-rouge">change_name</code> 函数中，我们仅仅只是更改了拷贝指针所指向的地址，并没有改变原指针的指向：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">change_name</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因此，<strong>不要试图在一个函数中更改一个指针的指向，我们只能更改指针指向的值</strong>。</p>

<h3 id="2-内存">2. 内存</h3>

<p>本节并不会介绍虚拟内存、MMU 以及 TLB 等内容，因为它们更贴近于操作系统。对于 C 程序语言而言，并不需要知道物理内存是个什么样子。</p>

<h4 id="21-内存对齐">2.1 内存对齐</h4>

<p>内存对齐是指一个数据类型在内存中存放时，对其地址的要求。简单来说内存对齐就是使得其内存地址是该类型大小的整数倍，例如 <code class="highlighter-rouge">double</code> 类型的变量，其内存地址需是 8 的倍数（<code class="highlighter-rouge">double</code> 大小为 8 字节）。</p>

<p>内存对齐的主要目的就是满足部分 CPU 对内存读写的要求以及优化 CPU 读取内存的效率。在 ARM、Alpha 等架构下，如果读取的内存是非对齐的（例如一个 4 字节的 <code class="highlighter-rouge">int</code> 落在一个奇数的内存地址上）则会直接抛出异常，当然，Intel 没有这样的限制。</p>

<p>那么为什么说 Intel 等不对内存对齐有要求的 CPU 来说使用内存对齐能优化读取效率呢？ 这是因为 CPU 在进行<strong>偶数</strong>地址读取时将更有效率，其中涉及到 RAM 的电路设计故不再深入展开，只需要知道<strong>奇数的物理内存地址不大可能出现在 CPU 中</strong></p>

<h4 id="22-结构体与内存对齐">2.2 结构体与内存对齐</h4>

<p>对于零散定义的变量，在编程时完全可以忽略内存对齐的影响，因为我们关注的是变量本身，而不是地址。但是，结构体中变量由于其紧凑的内存分布，开发人员不得不将内存对齐的因素考虑其中。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">mark</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">flag</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="n">node</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"node size: %ld </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"mark address: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">.</span><span class="n">mark</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"size address: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"flag address: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">.</span><span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// node size: 12 
// mark address: 0x7ffeef36125c 
// size address: 0x7ffeef361260 
// flag address: 0x7ffeef361264 
</span></code></pre></div></div>

<p>上述代码的运行结果 <code class="highlighter-rouge">Node</code> 大小并非预料的 6，而是 12，因为内存对齐的原因，<code class="highlighter-rouge">Node</code> 结构体额外花费了一倍的内存空间。再来看结构体变量的地址分配：</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/pointer/struct.png" alt="" /></p>

<p>由于 <code class="highlighter-rouge">int</code> 在本机器上占用 4 字节，所以其起始地址必须是 4 的倍数，也就是 <code class="highlighter-rouge">0x7ffeef361260</code>。所以第一个 <code class="highlighter-rouge">char</code> 类型后面会有 3 字节的内存空隙。而最后一个 <code class="highlighter-rouge">char</code> 类型后会有 3 字节空隙的原因则是遵循另一个原则：结构体的大小为对齐系数的整数倍。在 Linux 平台下，该值通常为 4，所以 <code class="highlighter-rouge">Node</code> 的大小必须为 4 的整数倍，故填充了 3 字节的空隙。</p>

<p>不过，我们可以通过调整结构体成员变量的定义顺序，来减少内存空隙，以节省内存：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">mark</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">flag</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">mark</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">flag</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>上述两种方式得到的 <code class="highlighter-rouge">Node</code> 大小均为 8，相较于最初版本节省了 4 字节的内存。<strong>所以，结构体中成员变量的顺序将会影响程序使用内存的大小。</strong></p>

<h4 id="23-程序运行时的进程地址空间">2.3 程序运行时的进程地址空间</h4>

<p>在未出现“分页虚拟内存”管理机制之前，操作系统对内存空间采用“分段”的方式进行管理：即将相似的数据放在一起，例如文本段、初始化数据段、未初始化数据段。时至今日，此类内存布局仍在使用，并结合分页虚拟内存共同实现对物理内存的管理。</p>

<ul>
  <li>文本段：又称为代码段，文本段中保存了程序的机器语言指令，所以这部分内容是只读的，并且可能会被多个进程所共享。</li>
  <li>初始化数据段：包含了显示初始化的全局变量和静态变量。</li>
  <li>未初始化数据段：包含了未显示初始化的全局变量和静态变量。</li>
  <li>堆栈：实现函数调用的重要内存区域，由栈帧组成，栈帧中保存了函数的参数、局部变量、调用方的栈帧地址以及返回值等。当一个函数调用返回时该函数的栈帧可能会被其它函数所占用，所以栈帧中的变量是易失的。</li>
  <li>堆：动态内存分配区，<code class="highlighter-rouge">malloc</code> 函数族所申请的内存就源于堆中，堆内存中的变量不易失，其生命周期可由程序控制。</li>
</ul>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/pointer/memory.png" alt="" /></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>                  <span class="cm">/* 全局已初始化数据区 */</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pointer</span><span class="p">;</span>                       <span class="cm">/* 全局未初始化数据区 */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>             <span class="cm">/* 全局静态已初始化数据区 */</span>

<span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>                     <span class="cm">/* 栈帧存储区 */</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">number</span> <span class="o">*</span> <span class="n">size</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* 堆 */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">student</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="n">number</span><span class="p">);</span>

    <span class="cm">/* 函数内部使用 static 修饰的变量将会作为静态变量 */</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">total_socre</span><span class="p">;</span>
    
    <span class="n">free</span><span class="p">(</span><span class="n">student</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>需要说明一点的是，当函数调用返回时，并不会清理该函数所使用的栈帧，当下一个函数调用时直接进行覆盖。同时因为栈帧是易失的以及语言特性，使得 C 语言中的变量无法从栈中逃逸。</p>

<h4 id="24-柔性数组">2.4 柔性数组</h4>

<p>在结构体中声明一个数组成员变量时，可能会直接定义一个指针，动态申请内存时，依次申请结构体和结构体中数组的内存：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdlib.h&gt;
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">heap</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">elements</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Heap</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

    <span class="n">Heap</span> <span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="p">(</span><span class="n">Heap</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Heap</span><span class="p">));</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">elements</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">);</span>

    <span class="n">heap</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">heap</span><span class="o">-&gt;</span><span class="n">elements</span> <span class="o">=</span> <span class="n">elements</span><span class="p">;</span>

    <span class="n">free</span><span class="p">(</span><span class="n">heap</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">elements</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>内存的申请和释放均需要两步操作，固然我们可以封装关于 <code class="highlighter-rouge">Heap</code> 结构体内存申请和释放的相关方法，但是还是会有些麻烦。所以，C99 允许在结构体中定义的一个长度为零的数组，作为一个占位符，运行时再为其分配内存。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">heap</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Heap</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Heap</span> <span class="n">heap</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"heap size: %ld </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">heap</span><span class="p">));</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"heap address: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"heap.size address: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heap</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"heap.elements address: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heap</span><span class="p">.</span><span class="n">elements</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>运行结果为：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>heap size: 8 
heap address: 0x7ffe67b7c390 
heap.size address: 0x7ffe67b7c390 
heap.elements address: 0x7ffe67b7c398 
</code></pre></div></div>

<p>所以，对于结构体中的零长数组而言，并不占用内存空间，但是会为其分配一个内存占位，这就为我们动态地创建数组打下了基础：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">heap</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Heap</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    
    <span class="c1">// 一次性初始化完毕
</span>    <span class="n">Heap</span> <span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="p">(</span><span class="n">Heap</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Heap</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">);</span>

    <span class="n">heap</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">heap</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"size address: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"elements address: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"elements[1] address: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">heap</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// size address: 0x55581becf2a0 
// elements address: 0x55581becf2a8 
// elements[1] address: 0x55581becf2ac
</span></code></pre></div></div>

<p>虽然柔性数组很方便，但是相比于指针定义仍然有不少的缺陷，例如<strong>零长数组必须定义在结构体最后一个成员中，且结构体中不能有多个零长数组</strong>。</p>

<p>（未完待续……</p>


	  ]]></description>
	</item>

	<item>
	  <title>Linux 阻塞与唤醒实现原理</title>
	  <link>//Linux-Blocking</link>
	  <author></author>
	  <pubDate>2020-09-09T07:50:25+00:00</pubDate>
	  <guid>//Linux-Blocking</guid>
	  <description><![CDATA[
	     <p>在前面的文件 I/O 文章中，我们有提到 Linux 文件 I/O 支持阻塞和非阻塞的数据读取方式，当采用阻塞方式进行 I/O 时，进程将会阻塞在<code class="highlighter-rouge">read()</code>或者<code class="highlighter-rouge">write()</code>系统调用上，直到文件可读或者是内核缓冲区可写。这些阻塞与唤醒的实现与内核调度紧密相关，Linux 内核使用等待队列和完成量来实现该功能。</p>
<blockquote>
  <p>注: 本篇文章所用Linux内核源码版本为v5.8</p>
</blockquote>

<!---more--->

<h3 id="1-进程状态有限状态机">1. 进程状态有限状态机</h3>

<p>进程并不总是可以立即运行的，一方面是 CPU 资源有限，另一方面则是进程时常需要等待外部事件的发生，例如 I/O 事件、定时器事件等。</p>

<p>因此，对进程的状态进行分类就是一件非常有必要的事情，对于等待某事件发生的进程给予 CPU 资源是没有任何意义的，因为此时事件可能仍未发生。而对于正等待 CPU 资源的进程而言，在得到 CPU 之后即可立即执行。调度器为了尽可能最大地使用硬件资源，通常会将进程分为3个主要的状态: 运行、等待和睡眠。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/schedule/process-state.png" alt="" /></p>

<p>处于运行状态的进程正在使用 CPU 等资源，从上图中可以看到，运行态的进程在执行完任务后结束，进入到结束状态。当 CPU 时间片到期之后，调度器选择其它进程执行，此时将进入等待状态。同时，当运行时的进程发起 I/O 操作，或者等待其它事件的发生时，将进入睡眠状态。</p>

<p>处于等待状态的进程由于缺少 CPU 资源而被迫停止运行，只要调度器下次选中该进程即可立即执行，由等待状态转变为运行状态。</p>

<p>处于睡眠状态的进程在等待外部事件的发生，例如 I/O 操作的数据抵达，创建的定时器到期等等，<strong>处于睡眠状态的进程永远不会被调度器进行选择并执行</strong>。当期望的事件到达后，进程由睡眠状态更改为等待状态，等待调度器的下一次选择。</p>

<p>处于等待的进程将会被放置于就绪队列中（红黑树实现），而处于睡眠状态的进程则放置于等待队列（双链表实现）中。调度器的目光主要放在就绪队列上，从该队列中取出下一个将要执行的进程，而等待队列和就绪队列中的进程会因为事件的发生而进行相互转移。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/schedule/read-and-wait-queue.png" alt="" /></p>

<p>在实际的内核实现中，进程的运行状态表示要比上文所述更加详细一些，进程状态定义于<code class="highlighter-rouge">include/linux/sched.h</code>:</p>

<ul>
  <li><code class="highlighter-rouge">TASK_RUNNING</code>，可运行状态。此时进程并不一定正在运行，一旦得到调度器的调度即可立即运行。</li>
  <li><code class="highlighter-rouge">TASK_INTERRUPTIBLE</code>，可中断睡眠状态。此时进程因为等待外部事件的发生而睡眠，此时可由信号或者是内核唤醒。</li>
  <li><code class="highlighter-rouge">TASK_UNINTERRUPTIBLE</code>，不可中断睡眠状态。和<code class="highlighter-rouge">TASK_INTERRUPTIBLE</code>状态类似，等待外部事件发生的睡眠状态。不同的是改状态只能由内核亲自唤醒，不能由信号唤醒，通常用于进程必须等待某件工作完成，不能被 Kill。</li>
</ul>

<p>除了这三个核心进程状态以外，还有<code class="highlighter-rouge">__TASK_STOPPED</code>、<code class="highlighter-rouge">__TASK_TRACED</code>等状态，由于这些状态在本文中并不重要，所以略去。</p>

<h3 id="2-等待队列">2. 等待队列</h3>

<p>等待队列相关的源码位于<code class="highlighter-rouge">include/linux/wait.h</code>以及<code class="highlighter-rouge">kernel/sched/wait.c</code>文件中，头文件中定义了等待队列以及队列元素的基本数据结构，<code class="highlighter-rouge">wait.c</code>源文件则主要包含具体的方法实现。</p>

<p>首先来看等待队列的基本结构，分为队列头和队列项:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 等待队列头 */</span>
<span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>       <span class="cm">/* 自旋锁 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">head</span><span class="p">;</span>   <span class="cm">/* previous、next指针 */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="n">wait_queue_head_t</span><span class="p">;</span>

<span class="cm">/* 等待队列元素 */</span>
<span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>  <span class="cm">/* 标识位 */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="k">private</span><span class="p">;</span>   <span class="cm">/* 通常指向等待进程 */</span>
	<span class="n">wait_queue_func_t</span>	<span class="n">func</span><span class="p">;</span>   <span class="cm">/* 唤醒函数 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">entry</span><span class="p">;</span>  <span class="cm">/* previous、next指针 */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在内核的链表实现中，绝大多数的链表均为循环双链表，等待队列也不例外。因为等待队列可能会在系统中断时进行修改，所以必须要添加互斥锁机制保护队列元素。</p>

<p>等待队列元素的设计也非常简洁，除了双链表必要的前后指针以外，仅包含一个指向等待进程<code class="highlighter-rouge">task_struct</code>实例的指针，一个唤醒函数和一个标识位。</p>

<p>唤醒函数通常由调度器实现，如<code class="highlighter-rouge">kernel/sched/core.c</code>中定义的<code class="highlighter-rouge">try_to_wake_up</code>方法，可以简单的认为唤醒函数就是将进程的状态由<code class="highlighter-rouge">TASK_INTERRUPTIBLE</code>或<code class="highlighter-rouge">TASK_UNINTERRUPTIBLE</code>修改为<code class="highlighter-rouge">TASK_RUNNING</code>，并将其加入至就绪队列中。</p>

<p><code class="highlighter-rouge">wait.h</code>中提供了一系列与等待队列相关的宏定义供外部使用，例如<code class="highlighter-rouge">wait_event</code>，本质上是对等待队列的进一步封装:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define wait_event(wq_head, condition)						\
do {										\
	might_sleep();								\
	if (condition)								\
		break;								\
    </span><span class="cm">/* 这里将原有的__wait_event宏展开，使用___wait_event代替 */</span><span class="cp">     \
	___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0, schedule())	\
} while (0)
</span></code></pre></div></div>

<p>其中<code class="highlighter-rouge">wq_head</code>即<code class="highlighter-rouge">wait_queue_head</code>，<code class="highlighter-rouge">condition</code>则是一个C语言表达式，表示一个等待条件。宏定义的<code class="highlighter-rouge">wait_event</code>使得使用标准C表达式指定条件成为可能，如果使用函数实现的话，无法做到如宏实现的灵活性。注意到在调用<code class="highlighter-rouge">___wait_event</code>之前会首先检查一遍条件是否满足，避免进行无效的睡眠。</p>

<p>在<code class="highlighter-rouge">___wait_event</code>宏定义中传入的进程状态为<code class="highlighter-rouge">TASK_UNINTERRUPTIBLE</code>，也就是说，<code class="highlighter-rouge">wait_event</code>实现的事件等待是不可中断的。当然，<code class="highlighter-rouge">wait.h</code>中同样提供了其它时间等待实现:</p>

<ul>
  <li><code class="highlighter-rouge">wait_event_timeout</code>: 带有超时时间的不可中断事件等待</li>
  <li><code class="highlighter-rouge">wait_event_interruptible</code>: 可中断的事件等待</li>
  <li><code class="highlighter-rouge">wait_event_interruptible_timeout</code>: 带有超时时间的可中断事件等待</li>
</ul>

<p>最后再来看<code class="highlighter-rouge">___wait_event</code>实现，该方法将会把当前进程包装成<code class="highlighter-rouge">wait_queue_entry</code>对象，并发安全地放置于等待队列中，并且在实际的让出CPU资源、引发调度器重新调度之前会再一次的检查等待事件是否发生，避免无效睡眠。由于源代码中该方法宏定义实现符号较多，所以将原实现抽象成伪代码:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">___wait_event</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">exclusive</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 初始化队列元素 */</span>
    <span class="n">init_wait_entry</span><span class="p">(...);</span>
    
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="cm">/* 将队列元素插入至等待队列中(线程安全) */</span>
        <span class="kt">long</span> <span class="n">__int</span> <span class="o">=</span> <span class="n">prepare_to_wait_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__wq_entry</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
        
        <span class="cm">/* 检查事件条件是否满足 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
            
        <span class="cm">/* 触发调度器重新调度 */</span>
        <span class="n">schedule</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于唤醒一个进程在前文中已经描述过了，通用方法为<code class="highlighter-rouge">wake_up()</code>，本质上会调用内核调度模块中的<code class="highlighter-rouge">try_to_wake_up()</code>来唤醒某个进程，唤醒的实质是将进程状态修改为<code class="highlighter-rouge">TASK_RUNNING</code>，从等待队列中移出并加入至就绪队列中。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Kubernetes-Informer</title>
	  <link>//Kubernetes-Informer</link>
	  <author></author>
	  <pubDate>2020-08-26T07:50:25+00:00</pubDate>
	  <guid>//Kubernetes-Informer</guid>
	  <description><![CDATA[
	     <p>Kubernetes 声明式API的核心就在于用户提交的YAML文件表示期望状态，Kubernetes 需要根据该期望状态与集群实际状态进行对比，并根据对比的结果作出相应的操作。期望状态由 APIServer 保存在 Etcd 中，Kubernetes 对资源进行调谐时，是否均需要通过 APIServer 查询 Etcd 来获取期望状态呢?</p>

<!---more--->

<h3 id="1-listandwatch机制">1. ListAndWatch机制</h3>

<p>在 Kubernetes 中，集群的状态、用户提交的YAML文件均保存在Etcd数据库中，而获取这些数据的唯一方法就是通过 APIServer。APIServer 与 Etcd 通过 RPC 进行通信，对外则暴露需要鉴权的 REST API 接口，用户可通过这些API接口间接地获取集群状态。例如<code class="highlighter-rouge">kubectl</code>工具就是通过封装 APIServer 的 REST API 进行工作的。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Kubernetes/Informer/client-apiserver-etcd-communicate.png" alt="" /></p>

<p>除了通用的<code class="highlighter-rouge">GET</code>、<code class="highlighter-rouge">POST</code>的API以外，APIServer 还提供了可用于持续监听的 Watch API。顾名思义，Watch API 本质上就是一种 APIServer 主动向客户端推送 Kubernetes 资源修改、创建的一种机制，默认采用 HTTP/1.1 的分块传输实现，同时也可以使用 websocket 协议进行信息接收。</p>

<p>以获取Pod事件为例，通过调用<code class="highlighter-rouge">/api/v1/watch/namespaces/{namespace}/pods?watch=yes</code>可使得客户端与 APIServer 建立HTTP长连接，每当集群中出现了 Pod 的相关事件(创建、更新等)，APIServer 将会通过该连接将对应的事件推送至客户端。实际上，Watch API 就是一种增量更新，如同MySQL主从复制中的Binlog数据传输。</p>

<p>当然，在进行资源的增量更新之前，首先要获取到当前集群中资源的存量信息，可通过 List API 获得: <code class="highlighter-rouge">/api/v1/namespaces/{namespace}/pods</code>。通过 List API 获取集群当前某资源的全部信息，以及通过 Watch API 获取资源的增量信息，在 Kubernetes 中称为 ListAndWatch 机制，是 APIServer 的核心机制之一。</p>

<blockquote>
  <p>关于kubernetes-api的更多信息可查看官网:
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#-strong-api-overview-strong-">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#-strong-api-overview-strong-</a></p>
</blockquote>

<h3 id="2-informer工作原理">2. Informer工作原理</h3>

<p>既然客户端可以使用 ListAndWatch 机制来实时地同步 Kubernetes 中某类资源的状态，那么在 Kubernetes 内部，同样可以使用该机制从 APIServer 中接收资源的变化，从而建立本地缓存减轻 APIServer 与 Etcd 的负载，并且实现 Kubernetes 中的控制器模式。该内部组件称之为 Informer，中文译为通知器。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Kubernetes/Informer/informer-ar.png" alt="" /></p>

<p>首先，Reflector 包会和 APIServer 建立长连接，并使用 ListAndWatch 方法获取并监听某一个资源的变化。List 方法将会获取某个资源的所有实例(如ReplicaSet、Deployment等)，Watch 方法则监听资源对象的创建、更新以及删除事件，获取到的事件称之为一个增量(Delta)，该增量会被放进一个称之为 Delta FIFO Queue，即增量先进先出队列中。</p>

<p>而后，Informer会不断的从 Delta FIFO Queue 中 pop 增量事件，并根据事件的类型来决定新增、更新或者是删除本地缓存，也就是 Local Key-Value Sotrage。<strong>根据集群中某资源的事件来更新本地缓存是Informer的第一个职责，同时也是最重要的职责。</strong></p>

<p>Informer 的另外一个职责就是根据事件类型来触发事先注册好的 Event Handler。在回调函数中通常只会做一些简单的过滤处理，然后将该事件丢到 Work Queue 这个工作队列中。工作队列的主要作用就是平衡 Informer 和 Controller 之间的速度差，避免 Controller 处理速度过慢而影响 Informer 的工作。</p>

<p>接下来就是 Controller 的表演时间了，也就是上图中的 Processer。控制器从 Work Queue 中取出一个事件并根据自身的业务逻辑对其进行处理，不同的控制器会有不同的处理逻辑。如 ReplicSet 控制器在收到某一个 Pod 被删除的事件时将会重新创建一个 Pod，以保证 Pod 的数量。</p>

<h3 id="3-informer代码编写流程">3. Informer代码编写流程</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="p">(</span><span class="x">
	</span><span class="s">"log"</span><span class="x">

	</span><span class="n">v1</span><span class="x"> </span><span class="s">"k8s.io/api/core/v1"</span><span class="x">
	</span><span class="s">"k8s.io/apimachinery/pkg/labels"</span><span class="x">
	</span><span class="s">"k8s.io/client-go/informers"</span><span class="x">
	</span><span class="s">"k8s.io/client-go/kubernetes"</span><span class="x">
	</span><span class="s">"k8s.io/client-go/tools/cache"</span><span class="x">
	</span><span class="s">"k8s.io/client-go/tools/clientcmd"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="c">// 简单起见硬编码相关配置</span><span class="x">
	</span><span class="n">configPath</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="s">"/home/smartkeyerror/.kube/config"</span><span class="x">
	</span><span class="n">masterURL</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="s">"https://10.39.35.19:6443"</span><span class="x">

	</span><span class="c">// 初始化config</span><span class="x">
	</span><span class="n">config</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">clientcmd</span><span class="o">.</span><span class="n">BuildConfigFromFlags</span><span class="p">(</span><span class="n">masterURL</span><span class="p">,</span><span class="x"> </span><span class="n">configPath</span><span class="p">)</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="c">// 初始化client</span><span class="x">
	</span><span class="n">kubeClient</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">kubernetes</span><span class="o">.</span><span class="n">NewForConfig</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="c">// 获取工厂实例, 通过这个工厂实例可获取到所有资源的 Informer</span><span class="x">
	</span><span class="n">factory</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">informers</span><span class="o">.</span><span class="n">NewSharedInformerFactory</span><span class="p">(</span><span class="n">kubeClient</span><span class="p">,</span><span class="x"> </span><span class="m">0</span><span class="p">)</span><span class="x">
	</span><span class="c">// 创建Pod Informer</span><span class="x">
	</span><span class="n">podInformer</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">factory</span><span class="o">.</span><span class="n">Core</span><span class="p">()</span><span class="o">.</span><span class="n">V1</span><span class="p">()</span><span class="o">.</span><span class="n">Pods</span><span class="p">()</span><span class="x">
	</span><span class="n">informer</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">podInformer</span><span class="o">.</span><span class="n">Informer</span><span class="p">()</span><span class="x">

	</span><span class="n">stopCh</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="k">struct</span><span class="p">{})</span><span class="x">
	</span><span class="k">defer</span><span class="x"> </span><span class="nb">close</span><span class="p">(</span><span class="n">stopCh</span><span class="p">)</span><span class="x">
	</span><span class="k">go</span><span class="x"> </span><span class="n">factory</span><span class="o">.</span><span class="n">Start</span><span class="p">(</span><span class="n">stopCh</span><span class="p">)</span><span class="x">

	</span><span class="k">if</span><span class="x"> </span><span class="o">!</span><span class="n">cache</span><span class="o">.</span><span class="n">WaitForCacheSync</span><span class="p">(</span><span class="n">stopCh</span><span class="p">,</span><span class="x"> </span><span class="n">informer</span><span class="o">.</span><span class="n">HasSynced</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="s">"sync failed"</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="c">// 注册定义处理函数(偷懒, 不使用队列, 直接print)</span><span class="x">
	</span><span class="n">informer</span><span class="o">.</span><span class="n">AddEventHandler</span><span class="p">(</span><span class="n">cache</span><span class="o">.</span><span class="n">ResourceEventHandlerFuncs</span><span class="p">{</span><span class="x">
		</span><span class="n">AddFunc</span><span class="o">:</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">obj</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="n">pod</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">obj</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">v1</span><span class="o">.</span><span class="n">Pod</span><span class="p">)</span><span class="x">
			</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Get a pod:"</span><span class="p">,</span><span class="x"> </span><span class="n">pod</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span><span class="x">
		</span><span class="p">},</span><span class="x">
		</span><span class="n">UpdateFunc</span><span class="o">:</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">oldObj</span><span class="p">,</span><span class="x"> </span><span class="n">newObj</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"update pod"</span><span class="p">)},</span><span class="x">
		</span><span class="n">DeleteFunc</span><span class="o">:</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"delete pod"</span><span class="p">)},</span><span class="x">
	</span><span class="p">})</span><span class="x">

	</span><span class="c">// 创建Lister</span><span class="x">
	</span><span class="n">podLister</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">podInformer</span><span class="o">.</span><span class="n">Lister</span><span class="p">()</span><span class="x">
	</span><span class="c">// 获取所有标签的pod</span><span class="x">
	</span><span class="n">podList</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">podLister</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">Everything</span><span class="p">())</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">podList</span><span class="p">)</span><span class="x">

	</span><span class="o">&lt;-</span><span class="x"> </span><span class="n">stopCh</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>这是一个最简单的使用 Informer 的代码示例，其作用就是通过<code class="highlighter-rouge">List</code>方法打印出当前集群中所有的 Pod，以及在创建、删除和更新 Pod 资源时打印出相关的信息。</p>

<p>首先我们通过集群的地址以及<code class="highlighter-rouge">config</code>认证文件生成一个基本的<code class="highlighter-rouge">config</code>对象，并且根据该对象初始化了一个<code class="highlighter-rouge">kubeClient</code>对象，然后使用<code class="highlighter-rouge">kubeClient</code>创建了一个工厂实例。这个工厂实例中包含了 Kubernetes 中所有资源的 Informer，例如 Pod，Node，Network，RBAC等等。</p>

<p>剩下的代码内容就是按照上述的原理图按部就班的编写和执行了。实际上，对上述代码进行稍加改造即可以得到一个自定义控制器(CRD)的简易版本。控制器模式本质上就是用户期望状态和集群实际状态之间的对比、调谐，使得集群实际状态在某个时刻之后与用户期望状态一致，保存在 Informer 本地缓存的资源状态，其实就是用户的期望状态。</p>

<h3 id="4-小结">4. 小结</h3>

<p>Kubernetes 可以说是一个由事件驱动的分布式对象管理中心，而 Informer 则正是提供驱动事件的发动机。从设计模式的角度来看，Informer 本质上就是一个观察者，Controller 和本地缓存就是基于该观察者所观察的结果进行相应的处理。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Python 虚拟机</title>
	  <link>//Python-Virtual-Machine</link>
	  <author></author>
	  <pubDate>2020-08-18T10:50:25+00:00</pubDate>
	  <guid>//Python-Virtual-Machine</guid>
	  <description><![CDATA[
	     <p>我们常说 Python 一是门解释型语言，只需要敲下 <code class="highlighter-rouge">python code.py</code> 就可以运行编写的代码，而无需使用类似于 <code class="highlighter-rouge">javac</code> 或者 <code class="highlighter-rouge">gcc</code> 进行编译。那么，Python 解释器是真的一行一行读取 Python 源代码而后执行吗? 实际上，Python 在执行程序时和 Java、C# 一样，都是先将源码进行编译生成字节码，然后由虚拟机进行执行，只不过 Python 解释器把这两步合二为一了而已。</p>

<!---more--->

<h3 id="1-python-程序执行过程">1. Python 程序执行过程</h3>

<p>事实上，Python 程序在执行过程中同样需要编译(Compile)，编译产生的结果称之为字节码，而后由 Python 虚拟机逐行地执行这些字节码。所以，Python 解释器由两部分组成: 编译器和虚拟机。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/Process.png" alt="" /></p>

<p>上图展示了 Python 程序的执行过程，以及C程序的编译、汇编与链接过程，从该图中可以非常明显地看出 Python 与 C 程序的执行区别。Python 如此设计的原因在于将程序的执行与底层硬件进一步地分离，无需担心程序的编译、汇编以及链接过程，使得 Python 程序相较于 C 程序而言更加易于移植。</p>

<p>这里再说一下 Python 和 Java 的区别。Java 在程序执行时必须使用 <code class="highlighter-rouge">javac</code> 对源代码进行编译，但是并不直接编译成机器语言，而是和 Python 一样，编译成字节码，而后由 JVM 进行执行。从这一点上来看，Python 和 Java 非常类似，只不过 Python 的编译过程由解释器完成，用户也可以手动的对 Python 源代码进行编译，生成 <code class="highlighter-rouge">.pyc</code> 文件，节省那么一丢丢的时间。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-m</span> compileall &lt;dir&gt;
</code></pre></div></div>

<p>通过运行上述命令可对 <code class="highlighter-rouge">&lt;dir&gt;</code> 目录下所有的Python文件进行编译，编译结果将会存放于该目录下的 <code class="highlighter-rouge">__pycache__</code> 的 <code class="highlighter-rouge">.pyc</code> 文件中。</p>

<h3 id="2-编译过程与字节码">2. 编译过程与字节码</h3>

<p>在Python的内建函数中，定义了 <code class="highlighter-rouge">compile</code> 以及 <code class="highlighter-rouge">exec</code> 两个方法，前者将源代码编译成为 Code Object 对象，Code Object 对象中即保存着源代码所对应的字节。而 <code class="highlighter-rouge">exec</code> 方法则是运行 Python 语句或者是由 <code class="highlighter-rouge">compile</code> 方法所返回的 Code Object。<code class="highlighter-rouge">exec</code> 方法可直接运行 Python 语句，其参数并一定需要是 Code Object。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> snippet <span class="o">=</span> <span class="s2">"for i in range(3): print(f'Output: {i}')"</span>

<span class="o">&gt;&gt;&gt;</span> result <span class="o">=</span> compile<span class="o">(</span>snippet, <span class="s2">""</span>, <span class="s2">"exec"</span><span class="o">)</span>

<span class="o">&gt;&gt;&gt;</span> result
&lt;code object &lt;module&gt; at 0x7f8e7e6471e0, file <span class="s2">""</span>, line 1&gt;

<span class="o">&gt;&gt;&gt;</span> <span class="nb">exec</span><span class="o">(</span>result<span class="o">)</span>
Output: 0
Output: 1
Output: 2
</code></pre></div></div>

<p>在上述代码中定义了一个非常简单的 Python 代码片段，其作用就是在标准输出中打印0，1，2这三个数而已。通过 <code class="highlighter-rouge">compile</code> 方法对该片段进行编译，得到 Code Object 对象，并将该对象交由 <code class="highlighter-rouge">exec</code> 函数执行。下面来具体看下返回的 Code Object 中到底包含了什么。</p>

<p>在源码 <code class="highlighter-rouge">cpython/Include/code.h</code> 中定义了 <code class="highlighter-rouge">PyCodeObject</code> 结构体，即 Code Object 对象:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Bytecode object */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>               <span class="cm">/* Python定长对象头 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_code</span><span class="p">;</span>          <span class="cm">/* 指令操作码，即字节码 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_consts</span><span class="p">;</span>        <span class="cm">/* 常量列表 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_names</span><span class="p">;</span>         <span class="cm">/* 名称列表(不一定是变量，也可能是函数名称、类名称等) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_filename</span><span class="p">;</span>      <span class="cm">/* 源码文件名称 */</span>
    
    <span class="p">...</span>                         <span class="cm">/* 省略若干字段 */</span>
<span class="p">}</span> <span class="n">PyCodeObject</span><span class="p">;</span>
</code></pre></div></div>

<p>字段 <code class="highlighter-rouge">co_code</code> 即为 Python 编译后字节码，其它字段在此处可暂时忽略。字节码的格式为人类不可阅读格式，其形式通常是这样的:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> result.co_code
b<span class="s1">'x\x1ee\x00d\x00\x83\x01D\x00]\x12Z\x01e\x02d\x01e\x01\x9b\x00\x9d\x02\x83\x01\x01\x00q\nW\x00d\x02S\x00'</span>
</code></pre></div></div>

<p>这个时候我们需要一个”反汇编器”来将字节码转换成人类可阅读的格式，”反汇编器”打引号的原因是在 Python 中并不能称为真正的反汇编器。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> import dis
<span class="o">&gt;&gt;&gt;</span> dis.dis<span class="o">(</span>result.co_code<span class="o">)</span>
          0 SETUP_LOOP              30 <span class="o">(</span>to 32<span class="o">)</span>
          2 LOAD_NAME                0 <span class="o">(</span>0<span class="o">)</span>
          4 LOAD_CONST               0 <span class="o">(</span>0<span class="o">)</span>
          6 CALL_FUNCTION            1
          8 GET_ITER
    <span class="o">&gt;&gt;</span>   10 FOR_ITER                18 <span class="o">(</span>to 30<span class="o">)</span>
         12 STORE_NAME               1 <span class="o">(</span>1<span class="o">)</span>
         14 LOAD_NAME                2 <span class="o">(</span>2<span class="o">)</span>
         16 LOAD_CONST               1 <span class="o">(</span>1<span class="o">)</span>
         18 LOAD_NAME                1 <span class="o">(</span>1<span class="o">)</span>
         20 FORMAT_VALUE             0
         22 BUILD_STRING             2
         24 CALL_FUNCTION            1
         26 POP_TOP
         28 JUMP_ABSOLUTE           10
    <span class="o">&gt;&gt;</span>   30 POP_BLOCK
    <span class="o">&gt;&gt;</span>   32 LOAD_CONST               2 <span class="o">(</span>2<span class="o">)</span>
         34 RETURN_VALUE
</code></pre></div></div>

<p><code class="highlighter-rouge">dis</code> 方法将返回字节码的助记符(mnemonics)，和汇编语言非常类似，从这些助记符的名称上我们就可以大概猜出解释器将要执行的动作，例如 <code class="highlighter-rouge">LOAD_NAME</code> 加载名称，<code class="highlighter-rouge">LOAD_CONST</code> 加载常量。所以，我们完全可以将这些助记符看作是汇编指令，而指令的操作数则在助记符后面描述。例如 <code class="highlighter-rouge">LOAD_NAME</code> 操作，其操作数的下标为0，而在源代码中使用过的名称保存在 <code class="highlighter-rouge">co_names</code> 字段中，所以 <code class="highlighter-rouge">LOAD_NAME  0</code> 即表示加载 <code class="highlighter-rouge">result.co_names[0]</code> :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> result.co_names[0]
<span class="s1">'range'</span>
</code></pre></div></div>

<p>又比如 <code class="highlighter-rouge">LOAD_CONST</code> 操作，其操作数的下标也为0，只不过这次操作数不再保存在 <code class="highlighter-rouge">co_names</code> ，而是 <code class="highlighter-rouge">co_consts</code> 中，所以 <code class="highlighter-rouge">LOAD_CONST  0</code> 则表示加载 <code class="highlighter-rouge">result.co_consts[0]</code> :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> result.co_consts[0]
3
</code></pre></div></div>

<p>由于 Code Object 对象保存了常量、变量、名称等一系列的上下文内容，所以可以直接对该对象进行反汇编操作:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> dis.dis<span class="o">(</span>result<span class="o">)</span>
  1           0 SETUP_LOOP              30 <span class="o">(</span>to 32<span class="o">)</span>
              2 LOAD_NAME                0 <span class="o">(</span>range<span class="o">)</span>
              4 LOAD_CONST               0 <span class="o">(</span>3<span class="o">)</span>
              ...
</code></pre></div></div>

<p>现在，我们可以对 Python 字节码做一下小结了。Python 在编译某段源码时，并不会直接返回字节码，而是返回一个 Code Object 对象，字节码则保存在该对象的 <code class="highlighter-rouge">co_code</code> 字段中。由于字节码是一个二进制字节序列，无法直接进行阅读，所以需要通过”反汇编器”(<code class="highlighter-rouge">dis</code> 模块)将字节码转换成人类可读的助记符。助记符的形式和汇编语言非常类似，均由操作指令+操作数所组成。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/compile.png" alt="" /></p>

<h3 id="3-命名空间与作用域">3. 命名空间与作用域</h3>

<p>Python 的命名空间与作用域经常被开发者所忽略，在未深入了解 Python 虚拟机之前，我个人也认为这些东西并不重要。但是，命名空间和变量作用域将会是 Python 虚拟机在执行过程中一个非常重要的一环。</p>

<p>命名空间实际上是名称到对象的一种映射，本质上就是一个键-值对，所以大部分的命名空间由 <code class="highlighter-rouge">dict</code> 实现。命名空间可以分为3类: 内置命名空间，全局命名空间与局部命名空间，在作用域存在嵌套的特殊情况下，可能还会有闭包命名空间。</p>

<h4 id="31-内置命名空间build-in">3.1 内置命名空间(Build-in)</h4>
<p>Python语言内置的名称，例如内置函数名(<code class="highlighter-rouge">len</code>, <code class="highlighter-rouge">dis</code>)，内置异常(<code class="highlighter-rouge">Exception</code>)等。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> import builtins
<span class="o">&gt;&gt;&gt;</span> builtins.__dict__
</code></pre></div></div>

<h4 id="32-全局命名空间global">3.2 全局命名空间(Global)</h4>

<p>全局命名空间以模块进行划分，每一个模块中都包含了 <code class="highlighter-rouge">dict</code> 对象，其中保存了模块中的变量名、类名、函数名等等。在字节码中，全局变量的导入使用 <code class="highlighter-rouge">LOAD_GLOBAL</code> 。</p>

<h4 id="33-局部命名空间local">3.3 局部命名空间(Local)</h4>

<p>局部命名空间可以简单的认为就是函数的命名空间，例如函数参数，在函数中定义的局部变量。</p>

<p>下面是关于局部命名空间和全局命名空间的一个非常典型的例子:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">number</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">number</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">foo</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnboundLocalError: <span class="nb">local </span>variable <span class="s1">'number'</span> referenced before assignment
</code></pre></div></div>

<p>在运行上述代码时将会抛出 <code class="highlighter-rouge">UnboundLocalError</code> 异常，这简直莫名其妙，在其它语言中，上述代码都能够正常运行，以 C 语言为例:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">number</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>  <span class="c1">// 正常运行并打印结果: 20
</span><span class="p">}</span>
</code></pre></div></div>

<p>但是在 Python 中却抛出了异常，这又是为什么? 官方在 <a href="https://docs.python.org/3.8/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python">Python FAQ</a> 给出了相关解释，原文如下:</p>

<blockquote>
  <p>In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a value anywhere within the function’s body, it’s assumed to be a local unless explicitly declared as global.</p>
</blockquote>

<p>简单来说，当我们在函数中引用一个变量时，Python 将隐式地默认该变量为全局变量。但是，一旦变量在没有<code class="highlighter-rouge">global</code>关键字修饰的情况下进行了赋值操作，Python 会将其作为局部变量处理。</p>

<p>而语句 <code class="highlighter-rouge">number += 10</code> 进行了赋值动作，此时 <code class="highlighter-rouge">number</code> 为局部变量，该函数中又没有声明该局部变量，故而抛出异常。Python 这么做的目的就是为了防止开发者者在某些函数中修改了全局变量而又不自知，通过显式地添加 <code class="highlighter-rouge">global</code> 关键字来确保开发者知道自己在做什么。这正如 Python 之禅所述的，Explicit is better than implicit。</p>

<p>首先先来看下正常的局部变量在字节码中是如何处理的:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dis</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 LOAD_CONST               1 <span class="o">(</span>10<span class="o">)</span>
2 STORE_FAST               0 <span class="o">(</span>number<span class="o">)</span>
4 LOAD_GLOBAL              0 <span class="o">(</span>print<span class="o">)</span>
6 LOAD_FAST                0 <span class="o">(</span>number<span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">STORE_FAST</code> 将当前变量压入到函数运行栈中，而 <code class="highlighter-rouge">LOAD_FAST</code> 则从函数运行栈取出该变量。<code class="highlighter-rouge">LOAD_FAST</code> 之前必须存在 <code class="highlighter-rouge">STORE_FAST</code>，否则在运行时将会抛出异常。对于最初的例子而言，在未添加 <code class="highlighter-rouge">global</code> 关键字的情况下，语句 <code class="highlighter-rouge">number += 10</code> 将会直接执行 <code class="highlighter-rouge">LOAD_FAST</code> 指令，而此时当前变量并未压入至当前函数运行栈。</p>

<h4 id="34-闭包命名空间enclosing">3.4 闭包命名空间(Enclosing)</h4>

<p>当出现嵌套函数定义时，或者作用域嵌套时，Python 将会把内层作用域所依赖的所有外层命名存储在一个特殊的命名空间中，也就是闭包命名空间。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">logging</span> <span class="k">as</span> <span class="n">logger</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s">"Execute func: {func.__name__}"</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">foo</code> 闭包函数中，参数 <code class="highlighter-rouge">func</code> 即属于闭包命名空间，内层函数 <code class="highlighter-rouge">wrapper</code> 在寻找变量时，若局部命名空间内无此变量，将会于闭包命名空间中进行查找。</p>

<p>如果在闭包函数中对外层函数的局部变量进行赋值会发生什么?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
        <span class="n">number</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">return</span> <span class="n">bar</span>
</code></pre></div></div>

<p>正如同在局部命名空间中提到的一样，当一个变量在函数中被赋值时，Python 默认将其作为<strong>全局变量</strong>，既不是局部变量，也不是这里提到的闭包空间变量。所以，当我们在实际运行 <code class="highlighter-rouge">bar</code> 方法时，同样会得到 <code class="highlighter-rouge">UnboundLocalError</code> 异常。在这里如果想要使用 <code class="highlighter-rouge">foo</code> 函数中的 <code class="highlighter-rouge">number</code> 变量的话，需要使用 <code class="highlighter-rouge">nonlocal</code> 关键字进行修饰，让 Python 去 <code class="highlighter-rouge">bar</code> 函数的最近外层，也就是 <code class="highlighter-rouge">foo</code> 寻找该变量的定义。</p>

<p>此外，闭包指函数，而不是类，所以在类的嵌套中，将不会存在闭包命名空间:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Reader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">4096</span>

    <span class="k">class</span> <span class="nc">ReaderInternal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span> <span class="o">=</span> <span class="n">BUFFER_SIZE</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="c"># ...</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">Reader</span><span class="o">.</span><span class="n">ReaderInternal</span><span class="p">()</span>
</code></pre></div></div>

<p>在执行 <code class="highlighter-rouge">Reader.ReaderInternal()</code> 语句时，将会抛出 <code class="highlighter-rouge">NameError</code> 的异常，表示 <code class="highlighter-rouge">BUFFER_SIZE</code> 未定义。</p>

<p>当语句需要查找变量 <code class="highlighter-rouge">X</code> 时，将会按照 Local -&gt; Enclosing -&gt; Global -&gt; Builtin 的顺序进行查找，俗称 LEGB 规则。</p>

<h3 id="4-python虚拟机的执行">4. Python虚拟机的执行</h3>

<h4 id="41-执行上下文栈帧">4.1 执行上下文——栈帧</h4>

<p>在 x86-64 CPU 中包含了16个64位的通用目的寄存器，这些寄存器用于存储数据或者是指针。在这16个通用目的寄存器中，有两个较为特殊的寄存器: %rsp 与 %rbp。%rsp 为栈指针寄存器，表示运行时栈的结束位置，可以简单地理解为栈顶。%rbp 为栈帧指针，用于标识当前栈帧的起始位置。</p>

<p>在 x86 体系结构中，函数调用是通过栈和栈帧实现的。当一个函数被调用时，首先做的事情就是将调用者栈帧指针入栈，以保留调用关系。其次将为调用的函数创建栈帧，栈帧中包含了函数的参数、创建的局部变量等信息。</p>

<p>回到Python虚拟机中，虚拟机在进行函数调用时，运行方式和x86没什么区别，都是由栈和栈帧所实现的。而栈帧则是由 <code class="highlighter-rouge">PyFrameObject</code> 表示，于源码 <code class="highlighter-rouge">cpython/Include/frameobject.h</code> 中定义。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_frame</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>           <span class="cm">/* Python固定长度对象头 */</span>
    <span class="k">struct</span> <span class="n">_frame</span> <span class="o">*</span><span class="n">f_back</span><span class="p">;</span>      <span class="cm">/* 指向上一个栈帧的指针 */</span>
    <span class="n">PyCodeObject</span> <span class="o">*</span><span class="n">f_code</span><span class="p">;</span>       <span class="cm">/* Code Object代码对象，其中包含了字节码 */</span>
    
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_builtins</span><span class="p">;</span>       <span class="cm">/* 内建命名空间字典(PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_globals</span><span class="p">;</span>        <span class="cm">/* 全局命名空间字典(PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_locals</span><span class="p">;</span>         <span class="cm">/* 局部命名空间表(通常是数组) */</span>

    <span class="kt">int</span> <span class="n">f_lasti</span><span class="p">;</span>                <span class="cm">/* 上一条指令编号 */</span>
    
    <span class="p">...</span>
<span class="p">}</span> <span class="n">PyFrameObject</span><span class="p">;</span>
</code></pre></div></div>

<p>可以看到，在一个栈帧中包含了Code Object代码对象，三个命名空间表，上一个栈帧指针等信息。可以说，<code class="highlighter-rouge">PyFrameObject</code> 对象包含了Python虚拟机执行所需的全部上下文。在 Python 源码层面，可以通过 <code class="highlighter-rouge">sys</code> 模块中的 <code class="highlighter-rouge">_getframe</code> 方法来获取当前函数运行时的栈帧，方法将返回 <code class="highlighter-rouge">FrameType</code> 类型，其实就是 <code class="highlighter-rouge">PyFrameObject</code> 简化后的 Python 结构。</p>

<p>下面通过一段简单的代码来具体看下 Python 运行时的栈帧结构:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">():</span>
    <span class="n">middle</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">middle</span><span class="p">():</span>
    <span class="n">finish</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">finish</span><span class="p">():</span>
    <span class="n">print_frame</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">print_frame</span><span class="p">():</span>
    <span class="n">current_frame</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">current_frame</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"func name: {current_frame.f_code.co_name}"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"*"</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="n">current_frame</span><span class="o">.</span><span class="n">f_back</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">first</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func name: print_frame
<span class="k">****************************************</span>
func name: finish
<span class="k">****************************************</span>
func name: middle
<span class="k">****************************************</span>
func name: first
<span class="k">****************************************</span>
func name: &lt;module&gt;
<span class="k">****************************************</span>
</code></pre></div></div>

<p>在 Python 开始执行该程序时，首先创建一个用于执行模块代码对象的栈帧对象，也就是 <code class="highlighter-rouge">module</code> 。随着一个一个的函数调用，不同的栈帧对象将会被创建，并且压入至运行栈中，而连接这些栈帧对象的纽带就是 <code class="highlighter-rouge">f_back</code> 指针。当栈顶的函数执行完毕开始返回时，将沿着 <code class="highlighter-rouge">f_back</code> 指针方向一直到当前调用链的起始位置。</p>

<p>结合前面提到的字节码和命名空间，我们可以用一张简图来描述。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/PyFrameObject.png" alt="" /></p>

<h4 id="42-指令的执行">4.2 指令的执行</h4>

<p>指令执行的源码均位于 <code class="highlighter-rouge">cpython/Python/ceval.c</code> 中，入口函数有两个，一个是 <code class="highlighter-rouge">PyEval_EvalCode</code> ，另一个则是 <code class="highlighter-rouge">PyEval_EvalCodeEx</code> ，最终的实际调用函数为 <code class="highlighter-rouge">_PyEval_EvalCodeWithName</code>，所以我们只需要关注该函数即可。</p>

<p><code class="highlighter-rouge">_PyEval_EvalCodeWithName</code> 函数的主要作用为进行函数调用的例常检查，例如校验函数参数的个数、类型，校验关键字参数等。除此之外，该函数将会初始化栈帧对象并将其交给 <code class="highlighter-rouge">PyEval_EvalFrame</code> 函数进行处理，最终由 <code class="highlighter-rouge">_PyEval_EvalFrameDefault</code> 函数真正的运行指令。</p>

<p><code class="highlighter-rouge">_PyEval_EvalFrameDefault</code> 函数定义超过了3K行，绝大部分的逻辑其实都是 <code class="highlighter-rouge">switch-case</code> : 根据指令类型执行相应的逻辑。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">LOAD_CONST</span><span class="p">):</span> <span class="p">{</span>      <span class="cm">/* 加载常量 */</span>
            <span class="p">...</span>
        <span class="p">}</span>		
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">ROT_TWO</span><span class="p">):</span> <span class="p">{</span>         <span class="cm">/* 交换两个变量 */</span>
            <span class="p">...</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">FORMAT_VALUE</span><span class="p">):{</span>     <span class="cm">/* 格式化字符串 */</span>
            <span class="p">...</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>可以看到 <code class="highlighter-rouge">TARGET()</code> 调用中的参数其实就是 <code class="highlighter-rouge">dis</code> 方法返回的助记符，当我们在分析助记符的具体实现逻辑时，可以在该文件中找到对应的 C 实现方法。</p>

<h4 id="43-gil-与字节码的执行">4.3 GIL 与字节码的执行</h4>

<p>对于 Python 中的容器，例如 dict，并没有实现像 Java 中的 <code class="highlighter-rouge">ConcurrentHashMap</code>，或者是 Golang 中的 <code class="highlighter-rouge">sync.Map</code>，这是因为 Python 中的容器(list, dict)本身就是并发安全的，但是在这些容器的源码中并没有发现定义 <code class="highlighter-rouge">mutex</code>，也就是说，Python 容器的并发安全并不是通过互斥锁实现的。</p>

<p>实际上，Python 容器的并发安全是通过 GIL 实现的，也就是被广大 Pythoner 口诛笔伐的全局解释器锁。某一个线程想要运行必须要首先获取全局锁，如此一来，在同一时刻只能有一个线程运行，无法充分利用多核的硬件资源。</p>

<p>Python 的线程调度非常类似于 CPU 的时间片实现，只不过并不是以时间为判断标准，而是以执行字节码的数量作为判断标准。当某一个线程执行了足够多的字节码条数时，当前线程将释放全局锁，唤醒其它线程进行执行。</p>

<p><strong>所以，得益于 GIL 的存在，Python 容器在进行诸如扩容、缩容操作时，完全不必担心并发问题，因为一条字节码的执行一定是原子性的。</strong></p>

	  ]]></description>
	</item>

	<item>
	  <title>VXLAN—构建Overlay容器网络</title>
	  <link>//VXLAN</link>
	  <author></author>
	  <pubDate>2020-08-06T09:06:25+00:00</pubDate>
	  <guid>//VXLAN</guid>
	  <description><![CDATA[
	     <p>由于 VLAN 实现中的 VLAN ID 仅有12位，只能划分4096个虚拟局域网网段，对于云计算等领域而言，其用户远远不止4096个。并且，VLAN 依赖于交换机等物理设备的实现，一旦升级物理设备，集群网络可能需要重新配置。因此，基于上述的限制，VMware、Cisco 等大型网络企业推出了 VXLAN 解决方案。</p>

<!---more--->

<p>VXLAN 全称为 Virtual eXtensible Local Area Network，可拓展虚拟局域网，不依赖于硬件实现，而是在三层网络(网络层)的基础之上构建出一个虚拟的二层网络(链路层)。也就是说，只要主机间 IP 地址可达，就可以使用 VXLAN 的方式构建一个 Overlay 网络。</p>

<blockquote>
  <p>Overlay: 可以理解为覆盖网络，属于一种虚拟网络的实现，依赖于物理网络，而物理网络又可称之为 Underlay。</p>
</blockquote>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/virtual-machine-communicate-problems.png" alt="" /></p>

<p>在实际的介绍 VXLAN 之前，先来看一个集群中虚拟机通讯的问题。如上图所示，虚拟机-A(<code class="highlighter-rouge">192.19.2.2</code>)想要和虚拟机-C(<code class="highlighter-rouge">192.16.2.6</code>)进行通信，要如何实现?</p>

<p>由于节点<code class="highlighter-rouge">10.168.4.3</code>和<code class="highlighter-rouge">10.168.9.3</code>能够实现通信，那么是否能够将虚拟机间通讯的数据包封装在节点间的通讯包之上，抵达目的地之后再进行解包、分发呢? 就好像特洛伊木马一样。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/virtual-machine-solution.png" alt="" /></p>

<p>如上图所示，虚拟机-A发送给虚拟机-C的数据包，首先经过一个工具进行封包，暂且称之为Tool，封包的结果就是将该数据包放置在节点间通讯数据包的 Body 中，作为数据发送给节点B。节点B收到该数据包之后，经过某种过滤规则，检查 Body，发现这是一个发送给虚拟机-C的数据包，那么将数据包发送给节点C，单向通讯完成。</p>

<p>上述的过程其实就是 VXLAN 的基本原理组成，本质上就是对虚拟机间通讯数据包的封装和解封，乘着节点间通讯这条大船抵达目的地。</p>

<h3 id="1-vxlan协议原理">1. VXLAN协议原理</h3>

<p>在 VXLAN 协议中，负责封包、解包的组件称之为 VTEP(VXLAN Tunnel Endpoints，VXLAN 隧道端点)，可以简单的认为就是运行在各个节点上的一个进程。</p>

<p>每一个 VTEP 都有一个唯一的标志符，称之为 VNI(VXLAN Network Identifier，VXLAN 网络标识符)，其实就是拓展的 VLAN ID。VNI 被设计成24位，可以容纳16777216个不同的虚拟局域网，相较于 VLAN 是一个非常大的提升。</p>

<p>VXLAN 在节点中的传输协议选择了 UDP 协议，而不是 TCP 协议。原因在于 UDP 协议相较于 TCP 协议速度更快，无需连接的建立与拆除，数据包的可靠传输则由虚拟机间的传输协议保证。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/VXLAN-package.png" alt="" /></p>

<p>其中，VXLAN Header 由 VTEP 添加，其中包含了24位 VNI 的值。可以看到，VXLAN 其实就是对原有网络添加了一层拓展: VTEP。当数据包到达主机时，内核将 MAC 头和 IP 头取下，将 UDP 报文段发送给主机上的 VTEP 进程，VTEP 进程首先检查 VNI 的值是否匹配(是不是给自己的包)，然后根据 Inner IP Header 决定发送给哪一个具体的虚拟机。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/VXLAN-Transfer.png" alt="" /></p>

<p>现在，我们对 VXLAN 协议的基本原理已经很清楚了，现在再来看一些细节问题。<strong>首先，虚拟机-A发出的数据帧的目标 MAC 地址，也就是目标 VTEP 的 MAC 地址该如何获取?</strong> 两种方式，一种是通过广播的方式，另外一种，则是由外部进程自动的添加至各节点的 ARP 表中。<strong>其次，IP 地址为192.16.2.6这台虚拟机所在节点的IP地址如何获取?</strong> 该 IP 地址则是通过 Linux 内核中的 FDB(Forwarding Database) 获取的，在该表中，会记录 VTEP 的 MAC 地址与节点 IP 地址的映射关系，该映射关系同样可以通过广播学习获取，或者由外部进程维护。</p>

<blockquote>
  <p>经典的”外部进程”有 flannel、Weave 等容器网络框架</p>
</blockquote>

<h3 id="2-使用-vagrant-构建-vxlan-点对点通信">2. 使用 Vagrant 构建 VXLAN 点对点通信</h3>

<p>Vagrant 环境如下:</p>
<ul>
  <li>node-1: 网卡接口-enp0s8，IP地址-192.168.2.15/24</li>
  <li>node-2: 网卡接口-enp0s8，IP地址-192.168.2.16/24</li>
</ul>

<p>首先，在node-1上添加 vxlan interface:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span><span class="nb">sudo </span>ip link add vxlan0 <span class="nb">type </span>vxlan <span class="se">\</span>
    id 1024 <span class="se">\</span>
    dstport 4789 <span class="se">\</span>
    remote 192.168.2.15 <span class="se">\</span>
    dev enp0s8
</code></pre></div></div>

<p>上述命令将创建出一个名称为<code class="highlighter-rouge">vxlan0</code>、类型为 vxlan 的网络接口，并且指定 VNI 为<code class="highlighter-rouge">1024</code>，vtep 通信端口为<code class="highlighter-rouge">4789</code>，并且手动地指出了对端 VTEP 的 IP 地址(<code class="highlighter-rouge">192.168.2.16</code>)。</p>

<p>其次，为 vxlan0 网络接口添加一个 IP 地址，该 IP 地址可以是任意值:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span><span class="nb">sudo </span>ip addr add 10.100.1.15/24 dev vxlan0
vagrant@node-1:~<span class="nv">$ </span><span class="nb">sudo </span>ip link <span class="nb">set </span>vxlan0 up
</code></pre></div></div>

<p>那么此时所有目标地址为<code class="highlighter-rouge">10.100.1.10/24</code>网段的数据包均会通过 vxlan0 接口处理，可以从路由表上查看此信息:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span>ip route
10.100.1.0/24 dev vxlan0 proto kernel scope link src 10.100.1.15
</code></pre></div></div>

<p>并且，如果此时查看 Linux FDB 表的话会发现，此时表项中的 MAC 地址为空值:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span>bridge fdb
00:00:00:00:00:00 dev vxlan0 dst 192.168.2.16 via enp0s8 self permanent
</code></pre></div></div>

<p>即所有经过 vxlan0 处理的数据包都会发到<code class="highlighter-rouge">192.168.2.16</code>，其原因在于在创建 vxlan0 时，手动地指定了对端 IP 地址。</p>

<p>用同样的方式在另一台虚拟机上创建 vxlan0 接口，并配置相应的 IP 地址，即可测试连通性。</p>

<p>通过上面的实验用例，我们可以看到几个非常关键的步骤:</p>

<ul>
  <li><strong>在路由表中添加 vtep 设备网络段的路由信息</strong></li>
  <li><strong>在 ARP 表中添加 vtep 设备的 MAC 地址与 vtep 的 IP 地址映射</strong></li>
  <li><strong>在 FDB 表中添加 vtep 设备的 MAC 地址与 vtep 所在节点的 IP 地址映射</strong></li>
</ul>

<p>实际上，<code class="highlighter-rouge">Flannel</code>这一经典的 Kubernetes 容器网络解决方案的 VXLAN 模式就是这么实现的，VXLAN 模式所组建的覆盖网络，其实就是一个由不同宿主机上的 VTEP 设备所组成的虚拟二层网络。</p>

<h3 id="reference">Reference</h3>

<ul>
  <li><a href="https://www.kernel.org/doc/Documentation/networking/vxlan.txt">https://www.kernel.org/doc/Documentation/networking/vxlan.txt</a></li>
  <li><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100087027">https://support.huawei.com/enterprise/zh/doc/EDOC1100087027</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>浅析gRPC</title>
	  <link>//gRPC</link>
	  <author></author>
	  <pubDate>2020-07-23T09:06:25+00:00</pubDate>
	  <guid>//gRPC</guid>
	  <description><![CDATA[
	     <p>gRPC是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。(这Ctrl-C/V也是没有下限了….</p>

<!---more--->

<h3 id="1-protocol-buffers">1. Protocol Buffers</h3>

<p>在早期，ProtoBuf主要用于解决Google内部的服务器高低版本的兼容性问题，后来由于其高效的数据传输效率被用于gRPC的传输数据格式。</p>

<p>相较于XML以及Json，ProtoBuf在传输和存储时由于其体积更小，所以效率更高，并且序列化的速度也比Json的序列化速度更快，原因将在后续部分介绍。</p>

<p>除此之外，ProtoBuf的最大特点就是支持向后兼容。如果使用Json或者XML的话，需要应用程序自行处理新旧版本数据格式之间的兼容性。而ProtoBuf则不需要破坏已经被部署的服务结构，ProtoBuf会帮助用户处理好高低版本的兼容性问题。</p>

<h4 id="11-protobuf所支持的数据类型">1.1 ProtoBuf所支持的数据类型</h4>

<p>对于基本数据类型，如int，float，double，string，bool以及bytes，ProtoBuf均支持定义以上数据类型。对于int类型的数据，ProtoBuf对其进行了额外的拓展，在不同的场景使用不同的整型将会有不同的运行效率。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">ProtoBuf Type</th>
      <th style="text-align: left">Explain</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">int32</td>
      <td style="text-align: left">int32最大支持4字节的整型数字，编码负数时效率较低</td>
    </tr>
    <tr>
      <td style="text-align: left">int64</td>
      <td style="text-align: left">int32最大支持8字节的整型数字，编码负数时效率较低</td>
    </tr>
    <tr>
      <td style="text-align: left">uint32</td>
      <td style="text-align: left">uint32最大支持4字节的无符整数</td>
    </tr>
    <tr>
      <td style="text-align: left">uint64</td>
      <td style="text-align: left">uint32最大支持8字节的无符整数</td>
    </tr>
    <tr>
      <td style="text-align: left">sint32</td>
      <td style="text-align: left">sint32最大支持4字节的有符整数，编码负数时效率更高</td>
    </tr>
    <tr>
      <td style="text-align: left">sint64</td>
      <td style="text-align: left">sint32最大支持8字节的有符整数，编码负数时效率更高</td>
    </tr>
    <tr>
      <td style="text-align: left">fixed32</td>
      <td style="text-align: left">不使用可变长度方式进行编码，总是传输4字节，在编码超过$2^{28}$数值的整数时效率更高</td>
    </tr>
    <tr>
      <td style="text-align: left">fixed64</td>
      <td style="text-align: left">不使用可变长度方式进行编码，总是传输8字节，在编码超过$2^{56}$数值的整数时效率更高</td>
    </tr>
  </tbody>
</table>

<p>除了上述的基本数据类型以外，ProtoBuf同时也支持列表，字典以及枚举类型的定义，再加上<code class="highlighter-rouge">message</code>类型支持嵌套定义，几乎可以说能够覆盖日常开发中的所有需求了。</p>

<h4 id="12-protobuf中的消息定义">1.2 ProtoBuf中的消息定义</h4>

<p><code class="highlighter-rouge">message</code>数据类型是ProtoBuf在序列化和反序列化中的最小单位，和C结构体非常类似。</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">Response</span> <span class="p">{</span>
    <span class="kt">int32</span> <span class="na">code</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">msg</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int32</span> <span class="na">data</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">message</code>中的字段类型和字段名称无需赘述，值得关注的是后面的Field Numbers，字段序列号。该序列号将会在数据存储和传输时用于指代<code class="highlighter-rouge">message</code>中所定义的字段，即对源数据编码成ProtoBuf格式数据后，字段名称将会被舍弃，转而使用字段系列号进行代替，所以会说ProtoBuf并不是自描述的传输格式，同时也是数据体积更小的原因之一。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MicroService/gRPC/FieldNumbers.png" alt="" /></p>

<p>所以，一个<code class="highlighter-rouge">message</code>中的字段系列号必须唯一，同时范围必须在[$1$, $2^{29}-1$]之间。并且19000到19999之间的数值被ProtoBuf内部所用，也不可定义。</p>

<p>下面是一个使用了大部分数据类型的<code class="highlighter-rouge">message</code>定义:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">UserStatus</span> <span class="p">{</span>
    <span class="c1">// 值为0的枚举值必须定义，因为这是ProtoBuf对枚举值的默认值
</span>    <span class="c1">// 同时，该零值不应该被应用程序所使用，否则会出现歧义
</span>    <span class="na">USER_STATUS_INVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="na">USER_STATUS_NORMAL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">USER_STATUS_FROZEN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">USER_STATUS_DELETED</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">MainAddress</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="na">province</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">city</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">address</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">UserInfo</span> <span class="p">{</span>
    <span class="kt">uint32</span> <span class="na">user_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">mobile</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">repeated</span> <span class="kt">string</span> <span class="na">extra_mobile</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">UserStatus</span> <span class="na">status</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">MainAddress</span> <span class="na">main_address</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="na">is_vip</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="13-protobuf编码">1.3 ProtoBuf编码</h4>

<p>ProtoBuf格式的数据体积更小的原因一方面归功于使用字段系列号来代替字段名称，另一方面则是因为对整型采用了可变长度编码方式，即使是指定了<code class="highlighter-rouge">int32</code>类型的数据也可能只使用一字节存储。</p>

<h5 id="131-base-128-varints">1.3.1 Base 128 Varints</h5>

<p>Varint使用一个或者多个字节表示一个数字，数字的值越小，所使用的字节数也会更小。其长度并不固定，所以称之为”可变长整数”。</p>

<p>Varint中的每个字节(最后一个字节除外)都设置了最高有效位(msb)，用于表示后面还会有更多字节出现，所以Varint中的最后一个字节不会设置msb。由于首位被当做是msb使用，所以一个字节只有7位有效位。</p>

<p>例如数字1，可以使用1字节进行表示，那么其最高有效位即可设置为0:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000 0001
</code></pre></div></div>

<p>对于多字节的数字，除了最后一个字节以外，其余字节的首位都应该置为1，以表示后续仍有字节。以数字1024为例，在一般情况下，1024需要使用2个字才能表示:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1024 <span class="o">=</span> 0000 0100 0000 0000
</code></pre></div></div>

<p>现在来看下Varint的编码过程:</p>

<ul>
  <li>首先，1024超过了7位，所以必须使用至少2个字节表示，但是又小于14位，所以需要2个字节表示。按每7位取一个字节，若不够7位则用0补齐:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000 0100 0000 0000 -&gt; 0001000 0000000
</code></pre></div></div>

<ul>
  <li>将低字节写入到高字节，最后一个字节最高位补0，其余字节最高位补1，即为最终结果:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10000000 00001000
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MicroService/gRPC/Varint.png" alt="" /></p>

<h5 id="132-message-structure">1.3.2 Message Structure</h5>

<p>在ProtoBuf中，<code class="highlighter-rouge">message</code>结构其实就是一系列的键值对，只不过<code class="highlighter-rouge">message</code>在序列化成二进制时，对键和值进行了特殊的处理而已。</p>

<p>首先来看对键的处理，键的计算方式是<code class="highlighter-rouge">(field_number &lt;&lt; 3) | wire_type</code>，根据键的计算公式可以看出，键的最后3位就是字段类型。<code class="highlighter-rouge">field_number</code>即为用户自定义的字段序列号，而<code class="highlighter-rouge">wire_type</code>则是一个由ProtoBuf所定义的对类型的”枚举”。:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Write Type</th>
      <th style="text-align: left">Meaning</th>
      <th style="text-align: left">Used For</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">0</td>
      <td style="text-align: left">Varint</td>
      <td style="text-align: left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
    </tr>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">64-bit</td>
      <td style="text-align: left">fixed64, sfixed64, double</td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">Length-delimited</td>
      <td style="text-align: left">string, bytes, embedded messages, packed repeated fields</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">32-bit</td>
      <td style="text-align: left">fixed32, sfixed32, float</td>
    </tr>
  </tbody>
</table>

<p>值得注意是当<code class="highlighter-rouge">wire_type</code>为2时，序列化结果中还需要包含数据的长度，即<code class="highlighter-rouge">length</code>。</p>

<ul>
  <li>当<code class="highlighter-rouge">wire_type</code>为0、1和5时，序列化的结果为<strong>key + 数据</strong>，数据长度由数据自描述。</li>
  <li>当<code class="highlighter-rouge">wire_type</code>为2时，序列化的结果为<strong>key + length + 数据</strong>，数据长度由<code class="highlighter-rouge">length</code>决定。</li>
</ul>

<p>下面通过一个实际的例子看下Message Structure的编码形式:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>syntax <span class="o">=</span> <span class="s2">"proto3"</span><span class="p">;</span>

message foo <span class="o">{</span>
    string bar <span class="o">=</span> 5<span class="p">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>将<code class="highlighter-rouge">bar</code>的值设置为”Hello”，序列化后将得到以下结果:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>052a 6548 6c6c 006f
</code></pre></div></div>

<p>ProtoBuf是小端字节序，阅读起来不是很方便，将其转换一下:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2a05 4865 6c6c 6f
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">4865 6c6c 6f</code>为字符串”Hello”的16进制表示，那么<code class="highlighter-rouge">2a05</code>就是前面提到的<strong>key+length</strong>了。<code class="highlighter-rouge">2a</code>的二进制格式为<code class="highlighter-rouge">101010</code>，最后3位为<code class="highlighter-rouge">010</code>，转换成十进制结果是2，对应string类型的<code class="highlighter-rouge">write_type</code>。<code class="highlighter-rouge">101</code>转换成十进制结果为5，对应bar字段的<code class="highlighter-rouge">field_number</code>。length则由<code class="highlighter-rouge">05</code>确定，表示字符串的长度为5。</p>

<h3 id="2-http2">2. HTTP/2</h3>

<p>HTTP/2协议在原有的HTTP/1协议版本之上进行了大幅度的修改，其传输效率大大提升，并且能够有效地降低服务端的资源消耗。</p>

<ul>
  <li>由文本传输改变为二进制数据传输，解析更加高效。</li>
  <li>使用新的二进制分帧机制改变了客户端和服务端之间交换数据的方式，每个二进制帧可进行乱序传输，解决了HTTP/1中的首部阻塞问题。</li>
  <li>对请求头部字段的压缩使得传输数据更小，传输效率更高。</li>
</ul>

<p>为了更好的理解HTTP/2，首先要明确HTTP/1的缺陷之处，首当其冲的就是TCP连接数限制。在浏览器中，同一个域名下同时只能创建6~8个TCP连接，剩下的请求只能等待这些请求的返回。并且，每个TCP连接只能承载一次请求/响应，当初始发送的请求响应时间较长时，整个页面加载也会受到阻塞。</p>

<h4 id="21-二进制分帧">2.1 二进制分帧</h4>

<p>在HTTP/1中，请求的数据以明文进行传输，例如:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET / HTTP/1.1
Host: example.com
</code></pre></div></div>

<p>而在HTTP/2中，请求或者响应数据不再以文本的方式进行传输，而是直接使用二进制数据进行传输，使得解析更加高效。其原因在于HTTP/1是通过特殊符号，如空格，<code class="highlighter-rouge">\r\n</code>等特殊字符进行分割并解析的。而HTTP/2首先对数据进行了分类，将请求头和Payload分开，并且在每一个传输单元中都进行了标记。</p>

<p>HTTP/2的基本传输单元为帧(Frame)，每一个都以固定的9个字节开头，后跟不定长度的Payload。Payload可以是用户传输的数据，也可以是协议本身携带的数据。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+-----------------------------------------------+
|                 Length <span class="o">(</span>24<span class="o">)</span>                   |
+---------------+---------------+---------------+
|   Type <span class="o">(</span>8<span class="o">)</span>    |   Flags <span class="o">(</span>8<span class="o">)</span>   |
+-+-------------+---------------+-------------------------------+
| R <span class="o">(</span>1<span class="o">)</span> |                 Stream Identifier <span class="o">(</span>31<span class="o">)</span>                |
+<span class="o">=</span>+<span class="o">=============================================================</span>+
|                   Frame Payload <span class="o">(</span>0...<span class="o">)</span>                      ...
+---------------------------------------------------------------+
</code></pre></div></div>

<p>24+8+8+1+31，刚好为72位，即9字节。下面来看每一个字段的含义:</p>

<ul>
  <li>Length: 表示Payload的长度，是一个24位的无符整数，单位为字节。也就是说，通常情况下一个帧最多能够传输2^14(16,384)个字节。如果想在一个帧中传输更多的数据，则可以通过传输<code class="highlighter-rouge">SETTINGS_MAX_FRAME_SIZE</code>帧来改变基本大小。</li>
  <li>Type: 帧的类型，如<code class="highlighter-rouge">DATA</code>帧、<code class="highlighter-rouge">HEADERS</code>帧。</li>
  <li>Flags: 该字段用于各类型的帧进行补充说明，表示特殊的含义。一个常见的标志就是<code class="highlighter-rouge">END_HEADERS</code>，表示头数据已经结束。</li>
  <li>R: 预留位，并未使用。</li>
  <li>Stream Identifier: 流标识符，31位无符整数，作用将在下方描述。</li>
</ul>

<h4 id="22-多路复用">2.2 多路复用</h4>

<p>HTTP/2一个最重要的特性就是多路复用，即在一个TCP连接中同时传输多个请求或者是响应，而HTTP/1想要做到这一点的话，必须要建立多个TCP连接。</p>

<p>在HTTP/2中引入了”流”(Stream)的概念，对应HTT/1的话，其实就是一个请求: 在一个连接中发送多个请求其实就是发送多个流。而流又是由帧组成的，所以在帧中需要字段<code class="highlighter-rouge">Stream Identifier</code>来标记当前帧属于哪个流。</p>

<p>实现多路复用的逻辑概念就是流，和TCP流式传输不同的是，HTTP/2中的流只是一个逻辑上的概念，每一个流使用<code class="highlighter-rouge">Stream Identifier</code>进行标识。一个请求或者是响应在拆分成多个帧以后，将使用同一个流ID在连接中进行传输，接收方在接收到乱序传输的帧以后，按照流ID进行组装，即可得到一个完整的请求或者是响应。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MicroService/gRPC/stream.png" alt="" /></p>

<h4 id="22-头部字段压缩">2.2 头部字段压缩</h4>

<p>TODO</p>

<h3 id="3-一些实践的代码用例">3. 一些实践的代码用例</h3>

<h4 id="31-python-client">3.1 Python Client</h4>

<p>gRPC的错误响应(如Not Found，Internal Server Error等)通常会以异常的形式抛出，所以，Python Client必须要对gRPC的相关方法进行进一步的封装，例如重试机制或者是进行其它行为。</p>

<p>最为常见的异常就是<code class="highlighter-rouge">_Rendezvous</code>，该异常为<code class="highlighter-rouge">RpcError</code>的一个子类，通常来说，只需要捕获该异常即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">grpc</span> <span class="kn">import</span> <span class="n">StatusCode</span><span class="p">,</span> <span class="n">RpcError</span>


<span class="c"># define retry times with different situation</span>
<span class="n">MAX_RETRIES_BY_CODE</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">StatusCode</span><span class="o">.</span><span class="n">INTERNAL</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">StatusCode</span><span class="o">.</span><span class="n">ABORTED</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">StatusCode</span><span class="o">.</span><span class="n">UNAVAILABLE</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">StatusCode</span><span class="o">.</span><span class="n">DEADLINE_EXCEEDED</span><span class="p">:</span> <span class="mi">5</span>
<span class="p">}</span>

<span class="c"># define MIN and MAX sleeping seconds</span>
<span class="n">MIN_SLEEPING</span> <span class="o">=</span> <span class="mf">0.015625</span>
<span class="n">MAX_SLEEPING</span> <span class="o">=</span> <span class="mf">1.0</span>


<span class="k">class</span> <span class="nc">RetriesExceeded</span><span class="p">(</span><span class="nb">Exception</span><span class="p">):</span>
    <span class="s">"""docstring for RetriesExceeded"""</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">retry</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wraps</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">RpcError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">code</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">code</span><span class="p">()</span>  <span class="c"># 使用e.code()获取响应码</span>
                <span class="n">max_retries</span> <span class="o">=</span> <span class="n">MAX_RETRIES_BY_CODE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">max_retries</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>

                <span class="k">if</span> <span class="n">retries</span> <span class="o">&gt;</span> <span class="n">max_retries</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">RetriesExceeded</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

                <span class="n">back_off</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">MIN_SLEEPING</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">retries</span><span class="p">,</span> <span class="n">MAX_SLEEPING</span><span class="p">)</span>

                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">back_off</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wraps</span>
</code></pre></div></div>

<h4 id="32-golang-server">3.2 Golang Server</h4>

<p>TODO</p>

<h3 id="4-reference">4. Reference</h3>

<ul>
  <li><a href="https://hpbn.co/">https://hpbn.co/</a></li>
  <li><a href="https://blog.wangriyu.wang/">https://blog.wangriyu.wang/</a></li>
  <li><a href="https://tools.ietf.org/html/rfc7540">https://tools.ietf.org/html/rfc7540</a></li>
  <li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn">https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>揭开Python元类(metaclass)神秘的面纱</title>
	  <link>//Python-metaclass</link>
	  <author></author>
	  <pubDate>2020-07-13T10:06:25+00:00</pubDate>
	  <guid>//Python-metaclass</guid>
	  <description><![CDATA[
	     <p>Python语言的<code class="highlighter-rouge">metaclass</code>特性一直是初学者的”噩梦”，当初博主在学习元类时也是一头雾水，但是一旦真正的理解了什么是”动态语言”之后，元类就不再神秘与难以理解了。Python这门动态语言最大的特性就是不需要一个类的字节码就能够在运行时创建出一个类，这是理解元类最为关键的信息。</p>

<!---more--->

<h3 id="1-基础知识汇总">1. 基础知识汇总</h3>

<h4 id="11-stackoverflow">1.1 stackoverflow</h4>

<p>首先，强烈推荐阅读stackoverflow上关于<code class="highlighter-rouge">metaclass</code>的回答，作者并没有使用什么高级词汇，就算英语稀烂也能看的懂。</p>

<blockquote>
  <p>https://stackoverflow.com/a/6581949/12523821</p>
</blockquote>

<h4 id="12-类属性和实例属性">1.2 类属性和实例属性</h4>

<p>类属性表示绑定在一个类上的属性，而实例属性则是绑定在不同实例上的属性，类属性只有一份，而实例属性则可以有多份。当实例属性和类属性重名，并通过实例获取该属性时，会返回实例属性，而不是类属性。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">Hugo</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Hugo</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>      <span class="c"># "smart"</span>

    <span class="n">hugo</span> <span class="o">=</span> <span class="n">Hugo</span><span class="p">(</span><span class="s">"raven"</span><span class="p">)</span>  
    <span class="k">print</span><span class="p">(</span><span class="n">hugo</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>      <span class="c"># "raven"</span>

    <span class="k">print</span><span class="p">(</span><span class="n">Hugo</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>      <span class="c"># "smart"</span>
</code></pre></div></div>

<h4 id="13-__new__方法和__init__方法">1.3 <code class="highlighter-rouge">__new__</code>方法和<code class="highlighter-rouge">__init__</code>方法</h4>

<p>在Python中，实际创建对象的过程是由<code class="highlighter-rouge">__new__</code>方法控制的，该方法接收class对象(cls)。而<code class="highlighter-rouge">__init__</code>方法则是在<code class="highlighter-rouge">__new__</code>方法所创建的对象实例上，进行属性的赋值或者其它操作，所以接收实例对象(self)。</p>

<p>当想要控制创建对象的过程时，应该使用<code class="highlighter-rouge">__new__</code>方法，例如常用的单例模式，而不是使用<code class="highlighter-rouge">__init__</code>方法:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Lock</span>

<span class="k">class</span> <span class="nc">SingletonClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">instance</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span>
        <span class="k">with</span> <span class="n">cls</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="c"># double check</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span><span class="p">:</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span>
</code></pre></div></div>

<h4 id="14-mro">1.4 MRO</h4>

<p>Python是通过MRO列表来实现类的继承的，MRO列表的构造由C3线性化算法实现。实际上，类的继承层级关系最终会表现成包含所有基类的线性顺序表。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Parent init"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Children</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Children</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Children init"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Grandchildren</span><span class="p">(</span><span class="n">Children</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Grandchildren</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Grandchildren init"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Grandchildren</span><span class="o">.</span><span class="n">__mro__</span><span class="p">)</span>
</code></pre></div></div>

<p>运行结果为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>
    &lt;class <span class="s1">'__main__.Grandchildren'</span><span class="o">&gt;</span>, 
    &lt;class <span class="s1">'__main__.Children'</span><span class="o">&gt;</span>, 
    &lt;class <span class="s1">'__main__.Parent'</span><span class="o">&gt;</span>, 
    &lt;class <span class="s1">'object'</span><span class="o">&gt;</span>
<span class="o">)</span>
</code></pre></div></div>

<p>其顺序与继承顺序刚好相反，也就是说，通过类的<code class="highlighter-rouge">__mro__</code>属性即可找到该类的所有父类，包括<code class="highlighter-rouge">object</code>类。</p>

<p>Python同时也提供了内建的反射函数，来返回某个类的MRO列表:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">getmro</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">__mro__</span>
</code></pre></div></div>

<h3 id="2-metaclass">2. metaclass</h3>

<p>我们已经知道了<code class="highlighter-rouge">metaclass</code>是创建一个类的工具，通过<code class="highlighter-rouge">metaclass</code>能够更加灵活地动态地创建一个类，其中一个非常重要的结果就是能够获取到”子类”的全部信息，例如类属性、类方法等。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"get class field: {name}===&gt;{value}"</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">HugoMetaclass</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="n">gender</span> <span class="o">=</span> <span class="s">"male"</span>
</code></pre></div></div>

<p>运行上述代码将会打印出<code class="highlighter-rouge">Hugo</code>类的所有属性信息:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>get class field: <span class="nv">__module__</span><span class="o">===&gt;</span>__main__
get class field: <span class="nv">__qualname__</span><span class="o">===&gt;</span>Hugo
get class field: <span class="nv">name</span><span class="o">===&gt;</span>smart
get class field: <span class="nv">gender</span><span class="o">===&gt;</span>male
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">__module__</code>和<code class="highlighter-rouge">__qualname__</code>为内部属性，而<code class="highlighter-rouge">name</code>和<code class="highlighter-rouge">gender</code>则是用户自定义的类属性。可以看到，在<code class="highlighter-rouge">HugoMetaclass。__new__</code>方法中，完全能够获取到<code class="highlighter-rouge">Hugo</code>类的相关类属性，那么更进一步地来说，不管用户定义了什么样的类属性，都可以使用<code class="highlighter-rouge">metaclass</code>在创建该类之前获取到该类的所有属性。这就为诸如ORM、表单验证等基础服务提供了构建的基础。</p>

<h4 id="21-metaclass的应用">2.1 metaclass的应用</h4>

<p><code class="highlighter-rouge">type</code>的<code class="highlighter-rouge">__new__</code>方法接收4个参数，分别为类对象，类名称，父类元组以及类属性。这四个参数中最为关键的就是父类元组和类属性，通常项目中使用<code class="highlighter-rouge">metaclass</code>时也是和这两个参数频繁打交道。</p>

<h5 id="211-父类元组">2.1.1 父类元组</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">HugoMetaclass</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">HugoChild</span><span class="p">(</span><span class="n">Hugo</span><span class="p">):</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p>运行后将得到以下结果:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">()</span>
<span class="o">(</span>&lt;class <span class="s1">'__main__.Hugo'</span><span class="o">&gt;</span>,<span class="o">)</span>
</code></pre></div></div>

<p>一共需要创建两个类: <code class="highlighter-rouge">Hugo</code>和<code class="highlighter-rouge">HugoChild</code>，<code class="highlighter-rouge">Hugo</code>类直接使用<code class="highlighter-rouge">HugoMetaclass</code>创建，所以其父类元组为空。而<code class="highlighter-rouge">HugoChild</code>直接继承自<code class="highlighter-rouge">Hugo</code>，所以其父类为<code class="highlighter-rouge">Hugo</code>。所以，可以通过<code class="highlighter-rouge">bases</code>参数来判断当前创建的类是否需要进行处理。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 这里所创建的类都是Hugo的子类, 而不是Hugo类</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="212-类属性">2.1.2 类属性</h5>

<p>类属性是”子类”中最为重要的数据，可以说元类的最终目的就是为了根据类属性创建出一个模板，将该模板数据保存在类中。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>

        <span class="c"># 对Hugo类不做任何处理</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="n">klass</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 保存attrs中所有的int类型数据</span>
        <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">klass</span>
        
<span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">HugoMetaclass</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">HugoChild</span><span class="p">(</span><span class="n">Hugo</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="n">age</span> <span class="o">=</span> <span class="mi">24</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
</code></pre></div></div>

<p>上面创建了一个<code class="highlighter-rouge">int</code>类型的”模板”，并保存在了<code class="highlighter-rouge">declared_fields</code>这个字典中。注意不要将<code class="highlighter-rouge">declared_fields</code>挂到<code class="highlighter-rouge">mcs</code>上，<code class="highlighter-rouge">mcs</code>就是<code class="highlighter-rouge">HugoMetaclass</code>，变量绑定到<code class="highlighter-rouge">mcs</code>上会丢失一些信息，导致程序出现BUG。</p>

<p>那么如果<code class="highlighter-rouge">HugoChild</code>又有子类呢? 上述方式是否能够将<code class="highlighter-rouge">HugoChild</code>和其子类的属性一起获取到呢?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoChild</span><span class="p">(</span><span class="n">Hugo</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="n">age</span> <span class="o">=</span> <span class="mi">24</span>

<span class="k">class</span> <span class="nc">HugoGrandChild</span><span class="p">(</span><span class="n">HugoChild</span><span class="p">):</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mi">180</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Hugo</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoGrandChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
</code></pre></div></div>

<p>这时候会发现，这三个类的<code class="highlighter-rouge">declared_fields</code>结果都是<code class="highlighter-rouge">{'height': 180}</code>，<code class="highlighter-rouge">age</code>字段丢失了。原因也很简单，在创建<code class="highlighter-rouge">HugoGrandChild</code>类时，<code class="highlighter-rouge">declared_fields</code>被重新声明成了空字典，所以<code class="highlighter-rouge">HugoChild</code>中的类属性就会丢失。那么有没有什么办法能够得到完整版呢? 这就需要用到上面所提到的MRO列表了。</p>

<p>我们可以通过MRO列表，来获取到<code class="highlighter-rouge">HugoGrandChild</code>的所有父类，而后逐一的遍历找出类型为<code class="highlighter-rouge">int</code>的类属性，保存在<code class="highlighter-rouge">declared_fields</code>这个字典中。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>

        <span class="c"># 对Hugo类不做任何处理</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 保存attrs中所有的int类型数据</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c"># 遍历__mro__列表并找出类型为`int`的类属性, 保存在字典中</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">klass</span><span class="o">.</span><span class="n">__mro__</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="s">'declared_fields'</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">klass</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoGrandChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
</code></pre></div></div>

<p>其运行结果为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span><span class="s1">'age'</span>: 24<span class="o">}</span>
<span class="o">{</span><span class="s1">'height'</span>: 180, <span class="s1">'age'</span>: 24<span class="o">}</span>
</code></pre></div></div>

<p>如此一来，<code class="highlighter-rouge">HugoGrandChild</code>在继承了<code class="highlighter-rouge">HugoChild</code>之后，也能够获取到其中的相关字段，并且父类不会受到子类的影响。</p>

<p>上述代码中存在一些重复的代码片段，将其抽离出来，使代码结构更加清晰:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_instance_or_subclass</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">class_</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">class_</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">class_</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_fields</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">field_class</span><span class="p">):</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">field_name</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">is_instance_or_subclass</span><span class="p">(</span><span class="n">field_value</span><span class="p">,</span> <span class="n">field_class</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">fields</span>

<span class="k">def</span> <span class="nf">_get_fields_by_mro</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">field_class</span><span class="p">):</span>
    <span class="n">mro</span> <span class="o">=</span> <span class="n">klass</span><span class="o">.</span><span class="n">__mro__</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">_get_fields</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s">'declared_fields'</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">__dict__</span><span class="p">),</span>
                <span class="n">field_class</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">mro</span><span class="p">[:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">),</span>
        <span class="p">[],</span>
    <span class="p">)</span>

<span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>

        <span class="c"># 对Hugo类不做任何处理</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 保存attrs中所有的int类型数据</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="n">class_fields</span> <span class="o">=</span> <span class="n">_get_fields</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">inherited_fields</span> <span class="o">=</span> <span class="n">_get_fields_by_mro</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">class_fields</span> <span class="o">+</span> <span class="n">inherited_fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">klass</span>
</code></pre></div></div>

<h3 id="3-小结">3. 小结</h3>

<p><code class="highlighter-rouge">metaclass</code>并不神秘，得益于Python是动态语言，可以在运行时动态地创建一个类的特性，我们能够在事前去创建一些有用的”模板”，在运行时将模板和数据有机的结合起来，最终呈现出宛如魔术般的效果。</p>

	  ]]></description>
	</item>


</channel>
</rss>
