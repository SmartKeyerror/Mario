<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description>Keep coding, Keep curiosity</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Linux 阻塞与唤醒实现原理</title>
	  <link>//Linux-Blocking</link>
	  <author></author>
	  <pubDate>2020-09-09T07:50:25+00:00</pubDate>
	  <guid>//Linux-Blocking</guid>
	  <description><![CDATA[
	     <p>在前面的文件 I/O 文章中，我们有提到 Linux 文件 I/O 支持阻塞和非阻塞的数据读取方式，当采用阻塞方式进行 I/O 时，进程将会阻塞在<code class="highlighter-rouge">read()</code>或者<code class="highlighter-rouge">write()</code>系统调用上，直到文件可读或者是内核缓冲区可写。这些阻塞与唤醒的实现与内核调度紧密相关，Linux 内核使用等待队列和完成量来实现该功能。</p>
<blockquote>
  <p>注: 本篇文章所用Linux内核源码版本为v5.8</p>
</blockquote>

<!---more--->

<h3 id="1-进程状态有限状态机">1. 进程状态有限状态机</h3>

<p>进程并不总是可以立即运行的，一方面是 CPU 资源有限，另一方面则是进程时常需要等待外部事件的发生，例如 I/O 事件、定时器事件等。</p>

<p>因此，对进程的状态进行分类就是一件非常有必要的事情，对于等待某事件发生的进程给予 CPU 资源是没有任何意义的，因为此时事件可能仍未发生。而对于正等待 CPU 资源的进程而言，在得到 CPU 之后即可立即执行。调度器为了尽可能最大地使用硬件资源，通常会将进程分为3个主要的状态: 运行、等待和睡眠。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/schedule/process-state.png" alt="" /></p>

<p>处于运行状态的进程正在使用 CPU 等资源，从上图中可以看到，运行态的进程在执行完任务后结束，进入到结束状态。当 CPU 时间片到期之后，调度器选择其它进程执行，此时将进入等待状态。同时，当运行时的进程发起 I/O 操作，或者等待其它事件的发生时，将进入睡眠状态。</p>

<p>处于等待状态的进程由于缺少 CPU 资源而被迫停止运行，只要调度器下次选中该进程即可立即执行，由等待状态转变为运行状态。</p>

<p>处于睡眠状态的进程在等待外部事件的发生，例如 I/O 操作的数据抵达，创建的定时器到期等等，<strong>处于睡眠状态的进程永远不会被调度器进行选择并执行</strong>。当期望的事件到达后，进程由睡眠状态更改为等待状态，等待调度器的下一次选择。</p>

<p>处于等待的进程将会被放置于就绪队列中（红黑树实现），而处于睡眠状态的进程则放置于等待队列（双链表实现）中。调度器的目光主要放在就绪队列上，从该队列中取出下一个将要执行的进程，而等待队列和就绪队列中的进程会因为事件的发生而进行相互转移。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Snorlax/schedule/read-and-wait-queue.png" alt="" /></p>

<p>在实际的内核实现中，进程的运行状态表示要比上文所述更加详细一些，进程状态定义于<code class="highlighter-rouge">include/linux/sched.h</code>:</p>

<ul>
  <li><code class="highlighter-rouge">TASK_RUNNING</code>，可运行状态。此时进程并不一定正在运行，一旦得到调度器的调度即可立即运行。</li>
  <li><code class="highlighter-rouge">TASK_INTERRUPTIBLE</code>，可中断睡眠状态。此时进程因为等待外部事件的发生而睡眠，此时可由信号或者是内核唤醒。</li>
  <li><code class="highlighter-rouge">TASK_UNINTERRUPTIBLE</code>，不可中断睡眠状态。和<code class="highlighter-rouge">TASK_INTERRUPTIBLE</code>状态类似，等待外部事件发生的睡眠状态。不同的是改状态只能由内核亲自唤醒，不能由信号唤醒，通常用于进程必须等待某件工作完成，不能被 Kill。</li>
</ul>

<p>除了这三个核心进程状态以外，还有<code class="highlighter-rouge">__TASK_STOPPED</code>、<code class="highlighter-rouge">__TASK_TRACED</code>等状态，由于这些状态在本文中并不重要，所以略去。</p>

<h3 id="2-等待队列">2. 等待队列</h3>

<p>等待队列相关的源码位于<code class="highlighter-rouge">include/linux/wait.h</code>以及<code class="highlighter-rouge">kernel/sched/wait.c</code>文件中，头文件中定义了等待队列以及队列元素的基本数据结构，<code class="highlighter-rouge">wait.c</code>源文件则主要包含具体的方法实现。</p>

<p>首先来看等待队列的基本结构，分为队列头和队列项:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 等待队列头 */</span>
<span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>       <span class="cm">/* 自旋锁 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">head</span><span class="p">;</span>   <span class="cm">/* previous、next指针 */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="n">wait_queue_head_t</span><span class="p">;</span>

<span class="cm">/* 等待队列元素 */</span>
<span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>  <span class="cm">/* 标识位 */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="k">private</span><span class="p">;</span>   <span class="cm">/* 通常指向等待进程 */</span>
	<span class="n">wait_queue_func_t</span>	<span class="n">func</span><span class="p">;</span>   <span class="cm">/* 唤醒函数 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">entry</span><span class="p">;</span>  <span class="cm">/* previous、next指针 */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在内核的链表实现中，绝大多数的链表均为循环双链表，等待队列也不例外。因为等待队列可能会在系统中断时进行修改，所以必须要添加互斥锁机制保护队列元素。</p>

<p>等待队列元素的设计也非常简洁，除了双链表必要的前后指针以外，仅包含一个指向等待进程<code class="highlighter-rouge">task_struct</code>实例的指针，一个唤醒函数和一个标识位。</p>

<p>唤醒函数通常由调度器实现，如<code class="highlighter-rouge">kernel/sched/core.c</code>中定义的<code class="highlighter-rouge">try_to_wake_up</code>方法，可以简单的认为唤醒函数就是将进程的状态由<code class="highlighter-rouge">TASK_INTERRUPTIBLE</code>或<code class="highlighter-rouge">TASK_UNINTERRUPTIBLE</code>修改为<code class="highlighter-rouge">TASK_RUNNING</code>，并将其加入至就绪队列中。</p>

<p><code class="highlighter-rouge">wait.h</code>中提供了一系列与等待队列相关的宏定义供外部使用，例如<code class="highlighter-rouge">wait_event</code>，本质上是对等待队列的进一步封装:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define wait_event(wq_head, condition)						\
do {										\
	might_sleep();								\
	if (condition)								\
		break;								\
    </span><span class="cm">/* 这里将原有的__wait_event宏展开，使用___wait_event代替 */</span><span class="cp">     \
	___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0, schedule())	\
} while (0)
</span></code></pre></div></div>

<p>其中<code class="highlighter-rouge">wq_head</code>即<code class="highlighter-rouge">wait_queue_head</code>，<code class="highlighter-rouge">condition</code>则是一个C语言表达式，表示一个等待条件。宏定义的<code class="highlighter-rouge">wait_event</code>使得使用标准C表达式指定条件成为可能，如果使用函数实现的话，无法做到如宏实现的灵活性。注意到在调用<code class="highlighter-rouge">___wait_event</code>之前会首先检查一遍条件是否满足，避免进行无效的睡眠。</p>

<p>在<code class="highlighter-rouge">___wait_event</code>宏定义中传入的进程状态为<code class="highlighter-rouge">TASK_UNINTERRUPTIBLE</code>，也就是说，<code class="highlighter-rouge">wait_event</code>实现的事件等待是不可中断的。当然，<code class="highlighter-rouge">wait.h</code>中同样提供了其它时间等待实现:</p>

<ul>
  <li><code class="highlighter-rouge">wait_event_timeout</code>: 带有超时时间的不可中断事件等待</li>
  <li><code class="highlighter-rouge">wait_event_interruptible</code>: 可中断的事件等待</li>
  <li><code class="highlighter-rouge">wait_event_interruptible_timeout</code>: 带有超时时间的可中断事件等待</li>
</ul>

<p>最后再来看<code class="highlighter-rouge">___wait_event</code>实现，该方法将会把当前进程包装成<code class="highlighter-rouge">wait_queue_entry</code>对象，并发安全地放置于等待队列中，并且在实际的让出CPU资源、引发调度器重新调度之前会再一次的检查等待事件是否发生，避免无效睡眠。由于源代码中该方法宏定义实现符号较多，所以将原实现抽象成伪代码:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">___wait_event</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">exclusive</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 初始化队列元素 */</span>
    <span class="n">init_wait_entry</span><span class="p">(...);</span>
    
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="cm">/* 将队列元素插入至等待队列中(线程安全) */</span>
        <span class="kt">long</span> <span class="n">__int</span> <span class="o">=</span> <span class="n">prepare_to_wait_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__wq_entry</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
        
        <span class="cm">/* 检查事件条件是否满足 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
            
        <span class="cm">/* 触发调度器重新调度 */</span>
        <span class="n">schedule</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于唤醒一个进程在前文中已经描述过了，通用方法为<code class="highlighter-rouge">wake_up()</code>，本质上会调用内核调度模块中的<code class="highlighter-rouge">try_to_wake_up()</code>来唤醒某个进程，唤醒的实质是将进程状态修改为<code class="highlighter-rouge">TASK_RUNNING</code>，从等待队列中移出并加入至就绪队列中。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Kubernetes-Informer</title>
	  <link>//Kubernetes-Informer</link>
	  <author></author>
	  <pubDate>2020-08-26T07:50:25+00:00</pubDate>
	  <guid>//Kubernetes-Informer</guid>
	  <description><![CDATA[
	     <p>Kubernetes 声明式API的核心就在于用户提交的YAML文件表示期望状态，Kubernetes 需要根据该期望状态与集群实际状态进行对比，并根据对比的结果作出相应的操作。期望状态由 APIServer 保存在 Etcd 中，Kubernetes 对资源进行调谐时，是否均需要通过 APIServer 查询 Etcd 来获取期望状态呢?</p>

<!---more--->

<h3 id="1-listandwatch机制">1. ListAndWatch机制</h3>

<p>在 Kubernetes 中，集群的状态、用户提交的YAML文件均保存在Etcd数据库中，而获取这些数据的唯一方法就是通过 APIServer。APIServer 与 Etcd 通过 RPC 进行通信，对外则暴露需要鉴权的 REST API 接口，用户可通过这些API接口间接地获取集群状态。例如<code class="highlighter-rouge">kubectl</code>工具就是通过封装 APIServer 的 REST API 进行工作的。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Kubernetes/Informer/client-apiserver-etcd-communicate.png" alt="" /></p>

<p>除了通用的<code class="highlighter-rouge">GET</code>、<code class="highlighter-rouge">POST</code>的API以外，APIServer 还提供了可用于持续监听的 Watch API。顾名思义，Watch API 本质上就是一种 APIServer 主动向客户端推送 Kubernetes 资源修改、创建的一种机制，默认采用 HTTP/1.1 的分块传输实现，同时也可以使用 websocket 协议进行信息接收。</p>

<p>以获取Pod事件为例，通过调用<code class="highlighter-rouge">/api/v1/watch/namespaces/{namespace}/pods?watch=yes</code>可使得客户端与 APIServer 建立HTTP长连接，每当集群中出现了 Pod 的相关事件(创建、更新等)，APIServer 将会通过该连接将对应的事件推送至客户端。实际上，Watch API 就是一种增量更新，如同MySQL主从复制中的Binlog数据传输。</p>

<p>当然，在进行资源的增量更新之前，首先要获取到当前集群中资源的存量信息，可通过 List API 获得: <code class="highlighter-rouge">/api/v1/namespaces/{namespace}/pods</code>。通过 List API 获取集群当前某资源的全部信息，以及通过 Watch API 获取资源的增量信息，在 Kubernetes 中称为 ListAndWatch 机制，是 APIServer 的核心机制之一。</p>

<blockquote>
  <p>关于kubernetes-api的更多信息可查看官网:
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#-strong-api-overview-strong-">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#-strong-api-overview-strong-</a></p>
</blockquote>

<h3 id="2-informer工作原理">2. Informer工作原理</h3>

<p>既然客户端可以使用 ListAndWatch 机制来实时地同步 Kubernetes 中某类资源的状态，那么在 Kubernetes 内部，同样可以使用该机制从 APIServer 中接收资源的变化，从而建立本地缓存减轻 APIServer 与 Etcd 的负载，并且实现 Kubernetes 中的控制器模式。该内部组件称之为 Informer，中文译为通知器。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Kubernetes/Informer/informer-ar.png" alt="" /></p>

<p>首先，Reflector 包会和 APIServer 建立长连接，并使用 ListAndWatch 方法获取并监听某一个资源的变化。List 方法将会获取某个资源的所有实例(如ReplicaSet、Deployment等)，Watch 方法则监听资源对象的创建、更新以及删除事件，获取到的事件称之为一个增量(Delta)，该增量会被放进一个称之为 Delta FIFO Queue，即增量先进先出队列中。</p>

<p>而后，Informer会不断的从 Delta FIFO Queue 中 pop 增量事件，并根据事件的类型来决定新增、更新或者是删除本地缓存，也就是 Local Key-Value Sotrage。<strong>根据集群中某资源的事件来更新本地缓存是Informer的第一个职责，同时也是最重要的职责。</strong></p>

<p>Informer 的另外一个职责就是根据事件类型来触发事先注册好的 Event Handler。在回调函数中通常只会做一些简单的过滤处理，然后将该事件丢到 Work Queue 这个工作队列中。工作队列的主要作用就是平衡 Informer 和 Controller 之间的速度差，避免 Controller 处理速度过慢而影响 Informer 的工作。</p>

<p>接下来就是 Controller 的表演时间了，也就是上图中的 Processer。控制器从 Work Queue 中取出一个事件并根据自身的业务逻辑对其进行处理，不同的控制器会有不同的处理逻辑。如 ReplicSet 控制器在收到某一个 Pod 被删除的事件时将会重新创建一个 Pod，以保证 Pod 的数量。</p>

<h3 id="3-informer代码编写流程">3. Informer代码编写流程</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="p">(</span><span class="x">
	</span><span class="s">"log"</span><span class="x">

	</span><span class="n">v1</span><span class="x"> </span><span class="s">"k8s.io/api/core/v1"</span><span class="x">
	</span><span class="s">"k8s.io/apimachinery/pkg/labels"</span><span class="x">
	</span><span class="s">"k8s.io/client-go/informers"</span><span class="x">
	</span><span class="s">"k8s.io/client-go/kubernetes"</span><span class="x">
	</span><span class="s">"k8s.io/client-go/tools/cache"</span><span class="x">
	</span><span class="s">"k8s.io/client-go/tools/clientcmd"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="c">// 简单起见硬编码相关配置</span><span class="x">
	</span><span class="n">configPath</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="s">"/home/smartkeyerror/.kube/config"</span><span class="x">
	</span><span class="n">masterURL</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="s">"https://10.39.35.19:6443"</span><span class="x">

	</span><span class="c">// 初始化config</span><span class="x">
	</span><span class="n">config</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">clientcmd</span><span class="o">.</span><span class="n">BuildConfigFromFlags</span><span class="p">(</span><span class="n">masterURL</span><span class="p">,</span><span class="x"> </span><span class="n">configPath</span><span class="p">)</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="c">// 初始化client</span><span class="x">
	</span><span class="n">kubeClient</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">kubernetes</span><span class="o">.</span><span class="n">NewForConfig</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="c">// 获取工厂实例, 通过这个工厂实例可获取到所有资源的 Informer</span><span class="x">
	</span><span class="n">factory</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">informers</span><span class="o">.</span><span class="n">NewSharedInformerFactory</span><span class="p">(</span><span class="n">kubeClient</span><span class="p">,</span><span class="x"> </span><span class="m">0</span><span class="p">)</span><span class="x">
	</span><span class="c">// 创建Pod Informer</span><span class="x">
	</span><span class="n">podInformer</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">factory</span><span class="o">.</span><span class="n">Core</span><span class="p">()</span><span class="o">.</span><span class="n">V1</span><span class="p">()</span><span class="o">.</span><span class="n">Pods</span><span class="p">()</span><span class="x">
	</span><span class="n">informer</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">podInformer</span><span class="o">.</span><span class="n">Informer</span><span class="p">()</span><span class="x">

	</span><span class="n">stopCh</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="k">struct</span><span class="p">{})</span><span class="x">
	</span><span class="k">defer</span><span class="x"> </span><span class="nb">close</span><span class="p">(</span><span class="n">stopCh</span><span class="p">)</span><span class="x">
	</span><span class="k">go</span><span class="x"> </span><span class="n">factory</span><span class="o">.</span><span class="n">Start</span><span class="p">(</span><span class="n">stopCh</span><span class="p">)</span><span class="x">

	</span><span class="k">if</span><span class="x"> </span><span class="o">!</span><span class="n">cache</span><span class="o">.</span><span class="n">WaitForCacheSync</span><span class="p">(</span><span class="n">stopCh</span><span class="p">,</span><span class="x"> </span><span class="n">informer</span><span class="o">.</span><span class="n">HasSynced</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="s">"sync failed"</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="c">// 注册定义处理函数(偷懒, 不使用队列, 直接print)</span><span class="x">
	</span><span class="n">informer</span><span class="o">.</span><span class="n">AddEventHandler</span><span class="p">(</span><span class="n">cache</span><span class="o">.</span><span class="n">ResourceEventHandlerFuncs</span><span class="p">{</span><span class="x">
		</span><span class="n">AddFunc</span><span class="o">:</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">obj</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="n">pod</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">obj</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">v1</span><span class="o">.</span><span class="n">Pod</span><span class="p">)</span><span class="x">
			</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Get a pod:"</span><span class="p">,</span><span class="x"> </span><span class="n">pod</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span><span class="x">
		</span><span class="p">},</span><span class="x">
		</span><span class="n">UpdateFunc</span><span class="o">:</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">oldObj</span><span class="p">,</span><span class="x"> </span><span class="n">newObj</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"update pod"</span><span class="p">)},</span><span class="x">
		</span><span class="n">DeleteFunc</span><span class="o">:</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"delete pod"</span><span class="p">)},</span><span class="x">
	</span><span class="p">})</span><span class="x">

	</span><span class="c">// 创建Lister</span><span class="x">
	</span><span class="n">podLister</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">podInformer</span><span class="o">.</span><span class="n">Lister</span><span class="p">()</span><span class="x">
	</span><span class="c">// 获取所有标签的pod</span><span class="x">
	</span><span class="n">podList</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">podLister</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">Everything</span><span class="p">())</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">podList</span><span class="p">)</span><span class="x">

	</span><span class="o">&lt;-</span><span class="x"> </span><span class="n">stopCh</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>这是一个最简单的使用 Informer 的代码示例，其作用就是通过<code class="highlighter-rouge">List</code>方法打印出当前集群中所有的 Pod，以及在创建、删除和更新 Pod 资源时打印出相关的信息。</p>

<p>首先我们通过集群的地址以及<code class="highlighter-rouge">config</code>认证文件生成一个基本的<code class="highlighter-rouge">config</code>对象，并且根据该对象初始化了一个<code class="highlighter-rouge">kubeClient</code>对象，然后使用<code class="highlighter-rouge">kubeClient</code>创建了一个工厂实例。这个工厂实例中包含了 Kubernetes 中所有资源的 Informer，例如 Pod，Node，Network，RBAC等等。</p>

<p>剩下的代码内容就是按照上述的原理图按部就班的编写和执行了。实际上，对上述代码进行稍加改造即可以得到一个自定义控制器(CRD)的简易版本。控制器模式本质上就是用户期望状态和集群实际状态之间的对比、调谐，使得集群实际状态在某个时刻之后与用户期望状态一致，保存在 Informer 本地缓存的资源状态，其实就是用户的期望状态。</p>

<h3 id="4-小结">4. 小结</h3>

<p>Kubernetes 可以说是一个由事件驱动的分布式对象管理中心，而 Informer 则正是提供驱动事件的发动机。从设计模式的角度来看，Informer 本质上就是一个观察者，Controller 和本地缓存就是基于该观察者所观察的结果进行相应的处理。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Python 虚拟机</title>
	  <link>//Python-Virtual-Machine</link>
	  <author></author>
	  <pubDate>2020-08-18T10:50:25+00:00</pubDate>
	  <guid>//Python-Virtual-Machine</guid>
	  <description><![CDATA[
	     <p>我们常说 Python 一是门解释型语言，只需要敲下 <code class="highlighter-rouge">python code.py</code> 就可以运行编写的代码，而无需使用类似于 <code class="highlighter-rouge">javac</code> 或者 <code class="highlighter-rouge">gcc</code> 进行编译。那么，Python 解释器是真的一行一行读取 Python 源代码而后执行吗? 实际上，Python 在执行程序时和 Java、C# 一样，都是先将源码进行编译生成字节码，然后由虚拟机进行执行，只不过 Python 解释器把这两步合二为一了而已。</p>

<!---more--->

<h3 id="1-python-程序执行过程">1. Python 程序执行过程</h3>

<p>事实上，Python 程序在执行过程中同样需要编译(Compile)，编译产生的结果称之为字节码，而后由 Python 虚拟机逐行地执行这些字节码。所以，Python 解释器由两部分组成: 编译器和虚拟机。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/Process.png" alt="" /></p>

<p>上图展示了 Python 程序的执行过程，以及C程序的编译、汇编与链接过程，从该图中可以非常明显地看出 Python 与 C 程序的执行区别。Python 如此设计的原因在于将程序的执行与底层硬件进一步地分离，无需担心程序的编译、汇编以及链接过程，使得 Python 程序相较于 C 程序而言更加易于移植。</p>

<p>这里再说一下 Python 和 Java 的区别。Java 在程序执行时必须使用 <code class="highlighter-rouge">javac</code> 对源代码进行编译，但是并不直接编译成机器语言，而是和 Python 一样，编译成字节码，而后由 JVM 进行执行。从这一点上来看，Python 和 Java 非常类似，只不过 Python 的编译过程由解释器完成，用户也可以手动的对 Python 源代码进行编译，生成 <code class="highlighter-rouge">.pyc</code> 文件，节省那么一丢丢的时间。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-m</span> compileall &lt;dir&gt;
</code></pre></div></div>

<p>通过运行上述命令可对 <code class="highlighter-rouge">&lt;dir&gt;</code> 目录下所有的Python文件进行编译，编译结果将会存放于该目录下的 <code class="highlighter-rouge">__pycache__</code> 的 <code class="highlighter-rouge">.pyc</code> 文件中。</p>

<h3 id="2-编译过程与字节码">2. 编译过程与字节码</h3>

<p>在Python的内建函数中，定义了 <code class="highlighter-rouge">compile</code> 以及 <code class="highlighter-rouge">exec</code> 两个方法，前者将源代码编译成为 Code Object 对象，Code Object 对象中即保存着源代码所对应的字节。而 <code class="highlighter-rouge">exec</code> 方法则是运行 Python 语句或者是由 <code class="highlighter-rouge">compile</code> 方法所返回的 Code Object。<code class="highlighter-rouge">exec</code> 方法可直接运行 Python 语句，其参数并一定需要是 Code Object。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> snippet <span class="o">=</span> <span class="s2">"for i in range(3): print(f'Output: {i}')"</span>

<span class="o">&gt;&gt;&gt;</span> result <span class="o">=</span> compile<span class="o">(</span>snippet, <span class="s2">""</span>, <span class="s2">"exec"</span><span class="o">)</span>

<span class="o">&gt;&gt;&gt;</span> result
&lt;code object &lt;module&gt; at 0x7f8e7e6471e0, file <span class="s2">""</span>, line 1&gt;

<span class="o">&gt;&gt;&gt;</span> <span class="nb">exec</span><span class="o">(</span>result<span class="o">)</span>
Output: 0
Output: 1
Output: 2
</code></pre></div></div>

<p>在上述代码中定义了一个非常简单的 Python 代码片段，其作用就是在标准输出中打印0，1，2这三个数而已。通过 <code class="highlighter-rouge">compile</code> 方法对该片段进行编译，得到 Code Object 对象，并将该对象交由 <code class="highlighter-rouge">exec</code> 函数执行。下面来具体看下返回的 Code Object 中到底包含了什么。</p>

<p>在源码 <code class="highlighter-rouge">cpython/Include/code.h</code> 中定义了 <code class="highlighter-rouge">PyCodeObject</code> 结构体，即 Code Object 对象:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Bytecode object */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>               <span class="cm">/* Python定长对象头 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_code</span><span class="p">;</span>          <span class="cm">/* 指令操作码，即字节码 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_consts</span><span class="p">;</span>        <span class="cm">/* 常量列表 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_names</span><span class="p">;</span>         <span class="cm">/* 名称列表(不一定是变量，也可能是函数名称、类名称等) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_filename</span><span class="p">;</span>      <span class="cm">/* 源码文件名称 */</span>
    
    <span class="p">...</span>                         <span class="cm">/* 省略若干字段 */</span>
<span class="p">}</span> <span class="n">PyCodeObject</span><span class="p">;</span>
</code></pre></div></div>

<p>字段 <code class="highlighter-rouge">co_code</code> 即为 Python 编译后字节码，其它字段在此处可暂时忽略。字节码的格式为人类不可阅读格式，其形式通常是这样的:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> result.co_code
b<span class="s1">'x\x1ee\x00d\x00\x83\x01D\x00]\x12Z\x01e\x02d\x01e\x01\x9b\x00\x9d\x02\x83\x01\x01\x00q\nW\x00d\x02S\x00'</span>
</code></pre></div></div>

<p>这个时候我们需要一个”反汇编器”来将字节码转换成人类可阅读的格式，”反汇编器”打引号的原因是在 Python 中并不能称为真正的反汇编器。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> import dis
<span class="o">&gt;&gt;&gt;</span> dis.dis<span class="o">(</span>result.co_code<span class="o">)</span>
          0 SETUP_LOOP              30 <span class="o">(</span>to 32<span class="o">)</span>
          2 LOAD_NAME                0 <span class="o">(</span>0<span class="o">)</span>
          4 LOAD_CONST               0 <span class="o">(</span>0<span class="o">)</span>
          6 CALL_FUNCTION            1
          8 GET_ITER
    <span class="o">&gt;&gt;</span>   10 FOR_ITER                18 <span class="o">(</span>to 30<span class="o">)</span>
         12 STORE_NAME               1 <span class="o">(</span>1<span class="o">)</span>
         14 LOAD_NAME                2 <span class="o">(</span>2<span class="o">)</span>
         16 LOAD_CONST               1 <span class="o">(</span>1<span class="o">)</span>
         18 LOAD_NAME                1 <span class="o">(</span>1<span class="o">)</span>
         20 FORMAT_VALUE             0
         22 BUILD_STRING             2
         24 CALL_FUNCTION            1
         26 POP_TOP
         28 JUMP_ABSOLUTE           10
    <span class="o">&gt;&gt;</span>   30 POP_BLOCK
    <span class="o">&gt;&gt;</span>   32 LOAD_CONST               2 <span class="o">(</span>2<span class="o">)</span>
         34 RETURN_VALUE
</code></pre></div></div>

<p><code class="highlighter-rouge">dis</code> 方法将返回字节码的助记符(mnemonics)，和汇编语言非常类似，从这些助记符的名称上我们就可以大概猜出解释器将要执行的动作，例如 <code class="highlighter-rouge">LOAD_NAME</code> 加载名称，<code class="highlighter-rouge">LOAD_CONST</code> 加载常量。所以，我们完全可以将这些助记符看作是汇编指令，而指令的操作数则在助记符后面描述。例如 <code class="highlighter-rouge">LOAD_NAME</code> 操作，其操作数的下标为0，而在源代码中使用过的名称保存在 <code class="highlighter-rouge">co_names</code> 字段中，所以 <code class="highlighter-rouge">LOAD_NAME  0</code> 即表示加载 <code class="highlighter-rouge">result.co_names[0]</code> :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> result.co_names[0]
<span class="s1">'range'</span>
</code></pre></div></div>

<p>又比如 <code class="highlighter-rouge">LOAD_CONST</code> 操作，其操作数的下标也为0，只不过这次操作数不再保存在 <code class="highlighter-rouge">co_names</code> ，而是 <code class="highlighter-rouge">co_consts</code> 中，所以 <code class="highlighter-rouge">LOAD_CONST  0</code> 则表示加载 <code class="highlighter-rouge">result.co_consts[0]</code> :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> result.co_consts[0]
3
</code></pre></div></div>

<p>由于 Code Object 对象保存了常量、变量、名称等一系列的上下文内容，所以可以直接对该对象进行反汇编操作:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> dis.dis<span class="o">(</span>result<span class="o">)</span>
  1           0 SETUP_LOOP              30 <span class="o">(</span>to 32<span class="o">)</span>
              2 LOAD_NAME                0 <span class="o">(</span>range<span class="o">)</span>
              4 LOAD_CONST               0 <span class="o">(</span>3<span class="o">)</span>
              ...
</code></pre></div></div>

<p>现在，我们可以对 Python 字节码做一下小结了。Python 在编译某段源码时，并不会直接返回字节码，而是返回一个 Code Object 对象，字节码则保存在该对象的 <code class="highlighter-rouge">co_code</code> 字段中。由于字节码是一个二进制字节序列，无法直接进行阅读，所以需要通过”反汇编器”(<code class="highlighter-rouge">dis</code> 模块)将字节码转换成人类可读的助记符。助记符的形式和汇编语言非常类似，均由操作指令+操作数所组成。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/compile.png" alt="" /></p>

<h3 id="3-命名空间与作用域">3. 命名空间与作用域</h3>

<p>Python 的命名空间与作用域经常被开发者所忽略，在未深入了解 Python 虚拟机之前，我个人也认为这些东西并不重要。但是，命名空间和变量作用域将会是 Python 虚拟机在执行过程中一个非常重要的一环。</p>

<p>命名空间实际上是名称到对象的一种映射，本质上就是一个键-值对，所以大部分的命名空间由 <code class="highlighter-rouge">dict</code> 实现。命名空间可以分为3类: 内置命名空间，全局命名空间与局部命名空间，在作用域存在嵌套的特殊情况下，可能还会有闭包命名空间。</p>

<h4 id="31-内置命名空间build-in">3.1 内置命名空间(Build-in)</h4>
<p>Python语言内置的名称，例如内置函数名(<code class="highlighter-rouge">len</code>, <code class="highlighter-rouge">dis</code>)，内置异常(<code class="highlighter-rouge">Exception</code>)等。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> import builtins
<span class="o">&gt;&gt;&gt;</span> builtins.__dict__
</code></pre></div></div>

<h4 id="32-全局命名空间global">3.2 全局命名空间(Global)</h4>

<p>全局命名空间以模块进行划分，每一个模块中都包含了 <code class="highlighter-rouge">dict</code> 对象，其中保存了模块中的变量名、类名、函数名等等。在字节码中，全局变量的导入使用 <code class="highlighter-rouge">LOAD_GLOBAL</code> 。</p>

<h4 id="33-局部命名空间local">3.3 局部命名空间(Local)</h4>

<p>局部命名空间可以简单的认为就是函数的命名空间，例如函数参数，在函数中定义的局部变量。</p>

<p>下面是关于局部命名空间和全局命名空间的一个非常典型的例子:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">number</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">number</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">foo</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnboundLocalError: <span class="nb">local </span>variable <span class="s1">'number'</span> referenced before assignment
</code></pre></div></div>

<p>在运行上述代码时将会抛出 <code class="highlighter-rouge">UnboundLocalError</code> 异常，这简直莫名其妙，在其它语言中，上述代码都能够正常运行，以 C 语言为例:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">number</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>  <span class="c1">// 正常运行并打印结果: 20
</span><span class="p">}</span>
</code></pre></div></div>

<p>但是在 Python 中却抛出了异常，这又是为什么? 官方在 <a href="https://docs.python.org/3.8/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python">Python FAQ</a> 给出了相关解释，原文如下:</p>

<blockquote>
  <p>In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a value anywhere within the function’s body, it’s assumed to be a local unless explicitly declared as global.</p>
</blockquote>

<p>简单来说，当我们在函数中引用一个变量时，Python 将隐式地默认该变量为全局变量。但是，一旦变量在没有<code class="highlighter-rouge">global</code>关键字修饰的情况下进行了赋值操作，Python 会将其作为局部变量处理。</p>

<p>而语句 <code class="highlighter-rouge">number += 10</code> 进行了赋值动作，此时 <code class="highlighter-rouge">number</code> 为局部变量，该函数中又没有声明该局部变量，故而抛出异常。Python 这么做的目的就是为了防止开发者者在某些函数中修改了全局变量而又不自知，通过显式地添加 <code class="highlighter-rouge">global</code> 关键字来确保开发者知道自己在做什么。这正如 Python 之禅所述的，Explicit is better than implicit。</p>

<p>首先先来看下正常的局部变量在字节码中是如何处理的:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dis</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 LOAD_CONST               1 <span class="o">(</span>10<span class="o">)</span>
2 STORE_FAST               0 <span class="o">(</span>number<span class="o">)</span>
4 LOAD_GLOBAL              0 <span class="o">(</span>print<span class="o">)</span>
6 LOAD_FAST                0 <span class="o">(</span>number<span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">STORE_FAST</code> 将当前变量压入到函数运行栈中，而 <code class="highlighter-rouge">LOAD_FAST</code> 则从函数运行栈取出该变量。<code class="highlighter-rouge">LOAD_FAST</code> 之前必须存在 <code class="highlighter-rouge">STORE_FAST</code>，否则在运行时将会抛出异常。对于最初的例子而言，在未添加 <code class="highlighter-rouge">global</code> 关键字的情况下，语句 <code class="highlighter-rouge">number += 10</code> 将会直接执行 <code class="highlighter-rouge">LOAD_FAST</code> 指令，而此时当前变量并未压入至当前函数运行栈。</p>

<h4 id="34-闭包命名空间enclosing">3.4 闭包命名空间(Enclosing)</h4>

<p>当出现嵌套函数定义时，或者作用域嵌套时，Python 将会把内层作用域所依赖的所有外层命名存储在一个特殊的命名空间中，也就是闭包命名空间。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">logging</span> <span class="k">as</span> <span class="n">logger</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s">"Execute func: {func.__name__}"</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">foo</code> 闭包函数中，参数 <code class="highlighter-rouge">func</code> 即属于闭包命名空间，内层函数 <code class="highlighter-rouge">wrapper</code> 在寻找变量时，若局部命名空间内无此变量，将会于闭包命名空间中进行查找。</p>

<p>如果在闭包函数中对外层函数的局部变量进行赋值会发生什么?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
        <span class="n">number</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">return</span> <span class="n">bar</span>
</code></pre></div></div>

<p>正如同在局部命名空间中提到的一样，当一个变量在函数中被赋值时，Python 默认将其作为<strong>全局变量</strong>，既不是局部变量，也不是这里提到的闭包空间变量。所以，当我们在实际运行 <code class="highlighter-rouge">bar</code> 方法时，同样会得到 <code class="highlighter-rouge">UnboundLocalError</code> 异常。在这里如果想要使用 <code class="highlighter-rouge">foo</code> 函数中的 <code class="highlighter-rouge">number</code> 变量的话，需要使用 <code class="highlighter-rouge">nonlocal</code> 关键字进行修饰，让 Python 去 <code class="highlighter-rouge">bar</code> 函数的最近外层，也就是 <code class="highlighter-rouge">foo</code> 寻找该变量的定义。</p>

<p>此外，闭包指函数，而不是类，所以在类的嵌套中，将不会存在闭包命名空间:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Reader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">4096</span>

    <span class="k">class</span> <span class="nc">ReaderInternal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span> <span class="o">=</span> <span class="n">BUFFER_SIZE</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="c"># ...</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">Reader</span><span class="o">.</span><span class="n">ReaderInternal</span><span class="p">()</span>
</code></pre></div></div>

<p>在执行 <code class="highlighter-rouge">Reader.ReaderInternal()</code> 语句时，将会抛出 <code class="highlighter-rouge">NameError</code> 的异常，表示 <code class="highlighter-rouge">BUFFER_SIZE</code> 未定义。</p>

<p>当语句需要查找变量 <code class="highlighter-rouge">X</code> 时，将会按照 Local -&gt; Enclosing -&gt; Global -&gt; Builtin 的顺序进行查找，俗称 LEGB 规则。</p>

<h3 id="4-python虚拟机的执行">4. Python虚拟机的执行</h3>

<h4 id="41-执行上下文栈帧">4.1 执行上下文——栈帧</h4>

<p>在 x86-64 CPU 中包含了16个64位的通用目的寄存器，这些寄存器用于存储数据或者是指针。在这16个通用目的寄存器中，有两个较为特殊的寄存器: %rsp 与 %rbp。%rsp 为栈指针寄存器，表示运行时栈的结束位置，可以简单地理解为栈顶。%rbp 为栈帧指针，用于标识当前栈帧的起始位置。</p>

<p>在 x86 体系结构中，函数调用是通过栈和栈帧实现的。当一个函数被调用时，首先做的事情就是将调用者栈帧指针入栈，以保留调用关系。其次将为调用的函数创建栈帧，栈帧中包含了函数的参数、创建的局部变量等信息。</p>

<p>回到Python虚拟机中，虚拟机在进行函数调用时，运行方式和x86没什么区别，都是由栈和栈帧所实现的。而栈帧则是由 <code class="highlighter-rouge">PyFrameObject</code> 表示，于源码 <code class="highlighter-rouge">cpython/Include/frameobject.h</code> 中定义。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_frame</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>           <span class="cm">/* Python固定长度对象头 */</span>
    <span class="k">struct</span> <span class="n">_frame</span> <span class="o">*</span><span class="n">f_back</span><span class="p">;</span>      <span class="cm">/* 指向上一个栈帧的指针 */</span>
    <span class="n">PyCodeObject</span> <span class="o">*</span><span class="n">f_code</span><span class="p">;</span>       <span class="cm">/* Code Object代码对象，其中包含了字节码 */</span>
    
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_builtins</span><span class="p">;</span>       <span class="cm">/* 内建命名空间字典(PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_globals</span><span class="p">;</span>        <span class="cm">/* 全局命名空间字典(PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_locals</span><span class="p">;</span>         <span class="cm">/* 局部命名空间表(通常是数组) */</span>

    <span class="kt">int</span> <span class="n">f_lasti</span><span class="p">;</span>                <span class="cm">/* 上一条指令编号 */</span>
    
    <span class="p">...</span>
<span class="p">}</span> <span class="n">PyFrameObject</span><span class="p">;</span>
</code></pre></div></div>

<p>可以看到，在一个栈帧中包含了Code Object代码对象，三个命名空间表，上一个栈帧指针等信息。可以说，<code class="highlighter-rouge">PyFrameObject</code> 对象包含了Python虚拟机执行所需的全部上下文。在 Python 源码层面，可以通过 <code class="highlighter-rouge">sys</code> 模块中的 <code class="highlighter-rouge">_getframe</code> 方法来获取当前函数运行时的栈帧，方法将返回 <code class="highlighter-rouge">FrameType</code> 类型，其实就是 <code class="highlighter-rouge">PyFrameObject</code> 简化后的 Python 结构。</p>

<p>下面通过一段简单的代码来具体看下 Python 运行时的栈帧结构:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">():</span>
    <span class="n">middle</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">middle</span><span class="p">():</span>
    <span class="n">finish</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">finish</span><span class="p">():</span>
    <span class="n">print_frame</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">print_frame</span><span class="p">():</span>
    <span class="n">current_frame</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">current_frame</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"func name: {current_frame.f_code.co_name}"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"*"</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="n">current_frame</span><span class="o">.</span><span class="n">f_back</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">first</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func name: print_frame
<span class="k">****************************************</span>
func name: finish
<span class="k">****************************************</span>
func name: middle
<span class="k">****************************************</span>
func name: first
<span class="k">****************************************</span>
func name: &lt;module&gt;
<span class="k">****************************************</span>
</code></pre></div></div>

<p>在 Python 开始执行该程序时，首先创建一个用于执行模块代码对象的栈帧对象，也就是 <code class="highlighter-rouge">module</code> 。随着一个一个的函数调用，不同的栈帧对象将会被创建，并且压入至运行栈中，而连接这些栈帧对象的纽带就是 <code class="highlighter-rouge">f_back</code> 指针。当栈顶的函数执行完毕开始返回时，将沿着 <code class="highlighter-rouge">f_back</code> 指针方向一直到当前调用链的起始位置。</p>

<p>结合前面提到的字节码和命名空间，我们可以用一张简图来描述。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/PyFrameObject.png" alt="" /></p>

<h4 id="42-指令的执行">4.2 指令的执行</h4>

<p>指令执行的源码均位于 <code class="highlighter-rouge">cpython/Python/ceval.c</code> 中，入口函数有两个，一个是 <code class="highlighter-rouge">PyEval_EvalCode</code> ，另一个则是 <code class="highlighter-rouge">PyEval_EvalCodeEx</code> ，最终的实际调用函数为 <code class="highlighter-rouge">_PyEval_EvalCodeWithName</code>，所以我们只需要关注该函数即可。</p>

<p><code class="highlighter-rouge">_PyEval_EvalCodeWithName</code> 函数的主要作用为进行函数调用的例常检查，例如校验函数参数的个数、类型，校验关键字参数等。除此之外，该函数将会初始化栈帧对象并将其交给 <code class="highlighter-rouge">PyEval_EvalFrame</code> 函数进行处理，最终由 <code class="highlighter-rouge">_PyEval_EvalFrameDefault</code> 函数真正的运行指令。</p>

<p><code class="highlighter-rouge">_PyEval_EvalFrameDefault</code> 函数定义超过了3K行，绝大部分的逻辑其实都是 <code class="highlighter-rouge">switch-case</code> : 根据指令类型执行相应的逻辑。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">LOAD_CONST</span><span class="p">):</span> <span class="p">{</span>      <span class="cm">/* 加载常量 */</span>
            <span class="p">...</span>
        <span class="p">}</span>		
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">ROT_TWO</span><span class="p">):</span> <span class="p">{</span>         <span class="cm">/* 交换两个变量 */</span>
            <span class="p">...</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">FORMAT_VALUE</span><span class="p">):{</span>     <span class="cm">/* 格式化字符串 */</span>
            <span class="p">...</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>可以看到 <code class="highlighter-rouge">TARGET()</code> 调用中的参数其实就是 <code class="highlighter-rouge">dis</code> 方法返回的助记符，当我们在分析助记符的具体实现逻辑时，可以在该文件中找到对应的 C 实现方法。</p>

<h4 id="43-gil-与字节码的执行">4.3 GIL 与字节码的执行</h4>

<p>对于 Python 中的容器，例如 dict，并没有实现像 Java 中的 <code class="highlighter-rouge">ConcurrentHashMap</code>，或者是 Golang 中的 <code class="highlighter-rouge">sync.Map</code>，这是因为 Python 中的容器(list, dict)本身就是并发安全的，但是在这些容器的源码中并没有发现定义 <code class="highlighter-rouge">mutex</code>，也就是说，Python 容器的并发安全并不是通过互斥锁实现的。</p>

<p>实际上，Python 容器的并发安全是通过 GIL 实现的，也就是被广大 Pythoner 口诛笔伐的全局解释器锁。某一个线程想要运行必须要首先获取全局锁，如此一来，在同一时刻只能有一个线程运行，无法充分利用多核的硬件资源。</p>

<p>Python 的线程调度非常类似于 CPU 的时间片实现，只不过并不是以时间为判断标准，而是以执行字节码的数量作为判断标准。当某一个线程执行了足够多的字节码条数时，当前线程将释放全局锁，唤醒其它线程进行执行。</p>

<p><strong>所以，得益于 GIL 的存在，Python 容器在进行诸如扩容、缩容操作时，完全不必担心并发问题，因为一条字节码的执行一定是原子性的。</strong></p>

	  ]]></description>
	</item>

	<item>
	  <title>VXLAN—构建Overlay容器网络</title>
	  <link>//VXLAN</link>
	  <author></author>
	  <pubDate>2020-08-06T09:06:25+00:00</pubDate>
	  <guid>//VXLAN</guid>
	  <description><![CDATA[
	     <p>由于VLAN实现中的VLAN ID仅有12位，只能划分4096个虚拟局域网网段，对于云计算等领域而言，其用户远远不止4096个。并且，VLAN依赖于交换机等物理设备的实现，一旦升级物理设备，集群网络可能需要重新配置。因此，基于上述的限制，VMware、Cisco等大型网络企业推出了VXLAN解决方案。</p>

<!---more--->

<p>VXLAN全称为Virtual eXtensible Local Area Network，可拓展虚拟局域网，不依赖于硬件实现，而是在三层网络(网络层)的基础之上构建出一个虚拟的二层网络(链路层)。也就是说，只要主机间IP地址可达，就可以使用VXLAN的方式构建一个Overlay网络。</p>

<blockquote>
  <p>Overlay: 可以理解为覆盖网络，属于一种虚拟网络的实现，依赖于物理网络，而物理网络又可称之为Underlay。</p>
</blockquote>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/virtual-machine-communicate-problems.png" alt="" /></p>

<p>在实际的介绍VXLAN之前，先来看一个集群中虚拟机通讯的问题。如上图所示，虚拟机-A(<code class="highlighter-rouge">192.19.2.2</code>)想要和虚拟机-C(<code class="highlighter-rouge">192.16.2.6</code>)进行通信，要如何实现?</p>

<p>由于节点<code class="highlighter-rouge">10.168.4.3</code>和<code class="highlighter-rouge">10.168.9.3</code>能够实现通信，那么是否能够将虚拟机间通讯的数据包封装在节点间的通讯包之上，抵达目的地之后再进行解包、分发呢? 就好像特洛伊木马一样。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/virtual-machine-solution.png" alt="" /></p>

<p>如上图所示，虚拟机-A发送给虚拟机-C的数据包，首先经过一个工具进行封包，暂且称之为Tool，封包的结果就是将该数据包放置在节点间通讯数据包的Body中，作为数据发送给节点B。节点B收到该数据包之后，经过某种过滤规则，检查Body，发现这是一个发送给虚拟机-C的数据包，那么将数据包发送给节点C，单向通讯完成。</p>

<p>上述的过程其实就是VXLAN的基本原理组成，本质上就是对虚拟机间通讯数据包的封装和解封，乘着节点间通讯这条大船抵达目的地。</p>

<h3 id="1-vxlan协议原理">1. VXLAN协议原理</h3>

<p>在VXLAN协议中，负责封包、解包的组件称之为VTEP(VXLAN Tunnel Endpoints，VXLAN隧道端点)，可以简单的认为就是运行在各个节点上的一个进程。</p>

<p>每一个VTEP都有一个唯一的标志符，称之为VNI(VXLAN Network Identifier，VXLAN网络标识符)，其实就是拓展的VLAN ID。VNI被设计成24位，可以容纳16777216个不同的虚拟局域网，相较于VLAN是一个非常大的提升。</p>

<p>VXLAN在节点中的传输协议选择了UDP协议，而不是TCP协议。原因在于UDP协议相较于TCP协议速度更快，无需连接的建立与拆除，数据包的可靠传输则由虚拟机间的传输协议保证。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/VXLAN-package.png" alt="" /></p>

<p>其中，VXLAN Header由VTEP添加，其中包含了24位VNI的值。可以看到，VXLAN其实就是对原有网络添加了一层拓展: VTEP。当数据包到达主机时，内核将MAC头和IP头取下，将UDP报文段发送给主机上的VTEP进程，VTEP进程首先检查VNI的值是否匹配(是不是给自己的包)，然后根据Inner IP Header决定发送给哪一个具体的虚拟机。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/VXLAN-Transfer.png" alt="" /></p>

<p>现在，我们对VXLAN协议的基本原理已经很清楚了，现在再来看一些细节问题。<strong>首先，虚拟机-A发出的数据帧的目标MAC地址，也就是目标VTEP的MAC地址该如何获取?</strong> 两种方式，一种是通过广播的方式，另外一种，则是由外部进程自动的添加至各节点的ARP表中。<strong>其次，IP地址为192.16.2.6这台虚拟机所在节点的IP地址如何获取?</strong> 该IP地址则是通过Linux内核中的FDB(Forwarding Database)获取的，在该表中，会记录VTEP的MAC地址与节点IP地址的映射关系，该映射关系同样可以通过广播学习获取，或者由外部进程维护。</p>

<blockquote>
  <p>经典的”外部进程”有flannel、Weave等容器网络框架</p>
</blockquote>

<h3 id="2-使用vagrant构建vxlan点对点通信">2. 使用Vagrant构建VXLAN点对点通信</h3>

<p>Vagrant环境如下:</p>
<ul>
  <li>node-1: 网卡接口-enp0s8，IP地址-192.168.2.15/24</li>
  <li>node-2: 网卡接口-enp0s8，IP地址-192.168.2.16/24</li>
</ul>

<p>首先，在node-1上添加vxlan interface:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span><span class="nb">sudo </span>ip link add vxlan0 <span class="nb">type </span>vxlan <span class="se">\</span>
    id 1024 <span class="se">\</span>
    dstport 4789 <span class="se">\</span>
    remote 192.168.2.15 <span class="se">\</span>
    dev enp0s8
</code></pre></div></div>

<p>上述命令将创建出一个名称为<code class="highlighter-rouge">vxlan0</code>、类型为vxlan的网络接口，并且指定VNI为<code class="highlighter-rouge">1024</code>，vtep通信端口为<code class="highlighter-rouge">4789</code>，并且手动地指出了对端VTEP的IP地址(<code class="highlighter-rouge">192.168.2.16</code>)。</p>

<p>其次，为vxlan0网络接口添加一个IP地址，该IP地址可以是任意值:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span><span class="nb">sudo </span>ip addr add 10.100.1.15/24 dev vxlan0
vagrant@node-1:~<span class="nv">$ </span><span class="nb">sudo </span>ip link <span class="nb">set </span>vxlan0 up
</code></pre></div></div>

<p>那么此时所有目标地址为<code class="highlighter-rouge">10.100.1.10/24</code>网段的数据包均会通过vxlan0接口处理，可以从路由表上查看此信息:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span>ip route
10.100.1.0/24 dev vxlan0 proto kernel scope link src 10.100.1.15
</code></pre></div></div>

<p>并且，如果此时查看Linux FDB表的话会发现，此时表项中的MAC地址为空值:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span>bridge fdb
00:00:00:00:00:00 dev vxlan0 dst 192.168.2.16 via enp0s8 self permanent
</code></pre></div></div>

<p>即所有经过vxlan0处理的数据包都会发到<code class="highlighter-rouge">192.168.2.16</code>，其原因在于在创建vxlan0时，手动地指定了对端IP地址。</p>

<p>用同样的方式在另一台虚拟机上创建vxlan0接口，并配置相应的IP地址，即可测试连通性。</p>

<p>通过上面的实验用例，我们可以看到几个非常关键的步骤:</p>

<ul>
  <li><strong>在路由表中添加vtep设备网络段的路由信息</strong></li>
  <li><strong>在ARP表中添加vtep设备的MAC地址与vtep的IP地址映射</strong></li>
  <li><strong>在FDB表中添加vtep设备的MAC地址与vtep所在节点的IP地址映射</strong></li>
</ul>

<p>实际上，<code class="highlighter-rouge">Flannel</code>这一经典的Kubernetes容器网络解决方案的VXLAN模式就是这么实现的，VXLAN模式所组建的覆盖网络，其实就是一个由不同宿主机上的VTEP设备所组成的虚拟二层网络。</p>

<h3 id="reference">Reference</h3>

<ul>
  <li><a href="https://www.kernel.org/doc/Documentation/networking/vxlan.txt">https://www.kernel.org/doc/Documentation/networking/vxlan.txt</a></li>
  <li><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100087027">https://support.huawei.com/enterprise/zh/doc/EDOC1100087027</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>浅析gRPC</title>
	  <link>//gRPC</link>
	  <author></author>
	  <pubDate>2020-07-23T09:06:25+00:00</pubDate>
	  <guid>//gRPC</guid>
	  <description><![CDATA[
	     <p>gRPC是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。(这Ctrl-C/V也是没有下限了….</p>

<!---more--->

<h3 id="1-protocol-buffers">1. Protocol Buffers</h3>

<p>在早期，ProtoBuf主要用于解决Google内部的服务器高低版本的兼容性问题，后来由于其高效的数据传输效率被用于gRPC的传输数据格式。</p>

<p>相较于XML以及Json，ProtoBuf在传输和存储时由于其体积更小，所以效率更高，并且序列化的速度也比Json的序列化速度更快，原因将在后续部分介绍。</p>

<p>除此之外，ProtoBuf的最大特点就是支持向后兼容。如果使用Json或者XML的话，需要应用程序自行处理新旧版本数据格式之间的兼容性。而ProtoBuf则不需要破坏已经被部署的服务结构，ProtoBuf会帮助用户处理好高低版本的兼容性问题。</p>

<h4 id="11-protobuf所支持的数据类型">1.1 ProtoBuf所支持的数据类型</h4>

<p>对于基本数据类型，如int，float，double，string，bool以及bytes，ProtoBuf均支持定义以上数据类型。对于int类型的数据，ProtoBuf对其进行了额外的拓展，在不同的场景使用不同的整型将会有不同的运行效率。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">ProtoBuf Type</th>
      <th style="text-align: left">Explain</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">int32</td>
      <td style="text-align: left">int32最大支持4字节的整型数字，编码负数时效率较低</td>
    </tr>
    <tr>
      <td style="text-align: left">int64</td>
      <td style="text-align: left">int32最大支持8字节的整型数字，编码负数时效率较低</td>
    </tr>
    <tr>
      <td style="text-align: left">uint32</td>
      <td style="text-align: left">uint32最大支持4字节的无符整数</td>
    </tr>
    <tr>
      <td style="text-align: left">uint64</td>
      <td style="text-align: left">uint32最大支持8字节的无符整数</td>
    </tr>
    <tr>
      <td style="text-align: left">sint32</td>
      <td style="text-align: left">sint32最大支持4字节的有符整数，编码负数时效率更高</td>
    </tr>
    <tr>
      <td style="text-align: left">sint64</td>
      <td style="text-align: left">sint32最大支持8字节的有符整数，编码负数时效率更高</td>
    </tr>
    <tr>
      <td style="text-align: left">fixed32</td>
      <td style="text-align: left">不使用可变长度方式进行编码，总是传输4字节，在编码超过$2^{28}$数值的整数时效率更高</td>
    </tr>
    <tr>
      <td style="text-align: left">fixed64</td>
      <td style="text-align: left">不使用可变长度方式进行编码，总是传输8字节，在编码超过$2^{56}$数值的整数时效率更高</td>
    </tr>
  </tbody>
</table>

<p>除了上述的基本数据类型以外，ProtoBuf同时也支持列表，字典以及枚举类型的定义，再加上<code class="highlighter-rouge">message</code>类型支持嵌套定义，几乎可以说能够覆盖日常开发中的所有需求了。</p>

<h4 id="12-protobuf中的消息定义">1.2 ProtoBuf中的消息定义</h4>

<p><code class="highlighter-rouge">message</code>数据类型是ProtoBuf在序列化和反序列化中的最小单位，和C结构体非常类似。</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">Response</span> <span class="p">{</span>
    <span class="kt">int32</span> <span class="na">code</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">msg</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int32</span> <span class="na">data</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">message</code>中的字段类型和字段名称无需赘述，值得关注的是后面的Field Numbers，字段序列号。该序列号将会在数据存储和传输时用于指代<code class="highlighter-rouge">message</code>中所定义的字段，即对源数据编码成ProtoBuf格式数据后，字段名称将会被舍弃，转而使用字段系列号进行代替，所以会说ProtoBuf并不是自描述的传输格式，同时也是数据体积更小的原因之一。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MicroService/gRPC/FieldNumbers.png" alt="" /></p>

<p>所以，一个<code class="highlighter-rouge">message</code>中的字段系列号必须唯一，同时范围必须在[$1$, $2^{29}-1$]之间。并且19000到19999之间的数值被ProtoBuf内部所用，也不可定义。</p>

<p>下面是一个使用了大部分数据类型的<code class="highlighter-rouge">message</code>定义:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">UserStatus</span> <span class="p">{</span>
    <span class="c1">// 值为0的枚举值必须定义，因为这是ProtoBuf对枚举值的默认值
</span>    <span class="c1">// 同时，该零值不应该被应用程序所使用，否则会出现歧义
</span>    <span class="na">USER_STATUS_INVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="na">USER_STATUS_NORMAL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">USER_STATUS_FROZEN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">USER_STATUS_DELETED</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">MainAddress</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="na">province</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">city</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">address</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">UserInfo</span> <span class="p">{</span>
    <span class="kt">uint32</span> <span class="na">user_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">mobile</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">repeated</span> <span class="kt">string</span> <span class="na">extra_mobile</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">UserStatus</span> <span class="na">status</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">MainAddress</span> <span class="na">main_address</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="na">is_vip</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="13-protobuf编码">1.3 ProtoBuf编码</h4>

<p>ProtoBuf格式的数据体积更小的原因一方面归功于使用字段系列号来代替字段名称，另一方面则是因为对整型采用了可变长度编码方式，即使是指定了<code class="highlighter-rouge">int32</code>类型的数据也可能只使用一字节存储。</p>

<h5 id="131-base-128-varints">1.3.1 Base 128 Varints</h5>

<p>Varint使用一个或者多个字节表示一个数字，数字的值越小，所使用的字节数也会更小。其长度并不固定，所以称之为”可变长整数”。</p>

<p>Varint中的每个字节(最后一个字节除外)都设置了最高有效位(msb)，用于表示后面还会有更多字节出现，所以Varint中的最后一个字节不会设置msb。由于首位被当做是msb使用，所以一个字节只有7位有效位。</p>

<p>例如数字1，可以使用1字节进行表示，那么其最高有效位即可设置为0:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000 0001
</code></pre></div></div>

<p>对于多字节的数字，除了最后一个字节以外，其余字节的首位都应该置为1，以表示后续仍有字节。以数字1024为例，在一般情况下，1024需要使用2个字才能表示:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1024 <span class="o">=</span> 0000 0100 0000 0000
</code></pre></div></div>

<p>现在来看下Varint的编码过程:</p>

<ul>
  <li>首先，1024超过了7位，所以必须使用至少2个字节表示，但是又小于14位，所以需要2个字节表示。按每7位取一个字节，若不够7位则用0补齐:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000 0100 0000 0000 -&gt; 0001000 0000000
</code></pre></div></div>

<ul>
  <li>将低字节写入到高字节，最后一个字节最高位补0，其余字节最高位补1，即为最终结果:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10000000 00001000
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MicroService/gRPC/Varint.png" alt="" /></p>

<h5 id="132-message-structure">1.3.2 Message Structure</h5>

<p>在ProtoBuf中，<code class="highlighter-rouge">message</code>结构其实就是一系列的键值对，只不过<code class="highlighter-rouge">message</code>在序列化成二进制时，对键和值进行了特殊的处理而已。</p>

<p>首先来看对键的处理，键的计算方式是<code class="highlighter-rouge">(field_number &lt;&lt; 3) | wire_type</code>，根据键的计算公式可以看出，键的最后3位就是字段类型。<code class="highlighter-rouge">field_number</code>即为用户自定义的字段序列号，而<code class="highlighter-rouge">wire_type</code>则是一个由ProtoBuf所定义的对类型的”枚举”。:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Write Type</th>
      <th style="text-align: left">Meaning</th>
      <th style="text-align: left">Used For</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">0</td>
      <td style="text-align: left">Varint</td>
      <td style="text-align: left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
    </tr>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">64-bit</td>
      <td style="text-align: left">fixed64, sfixed64, double</td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">Length-delimited</td>
      <td style="text-align: left">string, bytes, embedded messages, packed repeated fields</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">32-bit</td>
      <td style="text-align: left">fixed32, sfixed32, float</td>
    </tr>
  </tbody>
</table>

<p>值得注意是当<code class="highlighter-rouge">wire_type</code>为2时，序列化结果中还需要包含数据的长度，即<code class="highlighter-rouge">length</code>。</p>

<ul>
  <li>当<code class="highlighter-rouge">wire_type</code>为0、1和5时，序列化的结果为<strong>key + 数据</strong>，数据长度由数据自描述。</li>
  <li>当<code class="highlighter-rouge">wire_type</code>为2时，序列化的结果为<strong>key + length + 数据</strong>，数据长度由<code class="highlighter-rouge">length</code>决定。</li>
</ul>

<p>下面通过一个实际的例子看下Message Structure的编码形式:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>syntax <span class="o">=</span> <span class="s2">"proto3"</span><span class="p">;</span>

message foo <span class="o">{</span>
    string bar <span class="o">=</span> 5<span class="p">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>将<code class="highlighter-rouge">bar</code>的值设置为”Hello”，序列化后将得到以下结果:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>052a 6548 6c6c 006f
</code></pre></div></div>

<p>ProtoBuf是小端字节序，阅读起来不是很方便，将其转换一下:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2a05 4865 6c6c 6f
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">4865 6c6c 6f</code>为字符串”Hello”的16进制表示，那么<code class="highlighter-rouge">2a05</code>就是前面提到的<strong>key+length</strong>了。<code class="highlighter-rouge">2a</code>的二进制格式为<code class="highlighter-rouge">101010</code>，最后3位为<code class="highlighter-rouge">010</code>，转换成十进制结果是2，对应string类型的<code class="highlighter-rouge">write_type</code>。<code class="highlighter-rouge">101</code>转换成十进制结果为5，对应bar字段的<code class="highlighter-rouge">field_number</code>。length则由<code class="highlighter-rouge">05</code>确定，表示字符串的长度为5。</p>

<h3 id="2-http2">2. HTTP/2</h3>

<p>HTTP/2协议在原有的HTTP/1协议版本之上进行了大幅度的修改，其传输效率大大提升，并且能够有效地降低服务端的资源消耗。</p>

<ul>
  <li>由文本传输改变为二进制数据传输，解析更加高效。</li>
  <li>使用新的二进制分帧机制改变了客户端和服务端之间交换数据的方式，每个二进制帧可进行乱序传输，解决了HTTP/1中的首部阻塞问题。</li>
  <li>对请求头部字段的压缩使得传输数据更小，传输效率更高。</li>
</ul>

<p>为了更好的理解HTTP/2，首先要明确HTTP/1的缺陷之处，首当其冲的就是TCP连接数限制。在浏览器中，同一个域名下同时只能创建6~8个TCP连接，剩下的请求只能等待这些请求的返回。并且，每个TCP连接只能承载一次请求/响应，当初始发送的请求响应时间较长时，整个页面加载也会受到阻塞。</p>

<h4 id="21-二进制分帧">2.1 二进制分帧</h4>

<p>在HTTP/1中，请求的数据以明文进行传输，例如:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET / HTTP/1.1
Host: example.com
</code></pre></div></div>

<p>而在HTTP/2中，请求或者响应数据不再以文本的方式进行传输，而是直接使用二进制数据进行传输，使得解析更加高效。其原因在于HTTP/1是通过特殊符号，如空格，<code class="highlighter-rouge">\r\n</code>等特殊字符进行分割并解析的。而HTTP/2首先对数据进行了分类，将请求头和Payload分开，并且在每一个传输单元中都进行了标记。</p>

<p>HTTP/2的基本传输单元为帧(Frame)，每一个都以固定的9个字节开头，后跟不定长度的Payload。Payload可以是用户传输的数据，也可以是协议本身携带的数据。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+-----------------------------------------------+
|                 Length <span class="o">(</span>24<span class="o">)</span>                   |
+---------------+---------------+---------------+
|   Type <span class="o">(</span>8<span class="o">)</span>    |   Flags <span class="o">(</span>8<span class="o">)</span>   |
+-+-------------+---------------+-------------------------------+
| R <span class="o">(</span>1<span class="o">)</span> |                 Stream Identifier <span class="o">(</span>31<span class="o">)</span>                |
+<span class="o">=</span>+<span class="o">=============================================================</span>+
|                   Frame Payload <span class="o">(</span>0...<span class="o">)</span>                      ...
+---------------------------------------------------------------+
</code></pre></div></div>

<p>24+8+8+1+31，刚好为72位，即9字节。下面来看每一个字段的含义:</p>

<ul>
  <li>Length: 表示Payload的长度，是一个24位的无符整数，单位为字节。也就是说，通常情况下一个帧最多能够传输2^14(16,384)个字节。如果想在一个帧中传输更多的数据，则可以通过传输<code class="highlighter-rouge">SETTINGS_MAX_FRAME_SIZE</code>帧来改变基本大小。</li>
  <li>Type: 帧的类型，如<code class="highlighter-rouge">DATA</code>帧、<code class="highlighter-rouge">HEADERS</code>帧。</li>
  <li>Flags: 该字段用于各类型的帧进行补充说明，表示特殊的含义。一个常见的标志就是<code class="highlighter-rouge">END_HEADERS</code>，表示头数据已经结束。</li>
  <li>R: 预留位，并未使用。</li>
  <li>Stream Identifier: 流标识符，31位无符整数，作用将在下方描述。</li>
</ul>

<h4 id="22-多路复用">2.2 多路复用</h4>

<p>HTTP/2一个最重要的特性就是多路复用，即在一个TCP连接中同时传输多个请求或者是响应，而HTTP/1想要做到这一点的话，必须要建立多个TCP连接。</p>

<p>在HTTP/2中引入了”流”(Stream)的概念，对应HTT/1的话，其实就是一个请求: 在一个连接中发送多个请求其实就是发送多个流。而流又是由帧组成的，所以在帧中需要字段<code class="highlighter-rouge">Stream Identifier</code>来标记当前帧属于哪个流。</p>

<p>实现多路复用的逻辑概念就是流，和TCP流式传输不同的是，HTTP/2中的流只是一个逻辑上的概念，每一个流使用<code class="highlighter-rouge">Stream Identifier</code>进行标识。一个请求或者是响应在拆分成多个帧以后，将使用同一个流ID在连接中进行传输，接收方在接收到乱序传输的帧以后，按照流ID进行组装，即可得到一个完整的请求或者是响应。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MicroService/gRPC/stream.png" alt="" /></p>

<h4 id="22-头部字段压缩">2.2 头部字段压缩</h4>

<p>TODO</p>

<h3 id="3-一些实践的代码用例">3. 一些实践的代码用例</h3>

<h4 id="31-python-client">3.1 Python Client</h4>

<p>gRPC的错误响应(如Not Found，Internal Server Error等)通常会以异常的形式抛出，所以，Python Client必须要对gRPC的相关方法进行进一步的封装，例如重试机制或者是进行其它行为。</p>

<p>最为常见的异常就是<code class="highlighter-rouge">_Rendezvous</code>，该异常为<code class="highlighter-rouge">RpcError</code>的一个子类，通常来说，只需要捕获该异常即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">grpc</span> <span class="kn">import</span> <span class="n">StatusCode</span><span class="p">,</span> <span class="n">RpcError</span>


<span class="c"># define retry times with different situation</span>
<span class="n">MAX_RETRIES_BY_CODE</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">StatusCode</span><span class="o">.</span><span class="n">INTERNAL</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">StatusCode</span><span class="o">.</span><span class="n">ABORTED</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">StatusCode</span><span class="o">.</span><span class="n">UNAVAILABLE</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">StatusCode</span><span class="o">.</span><span class="n">DEADLINE_EXCEEDED</span><span class="p">:</span> <span class="mi">5</span>
<span class="p">}</span>

<span class="c"># define MIN and MAX sleeping seconds</span>
<span class="n">MIN_SLEEPING</span> <span class="o">=</span> <span class="mf">0.015625</span>
<span class="n">MAX_SLEEPING</span> <span class="o">=</span> <span class="mf">1.0</span>


<span class="k">class</span> <span class="nc">RetriesExceeded</span><span class="p">(</span><span class="nb">Exception</span><span class="p">):</span>
    <span class="s">"""docstring for RetriesExceeded"""</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">retry</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wraps</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">RpcError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">code</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">code</span><span class="p">()</span>  <span class="c"># 使用e.code()获取响应码</span>
                <span class="n">max_retries</span> <span class="o">=</span> <span class="n">MAX_RETRIES_BY_CODE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">max_retries</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>

                <span class="k">if</span> <span class="n">retries</span> <span class="o">&gt;</span> <span class="n">max_retries</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">RetriesExceeded</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

                <span class="n">back_off</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">MIN_SLEEPING</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">retries</span><span class="p">,</span> <span class="n">MAX_SLEEPING</span><span class="p">)</span>

                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">back_off</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wraps</span>
</code></pre></div></div>

<h4 id="32-golang-server">3.2 Golang Server</h4>

<p>TODO</p>

<h3 id="4-reference">4. Reference</h3>

<ul>
  <li><a href="https://hpbn.co/">https://hpbn.co/</a></li>
  <li><a href="https://blog.wangriyu.wang/">https://blog.wangriyu.wang/</a></li>
  <li><a href="https://tools.ietf.org/html/rfc7540">https://tools.ietf.org/html/rfc7540</a></li>
  <li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn">https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>揭开Python元类(metaclass)神秘的面纱</title>
	  <link>//Python-metaclass</link>
	  <author></author>
	  <pubDate>2020-07-13T10:06:25+00:00</pubDate>
	  <guid>//Python-metaclass</guid>
	  <description><![CDATA[
	     <p>Python语言的<code class="highlighter-rouge">metaclass</code>特性一直是初学者的”噩梦”，当初博主在学习元类时也是一头雾水，但是一旦真正的理解了什么是”动态语言”之后，元类就不再神秘与难以理解了。Python这门动态语言最大的特性就是不需要一个类的字节码就能够在运行时创建出一个类，这是理解元类最为关键的信息。</p>

<!---more--->

<h3 id="1-基础知识汇总">1. 基础知识汇总</h3>

<h4 id="11-stackoverflow">1.1 stackoverflow</h4>

<p>首先，强烈推荐阅读stackoverflow上关于<code class="highlighter-rouge">metaclass</code>的回答，作者并没有使用什么高级词汇，就算英语稀烂也能看的懂。</p>

<blockquote>
  <p>https://stackoverflow.com/a/6581949/12523821</p>
</blockquote>

<h4 id="12-类属性和实例属性">1.2 类属性和实例属性</h4>

<p>类属性表示绑定在一个类上的属性，而实例属性则是绑定在不同实例上的属性，类属性只有一份，而实例属性则可以有多份。当实例属性和类属性重名，并通过实例获取该属性时，会返回实例属性，而不是类属性。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">Hugo</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Hugo</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>      <span class="c"># "smart"</span>

    <span class="n">hugo</span> <span class="o">=</span> <span class="n">Hugo</span><span class="p">(</span><span class="s">"raven"</span><span class="p">)</span>  
    <span class="k">print</span><span class="p">(</span><span class="n">hugo</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>      <span class="c"># "raven"</span>

    <span class="k">print</span><span class="p">(</span><span class="n">Hugo</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>      <span class="c"># "smart"</span>
</code></pre></div></div>

<h4 id="13-__new__方法和__init__方法">1.3 <code class="highlighter-rouge">__new__</code>方法和<code class="highlighter-rouge">__init__</code>方法</h4>

<p>在Python中，实际创建对象的过程是由<code class="highlighter-rouge">__new__</code>方法控制的，该方法接收class对象(cls)。而<code class="highlighter-rouge">__init__</code>方法则是在<code class="highlighter-rouge">__new__</code>方法所创建的对象实例上，进行属性的赋值或者其它操作，所以接收实例对象(self)。</p>

<p>当想要控制创建对象的过程时，应该使用<code class="highlighter-rouge">__new__</code>方法，例如常用的单例模式，而不是使用<code class="highlighter-rouge">__init__</code>方法:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Lock</span>

<span class="k">class</span> <span class="nc">SingletonClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">instance</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span>
        <span class="k">with</span> <span class="n">cls</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="c"># double check</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span><span class="p">:</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span>
</code></pre></div></div>

<h4 id="14-mro">1.4 MRO</h4>

<p>Python是通过MRO列表来实现类的继承的，MRO列表的构造由C3线性化算法实现。实际上，类的继承层级关系最终会表现成包含所有基类的线性顺序表。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Parent init"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Children</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Children</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Children init"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Grandchildren</span><span class="p">(</span><span class="n">Children</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Grandchildren</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Grandchildren init"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Grandchildren</span><span class="o">.</span><span class="n">__mro__</span><span class="p">)</span>
</code></pre></div></div>

<p>运行结果为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>
    &lt;class <span class="s1">'__main__.Grandchildren'</span><span class="o">&gt;</span>, 
    &lt;class <span class="s1">'__main__.Children'</span><span class="o">&gt;</span>, 
    &lt;class <span class="s1">'__main__.Parent'</span><span class="o">&gt;</span>, 
    &lt;class <span class="s1">'object'</span><span class="o">&gt;</span>
<span class="o">)</span>
</code></pre></div></div>

<p>其顺序与继承顺序刚好相反，也就是说，通过类的<code class="highlighter-rouge">__mro__</code>属性即可找到该类的所有父类，包括<code class="highlighter-rouge">object</code>类。</p>

<p>Python同时也提供了内建的反射函数，来返回某个类的MRO列表:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">getmro</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">__mro__</span>
</code></pre></div></div>

<h3 id="2-metaclass">2. metaclass</h3>

<p>我们已经知道了<code class="highlighter-rouge">metaclass</code>是创建一个类的工具，通过<code class="highlighter-rouge">metaclass</code>能够更加灵活地动态地创建一个类，其中一个非常重要的结果就是能够获取到”子类”的全部信息，例如类属性、类方法等。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"get class field: {name}===&gt;{value}"</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">HugoMetaclass</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="n">gender</span> <span class="o">=</span> <span class="s">"male"</span>
</code></pre></div></div>

<p>运行上述代码将会打印出<code class="highlighter-rouge">Hugo</code>类的所有属性信息:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>get class field: <span class="nv">__module__</span><span class="o">===&gt;</span>__main__
get class field: <span class="nv">__qualname__</span><span class="o">===&gt;</span>Hugo
get class field: <span class="nv">name</span><span class="o">===&gt;</span>smart
get class field: <span class="nv">gender</span><span class="o">===&gt;</span>male
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">__module__</code>和<code class="highlighter-rouge">__qualname__</code>为内部属性，而<code class="highlighter-rouge">name</code>和<code class="highlighter-rouge">gender</code>则是用户自定义的类属性。可以看到，在<code class="highlighter-rouge">HugoMetaclass。__new__</code>方法中，完全能够获取到<code class="highlighter-rouge">Hugo</code>类的相关类属性，那么更进一步地来说，不管用户定义了什么样的类属性，都可以使用<code class="highlighter-rouge">metaclass</code>在创建该类之前获取到该类的所有属性。这就为诸如ORM、表单验证等基础服务提供了构建的基础。</p>

<h4 id="21-metaclass的应用">2.1 metaclass的应用</h4>

<p><code class="highlighter-rouge">type</code>的<code class="highlighter-rouge">__new__</code>方法接收4个参数，分别为类对象，类名称，父类元组以及类属性。这四个参数中最为关键的就是父类元组和类属性，通常项目中使用<code class="highlighter-rouge">metaclass</code>时也是和这两个参数频繁打交道。</p>

<h5 id="211-父类元组">2.1.1 父类元组</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">HugoMetaclass</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">HugoChild</span><span class="p">(</span><span class="n">Hugo</span><span class="p">):</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p>运行后将得到以下结果:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">()</span>
<span class="o">(</span>&lt;class <span class="s1">'__main__.Hugo'</span><span class="o">&gt;</span>,<span class="o">)</span>
</code></pre></div></div>

<p>一共需要创建两个类: <code class="highlighter-rouge">Hugo</code>和<code class="highlighter-rouge">HugoChild</code>，<code class="highlighter-rouge">Hugo</code>类直接使用<code class="highlighter-rouge">HugoMetaclass</code>创建，所以其父类元组为空。而<code class="highlighter-rouge">HugoChild</code>直接继承自<code class="highlighter-rouge">Hugo</code>，所以其父类为<code class="highlighter-rouge">Hugo</code>。所以，可以通过<code class="highlighter-rouge">bases</code>参数来判断当前创建的类是否需要进行处理。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 这里所创建的类都是Hugo的子类, 而不是Hugo类</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="212-类属性">2.1.2 类属性</h5>

<p>类属性是”子类”中最为重要的数据，可以说元类的最终目的就是为了根据类属性创建出一个模板，将该模板数据保存在类中。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>

        <span class="c"># 对Hugo类不做任何处理</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="n">klass</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 保存attrs中所有的int类型数据</span>
        <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">klass</span>
        
<span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">HugoMetaclass</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">HugoChild</span><span class="p">(</span><span class="n">Hugo</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="n">age</span> <span class="o">=</span> <span class="mi">24</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
</code></pre></div></div>

<p>上面创建了一个<code class="highlighter-rouge">int</code>类型的”模板”，并保存在了<code class="highlighter-rouge">declared_fields</code>这个字典中。注意不要将<code class="highlighter-rouge">declared_fields</code>挂到<code class="highlighter-rouge">mcs</code>上，<code class="highlighter-rouge">mcs</code>就是<code class="highlighter-rouge">HugoMetaclass</code>，变量绑定到<code class="highlighter-rouge">mcs</code>上会丢失一些信息，导致程序出现BUG。</p>

<p>那么如果<code class="highlighter-rouge">HugoChild</code>又有子类呢? 上述方式是否能够将<code class="highlighter-rouge">HugoChild</code>和其子类的属性一起获取到呢?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoChild</span><span class="p">(</span><span class="n">Hugo</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="n">age</span> <span class="o">=</span> <span class="mi">24</span>

<span class="k">class</span> <span class="nc">HugoGrandChild</span><span class="p">(</span><span class="n">HugoChild</span><span class="p">):</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mi">180</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Hugo</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoGrandChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
</code></pre></div></div>

<p>这时候会发现，这三个类的<code class="highlighter-rouge">declared_fields</code>结果都是<code class="highlighter-rouge">{'height': 180}</code>，<code class="highlighter-rouge">age</code>字段丢失了。原因也很简单，在创建<code class="highlighter-rouge">HugoGrandChild</code>类时，<code class="highlighter-rouge">declared_fields</code>被重新声明成了空字典，所以<code class="highlighter-rouge">HugoChild</code>中的类属性就会丢失。那么有没有什么办法能够得到完整版呢? 这就需要用到上面所提到的MRO列表了。</p>

<p>我们可以通过MRO列表，来获取到<code class="highlighter-rouge">HugoGrandChild</code>的所有父类，而后逐一的遍历找出类型为<code class="highlighter-rouge">int</code>的类属性，保存在<code class="highlighter-rouge">declared_fields</code>这个字典中。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>

        <span class="c"># 对Hugo类不做任何处理</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 保存attrs中所有的int类型数据</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c"># 遍历__mro__列表并找出类型为`int`的类属性, 保存在字典中</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">klass</span><span class="o">.</span><span class="n">__mro__</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="s">'declared_fields'</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">klass</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoGrandChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
</code></pre></div></div>

<p>其运行结果为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span><span class="s1">'age'</span>: 24<span class="o">}</span>
<span class="o">{</span><span class="s1">'height'</span>: 180, <span class="s1">'age'</span>: 24<span class="o">}</span>
</code></pre></div></div>

<p>如此一来，<code class="highlighter-rouge">HugoGrandChild</code>在继承了<code class="highlighter-rouge">HugoChild</code>之后，也能够获取到其中的相关字段，并且父类不会受到子类的影响。</p>

<p>上述代码中存在一些重复的代码片段，将其抽离出来，使代码结构更加清晰:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_instance_or_subclass</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">class_</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">class_</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">class_</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_fields</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">field_class</span><span class="p">):</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">field_name</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">is_instance_or_subclass</span><span class="p">(</span><span class="n">field_value</span><span class="p">,</span> <span class="n">field_class</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">fields</span>

<span class="k">def</span> <span class="nf">_get_fields_by_mro</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">field_class</span><span class="p">):</span>
    <span class="n">mro</span> <span class="o">=</span> <span class="n">klass</span><span class="o">.</span><span class="n">__mro__</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">_get_fields</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s">'declared_fields'</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">__dict__</span><span class="p">),</span>
                <span class="n">field_class</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">mro</span><span class="p">[:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">),</span>
        <span class="p">[],</span>
    <span class="p">)</span>

<span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>

        <span class="c"># 对Hugo类不做任何处理</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 保存attrs中所有的int类型数据</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="n">class_fields</span> <span class="o">=</span> <span class="n">_get_fields</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">inherited_fields</span> <span class="o">=</span> <span class="n">_get_fields_by_mro</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">class_fields</span> <span class="o">+</span> <span class="n">inherited_fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">klass</span>
</code></pre></div></div>

<h3 id="3-小结">3. 小结</h3>

<p><code class="highlighter-rouge">metaclass</code>并不神秘，得益于Python是动态语言，可以在运行时动态地创建一个类的特性，我们能够在事前去创建一些有用的”模板”，在运行时将模板和数据有机的结合起来，最终呈现出宛如魔术般的效果。</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL向客户端发送数据，客户端不接收会发生什么?</title>
	  <link>//MySQL-Sending-Data</link>
	  <author></author>
	  <pubDate>2020-06-17T10:50:25+00:00</pubDate>
	  <guid>//MySQL-Sending-Data</guid>
	  <description><![CDATA[
	     <p>MySQL服务端在发送数据时，为了减少数据在用户空间和内核空间的复制次数，往往会使用缓冲区对数据进行缓冲。那么，如果客户端在接收大量数据时，选择不接收，或者处理非常慢的时候，会影响MySQL的正常运行吗?</p>

<!---more--->

<h3 id="1-tcp连接的收发模型">1. TCP连接的收发模型</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/TCP-buffer.png" alt="" /></p>

<p>当调用<code class="highlighter-rouge">write()</code>或者<code class="highlighter-rouge">send()</code>系统调用向socket写入数据时，并不会直接被发送至网络，而是被发送至位于内核空间的TCP发送缓冲区。在缓冲区中，由TCP连接的窗口控制发送频率和数量。当发送缓冲区已满时，阻塞模式下的<code class="highlighter-rouge">write()</code>调用将会一直阻塞，直到有可用的发送缓冲区为止。而非阻塞模式下则会直接返回-1，<code class="highlighter-rouge">errno</code>将会被置为<code class="highlighter-rouge">EAGAIN</code>或者是<code class="highlighter-rouge">EWOULDBLOCK</code>。</p>

<p>对于<code class="highlighter-rouge">read()</code>或者是<code class="highlighter-rouge">recv()</code>系统调用读取socket数据时，情况和发送数据基本类似，只不过是读取接收缓冲区中的内容。阻塞模式下如果接收缓冲区为空，那么将会阻塞，而非阻塞模式下则会立即返回，<code class="highlighter-rouge">errno</code>为<code class="highlighter-rouge">EAGAIN</code>或者是<code class="highlighter-rouge">EWOULDBLOCK</code>。</p>

<p>接收方与发送方的窗口大小、MSS大小以及网络状况都会对发送缓冲区的动态大小变化造成影响。当接收方的缓冲区较小时，也就意味地接收窗口较小，那么当发送方持续发送数据时，很有可能将发送缓冲区填满导致发送方数据写入的阻塞。同样地，如果发送方的网络出现波动导致大量的丢包，由拥塞避免阶段重新进入慢启动阶段，也会导致发送缓冲区的数据不能及时地发出。</p>

<p>在一般的Linux操作系统下，发送缓冲区和接收缓冲区的的大小默认为208K。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span><span class="nb">cat</span> /proc/sys/net/core/wmem_default
212992
smartkeyerror@Zero:~<span class="nv">$ </span><span class="nb">cat</span> /proc/sys/net/core/rmem_default
212992
</code></pre></div></div>

<h3 id="2-mysql结果发送与客户端接收">2. MySQL结果发送与客户端接收</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/MySQL-Send.png" alt="" /></p>

<p>当客户端向MySQL请求查询数据时，MySQL会将结果暂存于net_buffer中，net_buffer的大小默认为16K，由参数<code class="highlighter-rouge">net_buffer_length</code>决定。当net_buffer已满或者是无更多结果时，调用网络接口将数据写入至TCP连接的发送缓冲区中。如果发送缓冲区已满，那么该查询请求的数据发送将会阻塞，直到有可用的发送缓冲区为止。</p>

<p>当TCP发送缓冲区已满时，通过<code class="highlighter-rouge">show processlist</code>将会得到Query语句”正在发送给客户端”的结果:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/Sending-To-Client.png" alt="" /></p>

<p>当出现State为<code class="highlighter-rouge">Sending to client</code>的查询语句时，表示当前线程已将TCP发送缓冲区填满，无法继续发送数据给客户端，并等待客户端接收数据。</p>

<p>如果出现了较多的<code class="highlighter-rouge">Sending to client</code>状态的线程，那么要么是客户端网络情况较差，要么是客户端在处理结果时过慢，此时需要优化客户端代码。</p>

<p><code class="highlighter-rouge">Sending to client</code>状态需要和<code class="highlighter-rouge">Sending data</code>状态区分开来，前者表示正在等待客户端接收结果，而后者则表示事务正在执行(不一定在发送数据，也可能在等待锁)。</p>

<h3 id="3-客户端不接收mysql的发送数据会发生什么">3. 客户端不接收MySQL的发送数据会发生什么?</h3>

<h4 id="31-innodb的一致性非锁定读">3.1 InnoDB的一致性非锁定读</h4>

<p>在InnoDB存储引擎中，每条UPDATE语句都会默认的在该TABLE上添加一个意向写锁(IX Lock)，并且在要修改的数据行上添加X Lock，防止其它线程对其同时更新。而在这个过程中，普通的数据读取操作依然能够进行，并不会等待X Lock的释放，极大的提升了数据库的并发读取能力，该读取方式称为一致性非锁定读，由undo段实现。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/undo-read.png" alt="" /></p>

<p>在undo段中，同一行数据可能因为事务并发的执行而导致出现多个版本的快照，在一致性非锁定读中，只需要选择其中一个快照数据进行读取即可。在RC隔离级别，总是读取最新版本的快照数据，而在RR隔离级别下，总是读取事务开始时的行数据版本。</p>

<h4 id="32-sending-to-client导致undo段迅速膨胀">3.2 <code class="highlighter-rouge">Sending to client</code>导致undo段迅速膨胀</h4>

<p>当服务端出现大量的线程处于<code class="highlighter-rouge">Sending to client</code>状态时，所执行的查询语句未完成，那么会导致长事务的产生。而如果此时数据更新较为频繁时，将会导致undo段空间迅速膨胀，因为长事务的进行导致undo页无法被回收。</p>

<p>最常见的例子就是使用<code class="highlighter-rouge">mysqldump</code>对数据进行热备时，备份存储节点的磁盘已满，导致<code class="highlighter-rouge">mysqldump</code>无法向备份文件中写入数据。数据由客户端的接收缓冲区开始堆积，到服务端的发送缓冲区，再到<code class="highlighter-rouge">net_buffer</code>，最终可能会导致undo段的数据堆积，使得MySQL服务出现大面积的异常。</p>

<h3 id="4-小结">4. 小结</h3>

<p>综上，客户端如果在处理MySQL发送的大量数据时，应该尽可能地将其暂存在本地的某个缓冲区中，而后应用程序想怎么处理、以何种速度处理都没问题，避免让MySQL产生过多的长事务。</p>

	  ]]></description>
	</item>

	<item>
	  <title>TCP有限状态机</title>
	  <link>//TCP-Finite-State-Machine</link>
	  <author></author>
	  <pubDate>2020-06-09T18:06:25+00:00</pubDate>
	  <guid>//TCP-Finite-State-Machine</guid>
	  <description><![CDATA[
	     <p>相较于Linux进程状态的变迁，TCP的状态变迁则会复杂许多，当然这与TCP本身的实现有关。当线上的Web服务或者是基于TCP连接的服务出现了时断时续的网络状况时，往往需要通过<code class="highlighter-rouge">tcpdump</code>以及TCP连接的状态进行问题定位。同时，这一复杂的有限状态机设计也能够为业务的设计提供指导性的帮助。</p>

<!---more--->

<h3 id="1-tcp连接的建立">1. TCP连接的建立</h3>

<p>TCP连接本质上是两个进程的某些属性的状态值，在TCP连接的建立和断开过程中，实际是状态的变更。连接的建立需要经过三次握手，确认连接的双方能够正确应答，同时进行<code class="highlighter-rouge">MSS</code>、<code class="highlighter-rouge">Win</code>等信息的交换。</p>

<p>TCP协议是可靠传输协议，所以存在TCP序列号以及确认机制。序列号是指当前传输方向上数据报第一个字节的逻辑偏移，由于TCP连接是双向的，所以连接的双方都会有各自的序列号，记为Sequence Number，简写为Seq。</p>

<p>确认机制则由位于TCP报文段中大小为1bit的ACK确认位以及确认序号实现。当一方收到了Seq为$s$、Len为$l$的报文后，需要向对方确认已经收到了该报文。确认的方式是设置ACK确认位，并且将确认序号设置为$s+l$，表示下一次想要接收的数据字节序列号。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/TCP-Status/TCP-build.png" alt="" /></p>

<p>如上图所示，TCP连接的建立需要进行三次握手，其中的细节不再赘述。当客户端使用SYN发起连接时，其状态将会由<code class="highlighter-rouge">CLOSED</code>变迁为<code class="highlighter-rouge">SYN_SENT</code>，表示进程主动地打开了一个连接，并等待对端回应以此完成连接的建立。</p>

<p>当服务端收到来自客户端带有SYN控制位的数据包时，将回复带有SYN以及ACK控制位的数据包，并将状态置为<code class="highlighter-rouge">SYN_RECV</code>，等待对端发送的ACK数据包以建立连接。</p>

<p>客户端收到服务端的报文以后，将连接状态改变为<code class="highlighter-rouge"> ESTABLISHED</code>，表示与对端TCP节点间的连接建立完成，可以正式地传输数据了。同样地，服务端收到对端的ACK确认包以后，也会将状态改变为<code class="highlighter-rouge">ESTABLISHED</code>，两者的连接正式建立。</p>

<p>在连接建立时，只有在确认对方能够正确应答(SYN发送且收到ACK应答)时才会进入<code class="highlighter-rouge">ESTABLISHED</code>状态。</p>

<h3 id="2-tcp连接的拆除">2. TCP连接的拆除</h3>

<p>TCP连接的建立相对来说比较简单，其状态变迁也相对较少，而连接的拆除则远比连接的建立复杂的多。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/TCP-Status/TCP-disconnect.png" alt="" /></p>

<p>发起连接断开的一段称为主动断开方，那么另一端则称为被动断开方。主动断开方执行<code class="highlighter-rouge">close()</code>系统调用，断开TCP连接，此时主动方将发送设置了FIN控制位的报文，并进入<code class="highlighter-rouge">FIN_WAIT_1</code>阶段，等待对方对该FIN包的应答。</p>

<p>当被动断开方收到FIN包以后，立即回送该FIN的确认包，并进入到<code class="highlighter-rouge">CLOSE_WAIT</code>阶段，<strong>主要的工作就是等待上层应用主动调用<code class="highlighter-rouge">close</code>方法关闭连接</strong>，在该阶段中上层应用任何的<code class="highlighter-rouge">read()</code>系统调用都将返回0，表示文件结尾。当应用层调用了<code class="highlighter-rouge">close()</code>系统调用之后，被动断开方将发送FIN结束包。</p>

<p>主动断开方收到FIN包以后，同样地回送ACK确认报文，并进入<code class="highlighter-rouge">TIME_WAIT</code>阶段，此时将固定的等待2倍MSL时间，MSL为报文的最大生存时间，Linux中默认的MSL时间为60S，那么主动断开方将等待120S后彻底关闭TCP连接。</p>

<p>被动断开方在收到ACK确认包以后，释放内核资源，完全关闭TCP连接。</p>

<h4 id="21-close_wait">2.1 CLOSE_WAIT</h4>

<p><code class="highlighter-rouge">CLOSE_WAIT</code>状态只有在被动断开方才会出现，其过程的长短并不由内核控制，必须等待上层应用程序主动调用<code class="highlighter-rouge">close()</code>系统调用，才会从此状态变迁为<code class="highlighter-rouge">LAST_ACK</code>状态。所以，由于此阶段需要应用程序的主动参与，该阶段也是最容易出现问题的阶段。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/TCP-Status/CLOSE_WAIT.png" alt="" /></p>

<p>当服务器出现了大量的、长时间的<code class="highlighter-rouge">CLOSE_WAIT</code>状态的连接，就需要判断是否是应用程序存在BUG，导致TCP连接未主动地关闭。或者是锁争抢过于激烈，又或是CPU资源不足导致应用程序没有额外的CPU对连接进行处理。</p>

<h4 id="22-time_wait">2.2 TIME_WAIT</h4>

<p><code class="highlighter-rouge">TIME_WAIT</code>阶段往往会被开发者所误解当做是优化的对象，因为该阶段的超时时间为2倍的MSL，开发人员认为该值过大，通常会将其减少至15S或者更短。但是，<code class="highlighter-rouge">TIME_WAIT</code>阶段的存在主要目的在于实现连接的可靠终止，以及让原有报文段在网络中过期失效，不会发送给新的连接。</p>

<h5 id="221-连接的可靠终止">2.2.1 连接的可靠终止</h5>

<p>在TCP四次挥手的过程中，首次发送FIN报文和最后一次发送ACK报文的都是主动断开方，被动断开方被”夹在中间”。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/TCP-Status/NOT-TIME-WAIT.png" alt="" /></p>

<p>如上图所示，假设没有<code class="highlighter-rouge">TIME_WAIT</code>阶段，并且主动断开方的最后一个ACK在网络中丢失。被动断开方迟迟等不到自己FIN包的ACK，当达到最大超时时间时将重传FIN包(此时无法触发快速重传)。但是，由于此时主动断开方的状态已经是<code class="highlighter-rouge">CLOSED</code>，即当前连接并不存在，则会返回一个RST，而该RST则会被视为错误。</p>

<h5 id="222-确保老的重复的报文在网络中过期失效">2.2.2 确保老的重复的报文在网络中过期失效</h5>

<p>TCP的重传算法可能会导致生成重复的报文，并且根据路由的不同选择，这些重复的报文可能会在连接终止之后到达。</p>

<p>假设主动断开方在发送最后一个ACK包以后立即进入<code class="highlighter-rouge">CLOSED</code>状态，并且在该段又新建了一个与之前一样的连接(IP地址和端口号相同)，那么此连接就是原来连接的化身。在这种情况下，TCP必须确保上一次连接中老的重复报文不会在新的连接中被当成合法数据接收。当有TCP结点处于<code class="highlighter-rouge">TIME_WAIT</code>状态时是无法通过该结点创建新的连接的，这样就阻止了新连接的建立。</p>

<p>当一条连接处于<code class="highlighter-rouge">TIME_WAIT</code>阶段时，其向内核申请的端口号并不会得到释放。如果系统中同时存在大量的处于<code class="highlighter-rouge">TIME_WAIT</code>阶段的连接的话，可能无法再建立新的连接: 端口号资源不够。所以某些并发量较高的应用程序会选择缩短<code class="highlighter-rouge">TIME_WAIT</code>的时间，已获得更高的并发量。</p>

<p>但是，当系统因为<code class="highlighter-rouge">TIME_WAIT</code>而无法建立新的连接时，表示当前节点的资源已经吃紧，最好的办法是增加机器，而不是缩短<code class="highlighter-rouge">TIME_WAIT</code>的时间。</p>

<h3 id="3-使用netstat查看套接字状态">3. 使用netstat查看套接字状态</h3>

<p><code class="highlighter-rouge">netstat</code>可以显示出系统中Internet和UNIX域套接字的状态，当服务器出现网络问题时，可首先用此命令获取基本情况。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span>netstat 
Active Internet connections <span class="o">(</span>w/o servers<span class="o">)</span>
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 localhost:33406         localhost:7890          TIME_WAIT  
tcp        0      0 Zero:56626              183.61.83.4:https       ESTABLISHED
tcp        0      0 localhost:33528         localhost:7890          ESTABLISHED
tcp        0      0 Zero:54438              119.147.134.30:https    TIME_WAIT  
tcp        0      0 Zero:32856              220.181.107.131:https   ESTABLISHED
tcp        0      1 Zero:60558              media-router-fp1.:https LAST_ACK
</code></pre></div></div>

<ul>
  <li>proto: 表示套接字所使用的协议，例如tcp、udp和unix。</li>
  <li>Recv-Q: 表示套接字接收缓冲区中还未被本地应用读取的字节数。对于UDP套接字
来说，该字段不只包含数据，还包含UDP首部及其他元数据所占的字节。</li>
  <li>Send-Q: 表示套接字发送缓冲区中排队等待发送的字节数。</li>
  <li>Local Address: 本地套接字所绑定的地址，格式为IP+端口号。</li>
  <li>Foreign Address: 对端套接字所绑定的地址。</li>
  <li>State: 套接字所处的状态。</li>
</ul>

<p>通常来说我们并不关心UNIX域套接字的相关信息，所以可以使用<code class="highlighter-rouge">--tcp</code>进行过滤，得到的结果仅包含TCP套接字的相关信息。还有一些其他有用的选项:</p>

<table>
  <thead>
    <tr>
      <th>选项</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-a</td>
      <td>显示所有套接字的信息，保证正在监听(LISTEN)的套接字</td>
    </tr>
    <tr>
      <td>-c</td>
      <td>每隔一秒钟刷新显示套接字信息</td>
    </tr>
    <tr>
      <td>-l</td>
      <td>仅显示正在监听的套接字信息</td>
    </tr>
    <tr>
      <td>-p</td>
      <td>显示进程 ID 号以及套接字所归属的程序名称</td>
    </tr>
    <tr>
      <td>–tcp</td>
      <td>显示 Internet域TCP(流)套接字的信息</td>
    </tr>
    <tr>
      <td>–udp</td>
      <td>显示 Internet域UDP(数据报)套接字的信息</td>
    </tr>
    <tr>
      <td>–unix</td>
      <td>显示 UNIX 域套接字的信息</td>
    </tr>
  </tbody>
</table>


	  ]]></description>
	</item>

	<item>
	  <title>InnoDB独特的LRU</title>
	  <link>//InnoDB-LRU</link>
	  <author></author>
	  <pubDate>2020-06-09T18:06:25+00:00</pubDate>
	  <guid>//InnoDB-LRU</guid>
	  <description><![CDATA[
	     <p>由于硬盘和内存的造价差异，一台主机实例的硬盘容量通常会远超于内存容量。对于数据库等应用而言，为了保证更快的查询效率，通常会将使用过的数据放在内存中进行加速读取。LRU算法经常用于数据的置换，但InnoDB的LRU却更加独特。</p>

<!---more--->

<h3 id="1-总览">1. 总览</h3>

<p>InnoDB存储引擎是基于硬盘存储的，并且以页(page)的方式对数据记录进行管理。由于硬盘和CPU之间数据处理速度存在巨大差异，所以必须要使用内存来弥补两者之间的速度鸿沟。</p>

<p>正如同操作系统在读取硬盘文件时会将其纳入内核缓冲区一样，InnoDB存储引擎也会为硬盘中的数据和索引建立位于用户空间的内存缓冲池。当数据库从硬盘读取数据时，首先将其放置于位于内存的缓冲池中，下一次读取相同的数据时，首先判断是否位于缓冲池中。若在，则直接返回，若不在，再从硬盘中进行读取。</p>

<p>当修改数据页时，首先修改位于缓冲池中的数据页，InnoDB会寻找合适的时机将此修改持久化至硬盘中，该合适的时机通常由Checkpoint技术决定。</p>

<p>在Linux操作系统中，位于内核的内核缓冲区就是为了提高系统的I/O效率而产生的，那么为什么InnoDB还要建立自己的缓冲区? 内核缓冲区的终端为硬盘，需要处理诸如页对齐、数据边界等和硬盘硬件相关的事宜，而InnoDB缓冲区则主要服务于应用，并不关心硬件细节，并且可由应用程序控制。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/InnoDB-Buffer/InnoDB-Buffer-Pool.png" alt="" /></p>

<p>如上图所示，InnoDB缓冲池主要由数据页和索引页构成，两者占据了缓冲区的绝大部分空间。除此之外，undo页、插入缓冲以及自适应哈希索引等内容也位于缓冲池中。</p>

<h3 id="2-数据页与索引页的lru">2. 数据页与索引页的LRU</h3>

<p>数据页和索引页的目的在于缓存一部分的表数据和索引数据，其数据总量通常会超过缓冲池大小，所以缓冲池中应只缓冲那些经常使用的热点数据。InnoDB内存管理使用的是最近最少使用(Least Recently Used, LRU)算法。来淘汰最久未使用的数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/InnoDB-Buffer/normal-LRU.png" alt="" /></p>

<p>在一般的LRU算法中，当链表中的某一个数据被读取时，将会将其放置于队首。当新增数据且链表已达最大数量时，将链表尾部的数据移除，并将新增的数据置于链表首部。</p>

<p>但是，InnoDB并没有采用传统的LRU算法，而是对其进行了一些更能够适应自身行为的改进: 最近访问到的数据并不直接放到LRU列表的首部，而是放到LRU列表的midpoiont位置。在默认配置下，midpoint位于LRU列表的5/8处。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/InnoDB-Buffer/midpoint.png" alt="" /></p>

<p>如上图所示，在midpoint之前的列表称之为new列表，或者使用Java中的GC术语: 新生代，在midpoint之后的列表称之为old列表，或者说，老年代。</p>

<p>当new列表中的数据被访问时，直接将其放置于LRU列表的首部。当出现新的页面进入LRU时，将其放置于midpoint位置，<strong>此时该数据页将会位于old列表</strong>。</p>

<p>当old列表中的数据被访问时，需要进行判断。如果当前页在old列表中存在时间超过了1秒，则将其移到列表首部。若存在时间小于1秒，则位置保持不变。该判断时间由<code class="highlighter-rouge">innodb_old_blocks_time</code>决定，默认为1000毫秒，即1秒。</p>

<p>另外一点需要注意的是，InnoDB管理数据的最小单位是页(page)，而不是数据库中的某一行。即如果两条记录处于同一页，在两次间隔时间超过<code class="highlighter-rouge">innodb_old_blocks_time</code>的不同行记录的访问也会将该页置于LRU的首部。</p>

<p>InnoDB如此设计的原因在于若使用朴素的LRU算法实现的，某些索引或者表扫描操作可能会将所有的索引页和数据页置换出去，而这些数据通常只是一次性使用的，热点数据被刷出之后，会严重的影响MySQL的性能。当采用midpoint实现后，至少能够保证5/8的数据都是热点数据，即使出现了大范围的表扫描和索引扫描。</p>

<p>让我们来具体分析下对大表进行顺序扫描的过程:</p>

<ol>
  <li>当扫描开始时，InnoDB会一次性地取出16KB的一页数据，将其置于LRU 5/8的位置。</li>
  <li>由于是顺序扫描，那么同一页将会被访问多次，但是访问的间隔一定不会超过默认的<code class="highlighter-rouge">innodb_old_blocks_time</code>，即1秒。所以该页并不会被置于LRU列表的首部，也就不会将真正的热点数据置换而出。</li>
  <li>后续的数据扫描将会在下一页进行，重复上述过程。</li>
</ol>

<p>通过执行<code class="highlighter-rouge">show engine innodb status\G;</code>可以查看InnoDB缓冲池的各种指标，包括当前缓冲池的大小。此外还有一个非常重要的性能指标: 内存命中率。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; show engine innodb status<span class="se">\G</span><span class="p">;</span>
Buffer pool hit rate 976 / 1000, young-making rate 0 / 1000 not 0 / 1000
</code></pre></div></div>

<p>其中Buffer pool hit rate即为缓冲池内存命中率，在一个线上服务中，如果要保证响应时间的话，命中率应不低于95%。 如果某台MySQL实例的hit rate低于此值的话，需要查看设置的缓冲池总大小，以及是否进行了频繁的大范围数据扫描导致LRU列表被污染。</p>

<p>除了增加缓冲池的大小来提高效率以外，当遇到持续的热点问题时，即预估将来的热点数据不止63%，也可以调整midpoint的值来减少热点数据被刷出的概率:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># innodb_old_blocks_pct默认值为37%, 即5/8</span>
mysql&gt; <span class="nb">set </span>global innodb_old_blocks_pct <span class="o">=</span> 20<span class="p">;</span>
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL主从复制</title>
	  <link>//MySQL-Replication</link>
	  <author></author>
	  <pubDate>2020-06-04T07:06:25+00:00</pubDate>
	  <guid>//MySQL-Replication</guid>
	  <description><![CDATA[
	     <p>MySQL的异步复制算的上是一种典型的单领导者复制模式，就复制本身而已并无特殊之处。但是复制的细节，例如binlog的格式选取，从节点如何在保证数据准确的情况下进行并行复制，MySQL的实现方案总是能令人眼前一亮。</p>

<!---more--->

<h3 id="1-binlog">1. binlog</h3>

<p>在经典的复制模型下，主节点和从节点的数据复制都是通过日志的传输进行的。例如Redis主从复制，复制的是<code class="highlighter-rouge">appendonly.aof</code>文件中的逻辑操作记录。又如Raft一致性算法，复制的是作为”日志项”的数据记录，<code class="highlighter-rouge">LogEntry</code>。而在MySQL中，则是使用binlog作为主节点和从节点的数据复制依据。</p>

<p>实际上，如果观察大多数数据库应用的话，会发现它们都会有逻辑日志这一概念，其中记录了对数据的逻辑增删改。一方面用于数据库在宕机时的数据恢复(Redis、MySQL)，另一方面则用于主从复制之中。</p>

<h4 id="11-binlog记录了哪些内容">1.1 binlog记录了哪些内容?</h4>

<p>有非常多的方式来查看binlog中的逻辑日志，一种是在MySQL-Client中查看，另一种则是直接查看位于硬盘中的binlog文件。前者其实也是读取位于硬盘中的binlog文件，只不过会对文件内容进行解析，并增加binlog内容的可读性。而后者则能够获取到更多的信息。</p>

<ul>
  <li>MySQL-Client</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">binary</span> <span class="n">logs</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">binlog</span> <span class="n">events</span> <span class="k">in</span> <span class="s1">'mysql-bin.000193'</span><span class="p">;</span>
</code></pre></div></div>

<p>所得到的结果如下所示:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/show-events.png" alt="" /></p>

<p>其中<code class="highlighter-rouge">Pos</code>表示该逻辑日志的起始位置，<code class="highlighter-rouge">End_log_pos</code>表示该逻辑日志的结束位置。<code class="highlighter-rouge">Event_type</code>表示事件名称，<code class="highlighter-rouge">Server_id</code>则是由用户配置的当前MySQL实例的集群ID，<code class="highlighter-rouge">Info</code>中记录了较为简短的逻辑事件。在起始位置为219的地方，实际上执行了一条<code class="highlighter-rouge">insert</code>语句，但是<code class="highlighter-rouge">Info</code>列中并没有给出详细信息。</p>

<ul>
  <li>mysqlbinlog</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span>mysqlbinlog <span class="nt">-vv</span> mysql-bin.000193
</code></pre></div></div>

<p>得到的输出结果如下:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span>
<span class="cm">/*!*/</span><span class="p">;</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">302</span>
<span class="o">#</span> <span class="err">中间省去一些注释内容</span>
<span class="cm">/*!*/</span><span class="p">;</span>

<span class="o">###</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="nv">`Mario`</span><span class="p">.</span><span class="nv">`hugo`</span>
<span class="o">###</span> <span class="k">SET</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">1</span><span class="o">=</span><span class="mi">7</span> <span class="cm">/* INT meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">2</span><span class="o">=</span><span class="s1">'2020-06-02 14:32:02'</span> <span class="cm">/* DATETIME(0) meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">3</span><span class="o">=</span><span class="s1">'2020-06-02 14:54:07'</span> <span class="cm">/* DATETIME(0) meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">4</span><span class="o">=</span><span class="s1">'nami'</span> <span class="cm">/* VARSTRING(256) meta=256 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">5</span><span class="o">=</span><span class="s1">'16399553366'</span> <span class="cm">/* VARSTRING(44) meta=44 nullable=0 is_null=0 */</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">428</span>
<span class="o">#</span><span class="mi">200602</span> <span class="mi">14</span><span class="p">:</span><span class="mi">54</span><span class="p">:</span><span class="mi">07</span> <span class="n">server</span> <span class="n">id</span> <span class="mi">1</span>  <span class="n">end_log_pos</span> <span class="mi">459</span> <span class="n">CRC32</span> <span class="mi">0</span><span class="n">x27a642a3</span> 	<span class="n">Xid</span> <span class="o">=</span> <span class="mi">146</span>
<span class="k">COMMIT</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">459</span>
</code></pre></div></div>

<p>其输出内容要比<code class="highlighter-rouge">show binlog events</code>更加完整，除了事务的起始位置和结束位置以外，还包括事务的执行时间，以及完整的数据记录、相关字段的注释。所以，当需要查看binlog的详细内容时，尽量使用<code class="highlighter-rouge">mysqlbinlog</code>命令行工具。</p>

<h4 id="12-binlog日志格式">1.2 binlog日志格式</h4>

<p>MySQL一共提供了3种binlog日志格式，分别是<code class="highlighter-rouge">STATEMENT</code>，<code class="highlighter-rouge">ROW</code>以及<code class="highlighter-rouge">MIXED</code>。</p>

<ul>
  <li>查看当前binlog_format格式</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="nv">"binlog_format"</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>在线修改binlog_format格式</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="k">global</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="k">STATEMENT</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="k">global</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="k">ROW</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="k">global</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="n">MIXED</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">STATEMENT</code>日志格式仅记录用户所执行的SQL语句，用户执行什么，binlog就记录什么，属于最节省硬盘空间的一种日志格式。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/STATEMENT.png" alt="" /></p>

<p>但是，无论是出于数据恢复的考虑，还是出于主从复制的目的，都不应该将binlog格式设置为<code class="highlighter-rouge">STATEMENT</code>。其原因在于<code class="highlighter-rouge">STATEMENT</code>格式的日志依赖于执行SQL时的上下文，例如日期函数，<code class="highlighter-rouge">rand</code>函数，不同的执行环境下得到的结果可能并不相同，从而导致主从的数据不一致。而对于数据恢复而言，当然是数据越详细越完整更好。</p>

<p><code class="highlighter-rouge">ROW</code>日志格式将记录完整的数据变更记录，每一条<code class="highlighter-rouge">insert</code>语句都会记录每个字段的插入值，对于<code class="highlighter-rouge">update</code>语句，则会记录数据更新前和更新后的完整数据(<code class="highlighter-rouge">binlog_row_image</code>值为<code class="highlighter-rouge">FULL</code>)。其缺点就是占用硬盘空间较多，假设一条<code class="highlighter-rouge">update</code>语句更新了10万条数据，那么在<code class="highlighter-rouge">ROW</code>格式的binlog中则同样会记录10万条数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/ROW.png" alt="" /></p>

<p><code class="highlighter-rouge">MIXED</code>日志格式结合了<code class="highlighter-rouge">STATEMENT</code>和<code class="highlighter-rouge">ROW</code>日志格式，当MySQL认为当前SQL语句不会引起歧义，即不会导致主从不一致时，将使用<code class="highlighter-rouge">STATEMENT</code>格式记录，反之使用<code class="highlighter-rouge">ROW</code>格式进行记录。节省了一部分的硬盘使用空间，同时又能够保证数据在主从之间的一致性。</p>

<p>在实际应用中，应将binlog日志格式最低设置为<code class="highlighter-rouge">MIXED</code>，如果磁盘空间确实比较紧张的话。否则，就应该将binlog日志格式设置为<code class="highlighter-rouge">ROW</code>，该格式对于数据的误删操作恢复有非常大的帮助。</p>

<h4 id="13-binlog_row_image">1.3 binlog_row_image</h4>

<p>当<code class="highlighter-rouge">binlog_format</code>的值为<code class="highlighter-rouge">ROW</code>时，还有一个控制binlog日志记录的参数: <code class="highlighter-rouge">binlog_row_image</code>。该参数同样有3个可选项: <code class="highlighter-rouge">FULL</code>，<code class="highlighter-rouge">MINIMAL</code>以及<code class="highlighter-rouge">NOBLOB</code>。该参数控制了<code class="highlighter-rouge">ROW</code>格式的binlog日志在写入数据时是否写入完整数据。</p>

<p><code class="highlighter-rouge">FULL</code>将会记录数据修改前后的完整字段，包括未被修改的字段:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/FULL.png" alt="" /></p>

<p><code class="highlighter-rouge">MINIMAL</code>则采用最小记录原则，仅记录修改行的关键定位信息(例如主键或者唯一键)，以及最终被修改的字段的修改值，而不会记录那些没有被修改的字段:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/MINIMAL.png" alt="" /></p>

<p><code class="highlighter-rouge">NOBLOB</code>和<code class="highlighter-rouge">FULL</code>非常类似，会记录完整的字段修改前后数据，只不过不会记录未被修改的、且字段类型为BLOG或TEXT的数据，实际应用较少。</p>

<p>在主从复制中，如果主库网络带宽或者从库网络带宽无法立即升级，并且同步的日志量较大时，可临时的将<code class="highlighter-rouge">binlog_row_image</code>参数由<code class="highlighter-rouge">FULL</code>更改为<code class="highlighter-rouge">MINIMAL</code>，减少一部分的网络带宽使用。</p>

<h3 id="2-异步复制模型">2. 异步复制模型</h3>

<p>对于异步复制模型而言，从原理上来说，只需要将逻辑日志不断地发送给所有的从节点，让从节点重新执行逻辑日志的内容即可，也不需要关心从节点是否接收成功并且执行成功。</p>

<p>MySQL的异步复制模型也确实如此。主节点开启<code class="highlighter-rouge">binlog dump</code>线程，用于锁定地读取binlog内容，并通过TCP长连接发送给从节点。而对于从节点来说，将会开启一个<code class="highlighter-rouge">slave I/O</code>线程，用于和主节点建立TCP连接，以及接收主节点发送的binlog逻辑日志，并将接收到的数据写入自身的中继日志(relay log)文件中。另外的一个线程，即<code class="highlighter-rouge">slave SQL</code>线程，将不断地读取中继日志数据，并执行其中的逻辑SQL语句。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/master-slave.png" alt="" /></p>

<h4 id="21-为什么需要relay-log中继日志">2.1 为什么需要relay log(中继日志)?</h4>

<p>从节点在接收到主节点发送的binlog日志之后，并没有直接执行，而是存储在relay log中，由另外一个线程读取该文件的数据并执行。那么MySQL为什么要使用这种会降低复制效率的设计?</p>

<p>个人认为原因有两点，一方面relay log可以作为日志同步的缓冲区。主节点发送日志的速度可能要大于从节点执行日志的速度，此时就需要一个缓冲区来弥补两者之间的速度差，避免主节点发送的binlog被阻塞在socket缓冲区中。</p>

<p>另外一个作用就是利于故障时的问题排查。relay log的结构与binlog非常相似，通过在从节点持久化一份主节点发送的日志，那么在出现故障时，可查看该文件的内容来大致地判断是主节点出了问题，还是从节点出了问题。</p>

<p>这种数据冗余的设计在业务系统设计中其实也非常实用，相较于直接执行外部发送的数据，采用”生产者-消费者”模型将会有更好的健壮性: 在微服务中，”数据同步”是一件极易出错，且令人无比蛋疼的苦差事。当保留源数据，并在源数据的基础之上开展业务的话，能避免许多麻烦。</p>

<h3 id="3-并行复制">3. 并行复制</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/master-slave-load.png" alt="" /></p>

<p>在主节点中，由于存在各种各样的<code class="highlighter-rouge">Lock</code>， 例如共享锁，排它锁，意向锁等等，使得事务可以并发执行，而无需担心数据不一致的问题。但是，在从节点如果想要并发执行binlog中的内容，并不是一件容易的事情，其原因在于事务和事务之间并不是完全独立存在的，而是存在依赖性。</p>

<p>如上图所示，从节点Execute中继日志的内容将会成为主从复制最后的延迟点，同时，也可能是最大的延迟点: 因为<code class="highlighter-rouge">binlog dump</code>线程以及<code class="highlighter-rouge">slave I/O</code>线程均是对文件的顺序读取和写入，而<code class="highlighter-rouge">slave SQL</code>线程在执行语句时，则没有那么简单。</p>

<h4 id="31-并行复制所面对的问题">3.1 并行复制所面对的问题</h4>

<p>假设现在有3个事务并发执行，且修改的是同一行数据，并且事务提交的顺序为<code class="highlighter-rouge">TRX-1</code>，<code class="highlighter-rouge">TRX-2</code>，<code class="highlighter-rouge">TRX-3</code>，则数据的新旧程度为: <code class="highlighter-rouge">TRX-3</code> &gt; <code class="highlighter-rouge">TRX-2</code> &gt; <code class="highlighter-rouge">TRX-1</code>。</p>

<p>当从节点SQL执行线程读取中继日志时，并不知道这3个事务是修改的同一条数据，如果只是简单地将这3个事务分配给3个Worker执行的话，完全有可能发生旧数据覆盖新数据的情况，即<code class="highlighter-rouge">TRX-1</code>最后被执行，<code class="highlighter-rouge">TRX-3</code>的最新更新将会丢失，导致从节点和主节点的数据不一致。</p>

<h4 id="32-基于table的并行复制">3.2 基于table的并行复制</h4>

<p>如果两个事务是对不同的表进行操作，那么这两个事务即可并行执行。处理方式也非常简单，对表名称进行哈希，并对结果进行worker数量的取模，将该事务分发至对应的worker即可。</p>

<p>但是，如果事务同时对多张表进行了修改的话，上述模型就会出现问题: 该事务应该分配给哪个worker? 所以，还需要记录每个线程中有哪些事务正在执行或者排队，操作的是哪些表。对于线程私有变量，可以使用<code class="highlighter-rouge">ThreadLocal</code>来实现，外部也可方便的获取线程中的私有内容。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/parallel-with-table.png" alt="" /></p>

<p>如上图所示，Assigner线程读取relay log中的内容，并对数据进行解析，决定将该事物分配给哪个worker执行。worker线程则是事务的执行线程，并且使用哈希表记录下当前线程队列中有多少个事务正在修改哪些表。其中key为表名称，value为队列中有多少事务修改该表。</p>

<p>当Assigner读取到只修改table-1的事务时，遍历所有worker的哈希表，判断是否有其它worker正在执行关于table-1的事务，发现只有worker-1存在，那么将会直接将其分发至worker-1线程，并将事务追加至该worker的队列中，以此保证对同一个表的操作串行执行。</p>

<p>当Assigner读取到同时修改table-1和table-3的事务时，首先根据解析规则获取到这两个表应该被分配的worker，然后取出两个队列中正在对table-1和table-3所修改的事务数量。发现worker-1存在对table-1的事务，而worker-2对table-3的修改事务数量为0，那么Assigner将会将该事务分配给worker-1。</p>

<p>当Assigner读取到同时修改table-1和table-4的事务时，发现worker-1和worker-2都存在对两个表的修改，那么Assigner将会等待，等待worker-1对table-1的修改事务数量为0，或者是worker-2对table-4的修改事务数量为0。</p>

<p>在大多数情况下基于表的并行复制策略能够快速地执行，但是，如果遇到热点表的话，该热点表仍然是串行复制，同样会出现效率问题。</p>

<h4 id="33-基于行的并行复制">3.3 基于行的并行复制</h4>

<p>既然基于表的并行复制会有热点表的问题，那么基于行的并行复制总没有热点表的问题了吧? 并且同一条数据的修改频率并不会特别高。基于行的并行复制虽然能够有着更快的执行效率，但是同样地带来的更多的内存开销和CPU计算开销。</p>

<p>在基于行的并行复制中，至少需要记录下所有正在被修改或者是已经在队列中的行数据，那么显而易见的，worker线程中的哈希表将会有存在大量的数据。所以综合来看，基于行的并行复制并不是一个好的选择，甚至可以说是一个比较差的选择。</p>

<p>但是，MySQL针对基于行的复制进行了优化，将判断两个事务是否存在”冲突”(即是否更新了同一行)由从节点转移至主节点。MySQL会记录下更新的每一行的哈希值，组成一个集合。为了能够唯一标识同一行，哈希值通常由”库名+表名+唯一索引名+唯一索引值”计算得到，而唯一索引通常是主键。</p>

<p>如果两个事务没有同时更新同一条数据，那么两个事务的集合就不存在交集，它们是可以并行执行的。并且该哈希值集合是在主节点写入binlog时即计算好的，不需要从节点再次解析binlog event，节省了从节点的一部分计算资源。</p>

<h4 id="34-基于group-commit的并行复制">3.4 基于Group Commit的并行复制</h4>

<p>InnoDB存储引擎是通过redo log + binlog来实现事务的原子性以及持久性的，为了保证数据的一致性，两个日志的数据写入通过”两阶段提交”完成，并且使用组提交(Group Commit)来提高事务的并发效率。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/LSN-Commit.png" alt="" /></p>

<p>当未使用组提交时，当<code class="highlighter-rouge">trx:1</code>提交，仅将该事务的数据持久化至redo log以及binlog中，当有两万个事务并发执行时，将需要执行四万次<code class="highlighter-rouge">fsync</code>系统调用。</p>

<p>当使用组提交时，当<code class="highlighter-rouge">trx:1</code>提交，redo log buffer中可能存在多个事务的物理页修改，那么此时<code class="highlighter-rouge">trx:1</code>将会作为Leader，将当前最大的LSN redo log持久化至磁盘，以减少<code class="highlighter-rouge">fsync</code>的系统调用次数。并且，为了尽可能多地在一次写入中写入更多的数据，InnoDB还会推迟redo log的<code class="highlighter-rouge">fsync</code>过程。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/delay-fsync.png" alt="" /></p>

<p>更具体的上下文请参考文章: <a href="https://smartkeyerror.com/InnoDB-AD">InnoDB如何保证事务的原子性与持久性</a></p>

<p><strong>假设多个事务能够同时进入prepare阶段，那么这些事务一定能够并行执行。</strong> 接下来分析一下这句话的正确性:</p>

<ol>
  <li>事务A和事务B并发执行，准备修改同一条数据。由于X Lock的存在，当一个事务修改数据时，另一个事务将会被阻塞，等待前一个事务<strong>提交</strong>。</li>
  <li>假设事务A首先获得了X Lock，成功修改了数据并提交了事务。而此时，事务B仍然处于运行中，在获取到数据的X Lock之后才开始执行自己的修改。</li>
</ol>

<p>所以，<strong>只要是能够同时进入prepare的阶段，事务一定是经过了锁冲突的检验，一定能够在从库并行执行</strong>。</p>

<p>如此一来，当redo log在使用最大的LSN持久化至磁盘时，使用一个<code class="highlighter-rouge">commit_id</code>对该事务进行标记。下次的redo log持久化将<code class="highlighter-rouge">commit_id</code>自增。从库在并行执行binlog event是，只要是相同的<code class="highlighter-rouge">commit_id</code>，就使其并发执行。</p>

<h4 id="35-mysql提供的并行复制配置项">3.5 MySQL提供的并行复制配置项</h4>

<p>MySQL一共提供了三种并行复制策略，由参数<code class="highlighter-rouge">binlog_transaction_dependency_tracking</code>控制(MySQL版本大于5.7.22)。</p>

<ul>
  <li>COMMIT_ORDER: 利用Group Commit机制进行并行执行。</li>
  <li>WRITESET: 基于行的并行执行。</li>
  <li>WRITESET_SESSION: 建立在WRITESET策略之上，只不过多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li>
</ul>

<p>其中COMMIT_ORDER为默认策略，当使用该策略时，可以调整<code class="highlighter-rouge">binlog_group_commit_sync_delay</code>以及<code class="highlighter-rouge">binlog_group_commit_sync_no_delay_count</code>来使得主节点更慢的提交，使从节点更快的执行事务。</p>

<p>当主节点事务执行的并发度较高时，可以选择COMMIT_ORDER策略。当主节点事务执行并发度并不高，并且趋近于单线程或者双线程时，可选择WRITESET策略。</p>

<h3 id="4-主从延迟来源">4. 主从延迟来源</h3>

<h4 id="41-从节点硬件资源不足">4.1 从节点硬件资源不足</h4>

<p>有时候我们会认为从库只负责读请求，而不处理客户端的写请求，所以从库的内存、硬盘以及CPU都可以使用较低配置。但事实上，从库需要处理的数据写入并不会比主库要少，同时还要处理比主库更多的读请求。因此，从库的硬件资源应该至少和主库相同，甚至可以高于从库。</p>

<p>通过<code class="highlighter-rouge">top</code>或者是<code class="highlighter-rouge">htop</code>可以很清晰的得到从节点的内存以及CPU使用率，使用<code class="highlighter-rouge">iostat</code>查看从节点的磁盘I/O活动情况。<code class="highlighter-rouge">iostat</code>有几个非常关键的指标:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span>iostat <span class="nt">-m</span>
Linux 4.15.0-101-generic <span class="o">(</span>Zero<span class="o">)</span>         2020年06月04日  _x86_64_        <span class="o">(</span>8 CPU<span class="o">)</span>

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           4.93    0.01    2.58    0.59    0.00   91.88
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">%iowait</code>表示CPU等待输入输出完成时间的百分比，<code class="highlighter-rouge">%idle</code>表示CPU空闲百分比。如果<code class="highlighter-rouge">%iowait</code>的值较高，说明硬盘存在I/O瓶颈; 如果<code class="highlighter-rouge">%idle</code>持续较低，说明系统的CPU处理能力较弱，此时应处理CPU资源。</p>

<h4 id="42-主节点大事务与从节点长事务">4.2 主节点大事务与从节点长事务</h4>

<p>大事务是指更新了较多数据行的事务，当从节点重放大事务的binlog event时，不管是使用<code class="highlighter-rouge">COMMIT_ORDER</code>还是<code class="highlighter-rouge">WRITESET</code>并行复制策略，后续操作均需要等待该事务的执行，事务执行所需要的执行时间越久，主从延迟就会越高。所以，尽量地将大事务拆分成多个小事务执行。</p>

<p>从节点长事务同样也可能导致主从延迟的产生。例如，当从库开启了一个长事务:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">hugo</span> <span class="k">WHERE</span> <span class="n">username</span> <span class="o">=</span> <span class="nv">"smart"</span><span class="p">;</span>
</code></pre></div></div>

<p>执行完<code class="highlighter-rouge">SELECT</code>语句之后因为种种原因长时间未提交事务，那么此时若主库对该表进行了DDL操作，即使<code class="highlighter-rouge">hugo</code>表只有几行数据，也会长时间的阻塞: 因为此时DDL操作无法获取到<code class="highlighter-rouge">hugo</code>表的意向排它锁(IX)。</p>

<p>如果主表的DDL操作在白天进行，并且恰好存在对该表的某一个长事务的话，即使不是高峰期也会带来非常大的主从延迟。</p>

<h4 id="43-从节点未开启并行复制">4.3 从节点未开启并行复制</h4>

<p>从节点的并行执行worker数量由<code class="highlighter-rouge">slave_parallel_workers</code>参数决定，最大值为1024，通常将其设置为CPU核心数的一半。</p>

	  ]]></description>
	</item>


</channel>
</rss>
