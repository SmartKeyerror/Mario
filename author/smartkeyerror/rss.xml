<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description>Keep coding, Keep curiosity</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Python虚拟机</title>
	  <link>//Python-Virtual-Machine</link>
	  <author></author>
	  <pubDate>2020-08-18T10:50:25+00:00</pubDate>
	  <guid>//Python-Virtual-Machine</guid>
	  <description><![CDATA[
	     <p>我们常说Python一是门解释型语言，只需要敲下<code class="highlighter-rouge">python code.py</code>就可以运行编写的代码，而无需使用类似于<code class="highlighter-rouge">javac</code>或者<code class="highlighter-rouge">gcc</code>进行编译。那么，Python解释器是真的一行一行读取Python源代码而后执行吗? 实际上，Python在执行程序时和Java、C#一样，都是先将源码进行编译生成字节码，然后由虚拟机进行执行，只不过Python解释器把这两步合二为一了而已。</p>

<!---more--->

<h3 id="1-python程序执行过程">1. Python程序执行过程</h3>

<p>事实上，Python程序在执行过程中同样需要编译(Compile)，编译产生的结果称之为字节码，而后由Python虚拟机逐行地执行这些字节码。所以，Python解释器由两部分组成: 编译器和虚拟机。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/process.png" alt="" /></p>

<p>上图展示了Python程序的执行过程，以及C程序的编译、汇编与链接过程，从该图中可以非常明显地看出Python与C程序的执行区别。Python如此设计的原因在于将程序的执行与底层硬件进一步地分离，无需担心程序的编译、汇编以及链接过程，使得Python程序相较于C程序而言更加易于移植。</p>

<p>这里再说一下Python和Java的区别。Java在程序执行时必须使用<code class="highlighter-rouge">javac</code>对源代码进行编译，但是并不直接编译成机器语言，而是和Python一样，编译成字节码，而后由JVM进行执行。从这一点上来看，Python和Java非常类似，只不过Python的编译过程由解释器完成，用户也可以手动的对Python源代码进行编译，生成<code class="highlighter-rouge">.pyc</code>文件，节省那么一丢丢的时间。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-m</span> compileall &lt;dir&gt;
</code></pre></div></div>

<p>通过运行上述命令可对<code class="highlighter-rouge">&lt;dir&gt;</code>目录下所有的Python文件进行编译，编译结果将会存放于该目录下的<code class="highlighter-rouge">__pycache__</code>的<code class="highlighter-rouge">.pyc</code>文件中。</p>

<h3 id="2-编译过程与字节码">2. 编译过程与字节码</h3>

<p>在Python的内建函数中，定义了<code class="highlighter-rouge">compile</code>以及<code class="highlighter-rouge">exec</code>两个方法，前者将源代码编译成为Code Object对象，Code Object对象中即保存着源代码所对应的字节。而<code class="highlighter-rouge">exec</code>方法则是运行Python语句或者是由<code class="highlighter-rouge">compile</code>方法所返回的Code Object。<code class="highlighter-rouge">exec</code>方法可直接运行Python语句，其参数并一定需要是Code Object。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">snippet</span> <span class="o">=</span> <span class="s">"for i in range(3): print(f'Output: {i}')"</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">snippet</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="s">"exec"</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">result</span>
<span class="o">&lt;</span><span class="n">code</span> <span class="nb">object</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span> <span class="n">at</span> <span class="mh">0x7f8e7e6471e0</span><span class="p">,</span> <span class="nb">file</span> <span class="s">""</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">exec</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">2</span>
</code></pre></div></div>

<p>在上述代码中定义了一个非常简单的Python代码片段，其作用就是在标准输出中打印0，1，2这三个数而已。通过<code class="highlighter-rouge">compile</code>方法对该片段进行编译，得到Code Object对象，并将该对象交由<code class="highlighter-rouge">exec</code>函数执行。下面来具体看下返回的Code Object中到底包含了什么。</p>

<p>在源码<code class="highlighter-rouge">cpython/Include/code.h</code>中定义了<code class="highlighter-rouge">PyCodeObject</code>结构体，即Code Object对象:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Bytecode object */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>               <span class="cm">/* Python定长对象头 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_code</span><span class="p">;</span>          <span class="cm">/* 指令操作码，即字节码 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_consts</span><span class="p">;</span>        <span class="cm">/* 常量列表 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_names</span><span class="p">;</span>         <span class="cm">/* 名称列表(不一定是变量，也可能是函数名称、类名称等) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_filename</span><span class="p">;</span>      <span class="cm">/* 源码文件名称 */</span>
    
    <span class="p">...</span>                         <span class="cm">/* 省略若干字段 */</span>
<span class="p">}</span> <span class="n">PyCodeObject</span><span class="p">;</span>
</code></pre></div></div>

<p>字段<code class="highlighter-rouge">co_code</code>即为Python编译后字节码，其它字段在此处可暂时忽略。字节码的格式为人类不可阅读格式，其形式通常是这样的:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">co_code</span>
<span class="n">b</span><span class="s">'x</span><span class="se">\x1e</span><span class="s">e</span><span class="se">\x00</span><span class="s">d</span><span class="se">\x00\x83\x01</span><span class="s">D</span><span class="se">\x00</span><span class="s">]</span><span class="se">\x12</span><span class="s">Z</span><span class="se">\x01</span><span class="s">e</span><span class="se">\x02</span><span class="s">d</span><span class="se">\x01</span><span class="s">e</span><span class="se">\x01\x9b\x00\x9d\x02\x83\x01\x01\x00</span><span class="s">q</span><span class="se">\n</span><span class="s">W</span><span class="se">\x00</span><span class="s">d</span><span class="se">\x02</span><span class="s">S</span><span class="se">\x00</span><span class="s">'</span>
</code></pre></div></div>

<p>这个时候我们需要一个”反汇编器”来将字节码转换成人类可阅读的格式，”反汇编器”打引号的原因是在Python中并不能称为真正的反汇编器。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">dis</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">co_code</span><span class="p">)</span>
          <span class="mi">0</span> <span class="n">SETUP_LOOP</span>              <span class="mi">30</span> <span class="p">(</span><span class="n">to</span> <span class="mi">32</span><span class="p">)</span>
          <span class="mi">2</span> <span class="n">LOAD_NAME</span>                <span class="mi">0</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
          <span class="mi">4</span> <span class="n">LOAD_CONST</span>               <span class="mi">0</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
          <span class="mi">6</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">1</span>
          <span class="mi">8</span> <span class="n">GET_ITER</span>
    <span class="o">&gt;&gt;</span>   <span class="mi">10</span> <span class="n">FOR_ITER</span>                <span class="mi">18</span> <span class="p">(</span><span class="n">to</span> <span class="mi">30</span><span class="p">)</span>
         <span class="mi">12</span> <span class="n">STORE_NAME</span>               <span class="mi">1</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
         <span class="mi">14</span> <span class="n">LOAD_NAME</span>                <span class="mi">2</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
         <span class="mi">16</span> <span class="n">LOAD_CONST</span>               <span class="mi">1</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
         <span class="mi">18</span> <span class="n">LOAD_NAME</span>                <span class="mi">1</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
         <span class="mi">20</span> <span class="n">FORMAT_VALUE</span>             <span class="mi">0</span>
         <span class="mi">22</span> <span class="n">BUILD_STRING</span>             <span class="mi">2</span>
         <span class="mi">24</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">1</span>
         <span class="mi">26</span> <span class="n">POP_TOP</span>
         <span class="mi">28</span> <span class="n">JUMP_ABSOLUTE</span>           <span class="mi">10</span>
    <span class="o">&gt;&gt;</span>   <span class="mi">30</span> <span class="n">POP_BLOCK</span>
    <span class="o">&gt;&gt;</span>   <span class="mi">32</span> <span class="n">LOAD_CONST</span>               <span class="mi">2</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
         <span class="mi">34</span> <span class="n">RETURN_VALUE</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">dis</code>方法将返回字节码的助记符(mnemonics)，和汇编语言非常类似，从这些助记符的名称上我们就可以大概猜出解释器将要执行的动作，例如<code class="highlighter-rouge">LOAD_NAME</code>加载名称，<code class="highlighter-rouge">LOAD_CONST</code>加载常量。所以，我们完全可以将这些助记符看作是汇编指令，而指令的操作数则在助记符后面描述。例如<code class="highlighter-rouge">LOAD_NAME</code>操作，其操作数的下标为0，而在源代码中使用过的名称保存在<code class="highlighter-rouge">co_names</code>字段中，所以<code class="highlighter-rouge">LOAD_NAME  0</code>即表示加载<code class="highlighter-rouge">result.co_names[0]</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">co_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="s">'range'</span>
</code></pre></div></div>

<p>又比如<code class="highlighter-rouge">LOAD_CONST</code>操作，其操作数的下标也为0，只不过这次操作数不再保存在<code class="highlighter-rouge">co_names</code>，而是<code class="highlighter-rouge">co_consts</code>中，所以<code class="highlighter-rouge">LOAD_CONST  0</code>则表示加载<code class="highlighter-rouge">result.co_consts[0]</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">co_consts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">3</span>
</code></pre></div></div>

<p>由于Code Object对象保存了常量、变量、名称等一系列的上下文内容，所以可以直接对该对象进行反汇编操作:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
  <span class="mi">1</span>           <span class="mi">0</span> <span class="n">SETUP_LOOP</span>              <span class="mi">30</span> <span class="p">(</span><span class="n">to</span> <span class="mi">32</span><span class="p">)</span>
              <span class="mi">2</span> <span class="n">LOAD_NAME</span>                <span class="mi">0</span> <span class="p">(</span><span class="nb">range</span><span class="p">)</span>
              <span class="mi">4</span> <span class="n">LOAD_CONST</span>               <span class="mi">0</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
              <span class="o">...</span>
</code></pre></div></div>

<p>现在，我们可以对Python字节码做一下小结了。Python在编译某段源码时，并不会直接返回字节码，而是返回一个Code Object对象，字节码则保存在该对象的<code class="highlighter-rouge">co_code</code>字段中。由于字节码是一个二进制字节序列，无法直接进行阅读，所以需要通过”反汇编器”(<code class="highlighter-rouge">dis</code>模块)将字节码转换成人类可读的助记符。助记符的形式和汇编语言非常类似，均由操作指令+操作数所组成。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/Compile.png" alt="" /></p>

<h3 id="3-命名空间与作用域">3. 命名空间与作用域</h3>

<p>Python的命名空间与作用域经常被开发者所忽略，在未深入了解Python虚拟机之前，我个人也认为这些东西并不重要。但是，命名空间和变量作用域将会是Python虚拟机在执行过程中一个非常重要的一环。</p>

<p>命名空间实际上是名称到对象的一种映射，本质上就是一个键-值对，所以大部分的命名空间由<code class="highlighter-rouge">dict</code>实现。命名空间可以分为3类: 内置命名空间，全局命名空间与局部命名空间，在作用域存在嵌套的特殊情况下，可能还会有闭包命名空间。</p>

<h4 id="31-内置命名空间build-in">3.1 内置命名空间(Build-in)</h4>
<p>Python语言内置的名称，例如内置函数名(<code class="highlighter-rouge">len</code>, <code class="highlighter-rouge">dis</code>)，内置异常(<code class="highlighter-rouge">Exception</code>)等。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">builtins</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">builtins</span><span class="o">.</span><span class="n">__dict__</span>
</code></pre></div></div>

<h4 id="32-全局命名空间global">3.2 全局命名空间(Global)</h4>

<p>全局命名空间以模块进行划分，每一个模块中都包含了<code class="highlighter-rouge">dict</code>对象，其中保存了模块中的变量名、类名、函数名等等。</p>

<h4 id="33-局部命名空间local">3.3 局部命名空间(Local)</h4>

<p>局部命名空间可以简单的认为就是函数的命名空间，例如函数参数，在函数中定义的局部变量。</p>

<p>在局部命名空间中，有一个非常特殊的情况，就是类定义:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Reader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">4096</span>
    
    <span class="k">class</span> <span class="nc">Inner</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">)</span>
</code></pre></div></div>

<p>在执行<code class="highlighter-rouge">Reader.Inner()</code>语句时，将会抛出<code class="highlighter-rouge">NameError</code>的异常，表示<code class="highlighter-rouge">BUFFER_SIZE</code>未定义。其原因在于类的嵌套并不等同于函数嵌套</p>

<h4 id="34-闭包命名空间enclosing">3.4 闭包命名空间(Enclosing)</h4>

<p>当出现嵌套函数定义时，或者作用域嵌套时，Python将会把内层作用域所依赖的所有外层命名存储在一个特殊的命名空间中，也就是闭包命名空间。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s">"Execute func: {func.__name__}"</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div>

<p>闭包指函数，而不是类，所以在类的嵌套中，将不会存在闭包命名空间:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Reader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">4096</span>
    
    <span class="k">class</span> <span class="nc">Inner</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">)</span>
</code></pre></div></div>

<p>在执行<code class="highlighter-rouge">Reader.Inner()</code>语句时，将会抛出<code class="highlighter-rouge">NameError</code>的异常，表示<code class="highlighter-rouge">BUFFER_SIZE</code>未定义。</p>

<p>当语句需要查找变量<code class="highlighter-rouge">X</code>时，将会按照 Local -&gt; Enclosing -&gt; Global -&gt; Builtin 的顺序进行查找，俗称LEGB规则。</p>

<h3 id="4-python虚拟机的执行">4. Python虚拟机的执行</h3>

<h4 id="41-执行上下文栈帧">4.1 执行上下文——栈帧</h4>

<p>在 x86-64 CPU 中包含了16个64位的通用目的寄存器，这些寄存器用于存储数据或者是指针。在这16个通用目的寄存器中，有两个较为特殊的寄存器: %rsp 与 %rbp。%rsp 为栈指针寄存器，表示运行时栈的结束位置，可以简单地理解为栈顶。%rbp 为栈帧指针，用于标识当前栈帧的起始位置。</p>

<p>在x86体系结构中，函数调用是通过栈和栈帧实现的。当一个函数被调用时，首先做的事情就是将调用者栈帧指针入栈，以保留调用关系。其次将为调用的函数创建栈帧，栈帧中包含了函数的参数、创建的局部变量等信息。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/x86-Stack.png" alt="" /></p>

<p>回到Python虚拟机中，虚拟机在进行函数调用时，运行方式和x86没什么区别，都是由栈和栈帧所实现的。而栈帧则是由<code class="highlighter-rouge">PyFrameObject</code>表示，于源码<code class="highlighter-rouge">cpython/Include/frameobject.h</code>中定义。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_frame</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>           <span class="cm">/* Python固定长度对象头 */</span>
    <span class="k">struct</span> <span class="n">_frame</span> <span class="o">*</span><span class="n">f_back</span><span class="p">;</span>      <span class="cm">/* 指向上一个栈帧的指针 */</span>
    <span class="n">PyCodeObject</span> <span class="o">*</span><span class="n">f_code</span><span class="p">;</span>       <span class="cm">/* Code Object代码对象，其中包含了字节码 */</span>
    
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_builtins</span><span class="p">;</span>       <span class="cm">/* 内建命名空间字典(PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_globals</span><span class="p">;</span>        <span class="cm">/* 全局命名空间字典(PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_locals</span><span class="p">;</span>         <span class="cm">/* 局部命名空间表(通常是数组) */</span>

    <span class="kt">int</span> <span class="n">f_lasti</span><span class="p">;</span>                <span class="cm">/* 上一条指令编号 */</span>
    
    <span class="p">...</span>
<span class="p">}</span> <span class="n">PyFrameObject</span><span class="p">;</span>
</code></pre></div></div>

<p>可以看到，在一个栈帧中包含了Code Object代码对象，三个命名空间表，上一个栈帧指针等信息。可以说，<code class="highlighter-rouge">PyFrameObject</code>对象包含了Python虚拟机执行所需的全部上下文。结合前面提到的字节码和命名空间，我们可以用一张简图来描述。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/FrameObject.png" alt="" /></p>

<h4 id="42-指令的执行">4.2 指令的执行</h4>

<p>指令执行的源码均位于<code class="highlighter-rouge">cpython/Python/ceval.c</code>中，入口函数有两个，一个是<code class="highlighter-rouge">PyEval_EvalCode</code>，另一个则是<code class="highlighter-rouge">PyEval_EvalCodeEx</code>，最终的实际调用函数为<code class="highlighter-rouge">_PyEval_EvalCodeWithName</code>，所以我们只需要关注该函数即可。</p>

<p><code class="highlighter-rouge">_PyEval_EvalCodeWithName</code>函数的主要作用为进行函数调用的例常检查，例如校验函数参数的个数、类型，校验关键字参数等。除此之外，该函数将会初始化栈帧对象并将其交给<code class="highlighter-rouge">PyEval_EvalFrame</code>函数进行处理，最终由<code class="highlighter-rouge">_PyEval_EvalFrameDefault</code>函数真正的运行指令。</p>

<p><code class="highlighter-rouge">_PyEval_EvalFrameDefault</code>函数定义超过了3K行，绝大部分的逻辑其实都是<code class="highlighter-rouge">switch-case</code>: 根据指令类型执行相应的逻辑。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">LOAD_CONST</span><span class="p">):</span> <span class="p">{</span>      <span class="cm">/* 加载常量 */</span>
            <span class="p">...</span>
        <span class="p">}</span>		
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">ROT_TWO</span><span class="p">):</span> <span class="p">{</span>         <span class="cm">/* 交换两个变量 */</span>
            <span class="p">...</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">FORMAT_VALUE</span><span class="p">):{</span>     <span class="cm">/* 格式化字符串 */</span>
            <span class="p">...</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>可以看到<code class="highlighter-rouge">TARGET()</code>调用中的参数其实就是<code class="highlighter-rouge">dis</code>方法返回的助记符，当我们在分析助记符的具体实现逻辑时，可以在该文件中找到对应的C实现方法。</p>

<h4 id="43-gil与字节码的执行">4.3 GIL与字节码的执行</h4>

<p>对于Python中的容器，例如dict，并没有实现像Java中的<code class="highlighter-rouge">ConcurrentHashMap</code>，或者是Golang中的<code class="highlighter-rouge">sync.Map</code>，这是因为Python中的容器(list, dict)本身就是并发安全的，但是在这些容器的源码中并没有发现定义<code class="highlighter-rouge">mutex</code>，也就是说，Python容器的并发安全并不是通过互斥锁实现的。</p>

<p>实际上，Python容器的并发安全是通过GIL实现的，也就是被广大Pythoner口诛笔伐的全局解释器锁。某一个线程想要运行必须要首先获取全局锁，如此一来，在同一时刻只能有一个线程运行，无法充分利用多核的硬件资源。</p>

<p>Python的线程调度非常类似于CPU的时间片实现，只不过并不是以时间为判断标准，而是以执行字节码的数量作为判断标准。当某一个线程执行了足够多的字节码条数时，当前线程将释放全局锁，唤醒其它线程进行执行。</p>

<p><strong>所以，得益于GIL的存在，Python容器在进行诸如扩容、缩容操作时，完全不必担心并发问题，因为一条字节码的执行一定是原子性的。</strong></p>

	  ]]></description>
	</item>

	<item>
	  <title>VXLAN—构建Overlay容器网络</title>
	  <link>//VXLAN</link>
	  <author></author>
	  <pubDate>2020-08-06T09:06:25+00:00</pubDate>
	  <guid>//VXLAN</guid>
	  <description><![CDATA[
	     <p>由于VLAN实现中的VLAN ID仅有12位，只能划分4096个虚拟局域网网段，对于云计算等领域而言，其用户远远不止4096个。并且，VLAN依赖于交换机等物理设备的实现，一旦升级物理设备，集群网络可能需要重新配置。因此，基于上述的限制，VMware、Cisco等大型网络企业推出了VXLAN解决方案。</p>

<!---more--->

<p>VXLAN全称为Virtual eXtensible Local Area Network，可拓展虚拟局域网，不依赖于硬件实现，而是在三层网络(网络层)的基础之上构建出一个虚拟的二层网络(链路层)。也就是说，只要主机间IP地址可达，就可以使用VXLAN的方式构建一个Overlay网络。</p>

<blockquote>
  <p>Overlay: 可以理解为覆盖网络，属于一种虚拟网络的实现，依赖于物理网络，而物理网络又可称之为Underlay。</p>
</blockquote>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/virtual-machine-communicate-problems.png" alt="" /></p>

<p>在实际的介绍VXLAN之前，先来看一个集群中虚拟机通讯的问题。如上图所示，虚拟机-A(<code class="highlighter-rouge">192.19.2.2</code>)想要和虚拟机-C(<code class="highlighter-rouge">192.16.2.6</code>)进行通信，要如何实现?</p>

<p>由于节点<code class="highlighter-rouge">10.168.4.3</code>和<code class="highlighter-rouge">10.168.9.3</code>能够实现通信，那么是否能够将虚拟机间通讯的数据包封装在节点间的通讯包之上，抵达目的地之后再进行解包、分发呢? 就好像特洛伊木马一样。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/virtual-machine-solution.png" alt="" /></p>

<p>如上图所示，虚拟机-A发送给虚拟机-C的数据包，首先经过一个工具进行封包，暂且称之为Tool，封包的结果就是将该数据包放置在节点间通讯数据包的Body中，作为数据发送给节点B。节点B收到该数据包之后，经过某种过滤规则，检查Body，发现这是一个发送给虚拟机-C的数据包，那么将数据包发送给节点C，单向通讯完成。</p>

<p>上述的过程其实就是VXLAN的基本原理组成，本质上就是对虚拟机间通讯数据包的封装和解封，乘着节点间通讯这条大船抵达目的地。</p>

<h3 id="1-vxlan协议原理">1. VXLAN协议原理</h3>

<p>在VXLAN协议中，负责封包、解包的组件称之为VTEP(VXLAN Tunnel Endpoints，VXLAN隧道端点)，可以简单的认为就是运行在各个节点上的一个进程。</p>

<p>每一个VTEP都有一个唯一的标志符，称之为VNI(VXLAN Network Identifier，VXLAN网络标识符)，其实就是拓展的VLAN ID。VNI被设计成24位，可以容纳16777216个不同的虚拟局域网，相较于VLAN是一个非常大的提升。</p>

<p>VXLAN在节点中的传输协议选择了UDP协议，而不是TCP协议。原因在于UDP协议相较于TCP协议速度更快，无需连接的建立与拆除，数据包的可靠传输则由虚拟机间的传输协议保证。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/VXLAN-package.png" alt="" /></p>

<p>其中，VXLAN Header由VTEP添加，其中包含了24位VNI的值。可以看到，VXLAN其实就是对原有网络添加了一层拓展: VTEP。当数据包到达主机时，内核将MAC头和IP头取下，将UDP报文段发送给主机上的VTEP进程，VTEP进程首先检查VNI的值是否匹配(是不是给自己的包)，然后根据Inner IP Header决定发送给哪一个具体的虚拟机。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/VXLAN/VXLAN-Transfer.png" alt="" /></p>

<p>现在，我们对VXLAN协议的基本原理已经很清楚了，现在再来看一些细节问题。<strong>首先，虚拟机-A发出的数据帧的目标MAC地址，也就是目标VTEP的MAC地址该如何获取?</strong> 两种方式，一种是通过广播的方式，另外一种，则是由外部进程自动的添加至各节点的ARP表中。<strong>其次，IP地址为192.16.2.6这台虚拟机所在节点的IP地址如何获取?</strong> 该IP地址则是通过Linux内核中的FDB(Forwarding Database)获取的，在该表中，会记录VTEP的MAC地址与节点IP地址的映射关系，该映射关系同样可以通过广播学习获取，或者由外部进程维护。</p>

<blockquote>
  <p>经典的”外部进程”有flannel、Weave等容器网络框架</p>
</blockquote>

<h3 id="2-使用vagrant构建vxlan点对点通信">2. 使用Vagrant构建VXLAN点对点通信</h3>

<p>Vagrant环境如下:</p>
<ul>
  <li>node-1: 网卡接口-enp0s8，IP地址-192.168.2.15/24</li>
  <li>node-2: 网卡接口-enp0s8，IP地址-192.168.2.16/24</li>
</ul>

<p>首先，在node-1上添加vxlan interface:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span><span class="nb">sudo </span>ip link add vxlan0 <span class="nb">type </span>vxlan <span class="se">\</span>
    id 1024 <span class="se">\</span>
    dstport 4789 <span class="se">\</span>
    remote 192.168.2.15 <span class="se">\</span>
    dev enp0s8
</code></pre></div></div>

<p>上述命令将创建出一个名称为<code class="highlighter-rouge">vxlan0</code>、类型为vxlan的网络接口，并且指定VNI为<code class="highlighter-rouge">1024</code>，vtep通信端口为<code class="highlighter-rouge">4789</code>，并且手动地指出了对端VTEP的IP地址(<code class="highlighter-rouge">192.168.2.16</code>)。</p>

<p>其次，为vxlan0网络接口添加一个IP地址，该IP地址可以是任意值:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span><span class="nb">sudo </span>ip addr add 10.100.1.15/24 dev vxlan0
vagrant@node-1:~<span class="nv">$ </span><span class="nb">sudo </span>ip link <span class="nb">set </span>vxlan0 up
</code></pre></div></div>

<p>那么此时所有目标地址为<code class="highlighter-rouge">10.100.1.10/24</code>网段的数据包均会通过vxlan0接口处理，可以从路由表上查看此信息:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span>ip route
10.100.1.0/24 dev vxlan0 proto kernel scope link src 10.100.1.15
</code></pre></div></div>

<p>并且，如果此时查看Linux FDB表的话会发现，此时表项中的MAC地址为空值:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@node-1:~<span class="nv">$ </span>bridge fdb
00:00:00:00:00:00 dev vxlan0 dst 192.168.2.16 via enp0s8 self permanent
</code></pre></div></div>

<p>即所有经过vxlan0处理的数据包都会发到<code class="highlighter-rouge">192.168.2.16</code>，其原因在于在创建vxlan0时，手动地指定了对端IP地址。</p>

<p>用同样的方式在另一台虚拟机上创建vxlan0接口，并配置相应的IP地址，即可测试连通性。</p>

<p>通过上面的实验用例，我们可以看到几个非常关键的步骤:</p>

<ul>
  <li><strong>在路由表中添加vtep设备网络段的路由信息</strong></li>
  <li><strong>在ARP表中添加vtep设备的MAC地址与vtep的IP地址映射</strong></li>
  <li><strong>在FDB表中添加vtep设备的MAC地址与vtep所在节点的IP地址映射</strong></li>
</ul>

<p>实际上，<code class="highlighter-rouge">Flannel</code>这一经典的Kubernetes容器网络解决方案的VXLAN模式就是这么实现的，VXLAN模式所组建的覆盖网络，其实就是一个由不同宿主机上的VTEP设备所组成的虚拟二层网络。</p>

<h3 id="reference">Reference</h3>

<ul>
  <li>https://www.kernel.org/doc/Documentation/networking/vxlan.txt</li>
  <li>https://support.huawei.com/enterprise/zh/doc/EDOC1100087027</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>浅析gRPC</title>
	  <link>//gRPC</link>
	  <author></author>
	  <pubDate>2020-07-23T09:06:25+00:00</pubDate>
	  <guid>//gRPC</guid>
	  <description><![CDATA[
	     <p>gRPC是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。(这Ctrl-C/V也是没有下限了….</p>

<!---more--->

<h3 id="1-protocol-buffers">1. Protocol Buffers</h3>

<p>在早期，ProtoBuf主要用于解决Google内部的服务器高低版本的兼容性问题，后来由于其高效的数据传输效率被用于gRPC的传输数据格式。</p>

<p>相较于XML以及Json，ProtoBuf在传输和存储时由于其体积更小，所以效率更高，并且序列化的速度也比Json的序列化速度更快，原因将在后续部分介绍。</p>

<p>除此之外，ProtoBuf的最大特点就是支持向后兼容。如果使用Json或者XML的话，需要应用程序自行处理新旧版本数据格式之间的兼容性。而ProtoBuf则不需要破坏已经被部署的服务结构，ProtoBuf会帮助用户处理好高低版本的兼容性问题。</p>

<h4 id="11-protobuf所支持的数据类型">1.1 ProtoBuf所支持的数据类型</h4>

<p>对于基本数据类型，如int，float，double，string，bool以及bytes，ProtoBuf均支持定义以上数据类型。对于int类型的数据，ProtoBuf对其进行了额外的拓展，在不同的场景使用不同的整型将会有不同的运行效率。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">ProtoBuf Type</th>
      <th style="text-align: left">Explain</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">int32</td>
      <td style="text-align: left">int32最大支持4字节的整型数字，编码负数时效率较低</td>
    </tr>
    <tr>
      <td style="text-align: left">int64</td>
      <td style="text-align: left">int32最大支持8字节的整型数字，编码负数时效率较低</td>
    </tr>
    <tr>
      <td style="text-align: left">uint32</td>
      <td style="text-align: left">uint32最大支持4字节的无符整数</td>
    </tr>
    <tr>
      <td style="text-align: left">uint64</td>
      <td style="text-align: left">uint32最大支持8字节的无符整数</td>
    </tr>
    <tr>
      <td style="text-align: left">sint32</td>
      <td style="text-align: left">sint32最大支持4字节的有符整数，编码负数时效率更高</td>
    </tr>
    <tr>
      <td style="text-align: left">sint64</td>
      <td style="text-align: left">sint32最大支持8字节的有符整数，编码负数时效率更高</td>
    </tr>
    <tr>
      <td style="text-align: left">fixed32</td>
      <td style="text-align: left">不使用可变长度方式进行编码，总是传输4字节，在编码超过$2^{28}$数值的整数时效率更高</td>
    </tr>
    <tr>
      <td style="text-align: left">fixed64</td>
      <td style="text-align: left">不使用可变长度方式进行编码，总是传输8字节，在编码超过$2^{56}$数值的整数时效率更高</td>
    </tr>
  </tbody>
</table>

<p>除了上述的基本数据类型以外，ProtoBuf同时也支持列表，字典以及枚举类型的定义，再加上<code class="highlighter-rouge">message</code>类型支持嵌套定义，几乎可以说能够覆盖日常开发中的所有需求了。</p>

<h4 id="12-protobuf中的消息定义">1.2 ProtoBuf中的消息定义</h4>

<p><code class="highlighter-rouge">message</code>数据类型是ProtoBuf在序列化和反序列化中的最小单位，和C结构体非常类似。</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">Response</span> <span class="p">{</span>
    <span class="kt">int32</span> <span class="na">code</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">msg</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int32</span> <span class="na">data</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">message</code>中的字段类型和字段名称无需赘述，值得关注的是后面的Field Numbers，字段序列号。该序列号将会在数据存储和传输时用于指代<code class="highlighter-rouge">message</code>中所定义的字段，即对源数据编码成ProtoBuf格式数据后，字段名称将会被舍弃，转而使用字段系列号进行代替，所以会说ProtoBuf并不是自描述的传输格式，同时也是数据体积更小的原因之一。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MicroService/gRPC/FieldNumbers.png" alt="" /></p>

<p>所以，一个<code class="highlighter-rouge">message</code>中的字段系列号必须唯一，同时范围必须在[$1$, $2^{29}-1$]之间。并且19000到19999之间的数值被ProtoBuf内部所用，也不可定义。</p>

<p>下面是一个使用了大部分数据类型的<code class="highlighter-rouge">message</code>定义:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">UserStatus</span> <span class="p">{</span>
    <span class="c1">// 值为0的枚举值必须定义，因为这是ProtoBuf对枚举值的默认值
</span>    <span class="c1">// 同时，该零值不应该被应用程序所使用，否则会出现歧义
</span>    <span class="na">USER_STATUS_INVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="na">USER_STATUS_NORMAL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">USER_STATUS_FROZEN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">USER_STATUS_DELETED</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">MainAddress</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="na">province</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">city</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">address</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">UserInfo</span> <span class="p">{</span>
    <span class="kt">uint32</span> <span class="na">user_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">mobile</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">repeated</span> <span class="kt">string</span> <span class="na">extra_mobile</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">UserStatus</span> <span class="na">status</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">MainAddress</span> <span class="na">main_address</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="na">is_vip</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="13-protobuf编码">1.3 ProtoBuf编码</h4>

<p>ProtoBuf格式的数据体积更小的原因一方面归功于使用字段系列号来代替字段名称，另一方面则是因为对整型采用了可变长度编码方式，即使是指定了<code class="highlighter-rouge">int32</code>类型的数据也可能只使用一字节存储。</p>

<h5 id="131-base-128-varints">1.3.1 Base 128 Varints</h5>

<p>Varint使用一个或者多个字节表示一个数字，数字的值越小，所使用的字节数也会更小。其长度并不固定，所以称之为”可变长整数”。</p>

<p>Varint中的每个字节(最后一个字节除外)都设置了最高有效位(msb)，用于表示后面还会有更多字节出现，所以Varint中的最后一个字节不会设置msb。由于首位被当做是msb使用，所以一个字节只有7位有效位。</p>

<p>例如数字1，可以使用1字节进行表示，那么其最高有效位即可设置为0:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000 0001
</code></pre></div></div>

<p>对于多字节的数字，除了最后一个字节以外，其余字节的首位都应该置为1，以表示后续仍有字节。以数字1024为例，在一般情况下，1024需要使用2个字才能表示:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1024 <span class="o">=</span> 0000 0100 0000 0000
</code></pre></div></div>

<p>现在来看下Varint的编码过程:</p>

<ul>
  <li>首先，1024超过了7位，所以必须使用至少2个字节表示，但是又小于14位，所以需要2个字节表示。按每7位取一个字节，若不够7位则用0补齐:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000 0100 0000 0000 -&gt; 0001000 0000000
</code></pre></div></div>

<ul>
  <li>将低字节写入到高字节，最后一个字节最高位补0，其余字节最高位补1，即为最终结果:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10000000 00001000
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MicroService/gRPC/Varint.png" alt="" /></p>

<h5 id="132-message-structure">1.3.2 Message Structure</h5>

<p>在ProtoBuf中，<code class="highlighter-rouge">message</code>结构其实就是一系列的键值对，只不过<code class="highlighter-rouge">message</code>在序列化成二进制时，对键和值进行了特殊的处理而已。</p>

<p>首先来看对键的处理，键的计算方式是<code class="highlighter-rouge">(field_number &lt;&lt; 3) | wire_type</code>，根据键的计算公式可以看出，键的最后3位就是字段类型。<code class="highlighter-rouge">field_number</code>即为用户自定义的字段序列号，而<code class="highlighter-rouge">wire_type</code>则是一个由ProtoBuf所定义的对类型的”枚举”。:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Write Type</th>
      <th style="text-align: left">Meaning</th>
      <th style="text-align: left">Used For</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">0</td>
      <td style="text-align: left">Varint</td>
      <td style="text-align: left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
    </tr>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">64-bit</td>
      <td style="text-align: left">fixed64, sfixed64, double</td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">Length-delimited</td>
      <td style="text-align: left">string, bytes, embedded messages, packed repeated fields</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">32-bit</td>
      <td style="text-align: left">fixed32, sfixed32, float</td>
    </tr>
  </tbody>
</table>

<p>值得注意是当<code class="highlighter-rouge">wire_type</code>为2时，序列化结果中还需要包含数据的长度，即<code class="highlighter-rouge">length</code>。</p>

<ul>
  <li>当<code class="highlighter-rouge">wire_type</code>为0、1和5时，序列化的结果为<strong>key + 数据</strong>，数据长度由数据自描述。</li>
  <li>当<code class="highlighter-rouge">wire_type</code>为2时，序列化的结果为<strong>key + length + 数据</strong>，数据长度由<code class="highlighter-rouge">length</code>决定。</li>
</ul>

<p>下面通过一个实际的例子看下Message Structure的编码形式:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>syntax <span class="o">=</span> <span class="s2">"proto3"</span><span class="p">;</span>

message foo <span class="o">{</span>
    string bar <span class="o">=</span> 5<span class="p">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>将<code class="highlighter-rouge">bar</code>的值设置为”Hello”，序列化后将得到以下结果:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>052a 6548 6c6c 006f
</code></pre></div></div>

<p>ProtoBuf是小端字节序，阅读起来不是很方便，将其转换一下:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2a05 4865 6c6c 6f
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">4865 6c6c 6f</code>为字符串”Hello”的16进制表示，那么<code class="highlighter-rouge">2a05</code>就是前面提到的<strong>key+length</strong>了。<code class="highlighter-rouge">2a</code>的二进制格式为<code class="highlighter-rouge">101010</code>，最后3位为<code class="highlighter-rouge">010</code>，转换成十进制结果是2，对应string类型的<code class="highlighter-rouge">write_type</code>。<code class="highlighter-rouge">101</code>转换成十进制结果为5，对应bar字段的<code class="highlighter-rouge">field_number</code>。length则由<code class="highlighter-rouge">05</code>确定，表示字符串的长度为5。</p>

<h3 id="2-http2">2. HTTP/2</h3>

<p>HTTP/2协议在原有的HTTP/1协议版本之上进行了大幅度的修改，其传输效率大大提升，并且能够有效地降低服务端的资源消耗。</p>

<ul>
  <li>由文本传输改变为二进制数据传输，解析更加高效。</li>
  <li>使用新的二进制分帧机制改变了客户端和服务端之间交换数据的方式，每个二进制帧可进行乱序传输，解决了HTTP/1中的首部阻塞问题。</li>
  <li>对请求头部字段的压缩使得传输数据更小，传输效率更高。</li>
</ul>

<p>为了更好的理解HTTP/2，首先要明确HTTP/1的缺陷之处，首当其冲的就是TCP连接数限制。在浏览器中，同一个域名下同时只能创建6~8个TCP连接，剩下的请求只能等待这些请求的返回。并且，每个TCP连接只能承载一次请求/响应，当初始发送的请求响应时间较长时，整个页面加载也会受到阻塞。</p>

<h4 id="21-二进制分帧">2.1 二进制分帧</h4>

<p>在HTTP/1中，请求的数据以明文进行传输，例如:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET / HTTP/1.1
Host: example.com
</code></pre></div></div>

<p>而在HTTP/2中，请求或者响应数据不再以文本的方式进行传输，而是直接使用二进制数据进行传输，使得解析更加高效。其原因在于HTTP/1是通过特殊符号，如空格，<code class="highlighter-rouge">\r\n</code>等特殊字符进行分割并解析的。而HTTP/2首先对数据进行了分类，将请求头和Payload分开，并且在每一个传输单元中都进行了标记。</p>

<p>HTTP/2的基本传输单元为帧(Frame)，每一个都以固定的9个字节开头，后跟不定长度的Payload。Payload可以是用户传输的数据，也可以是协议本身携带的数据。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+-----------------------------------------------+
|                 Length <span class="o">(</span>24<span class="o">)</span>                   |
+---------------+---------------+---------------+
|   Type <span class="o">(</span>8<span class="o">)</span>    |   Flags <span class="o">(</span>8<span class="o">)</span>   |
+-+-------------+---------------+-------------------------------+
| R <span class="o">(</span>1<span class="o">)</span> |                 Stream Identifier <span class="o">(</span>31<span class="o">)</span>                |
+<span class="o">=</span>+<span class="o">=============================================================</span>+
|                   Frame Payload <span class="o">(</span>0...<span class="o">)</span>                      ...
+---------------------------------------------------------------+
</code></pre></div></div>

<p>24+8+8+1+31，刚好为72位，即9字节。下面来看每一个字段的含义:</p>

<ul>
  <li>Length: 表示Payload的长度，是一个24位的无符整数，单位为字节。也就是说，通常情况下一个帧最多能够传输2^14(16,384)个字节。如果想在一个帧中传输更多的数据，则可以通过传输<code class="highlighter-rouge">SETTINGS_MAX_FRAME_SIZE</code>帧来改变基本大小。</li>
  <li>Type: 帧的类型，如<code class="highlighter-rouge">DATA</code>帧、<code class="highlighter-rouge">HEADERS</code>帧。</li>
  <li>Flags: 该字段用于各类型的帧进行补充说明，表示特殊的含义。一个常见的标志就是<code class="highlighter-rouge">END_HEADERS</code>，表示头数据已经结束。</li>
  <li>R: 预留位，并未使用。</li>
  <li>Stream Identifier: 流标识符，31位无符整数，作用将在下方描述。</li>
</ul>

<h4 id="22-多路复用">2.2 多路复用</h4>

<p>HTTP/2一个最重要的特性就是多路复用，即在一个TCP连接中同时传输多个请求或者是响应，而HTTP/1想要做到这一点的话，必须要建立多个TCP连接。</p>

<p>在HTTP/2中引入了”流”(Stream)的概念，对应HTT/1的话，其实就是一个请求: 在一个连接中发送多个请求其实就是发送多个流。而流又是由帧组成的，所以在帧中需要字段<code class="highlighter-rouge">Stream Identifier</code>来标记当前帧属于哪个流。</p>

<p>实现多路复用的逻辑概念就是流，和TCP流式传输不同的是，HTTP/2中的流只是一个逻辑上的概念，每一个流使用<code class="highlighter-rouge">Stream Identifier</code>进行标识。一个请求或者是响应在拆分成多个帧以后，将使用同一个流ID在连接中进行传输，接收方在接收到乱序传输的帧以后，按照流ID进行组装，即可得到一个完整的请求或者是响应。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MicroService/gRPC/stream.png" alt="" /></p>

<h4 id="22-头部字段压缩">2.2 头部字段压缩</h4>

<p>TODO</p>

<h3 id="3-一些实践的代码用例">3. 一些实践的代码用例</h3>

<h4 id="31-python-client">3.1 Python Client</h4>

<p>gRPC的错误响应(如Not Found，Internal Server Error等)通常会以异常的形式抛出，所以，Python Client必须要对gRPC的相关方法进行进一步的封装，例如重试机制或者是进行其它行为。</p>

<p>最为常见的异常就是<code class="highlighter-rouge">_Rendezvous</code>，该异常为<code class="highlighter-rouge">RpcError</code>的一个子类，通常来说，只需要捕获该异常即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">grpc</span> <span class="kn">import</span> <span class="n">StatusCode</span><span class="p">,</span> <span class="n">RpcError</span>


<span class="c"># define retry times with different situation</span>
<span class="n">MAX_RETRIES_BY_CODE</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">StatusCode</span><span class="o">.</span><span class="n">INTERNAL</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">StatusCode</span><span class="o">.</span><span class="n">ABORTED</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">StatusCode</span><span class="o">.</span><span class="n">UNAVAILABLE</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">StatusCode</span><span class="o">.</span><span class="n">DEADLINE_EXCEEDED</span><span class="p">:</span> <span class="mi">5</span>
<span class="p">}</span>

<span class="c"># define MIN and MAX sleeping seconds</span>
<span class="n">MIN_SLEEPING</span> <span class="o">=</span> <span class="mf">0.015625</span>
<span class="n">MAX_SLEEPING</span> <span class="o">=</span> <span class="mf">1.0</span>


<span class="k">class</span> <span class="nc">RetriesExceeded</span><span class="p">(</span><span class="nb">Exception</span><span class="p">):</span>
    <span class="s">"""docstring for RetriesExceeded"""</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">retry</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wraps</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">RpcError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">code</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">code</span><span class="p">()</span>  <span class="c"># 使用e.code()获取响应码</span>
                <span class="n">max_retries</span> <span class="o">=</span> <span class="n">MAX_RETRIES_BY_CODE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">max_retries</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>

                <span class="k">if</span> <span class="n">retries</span> <span class="o">&gt;</span> <span class="n">max_retries</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">RetriesExceeded</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

                <span class="n">back_off</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">MIN_SLEEPING</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">retries</span><span class="p">,</span> <span class="n">MAX_SLEEPING</span><span class="p">)</span>

                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">back_off</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wraps</span>
</code></pre></div></div>

<h4 id="32-golang-server">3.2 Golang Server</h4>

<p>TODO</p>

<h3 id="4-reference">4. Reference</h3>

<ul>
  <li>https://hpbn.co/</li>
  <li>https://blog.wangriyu.wang/</li>
  <li>https://tools.ietf.org/html/rfc7540</li>
  <li>https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>揭开Python元类(metaclass)神秘的面纱</title>
	  <link>//Python-metaclass</link>
	  <author></author>
	  <pubDate>2020-07-13T10:06:25+00:00</pubDate>
	  <guid>//Python-metaclass</guid>
	  <description><![CDATA[
	     <p>Python语言的<code class="highlighter-rouge">metaclass</code>特性一直是初学者的”噩梦”，当初博主在学习元类时也是一头雾水，但是一旦真正的理解了什么是”动态语言”之后，元类就不再神秘与难以理解了。Python这门动态语言最大的特性就是不需要一个类的字节码就能够在运行时创建出一个类，这是理解元类最为关键的信息。</p>

<!---more--->

<h3 id="1-基础知识汇总">1. 基础知识汇总</h3>

<h4 id="11-stackoverflow">1.1 stackoverflow</h4>

<p>首先，强烈推荐阅读stackoverflow上关于<code class="highlighter-rouge">metaclass</code>的回答，作者并没有使用什么高级词汇，就算英语稀烂也能看的懂。</p>

<blockquote>
  <p>https://stackoverflow.com/a/6581949/12523821</p>
</blockquote>

<h4 id="12-类属性和实例属性">1.2 类属性和实例属性</h4>

<p>类属性表示绑定在一个类上的属性，而实例属性则是绑定在不同实例上的属性，类属性只有一份，而实例属性则可以有多份。当实例属性和类属性重名，并通过实例获取该属性时，会返回实例属性，而不是类属性。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">Hugo</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Hugo</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>      <span class="c"># "smart"</span>

    <span class="n">hugo</span> <span class="o">=</span> <span class="n">Hugo</span><span class="p">(</span><span class="s">"raven"</span><span class="p">)</span>  
    <span class="k">print</span><span class="p">(</span><span class="n">hugo</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>      <span class="c"># "raven"</span>

    <span class="k">print</span><span class="p">(</span><span class="n">Hugo</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>      <span class="c"># "smart"</span>
</code></pre></div></div>

<h4 id="13-__new__方法和__init__方法">1.3 <code class="highlighter-rouge">__new__</code>方法和<code class="highlighter-rouge">__init__</code>方法</h4>

<p>在Python中，实际创建对象的过程是由<code class="highlighter-rouge">__new__</code>方法控制的，该方法接收class对象(cls)。而<code class="highlighter-rouge">__init__</code>方法则是在<code class="highlighter-rouge">__new__</code>方法所创建的对象实例上，进行属性的赋值或者其它操作，所以接收实例对象(self)。</p>

<p>当想要控制创建对象的过程时，应该使用<code class="highlighter-rouge">__new__</code>方法，例如常用的单例模式，而不是使用<code class="highlighter-rouge">__init__</code>方法:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Lock</span>

<span class="k">class</span> <span class="nc">SingletonClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">instance</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span>
        <span class="k">with</span> <span class="n">cls</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="c"># double check</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span><span class="p">:</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span>
</code></pre></div></div>

<h4 id="14-mro">1.4 MRO</h4>

<p>Python是通过MRO列表来实现类的继承的，MRO列表的构造由C3线性化算法实现。实际上，类的继承层级关系最终会表现成包含所有基类的线性顺序表。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Parent init"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Children</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Children</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Children init"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Grandchildren</span><span class="p">(</span><span class="n">Children</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Grandchildren</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Grandchildren init"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Grandchildren</span><span class="o">.</span><span class="n">__mro__</span><span class="p">)</span>
</code></pre></div></div>

<p>运行结果为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>
    &lt;class <span class="s1">'__main__.Grandchildren'</span><span class="o">&gt;</span>, 
    &lt;class <span class="s1">'__main__.Children'</span><span class="o">&gt;</span>, 
    &lt;class <span class="s1">'__main__.Parent'</span><span class="o">&gt;</span>, 
    &lt;class <span class="s1">'object'</span><span class="o">&gt;</span>
<span class="o">)</span>
</code></pre></div></div>

<p>其顺序与继承顺序刚好相反，也就是说，通过类的<code class="highlighter-rouge">__mro__</code>属性即可找到该类的所有父类，包括<code class="highlighter-rouge">object</code>类。</p>

<p>Python同时也提供了内建的反射函数，来返回某个类的MRO列表:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">getmro</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">__mro__</span>
</code></pre></div></div>

<h3 id="2-metaclass">2. metaclass</h3>

<p>我们已经知道了<code class="highlighter-rouge">metaclass</code>是创建一个类的工具，通过<code class="highlighter-rouge">metaclass</code>能够更加灵活地动态地创建一个类，其中一个非常重要的结果就是能够获取到”子类”的全部信息，例如类属性、类方法等。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"get class field: {name}===&gt;{value}"</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">HugoMetaclass</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="n">gender</span> <span class="o">=</span> <span class="s">"male"</span>
</code></pre></div></div>

<p>运行上述代码将会打印出<code class="highlighter-rouge">Hugo</code>类的所有属性信息:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>get class field: <span class="nv">__module__</span><span class="o">===&gt;</span>__main__
get class field: <span class="nv">__qualname__</span><span class="o">===&gt;</span>Hugo
get class field: <span class="nv">name</span><span class="o">===&gt;</span>smart
get class field: <span class="nv">gender</span><span class="o">===&gt;</span>male
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">__module__</code>和<code class="highlighter-rouge">__qualname__</code>为内部属性，而<code class="highlighter-rouge">name</code>和<code class="highlighter-rouge">gender</code>则是用户自定义的类属性。可以看到，在<code class="highlighter-rouge">HugoMetaclass。__new__</code>方法中，完全能够获取到<code class="highlighter-rouge">Hugo</code>类的相关类属性，那么更进一步地来说，不管用户定义了什么样的类属性，都可以使用<code class="highlighter-rouge">metaclass</code>在创建该类之前获取到该类的所有属性。这就为诸如ORM、表单验证等基础服务提供了构建的基础。</p>

<h4 id="21-metaclass的应用">2.1 metaclass的应用</h4>

<p><code class="highlighter-rouge">type</code>的<code class="highlighter-rouge">__new__</code>方法接收4个参数，分别为类对象，类名称，父类元组以及类属性。这四个参数中最为关键的就是父类元组和类属性，通常项目中使用<code class="highlighter-rouge">metaclass</code>时也是和这两个参数频繁打交道。</p>

<h5 id="211-父类元组">2.1.1 父类元组</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">HugoMetaclass</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">HugoChild</span><span class="p">(</span><span class="n">Hugo</span><span class="p">):</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p>运行后将得到以下结果:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">()</span>
<span class="o">(</span>&lt;class <span class="s1">'__main__.Hugo'</span><span class="o">&gt;</span>,<span class="o">)</span>
</code></pre></div></div>

<p>一共需要创建两个类: <code class="highlighter-rouge">Hugo</code>和<code class="highlighter-rouge">HugoChild</code>，<code class="highlighter-rouge">Hugo</code>类直接使用<code class="highlighter-rouge">HugoMetaclass</code>创建，所以其父类元组为空。而<code class="highlighter-rouge">HugoChild</code>直接继承自<code class="highlighter-rouge">Hugo</code>，所以其父类为<code class="highlighter-rouge">Hugo</code>。所以，可以通过<code class="highlighter-rouge">bases</code>参数来判断当前创建的类是否需要进行处理。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 这里所创建的类都是Hugo的子类, 而不是Hugo类</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="212-类属性">2.1.2 类属性</h5>

<p>类属性是”子类”中最为重要的数据，可以说元类的最终目的就是为了根据类属性创建出一个模板，将该模板数据保存在类中。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>

        <span class="c"># 对Hugo类不做任何处理</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="n">klass</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 保存attrs中所有的int类型数据</span>
        <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">klass</span>
        
<span class="k">class</span> <span class="nc">Hugo</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">HugoMetaclass</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">HugoChild</span><span class="p">(</span><span class="n">Hugo</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="n">age</span> <span class="o">=</span> <span class="mi">24</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
</code></pre></div></div>

<p>上面创建了一个<code class="highlighter-rouge">int</code>类型的”模板”，并保存在了<code class="highlighter-rouge">declared_fields</code>这个字典中。注意不要将<code class="highlighter-rouge">declared_fields</code>挂到<code class="highlighter-rouge">mcs</code>上，<code class="highlighter-rouge">mcs</code>就是<code class="highlighter-rouge">HugoMetaclass</code>，变量绑定到<code class="highlighter-rouge">mcs</code>上会丢失一些信息，导致程序出现BUG。</p>

<p>那么如果<code class="highlighter-rouge">HugoChild</code>又有子类呢? 上述方式是否能够将<code class="highlighter-rouge">HugoChild</code>和其子类的属性一起获取到呢?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoChild</span><span class="p">(</span><span class="n">Hugo</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"smart"</span>
    <span class="n">age</span> <span class="o">=</span> <span class="mi">24</span>

<span class="k">class</span> <span class="nc">HugoGrandChild</span><span class="p">(</span><span class="n">HugoChild</span><span class="p">):</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mi">180</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Hugo</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoGrandChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
</code></pre></div></div>

<p>这时候会发现，这三个类的<code class="highlighter-rouge">declared_fields</code>结果都是<code class="highlighter-rouge">{'height': 180}</code>，<code class="highlighter-rouge">age</code>字段丢失了。原因也很简单，在创建<code class="highlighter-rouge">HugoGrandChild</code>类时，<code class="highlighter-rouge">declared_fields</code>被重新声明成了空字典，所以<code class="highlighter-rouge">HugoChild</code>中的类属性就会丢失。那么有没有什么办法能够得到完整版呢? 这就需要用到上面所提到的MRO列表了。</p>

<p>我们可以通过MRO列表，来获取到<code class="highlighter-rouge">HugoGrandChild</code>的所有父类，而后逐一的遍历找出类型为<code class="highlighter-rouge">int</code>的类属性，保存在<code class="highlighter-rouge">declared_fields</code>这个字典中。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>

        <span class="c"># 对Hugo类不做任何处理</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 保存attrs中所有的int类型数据</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c"># 遍历__mro__列表并找出类型为`int`的类属性, 保存在字典中</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">klass</span><span class="o">.</span><span class="n">__mro__</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="s">'declared_fields'</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">klass</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">HugoGrandChild</span><span class="o">.</span><span class="n">declared_fields</span><span class="p">)</span>
</code></pre></div></div>

<p>其运行结果为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span><span class="s1">'age'</span>: 24<span class="o">}</span>
<span class="o">{</span><span class="s1">'height'</span>: 180, <span class="s1">'age'</span>: 24<span class="o">}</span>
</code></pre></div></div>

<p>如此一来，<code class="highlighter-rouge">HugoGrandChild</code>在继承了<code class="highlighter-rouge">HugoChild</code>之后，也能够获取到其中的相关字段，并且父类不会受到子类的影响。</p>

<p>上述代码中存在一些重复的代码片段，将其抽离出来，使代码结构更加清晰:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_instance_or_subclass</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">class_</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">class_</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">class_</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_fields</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">field_class</span><span class="p">):</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">field_name</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">is_instance_or_subclass</span><span class="p">(</span><span class="n">field_value</span><span class="p">,</span> <span class="n">field_class</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">fields</span>

<span class="k">def</span> <span class="nf">_get_fields_by_mro</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">field_class</span><span class="p">):</span>
    <span class="n">mro</span> <span class="o">=</span> <span class="n">klass</span><span class="o">.</span><span class="n">__mro__</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">_get_fields</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s">'declared_fields'</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">__dict__</span><span class="p">),</span>
                <span class="n">field_class</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">mro</span><span class="p">[:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">),</span>
        <span class="p">[],</span>
    <span class="p">)</span>

<span class="k">class</span> <span class="nc">HugoMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">HugoMetaclass</span><span class="p">)]</span>

        <span class="c"># 对Hugo类不做任何处理</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c"># 保存attrs中所有的int类型数据</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="n">class_fields</span> <span class="o">=</span> <span class="n">_get_fields</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">inherited_fields</span> <span class="o">=</span> <span class="n">_get_fields_by_mro</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">klass</span><span class="o">.</span><span class="n">declared_fields</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">class_fields</span> <span class="o">+</span> <span class="n">inherited_fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">klass</span>
</code></pre></div></div>

<h3 id="3-小结">3. 小结</h3>

<p><code class="highlighter-rouge">metaclass</code>并不神秘，得益于Python是动态语言，可以在运行时动态地创建一个类的特性，我们能够在事前去创建一些有用的”模板”，在运行时将模板和数据有机的结合起来，最终呈现出宛如魔术般的效果。</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL向客户端发送数据，客户端不接收会发生什么?</title>
	  <link>//MySQL-Sending-Data</link>
	  <author></author>
	  <pubDate>2020-06-17T10:50:25+00:00</pubDate>
	  <guid>//MySQL-Sending-Data</guid>
	  <description><![CDATA[
	     <p>MySQL服务端在发送数据时，为了减少数据在用户空间和内核空间的复制次数，往往会使用缓冲区对数据进行缓冲。那么，如果客户端在接收大量数据时，选择不接收，或者处理非常慢的时候，会影响MySQL的正常运行吗?</p>

<!---more--->

<h3 id="1-tcp连接的收发模型">1. TCP连接的收发模型</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/TCP-buffer.png" alt="" /></p>

<p>当调用<code class="highlighter-rouge">write()</code>或者<code class="highlighter-rouge">send()</code>系统调用向socket写入数据时，并不会直接被发送至网络，而是被发送至位于内核空间的TCP发送缓冲区。在缓冲区中，由TCP连接的窗口控制发送频率和数量。当发送缓冲区已满时，阻塞模式下的<code class="highlighter-rouge">write()</code>调用将会一直阻塞，直到有可用的发送缓冲区为止。而非阻塞模式下则会直接返回-1，<code class="highlighter-rouge">errno</code>将会被置为<code class="highlighter-rouge">EAGAIN</code>或者是<code class="highlighter-rouge">EWOULDBLOCK</code>。</p>

<p>对于<code class="highlighter-rouge">read()</code>或者是<code class="highlighter-rouge">recv()</code>系统调用读取socket数据时，情况和发送数据基本类似，只不过是读取接收缓冲区中的内容。阻塞模式下如果接收缓冲区为空，那么将会阻塞，而非阻塞模式下则会立即返回，<code class="highlighter-rouge">errno</code>为<code class="highlighter-rouge">EAGAIN</code>或者是<code class="highlighter-rouge">EWOULDBLOCK</code>。</p>

<p>接收方与发送方的窗口大小、MSS大小以及网络状况都会对发送缓冲区的动态大小变化造成影响。当接收方的缓冲区较小时，也就意味地接收窗口较小，那么当发送方持续发送数据时，很有可能将发送缓冲区填满导致发送方数据写入的阻塞。同样地，如果发送方的网络出现波动导致大量的丢包，由拥塞避免阶段重新进入慢启动阶段，也会导致发送缓冲区的数据不能及时地发出。</p>

<p>在一般的Linux操作系统下，发送缓冲区和接收缓冲区的的大小默认为208K。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span><span class="nb">cat</span> /proc/sys/net/core/wmem_default
212992
smartkeyerror@Zero:~<span class="nv">$ </span><span class="nb">cat</span> /proc/sys/net/core/rmem_default
212992
</code></pre></div></div>

<h3 id="2-mysql结果发送与客户端接收">2. MySQL结果发送与客户端接收</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/MySQL-Send.png" alt="" /></p>

<p>当客户端向MySQL请求查询数据时，MySQL会将结果暂存于net_buffer中，net_buffer的大小默认为16K，由参数<code class="highlighter-rouge">net_buffer_length</code>决定。当net_buffer已满或者是无更多结果时，调用网络接口将数据写入至TCP连接的发送缓冲区中。如果发送缓冲区已满，那么该查询请求的数据发送将会阻塞，直到有可用的发送缓冲区为止。</p>

<p>当TCP发送缓冲区已满时，通过<code class="highlighter-rouge">show processlist</code>将会得到Query语句”正在发送给客户端”的结果:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/Sending-To-Client.png" alt="" /></p>

<p>当出现State为<code class="highlighter-rouge">Sending to client</code>的查询语句时，表示当前线程已将TCP发送缓冲区填满，无法继续发送数据给客户端，并等待客户端接收数据。</p>

<p>如果出现了较多的<code class="highlighter-rouge">Sending to client</code>状态的线程，那么要么是客户端网络情况较差，要么是客户端在处理结果时过慢，此时需要优化客户端代码。</p>

<p><code class="highlighter-rouge">Sending to client</code>状态需要和<code class="highlighter-rouge">Sending data</code>状态区分开来，前者表示正在等待客户端接收结果，而后者则表示事务正在执行(不一定在发送数据，也可能在等待锁)。</p>

<h3 id="3-客户端不接收mysql的发送数据会发生什么">3. 客户端不接收MySQL的发送数据会发生什么?</h3>

<h4 id="31-innodb的一致性非锁定读">3.1 InnoDB的一致性非锁定读</h4>

<p>在InnoDB存储引擎中，每条UPDATE语句都会默认的在该TABLE上添加一个意向写锁(IX Lock)，并且在要修改的数据行上添加X Lock，防止其它线程对其同时更新。而在这个过程中，普通的数据读取操作依然能够进行，并不会等待X Lock的释放，极大的提升了数据库的并发读取能力，该读取方式称为一致性非锁定读，由undo段实现。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/undo-read.png" alt="" /></p>

<p>在undo段中，同一行数据可能因为事务并发的执行而导致出现多个版本的快照，在一致性非锁定读中，只需要选择其中一个快照数据进行读取即可。在RC隔离级别，总是读取最新版本的快照数据，而在RR隔离级别下，总是读取事务开始时的行数据版本。</p>

<h4 id="32-sending-to-client导致undo段迅速膨胀">3.2 <code class="highlighter-rouge">Sending to client</code>导致undo段迅速膨胀</h4>

<p>当服务端出现大量的线程处于<code class="highlighter-rouge">Sending to client</code>状态时，所执行的查询语句未完成，那么会导致长事务的产生。而如果此时数据更新较为频繁时，将会导致undo段空间迅速膨胀，因为长事务的进行导致undo页无法被回收。</p>

<p>最常见的例子就是使用<code class="highlighter-rouge">mysqldump</code>对数据进行热备时，备份存储节点的磁盘已满，导致<code class="highlighter-rouge">mysqldump</code>无法向备份文件中写入数据。数据由客户端的接收缓冲区开始堆积，到服务端的发送缓冲区，再到<code class="highlighter-rouge">net_buffer</code>，最终可能会导致undo段的数据堆积，使得MySQL服务出现大面积的异常。</p>

<h3 id="4-小结">4. 小结</h3>

<p>综上，客户端如果在处理MySQL发送的大量数据时，应该尽可能地将其暂存在本地的某个缓冲区中，而后应用程序想怎么处理、以何种速度处理都没问题，避免让MySQL产生过多的长事务。</p>

	  ]]></description>
	</item>

	<item>
	  <title>TCP有限状态机</title>
	  <link>//TCP-Finite-State-Machine</link>
	  <author></author>
	  <pubDate>2020-06-09T18:06:25+00:00</pubDate>
	  <guid>//TCP-Finite-State-Machine</guid>
	  <description><![CDATA[
	     <p>相较于Linux进程状态的变迁，TCP的状态变迁则会复杂许多，当然这与TCP本身的实现有关。当线上的Web服务或者是基于TCP连接的服务出现了时断时续的网络状况时，往往需要通过<code class="highlighter-rouge">tcpdump</code>以及TCP连接的状态进行问题定位。同时，这一复杂的有限状态机设计也能够为业务的设计提供指导性的帮助。</p>

<!---more--->

<h3 id="1-tcp连接的建立">1. TCP连接的建立</h3>

<p>TCP连接本质上是两个进程的某些属性的状态值，在TCP连接的建立和断开过程中，实际是状态的变更。连接的建立需要经过三次握手，确认连接的双方能够正确应答，同时进行<code class="highlighter-rouge">MSS</code>、<code class="highlighter-rouge">Win</code>等信息的交换。</p>

<p>TCP协议是可靠传输协议，所以存在TCP序列号以及确认机制。序列号是指当前传输方向上数据报第一个字节的逻辑偏移，由于TCP连接是双向的，所以连接的双方都会有各自的序列号，记为Sequence Number，简写为Seq。</p>

<p>确认机制则由位于TCP报文段中大小为1bit的ACK确认位以及确认序号实现。当一方收到了Seq为$s$、Len为$l$的报文后，需要向对方确认已经收到了该报文。确认的方式是设置ACK确认位，并且将确认序号设置为$s+l$，表示下一次想要接收的数据字节序列号。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/TCP-Status/TCP-build.png" alt="" /></p>

<p>如上图所示，TCP连接的建立需要进行三次握手，其中的细节不再赘述。当客户端使用SYN发起连接时，其状态将会由<code class="highlighter-rouge">CLOSED</code>变迁为<code class="highlighter-rouge">SYN_SENT</code>，表示进程主动地打开了一个连接，并等待对端回应以此完成连接的建立。</p>

<p>当服务端收到来自客户端带有SYN控制位的数据包时，将回复带有SYN以及ACK控制位的数据包，并将状态置为<code class="highlighter-rouge">SYN_RECV</code>，等待对端发送的ACK数据包以建立连接。</p>

<p>客户端收到服务端的报文以后，将连接状态改变为<code class="highlighter-rouge"> ESTABLISHED</code>，表示与对端TCP节点间的连接建立完成，可以正式地传输数据了。同样地，服务端收到对端的ACK确认包以后，也会将状态改变为<code class="highlighter-rouge">ESTABLISHED</code>，两者的连接正式建立。</p>

<p>在连接建立时，只有在确认对方能够正确应答(SYN发送且收到ACK应答)时才会进入<code class="highlighter-rouge">ESTABLISHED</code>状态。</p>

<h3 id="2-tcp连接的拆除">2. TCP连接的拆除</h3>

<p>TCP连接的建立相对来说比较简单，其状态变迁也相对较少，而连接的拆除则远比连接的建立复杂的多。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/TCP-Status/TCP-disconnect.png" alt="" /></p>

<p>发起连接断开的一段称为主动断开方，那么另一端则称为被动断开方。主动断开方执行<code class="highlighter-rouge">close()</code>系统调用，断开TCP连接，此时主动方将发送设置了FIN控制位的报文，并进入<code class="highlighter-rouge">FIN_WAIT_1</code>阶段，等待对方对该FIN包的应答。</p>

<p>当被动断开方收到FIN包以后，立即回送该FIN的确认包，并进入到<code class="highlighter-rouge">CLOSE_WAIT</code>阶段，<strong>主要的工作就是等待上层应用主动调用<code class="highlighter-rouge">close</code>方法关闭连接</strong>，在该阶段中上层应用任何的<code class="highlighter-rouge">read()</code>系统调用都将返回0，表示文件结尾。当应用层调用了<code class="highlighter-rouge">close()</code>系统调用之后，被动断开方将发送FIN结束包。</p>

<p>主动断开方收到FIN包以后，同样地回送ACK确认报文，并进入<code class="highlighter-rouge">TIME_WAIT</code>阶段，此时将固定的等待2倍MSL时间，MSL为报文的最大生存时间，Linux中默认的MSL时间为60S，那么主动断开方将等待120S后彻底关闭TCP连接。</p>

<p>被动断开方在收到ACK确认包以后，释放内核资源，完全关闭TCP连接。</p>

<h4 id="21-close_wait">2.1 CLOSE_WAIT</h4>

<p><code class="highlighter-rouge">CLOSE_WAIT</code>状态只有在被动断开方才会出现，其过程的长短并不由内核控制，必须等待上层应用程序主动调用<code class="highlighter-rouge">close()</code>系统调用，才会从此状态变迁为<code class="highlighter-rouge">LAST_ACK</code>状态。所以，由于此阶段需要应用程序的主动参与，该阶段也是最容易出现问题的阶段。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/TCP-Status/CLOSE_WAIT.png" alt="" /></p>

<p>当服务器出现了大量的、长时间的<code class="highlighter-rouge">CLOSE_WAIT</code>状态的连接，就需要判断是否是应用程序存在BUG，导致TCP连接未主动地关闭。或者是锁争抢过于激烈，又或是CPU资源不足导致应用程序没有额外的CPU对连接进行处理。</p>

<h4 id="22-time_wait">2.2 TIME_WAIT</h4>

<p><code class="highlighter-rouge">TIME_WAIT</code>阶段往往会被开发者所误解当做是优化的对象，因为该阶段的超时时间为2倍的MSL，开发人员认为该值过大，通常会将其减少至15S或者更短。但是，<code class="highlighter-rouge">TIME_WAIT</code>阶段的存在主要目的在于实现连接的可靠终止，以及让原有报文段在网络中过期失效，不会发送给新的连接。</p>

<h5 id="221-连接的可靠终止">2.2.1 连接的可靠终止</h5>

<p>在TCP四次挥手的过程中，首次发送FIN报文和最后一次发送ACK报文的都是主动断开方，被动断开方被”夹在中间”。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/TCP-Status/NOT-TIME-WAIT.png" alt="" /></p>

<p>如上图所示，假设没有<code class="highlighter-rouge">TIME_WAIT</code>阶段，并且主动断开方的最后一个ACK在网络中丢失。被动断开方迟迟等不到自己FIN包的ACK，当达到最大超时时间时将重传FIN包(此时无法触发快速重传)。但是，由于此时主动断开方的状态已经是<code class="highlighter-rouge">CLOSED</code>，即当前连接并不存在，则会返回一个RST，而该RST则会被视为错误。</p>

<h5 id="222-确保老的重复的报文在网络中过期失效">2.2.2 确保老的重复的报文在网络中过期失效</h5>

<p>TCP的重传算法可能会导致生成重复的报文，并且根据路由的不同选择，这些重复的报文可能会在连接终止之后到达。</p>

<p>假设主动断开方在发送最后一个ACK包以后立即进入<code class="highlighter-rouge">CLOSED</code>状态，并且在该段又新建了一个与之前一样的连接(IP地址和端口号相同)，那么此连接就是原来连接的化身。在这种情况下，TCP必须确保上一次连接中老的重复报文不会在新的连接中被当成合法数据接收。当有TCP结点处于<code class="highlighter-rouge">TIME_WAIT</code>状态时是无法通过该结点创建新的连接的，这样就阻止了新连接的建立。</p>

<p>当一条连接处于<code class="highlighter-rouge">TIME_WAIT</code>阶段时，其向内核申请的端口号并不会得到释放。如果系统中同时存在大量的处于<code class="highlighter-rouge">TIME_WAIT</code>阶段的连接的话，可能无法再建立新的连接: 端口号资源不够。所以某些并发量较高的应用程序会选择缩短<code class="highlighter-rouge">TIME_WAIT</code>的时间，已获得更高的并发量。</p>

<p>但是，当系统因为<code class="highlighter-rouge">TIME_WAIT</code>而无法建立新的连接时，表示当前节点的资源已经吃紧，最好的办法是增加机器，而不是缩短<code class="highlighter-rouge">TIME_WAIT</code>的时间。</p>

<h3 id="3-使用netstat查看套接字状态">3. 使用netstat查看套接字状态</h3>

<p><code class="highlighter-rouge">netstat</code>可以显示出系统中Internet和UNIX域套接字的状态，当服务器出现网络问题时，可首先用此命令获取基本情况。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span>netstat 
Active Internet connections <span class="o">(</span>w/o servers<span class="o">)</span>
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 localhost:33406         localhost:7890          TIME_WAIT  
tcp        0      0 Zero:56626              183.61.83.4:https       ESTABLISHED
tcp        0      0 localhost:33528         localhost:7890          ESTABLISHED
tcp        0      0 Zero:54438              119.147.134.30:https    TIME_WAIT  
tcp        0      0 Zero:32856              220.181.107.131:https   ESTABLISHED
tcp        0      1 Zero:60558              media-router-fp1.:https LAST_ACK
</code></pre></div></div>

<ul>
  <li>proto: 表示套接字所使用的协议，例如tcp、udp和unix。</li>
  <li>Recv-Q: 表示套接字接收缓冲区中还未被本地应用读取的字节数。对于UDP套接字
来说，该字段不只包含数据，还包含UDP首部及其他元数据所占的字节。</li>
  <li>Send-Q: 表示套接字发送缓冲区中排队等待发送的字节数。</li>
  <li>Local Address: 本地套接字所绑定的地址，格式为IP+端口号。</li>
  <li>Foreign Address: 对端套接字所绑定的地址。</li>
  <li>State: 套接字所处的状态。</li>
</ul>

<p>通常来说我们并不关心UNIX域套接字的相关信息，所以可以使用<code class="highlighter-rouge">--tcp</code>进行过滤，得到的结果仅包含TCP套接字的相关信息。还有一些其他有用的选项:</p>

<table>
  <thead>
    <tr>
      <th>选项</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-a</td>
      <td>显示所有套接字的信息，保证正在监听(LISTEN)的套接字</td>
    </tr>
    <tr>
      <td>-c</td>
      <td>每隔一秒钟刷新显示套接字信息</td>
    </tr>
    <tr>
      <td>-l</td>
      <td>仅显示正在监听的套接字信息</td>
    </tr>
    <tr>
      <td>-p</td>
      <td>显示进程 ID 号以及套接字所归属的程序名称</td>
    </tr>
    <tr>
      <td>–tcp</td>
      <td>显示 Internet域TCP(流)套接字的信息</td>
    </tr>
    <tr>
      <td>–udp</td>
      <td>显示 Internet域UDP(数据报)套接字的信息</td>
    </tr>
    <tr>
      <td>–unix</td>
      <td>显示 UNIX 域套接字的信息</td>
    </tr>
  </tbody>
</table>


	  ]]></description>
	</item>

	<item>
	  <title>InnoDB独特的LRU</title>
	  <link>//InnoDB-LRU</link>
	  <author></author>
	  <pubDate>2020-06-09T18:06:25+00:00</pubDate>
	  <guid>//InnoDB-LRU</guid>
	  <description><![CDATA[
	     <p>由于硬盘和内存的造价差异，一台主机实例的硬盘容量通常会远超于内存容量。对于数据库等应用而言，为了保证更快的查询效率，通常会将使用过的数据放在内存中进行加速读取。LRU算法经常用于数据的置换，但InnoDB的LRU却更加独特。</p>

<!---more--->

<h3 id="1-总览">1. 总览</h3>

<p>InnoDB存储引擎是基于硬盘存储的，并且以页(page)的方式对数据记录进行管理。由于硬盘和CPU之间数据处理速度存在巨大差异，所以必须要使用内存来弥补两者之间的速度鸿沟。</p>

<p>正如同操作系统在读取硬盘文件时会将其纳入内核缓冲区一样，InnoDB存储引擎也会为硬盘中的数据和索引建立位于用户空间的内存缓冲池。当数据库从硬盘读取数据时，首先将其放置于位于内存的缓冲池中，下一次读取相同的数据时，首先判断是否位于缓冲池中。若在，则直接返回，若不在，再从硬盘中进行读取。</p>

<p>当修改数据页时，首先修改位于缓冲池中的数据页，InnoDB会寻找合适的时机将此修改持久化至硬盘中，该合适的时机通常由Checkpoint技术决定。</p>

<p>在Linux操作系统中，位于内核的内核缓冲区就是为了提高系统的I/O效率而产生的，那么为什么InnoDB还要建立自己的缓冲区? 内核缓冲区的终端为硬盘，需要处理诸如页对齐、数据边界等和硬盘硬件相关的事宜，而InnoDB缓冲区则主要服务于应用，并不关心硬件细节，并且可由应用程序控制。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/InnoDB-Buffer/InnoDB-Buffer-Pool.png" alt="" /></p>

<p>如上图所示，InnoDB缓冲池主要由数据页和索引页构成，两者占据了缓冲区的绝大部分空间。除此之外，undo页、插入缓冲以及自适应哈希索引等内容也位于缓冲池中。</p>

<h3 id="2-数据页与索引页的lru">2. 数据页与索引页的LRU</h3>

<p>数据页和索引页的目的在于缓存一部分的表数据和索引数据，其数据总量通常会超过缓冲池大小，所以缓冲池中应只缓冲那些经常使用的热点数据。InnoDB内存管理使用的是最近最少使用(Least Recently Used, LRU)算法。来淘汰最久未使用的数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/InnoDB-Buffer/normal-LRU.png" alt="" /></p>

<p>在一般的LRU算法中，当链表中的某一个数据被读取时，将会将其放置于队首。当新增数据且链表已达最大数量时，将链表尾部的数据移除，并将新增的数据置于链表首部。</p>

<p>但是，InnoDB并没有采用传统的LRU算法，而是对其进行了一些更能够适应自身行为的改进: 最近访问到的数据并不直接放到LRU列表的首部，而是放到LRU列表的midpoiont位置。在默认配置下，midpoint位于LRU列表的5/8处。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/InnoDB-Buffer/midpoint.png" alt="" /></p>

<p>如上图所示，在midpoint之前的列表称之为new列表，或者使用Java中的GC术语: 新生代，在midpoint之后的列表称之为old列表，或者说，老年代。</p>

<p>当new列表中的数据被访问时，直接将其放置于LRU列表的首部。当出现新的页面进入LRU时，将其放置于midpoint位置，<strong>此时该数据页将会位于old列表</strong>。</p>

<p>当old列表中的数据被访问时，需要进行判断。如果当前页在old列表中存在时间超过了1秒，则将其移到列表首部。若存在时间小于1秒，则位置保持不变。该判断时间由<code class="highlighter-rouge">innodb_old_blocks_time</code>决定，默认为1000毫秒，即1秒。</p>

<p>另外一点需要注意的是，InnoDB管理数据的最小单位是页(page)，而不是数据库中的某一行。即如果两条记录处于同一页，在两次间隔时间超过<code class="highlighter-rouge">innodb_old_blocks_time</code>的不同行记录的访问也会将该页置于LRU的首部。</p>

<p>InnoDB如此设计的原因在于若使用朴素的LRU算法实现的，某些索引或者表扫描操作可能会将所有的索引页和数据页置换出去，而这些数据通常只是一次性使用的，热点数据被刷出之后，会严重的影响MySQL的性能。当采用midpoint实现后，至少能够保证5/8的数据都是热点数据，即使出现了大范围的表扫描和索引扫描。</p>

<p>让我们来具体分析下对大表进行顺序扫描的过程:</p>

<ol>
  <li>当扫描开始时，InnoDB会一次性地取出16KB的一页数据，将其置于LRU 5/8的位置。</li>
  <li>由于是顺序扫描，那么同一页将会被访问多次，但是访问的间隔一定不会超过默认的<code class="highlighter-rouge">innodb_old_blocks_time</code>，即1秒。所以该页并不会被置于LRU列表的首部，也就不会将真正的热点数据置换而出。</li>
  <li>后续的数据扫描将会在下一页进行，重复上述过程。</li>
</ol>

<p>通过执行<code class="highlighter-rouge">show engine innodb status\G;</code>可以查看InnoDB缓冲池的各种指标，包括当前缓冲池的大小。此外还有一个非常重要的性能指标: 内存命中率。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; show engine innodb status<span class="se">\G</span><span class="p">;</span>
Buffer pool hit rate 976 / 1000, young-making rate 0 / 1000 not 0 / 1000
</code></pre></div></div>

<p>其中Buffer pool hit rate即为缓冲池内存命中率，在一个线上服务中，如果要保证响应时间的话，命中率应不低于95%。 如果某台MySQL实例的hit rate低于此值的话，需要查看设置的缓冲池总大小，以及是否进行了频繁的大范围数据扫描导致LRU列表被污染。</p>

<p>除了增加缓冲池的大小来提高效率以外，当遇到持续的热点问题时，即预估将来的热点数据不止63%，也可以调整midpoint的值来减少热点数据被刷出的概率:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># innodb_old_blocks_pct默认值为37%, 即5/8</span>
mysql&gt; <span class="nb">set </span>global innodb_old_blocks_pct <span class="o">=</span> 20<span class="p">;</span>
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL主从复制</title>
	  <link>//MySQL-Replication</link>
	  <author></author>
	  <pubDate>2020-06-04T07:06:25+00:00</pubDate>
	  <guid>//MySQL-Replication</guid>
	  <description><![CDATA[
	     <p>MySQL的异步复制算的上是一种典型的单领导者复制模式，就复制本身而已并无特殊之处。但是复制的细节，例如binlog的格式选取，从节点如何在保证数据准确的情况下进行并行复制，MySQL的实现方案总是能令人眼前一亮。</p>

<!---more--->

<h3 id="1-binlog">1. binlog</h3>

<p>在经典的复制模型下，主节点和从节点的数据复制都是通过日志的传输进行的。例如Redis主从复制，复制的是<code class="highlighter-rouge">appendonly.aof</code>文件中的逻辑操作记录。又如Raft一致性算法，复制的是作为”日志项”的数据记录，<code class="highlighter-rouge">LogEntry</code>。而在MySQL中，则是使用binlog作为主节点和从节点的数据复制依据。</p>

<p>实际上，如果观察大多数数据库应用的话，会发现它们都会有逻辑日志这一概念，其中记录了对数据的逻辑增删改。一方面用于数据库在宕机时的数据恢复(Redis、MySQL)，另一方面则用于主从复制之中。</p>

<h4 id="11-binlog记录了哪些内容">1.1 binlog记录了哪些内容?</h4>

<p>有非常多的方式来查看binlog中的逻辑日志，一种是在MySQL-Client中查看，另一种则是直接查看位于硬盘中的binlog文件。前者其实也是读取位于硬盘中的binlog文件，只不过会对文件内容进行解析，并增加binlog内容的可读性。而后者则能够获取到更多的信息。</p>

<ul>
  <li>MySQL-Client</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">binary</span> <span class="n">logs</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">binlog</span> <span class="n">events</span> <span class="k">in</span> <span class="s1">'mysql-bin.000193'</span><span class="p">;</span>
</code></pre></div></div>

<p>所得到的结果如下所示:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/show-events.png" alt="" /></p>

<p>其中<code class="highlighter-rouge">Pos</code>表示该逻辑日志的起始位置，<code class="highlighter-rouge">End_log_pos</code>表示该逻辑日志的结束位置。<code class="highlighter-rouge">Event_type</code>表示事件名称，<code class="highlighter-rouge">Server_id</code>则是由用户配置的当前MySQL实例的集群ID，<code class="highlighter-rouge">Info</code>中记录了较为简短的逻辑事件。在起始位置为219的地方，实际上执行了一条<code class="highlighter-rouge">insert</code>语句，但是<code class="highlighter-rouge">Info</code>列中并没有给出详细信息。</p>

<ul>
  <li>mysqlbinlog</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span>mysqlbinlog <span class="nt">-vv</span> mysql-bin.000193
</code></pre></div></div>

<p>得到的输出结果如下:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span>
<span class="cm">/*!*/</span><span class="p">;</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">302</span>
<span class="o">#</span> <span class="err">中间省去一些注释内容</span>
<span class="cm">/*!*/</span><span class="p">;</span>

<span class="o">###</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="nv">`Mario`</span><span class="p">.</span><span class="nv">`hugo`</span>
<span class="o">###</span> <span class="k">SET</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">1</span><span class="o">=</span><span class="mi">7</span> <span class="cm">/* INT meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">2</span><span class="o">=</span><span class="s1">'2020-06-02 14:32:02'</span> <span class="cm">/* DATETIME(0) meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">3</span><span class="o">=</span><span class="s1">'2020-06-02 14:54:07'</span> <span class="cm">/* DATETIME(0) meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">4</span><span class="o">=</span><span class="s1">'nami'</span> <span class="cm">/* VARSTRING(256) meta=256 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">5</span><span class="o">=</span><span class="s1">'16399553366'</span> <span class="cm">/* VARSTRING(44) meta=44 nullable=0 is_null=0 */</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">428</span>
<span class="o">#</span><span class="mi">200602</span> <span class="mi">14</span><span class="p">:</span><span class="mi">54</span><span class="p">:</span><span class="mi">07</span> <span class="n">server</span> <span class="n">id</span> <span class="mi">1</span>  <span class="n">end_log_pos</span> <span class="mi">459</span> <span class="n">CRC32</span> <span class="mi">0</span><span class="n">x27a642a3</span> 	<span class="n">Xid</span> <span class="o">=</span> <span class="mi">146</span>
<span class="k">COMMIT</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">459</span>
</code></pre></div></div>

<p>其输出内容要比<code class="highlighter-rouge">show binlog events</code>更加完整，除了事务的起始位置和结束位置以外，还包括事务的执行时间，以及完整的数据记录、相关字段的注释。所以，当需要查看binlog的详细内容时，尽量使用<code class="highlighter-rouge">mysqlbinlog</code>命令行工具。</p>

<h4 id="12-binlog日志格式">1.2 binlog日志格式</h4>

<p>MySQL一共提供了3种binlog日志格式，分别是<code class="highlighter-rouge">STATEMENT</code>，<code class="highlighter-rouge">ROW</code>以及<code class="highlighter-rouge">MIXED</code>。</p>

<ul>
  <li>查看当前binlog_format格式</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="nv">"binlog_format"</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>在线修改binlog_format格式</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="k">global</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="k">STATEMENT</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="k">global</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="k">ROW</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="k">global</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="n">MIXED</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">STATEMENT</code>日志格式仅记录用户所执行的SQL语句，用户执行什么，binlog就记录什么，属于最节省硬盘空间的一种日志格式。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/STATEMENT.png" alt="" /></p>

<p>但是，无论是出于数据恢复的考虑，还是出于主从复制的目的，都不应该将binlog格式设置为<code class="highlighter-rouge">STATEMENT</code>。其原因在于<code class="highlighter-rouge">STATEMENT</code>格式的日志依赖于执行SQL时的上下文，例如日期函数，<code class="highlighter-rouge">rand</code>函数，不同的执行环境下得到的结果可能并不相同，从而导致主从的数据不一致。而对于数据恢复而言，当然是数据越详细越完整更好。</p>

<p><code class="highlighter-rouge">ROW</code>日志格式将记录完整的数据变更记录，每一条<code class="highlighter-rouge">insert</code>语句都会记录每个字段的插入值，对于<code class="highlighter-rouge">update</code>语句，则会记录数据更新前和更新后的完整数据(<code class="highlighter-rouge">binlog_row_image</code>值为<code class="highlighter-rouge">FULL</code>)。其缺点就是占用硬盘空间较多，假设一条<code class="highlighter-rouge">update</code>语句更新了10万条数据，那么在<code class="highlighter-rouge">ROW</code>格式的binlog中则同样会记录10万条数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/ROW.png" alt="" /></p>

<p><code class="highlighter-rouge">MIXED</code>日志格式结合了<code class="highlighter-rouge">STATEMENT</code>和<code class="highlighter-rouge">ROW</code>日志格式，当MySQL认为当前SQL语句不会引起歧义，即不会导致主从不一致时，将使用<code class="highlighter-rouge">STATEMENT</code>格式记录，反之使用<code class="highlighter-rouge">ROW</code>格式进行记录。节省了一部分的硬盘使用空间，同时又能够保证数据在主从之间的一致性。</p>

<p>在实际应用中，应将binlog日志格式最低设置为<code class="highlighter-rouge">MIXED</code>，如果磁盘空间确实比较紧张的话。否则，就应该将binlog日志格式设置为<code class="highlighter-rouge">ROW</code>，该格式对于数据的误删操作恢复有非常大的帮助。</p>

<h4 id="13-binlog_row_image">1.3 binlog_row_image</h4>

<p>当<code class="highlighter-rouge">binlog_format</code>的值为<code class="highlighter-rouge">ROW</code>时，还有一个控制binlog日志记录的参数: <code class="highlighter-rouge">binlog_row_image</code>。该参数同样有3个可选项: <code class="highlighter-rouge">FULL</code>，<code class="highlighter-rouge">MINIMAL</code>以及<code class="highlighter-rouge">NOBLOB</code>。该参数控制了<code class="highlighter-rouge">ROW</code>格式的binlog日志在写入数据时是否写入完整数据。</p>

<p><code class="highlighter-rouge">FULL</code>将会记录数据修改前后的完整字段，包括未被修改的字段:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/FULL.png" alt="" /></p>

<p><code class="highlighter-rouge">MINIMAL</code>则采用最小记录原则，仅记录修改行的关键定位信息(例如主键或者唯一键)，以及最终被修改的字段的修改值，而不会记录那些没有被修改的字段:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/MINIMAL.png" alt="" /></p>

<p><code class="highlighter-rouge">NOBLOB</code>和<code class="highlighter-rouge">FULL</code>非常类似，会记录完整的字段修改前后数据，只不过不会记录未被修改的、且字段类型为BLOG或TEXT的数据，实际应用较少。</p>

<p>在主从复制中，如果主库网络带宽或者从库网络带宽无法立即升级，并且同步的日志量较大时，可临时的将<code class="highlighter-rouge">binlog_row_image</code>参数由<code class="highlighter-rouge">FULL</code>更改为<code class="highlighter-rouge">MINIMAL</code>，减少一部分的网络带宽使用。</p>

<h3 id="2-异步复制模型">2. 异步复制模型</h3>

<p>对于异步复制模型而言，从原理上来说，只需要将逻辑日志不断地发送给所有的从节点，让从节点重新执行逻辑日志的内容即可，也不需要关心从节点是否接收成功并且执行成功。</p>

<p>MySQL的异步复制模型也确实如此。主节点开启<code class="highlighter-rouge">binlog dump</code>线程，用于锁定地读取binlog内容，并通过TCP长连接发送给从节点。而对于从节点来说，将会开启一个<code class="highlighter-rouge">slave I/O</code>线程，用于和主节点建立TCP连接，以及接收主节点发送的binlog逻辑日志，并将接收到的数据写入自身的中继日志(relay log)文件中。另外的一个线程，即<code class="highlighter-rouge">slave SQL</code>线程，将不断地读取中继日志数据，并执行其中的逻辑SQL语句。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/master-slave.png" alt="" /></p>

<h4 id="21-为什么需要relay-log中继日志">2.1 为什么需要relay log(中继日志)?</h4>

<p>从节点在接收到主节点发送的binlog日志之后，并没有直接执行，而是存储在relay log中，由另外一个线程读取该文件的数据并执行。那么MySQL为什么要使用这种会降低复制效率的设计?</p>

<p>个人认为原因有两点，一方面relay log可以作为日志同步的缓冲区。主节点发送日志的速度可能要大于从节点执行日志的速度，此时就需要一个缓冲区来弥补两者之间的速度差，避免主节点发送的binlog被阻塞在socket缓冲区中。</p>

<p>另外一个作用就是利于故障时的问题排查。relay log的结构与binlog非常相似，通过在从节点持久化一份主节点发送的日志，那么在出现故障时，可查看该文件的内容来大致地判断是主节点出了问题，还是从节点出了问题。</p>

<p>这种数据冗余的设计在业务系统设计中其实也非常实用，相较于直接执行外部发送的数据，采用”生产者-消费者”模型将会有更好的健壮性: 在微服务中，”数据同步”是一件极易出错，且令人无比蛋疼的苦差事。当保留源数据，并在源数据的基础之上开展业务的话，能避免许多麻烦。</p>

<h3 id="3-并行复制">3. 并行复制</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/master-slave-load.png" alt="" /></p>

<p>在主节点中，由于存在各种各样的<code class="highlighter-rouge">Lock</code>， 例如共享锁，排它锁，意向锁等等，使得事务可以并发执行，而无需担心数据不一致的问题。但是，在从节点如果想要并发执行binlog中的内容，并不是一件容易的事情，其原因在于事务和事务之间并不是完全独立存在的，而是存在依赖性。</p>

<p>如上图所示，从节点Execute中继日志的内容将会成为主从复制最后的延迟点，同时，也可能是最大的延迟点: 因为<code class="highlighter-rouge">binlog dump</code>线程以及<code class="highlighter-rouge">slave I/O</code>线程均是对文件的顺序读取和写入，而<code class="highlighter-rouge">slave SQL</code>线程在执行语句时，则没有那么简单。</p>

<h4 id="31-并行复制所面对的问题">3.1 并行复制所面对的问题</h4>

<p>假设现在有3个事务并发执行，且修改的是同一行数据，并且事务提交的顺序为<code class="highlighter-rouge">TRX-1</code>，<code class="highlighter-rouge">TRX-2</code>，<code class="highlighter-rouge">TRX-3</code>，则数据的新旧程度为: <code class="highlighter-rouge">TRX-3</code> &gt; <code class="highlighter-rouge">TRX-2</code> &gt; <code class="highlighter-rouge">TRX-1</code>。</p>

<p>当从节点SQL执行线程读取中继日志时，并不知道这3个事务是修改的同一条数据，如果只是简单地将这3个事务分配给3个Worker执行的话，完全有可能发生旧数据覆盖新数据的情况，即<code class="highlighter-rouge">TRX-1</code>最后被执行，<code class="highlighter-rouge">TRX-3</code>的最新更新将会丢失，导致从节点和主节点的数据不一致。</p>

<h4 id="32-基于table的并行复制">3.2 基于table的并行复制</h4>

<p>如果两个事务是对不同的表进行操作，那么这两个事务即可并行执行。处理方式也非常简单，对表名称进行哈希，并对结果进行worker数量的取模，将该事务分发至对应的worker即可。</p>

<p>但是，如果事务同时对多张表进行了修改的话，上述模型就会出现问题: 该事务应该分配给哪个worker? 所以，还需要记录每个线程中有哪些事务正在执行或者排队，操作的是哪些表。对于线程私有变量，可以使用<code class="highlighter-rouge">ThreadLocal</code>来实现，外部也可方便的获取线程中的私有内容。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/parallel-with-table.png" alt="" /></p>

<p>如上图所示，Assigner线程读取relay log中的内容，并对数据进行解析，决定将该事物分配给哪个worker执行。worker线程则是事务的执行线程，并且使用哈希表记录下当前线程队列中有多少个事务正在修改哪些表。其中key为表名称，value为队列中有多少事务修改该表。</p>

<p>当Assigner读取到只修改table-1的事务时，遍历所有worker的哈希表，判断是否有其它worker正在执行关于table-1的事务，发现只有worker-1存在，那么将会直接将其分发至worker-1线程，并将事务追加至该worker的队列中，以此保证对同一个表的操作串行执行。</p>

<p>当Assigner读取到同时修改table-1和table-3的事务时，首先根据解析规则获取到这两个表应该被分配的worker，然后取出两个队列中正在对table-1和table-3所修改的事务数量。发现worker-1存在对table-1的事务，而worker-2对table-3的修改事务数量为0，那么Assigner将会将该事务分配给worker-1。</p>

<p>当Assigner读取到同时修改table-1和table-4的事务时，发现worker-1和worker-2都存在对两个表的修改，那么Assigner将会等待，等待worker-1对table-1的修改事务数量为0，或者是worker-2对table-4的修改事务数量为0。</p>

<p>在大多数情况下基于表的并行复制策略能够快速地执行，但是，如果遇到热点表的话，该热点表仍然是串行复制，同样会出现效率问题。</p>

<h4 id="33-基于行的并行复制">3.3 基于行的并行复制</h4>

<p>既然基于表的并行复制会有热点表的问题，那么基于行的并行复制总没有热点表的问题了吧? 并且同一条数据的修改频率并不会特别高。基于行的并行复制虽然能够有着更快的执行效率，但是同样地带来的更多的内存开销和CPU计算开销。</p>

<p>在基于行的并行复制中，至少需要记录下所有正在被修改或者是已经在队列中的行数据，那么显而易见的，worker线程中的哈希表将会有存在大量的数据。所以综合来看，基于行的并行复制并不是一个好的选择，甚至可以说是一个比较差的选择。</p>

<p>但是，MySQL针对基于行的复制进行了优化，将判断两个事务是否存在”冲突”(即是否更新了同一行)由从节点转移至主节点。MySQL会记录下更新的每一行的哈希值，组成一个集合。为了能够唯一标识同一行，哈希值通常由”库名+表名+唯一索引名+唯一索引值”计算得到，而唯一索引通常是主键。</p>

<p>如果两个事务没有同时更新同一条数据，那么两个事务的集合就不存在交集，它们是可以并行执行的。并且该哈希值集合是在主节点写入binlog时即计算好的，不需要从节点再次解析binlog event，节省了从节点的一部分计算资源。</p>

<h4 id="34-基于group-commit的并行复制">3.4 基于Group Commit的并行复制</h4>

<p>InnoDB存储引擎是通过redo log + binlog来实现事务的原子性以及持久性的，为了保证数据的一致性，两个日志的数据写入通过”两阶段提交”完成，并且使用组提交(Group Commit)来提高事务的并发效率。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/LSN-Commit.png" alt="" /></p>

<p>当未使用组提交时，当<code class="highlighter-rouge">trx:1</code>提交，仅将该事务的数据持久化至redo log以及binlog中，当有两万个事务并发执行时，将需要执行四万次<code class="highlighter-rouge">fsync</code>系统调用。</p>

<p>当使用组提交时，当<code class="highlighter-rouge">trx:1</code>提交，redo log buffer中可能存在多个事务的物理页修改，那么此时<code class="highlighter-rouge">trx:1</code>将会作为Leader，将当前最大的LSN redo log持久化至磁盘，以减少<code class="highlighter-rouge">fsync</code>的系统调用次数。并且，为了尽可能多地在一次写入中写入更多的数据，InnoDB还会推迟redo log的<code class="highlighter-rouge">fsync</code>过程。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/delay-fsync.png" alt="" /></p>

<p>更具体的上下文请参考文章: <a href="https://smartkeyerror.com/InnoDB-AD">InnoDB如何保证事务的原子性与持久性</a></p>

<p><strong>假设多个事务能够同时进入prepare阶段，那么这些事务一定能够并行执行。</strong> 接下来分析一下这句话的正确性:</p>

<ol>
  <li>事务A和事务B并发执行，准备修改同一条数据。由于X Lock的存在，当一个事务修改数据时，另一个事务将会被阻塞，等待前一个事务<strong>提交</strong>。</li>
  <li>假设事务A首先获得了X Lock，成功修改了数据并提交了事务。而此时，事务B仍然处于运行中，在获取到数据的X Lock之后才开始执行自己的修改。</li>
</ol>

<p>所以，<strong>只要是能够同时进入prepare的阶段，事务一定是经过了锁冲突的检验，一定能够在从库并行执行</strong>。</p>

<p>如此一来，当redo log在使用最大的LSN持久化至磁盘时，使用一个<code class="highlighter-rouge">commit_id</code>对该事务进行标记。下次的redo log持久化将<code class="highlighter-rouge">commit_id</code>自增。从库在并行执行binlog event是，只要是相同的<code class="highlighter-rouge">commit_id</code>，就使其并发执行。</p>

<h4 id="35-mysql提供的并行复制配置项">3.5 MySQL提供的并行复制配置项</h4>

<p>MySQL一共提供了三种并行复制策略，由参数<code class="highlighter-rouge">binlog_transaction_dependency_tracking</code>控制(MySQL版本大于5.7.22)。</p>

<ul>
  <li>COMMIT_ORDER: 利用Group Commit机制进行并行执行。</li>
  <li>WRITESET: 基于行的并行执行。</li>
  <li>WRITESET_SESSION: 建立在WRITESET策略之上，只不过多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li>
</ul>

<p>其中COMMIT_ORDER为默认策略，当使用该策略时，可以调整<code class="highlighter-rouge">binlog_group_commit_sync_delay</code>以及<code class="highlighter-rouge">binlog_group_commit_sync_no_delay_count</code>来使得主节点更慢的提交，使从节点更快的执行事务。</p>

<p>当主节点事务执行的并发度较高时，可以选择COMMIT_ORDER策略。当主节点事务执行并发度并不高，并且趋近于单线程或者双线程时，可选择WRITESET策略。</p>

<h3 id="4-主从延迟来源">4. 主从延迟来源</h3>

<h4 id="41-从节点硬件资源不足">4.1 从节点硬件资源不足</h4>

<p>有时候我们会认为从库只负责读请求，而不处理客户端的写请求，所以从库的内存、硬盘以及CPU都可以使用较低配置。但事实上，从库需要处理的数据写入并不会比主库要少，同时还要处理比主库更多的读请求。因此，从库的硬件资源应该至少和主库相同，甚至可以高于从库。</p>

<p>通过<code class="highlighter-rouge">top</code>或者是<code class="highlighter-rouge">htop</code>可以很清晰的得到从节点的内存以及CPU使用率，使用<code class="highlighter-rouge">iostat</code>查看从节点的磁盘I/O活动情况。<code class="highlighter-rouge">iostat</code>有几个非常关键的指标:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span>iostat <span class="nt">-m</span>
Linux 4.15.0-101-generic <span class="o">(</span>Zero<span class="o">)</span>         2020年06月04日  _x86_64_        <span class="o">(</span>8 CPU<span class="o">)</span>

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           4.93    0.01    2.58    0.59    0.00   91.88
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">%iowait</code>表示CPU等待输入输出完成时间的百分比，<code class="highlighter-rouge">%idle</code>表示CPU空闲百分比。如果<code class="highlighter-rouge">%iowait</code>的值较高，说明硬盘存在I/O瓶颈; 如果<code class="highlighter-rouge">%idle</code>持续较低，说明系统的CPU处理能力较弱，此时应处理CPU资源。</p>

<h4 id="42-主节点大事务与从节点长事务">4.2 主节点大事务与从节点长事务</h4>

<p>大事务是指更新了较多数据行的事务，当从节点重放大事务的binlog event时，不管是使用<code class="highlighter-rouge">COMMIT_ORDER</code>还是<code class="highlighter-rouge">WRITESET</code>并行复制策略，后续操作均需要等待该事务的执行，事务执行所需要的执行时间越久，主从延迟就会越高。所以，尽量地将大事务拆分成多个小事务执行。</p>

<p>从节点长事务同样也可能导致主从延迟的产生。例如，当从库开启了一个长事务:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">hugo</span> <span class="k">WHERE</span> <span class="n">username</span> <span class="o">=</span> <span class="nv">"smart"</span><span class="p">;</span>
</code></pre></div></div>

<p>执行完<code class="highlighter-rouge">SELECT</code>语句之后因为种种原因长时间未提交事务，那么此时若主库对该表进行了DDL操作，即使<code class="highlighter-rouge">hugo</code>表只有几行数据，也会长时间的阻塞: 因为此时DDL操作无法获取到<code class="highlighter-rouge">hugo</code>表的意向排它锁(IX)。</p>

<p>如果主表的DDL操作在白天进行，并且恰好存在对该表的某一个长事务的话，即使不是高峰期也会带来非常大的主从延迟。</p>

<h4 id="43-从节点未开启并行复制">4.3 从节点未开启并行复制</h4>

<p>从节点的并行执行worker数量由<code class="highlighter-rouge">slave_parallel_workers</code>参数决定，最大值为1024，通常将其设置为CPU核心数的一半。</p>

	  ]]></description>
	</item>

	<item>
	  <title>InnoDB如何保证事务的原子性与持久性</title>
	  <link>//InnoDB-AD</link>
	  <author></author>
	  <pubDate>2020-05-28T18:06:25+00:00</pubDate>
	  <guid>//InnoDB-AD</guid>
	  <description><![CDATA[
	     <p>在InnoDB存储引擎中，一个事务的执行将涉及到3个日志的数据写入: redo log，undo log以及binlog。其中redo log以及binlog主要实现事务的原子性和持久性，而undo log主要用于实现事务的隔离性。</p>

<!---more--->

<h3 id="1-redo-log">1. redo log</h3>

<p>redo log又称之为重做日志，主要记录了事务对数据页(Page)的物理修改。redo log由两部分组成: 一是位于内存的redo log buffer，用于对redo log进行缓冲，目的在于提升性能。另一部分则位于硬盘中，用于对redo log的持久化。</p>

<h4 id="11-redo-log-buffer">1.1 redo log buffer</h4>

<p>redo log buffer用于优化redo log的写入性能，默认大小为16MB，最大大小为4GB。当一个事务对数据页进行修改时，首先将修改内容放置于缓冲中，而后再对其进行持久化。</p>

<h4 id="12-redo-log">1.2 redo log</h4>

<p>默认情况下，redo log由两个文件构成，<code class="highlighter-rouge">ib_logfile0</code>以及<code class="highlighter-rouge">ib_logfile1</code>。redo log的大小由配置文件决定，在5.7版本中，默认大小为48MB。由于其大小固定，所以数据在写入该日志文件时，将使用循环写入的方式: 首先从头开始写，写到末尾，然后再从头开始写，后面写入的内容会覆盖最初的内容，所以称之为循环写入。</p>

<p>redo log的文件大小设置和MySQL的负载相关，通常来说redo log应该能容纳至少一个小时的数据修改，一般<code class="highlighter-rouge">innodb_log_file_size</code>设置为1GB，<code class="highlighter-rouge">innodb_log_files_in_group</code>设置为4，总计4GB的redo log容量。重做日志大小如果设置的过大，宕机恢复时所花的时间也会越多，所以并不是越大越好。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/redo-log.png" alt="" /></p>

<p>redo log buffer中的数据将会在以下时机持久化至位于磁盘的redo log中:</p>

<ul>
  <li>事务提交</li>
  <li>当redo log buffer有一半的空间已经被使用时</li>
  <li>InnoDB后台线程每秒将数据持久化至硬盘</li>
</ul>

<p>所以，需要明确的是，当某个事务未提交(commit)时，该事务对物理数据页的修改也可能会持久化至redo log文件中。</p>

<h4 id="13-lsn">1.3 LSN</h4>

<p>在redo log中，还有一个非常重要的属性: LSN，Log Sequence Number，即日志序列号。接下来我们将会看到，LSN在数据恢复以及Group Commit中起到了决定性的作用。</p>

<p>在InnoDB存储引擎中，LSN占用8个字节，且单调递增。LSN所表示的含义包括redo log的总量，checkpoint的位置以及数据页的版本。</p>

<p>假设当前redo log的LSN为1000，事务T1写入了200字节的redo log，那么LSN将递增至1200。若事务T2写入了500字节的redo log，那么LSN又将变成1700。所以通过查看LSN的大小即可知道redo log的总量，单位为字节。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; show engine innodb status<span class="se">\G</span><span class="p">;</span>
<span class="nt">---</span>
LOG
<span class="nt">---</span>
Log sequence number 20598039739
Log flushed up to   20598039739
Pages flushed up to 20598039739
Last checkpoint at  20598039730
0 pending log flushes, 0 pending chkp writes
10 log i/o<span class="s1">'s done, 0.00 log i/o'</span>s/second
</code></pre></div></div>

<p>如上所示，Log sequence number表示当前的LSN，Log flushed up to表示已经刷新到redo log文件的LSN。</p>

<h3 id="2-binlog">2. binlog</h3>

<p>binlog为MySQL层面的逻辑日志，用于记录对哪一行数据进行了哪些修改，不管使用何种存储引擎，都会有binlog的记录。redo log则是InnoDB存储引擎所特有的日志记录，并且其中记录的是对物理数据页的修改。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/logical-binlog.png" alt="" /></p>

<p>关于binlog的更多内容将在后续的MySQL主从复制中描述。</p>

<h3 id="3-事务执行过程">3. 事务执行过程</h3>

<p>InnoDB存储引擎在提交事务时，为了保证原子性和持久性，将会采用”两阶段”提交的方式写入redo log和binlog。</p>

<h4 id="31-一阶段">3.1 一阶段</h4>

<p>首先，在MySQL中所有执行的SQL语句都会有一个全局递增且循环使用的query_id。当用户开启事务并执行语句后，MySQL将会把第一个语句的query_id分配给该事务，作为Xid的值。</p>

<p>当用户执行<code class="highlighter-rouge">COMMIT</code>提交事务时，将redo log buffer的内容调用<code class="highlighter-rouge">write()</code>系统调用写入内核缓冲区，并调用<code class="highlighter-rouge">fsync()</code>系统调用确保数据写入至硬盘(至少是硬盘的缓冲区)，更新状态为prepare。</p>

<h4 id="32-二阶段">3.2 二阶段</h4>

<p>将产生的binlog调用<code class="highlighter-rouge">write()</code>系统调用写入内核缓冲区，并调用<code class="highlighter-rouge">fsync()</code>系统调用将数据持久化至硬盘，写入成功后事务即可被提交，并更新状态为commit。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/2PC.png" alt="" /></p>

<p>当数据成功地写入到binlog以后，即可返回给用户事务提交成功。由于数据写入<code class="highlighter-rouge">.ibd</code>文件需要随机读写，所以将会由其它线程异步写入，以提高事务执行的效率。</p>

<p>现在来看两阶段提交在数据库Crash的情况:</p>

<ul>
  <li>binlog有记录，但redo log状态为prepare: 此时表示在写入binlog数据库崩溃，需要根据binlog进行数据恢复</li>
  <li>binlog有记录，redo log状态为commit: 事务正常提交，无需恢复</li>
  <li>binlog无记录，redo log状态为prepare: 事务执行一半时崩溃，无需恢复</li>
  <li>binlog无记录，redo log状态为commit: 在binlog持久化时崩溃，事务直接回滚</li>
</ul>

<p>可以看到，通过上述的两阶段提交方式能够保证不会产生脏事务，并且已成功提交的事务也能够在MySQL崩溃后重启恢复。</p>

<p>当redo log和binlog均正确的写入数据以后，就可以返回<code class="highlighter-rouge">OK</code>给用户了。至于何时将用户的修改持久化至<code class="highlighter-rouge">.ibd</code>文件中，由MySQL后台线程决定。</p>

<p>基于redo log和binlog的WAL(Write-Ahead Log)机制可以保证数据的原子性以及持久性，并且由于日志是顺序读写，所以事务的执行速度会快很多。</p>

<h3 id="4-group-commit">4. Group Commit</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/2PC.png" alt="" /></p>

<p>从上图模型可以看到，每一个事务的提交，都会伴随着两次<code class="highlighter-rouge">write()</code>以及<code class="highlighter-rouge">fsync()</code>系统调用。对于<code class="highlighter-rouge">Write()</code>调用来说，仅仅只是将用户缓冲区的内容写入至内核缓冲区中，虽然会有用户态与内核态的切换，但是仍然要比<code class="highlighter-rouge">fsync()</code>要快。</p>

<p>如果采用上述模型实现事务的话，如果有两万个并发事务执行，那么磁盘的IO负载将会达到四万，并且事务的执行效率将会非常之差。</p>

<p>为了解决事务执行效率问题，MySQL引入了组提交(Group Commit)技术: 在事务提交时，尽可能多地向文件中写入数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/LSN-Commit.png" alt="" /></p>

<p>如上图所示，共有3个事务并行执行，其中trx:1事务准备提交。按照之前的模型，将trx:1的redo log写入至磁盘中，并将binlog写入至磁盘中。</p>

<p>而在Group Commit中，当trx:1准备提交时，将会刷新最大的LSN之前未刷新的所有redo log。在该示例中，trx:1准备刷新时，则会将LSN为1600之前的所有redo log一齐刷新至磁盘。原来需要6次系统调用，现在只需要2次。</p>

<p>为了能够让redo log在每次写入时尽可能多的写入，MySQL将redo log调用<code class="highlighter-rouge">fsync()</code>的时机延迟，延迟至binlog调用<code class="highlighter-rouge">write()</code>之后:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/delay-fsync.png" alt="" /></p>

<p>这样一来，binlog也能够组提交了，能够有效地减少IOPS的消耗。</p>

<p>MySQL额外的提供了两个延迟参数来提高binlog的组提交效率:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 表示延迟多少微秒后才调用binlog的fsync()</span>
binlog_group_commit_sync_delay

<span class="c"># 表示累积了多少个binlog才调用binlog的fsync()</span>
binlog_group_commit_sync_no_delay_count
</code></pre></div></div>

<p>这两个参数为”或”关系，即只要满足一个条件，就会调用<code class="highlighter-rouge">fsync()</code>。当磁盘IO出现性能瓶颈时，可根据实际负载来设置该值，从而降低磁盘IO负载，代价是会增加事务的响应时间。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Linux主机通过Windows虚拟机转发Easyconnect内网请求</title>
	  <link>//Linux-Use-EasyConnect</link>
	  <author></author>
	  <pubDate>2020-02-27T12:06:25+00:00</pubDate>
	  <guid>//Linux-Use-EasyConnect</guid>
	  <description><![CDATA[
	     <p>世界上有个恶心的公司叫Sangfor，开发出了恶心的工具EasyConnect，本来这东西都是给在校的学生用的，好不好用都无所谓。但是很多公司也开始使用这个来访问内网，并且还不支持Linux(反正到目前Ubuntu下的64bit版本连接就没成功过)，这就很令人讨厌了。回想起Ubuntu下使用Wine安装微信的种种难受，决定还是使用Windows虚拟机开启EasyConnect，并把部分的Linux流量打进虚拟机。</p>

<!---more--->

<h4 id="1-虚拟机配置">1. 虚拟机配置</h4>
<p>虚拟机需要两块网卡，其中一块必须是Host-only类型的，用来和Linux主机通信，这块儿网卡是内网流量的入口，所以必须配置。另一块可以是NAT，也可以是Bridge，随个人喜好。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/VMware-Network-Config.png" alt="" /></p>

<h4 id="2-windows虚拟机网络配置">2. Windows虚拟机网络配置</h4>

<p>进到Windows虚拟机以后，打开网络适配器设置，这时候可以看到两张网卡: Ethernet0和Ethernet1，找到Host-only那张网卡，并修改其名称为<code class="highlighter-rouge">Host</code>，起一个有意义的名称对后面的操作非常有帮助。如果不确定哪张网卡是Host-only的话，可以对比网卡的MAC地址和虚拟机网络配置中的MAC地址。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/Ethernet.png" alt="" /></p>

<p>开启EasyConnect，并建立与内网的连接，此时会多出一张名为”以太网”的网卡，这张网卡的IP地址子网掩码什么的都可以不用管，就是张工具卡。设置该网络的共享属性，和前面建立的Host-only网卡建立共享。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/share-with-host-only.png" alt="" /></p>

<p>设置完成以后会发现Host-only那张网卡的IP地址被强制更改成了192.168.137.1，改了就改了吧，也不是不能用。</p>

<p>并关闭Windows的公用网络防火墙，不然数据包会被防火墙拦截。</p>

<h4 id="3-设置linux路由规则">3. 设置Linux路由规则</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>ip a add 192.168.137.2/24 dev vmnet1
<span class="nb">sudo </span>ip r add 10.0.0.0/8 via 192.168.137.1
</code></pre></div></div>

<p>给vmnet1，也就是Host-only网卡添加一个和192.168.137.2相同IP地址段的IP地址，使Linux能够建立正常的路由转发规则，否则Linux主机根本就不知道192.168.137.1这个IP地址是谁的。然后将所有的内网(10.0.0.0/8)请求都通过192.168.137.1走Windows的内网网络。</p>

<h4 id="4-windows安装ccproxy">4. Windows安装CCProxy</h4>

<p>对于某些需要域名解析的HTTP请求，又不想用dnsmasq去自己解析DNS，就可以直接用该工具进行转发，下载、安装和使用傻瓜式操作，完美，非常适合我这种智商不高的人。</p>

<p>安装完成以后设置下本机局域网IP地址，选择NAT或者是Bridge的那张网卡即可:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/CCProxy.png" alt="" /></p>

<p>由于我的Chrome用了SwitchOmega，并不想牺牲某些便利，所以使用Firefox进行代理设置，内网的HTTP请求以后就用Firefox发送，流量使用分明，代理配置也尽量分开。</p>

<p>Firefox中输入<code class="highlighter-rouge">about:preferences</code>，拉到最底下，选择Network Settings，就可以进行代理设置了。</p>

<p>CCProxy的HTTP协议默认端口为808，IP地址则是NAT或者Bridge网卡的IP地址，进行配置即可:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/Firefox-Config.png" alt="" /></p>

<p>需要注意的是FTP端口为2121，SOCKS端口为1080，因为我不需要这两个协议，所以并没有配置。</p>

<p>完)</p>

	  ]]></description>
	</item>


</channel>
</rss>
