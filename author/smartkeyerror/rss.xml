<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description>Keep coding, Keep curiosity</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>MySQL向客户端发送数据，客户端不接收会发生什么?</title>
	  <link>//MySQL-Sending-Data</link>
	  <author></author>
	  <pubDate>2020-06-17T10:50:25+00:00</pubDate>
	  <guid>//MySQL-Sending-Data</guid>
	  <description><![CDATA[
	     <p>MySQL服务端在发送数据时，为了减少数据在用户空间和内核空间的复制次数，往往会使用缓冲区对数据进行缓冲。那么，如果客户端在接收大量数据时，选择不接收，或者处理非常慢的时候，会影响MySQL的正常运行吗?</p>

<!---more--->

<h3 id="1-tcp连接的收发模型">1. TCP连接的收发模型</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/TCP-buffer.png" alt="" /></p>

<p>当调用<code class="highlighter-rouge">write()</code>或者<code class="highlighter-rouge">send()</code>系统调用向socket写入数据时，并不会直接被发送至网络，而是被发送至位于内核空间的TCP发送缓冲区。在缓冲区中，由TCP连接的窗口控制发送频率和数量。当发送缓冲区已满时，阻塞模式下的<code class="highlighter-rouge">write()</code>调用将会一直阻塞，直到有可用的发送缓冲区为止。而非阻塞模式下则会直接返回-1，<code class="highlighter-rouge">errno</code>将会被置为<code class="highlighter-rouge">EAGAIN</code>或者是<code class="highlighter-rouge">EWOULDBLOCK</code>。</p>

<p>对于<code class="highlighter-rouge">read()</code>或者是<code class="highlighter-rouge">recv()</code>系统调用读取socket数据时，情况和发送数据基本类似，只不过是读取接收缓冲区中的内容。阻塞模式下如果接收缓冲区为空，那么将会阻塞，而非阻塞模式下则会立即返回，<code class="highlighter-rouge">errno</code>为<code class="highlighter-rouge">EAGAIN</code>或者是<code class="highlighter-rouge">EWOULDBLOCK</code>。</p>

<p>接收方与发送方的窗口大小、MSS大小以及网络状况都会对发送缓冲区的动态大小变化造成影响。当接收方的缓冲区较小时，也就意味地接收窗口较小，那么当发送方持续发送数据时，很有可能将发送缓冲区填满导致发送方数据写入的阻塞。同样地，如果发送方的网络出现波动导致大量的丢包，由拥塞避免阶段重新进入慢启动阶段，也会导致发送缓冲区的数据不能及时地发出。</p>

<p>在一般的Linux操作系统下，发送缓冲区和接收缓冲区的的大小默认为208K。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span><span class="nb">cat</span> /proc/sys/net/core/wmem_default
212992
smartkeyerror@Zero:~<span class="nv">$ </span><span class="nb">cat</span> /proc/sys/net/core/rmem_default
212992
</code></pre></div></div>

<h3 id="2-mysql结果发送与客户端接收">2. MySQL结果发送与客户端接收</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/MySQL-Send.png" alt="" /></p>

<p>当客户端向MySQL请求查询数据时，MySQL会将结果暂存于net_buffer中，net_buffer的大小默认为16K，由参数<code class="highlighter-rouge">net_buffer_length</code>决定。当net_buffer已满或者是无更多结果时，调用网络接口将数据写入至TCP连接的发送缓冲区中。如果发送缓冲区已满，那么该查询请求的数据发送将会阻塞，直到有可用的发送缓冲区为止。</p>

<p>当TCP发送缓冲区已满时，通过<code class="highlighter-rouge">show processlist</code>将会得到Query语句”正在发送给客户端”的结果:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/Sending-To-Client.png" alt="" /></p>

<p>当出现State为<code class="highlighter-rouge">Sending to client</code>的查询语句时，表示当前线程已将TCP发送缓冲区填满，无法继续发送数据给客户端，并等待客户端接收数据。</p>

<p>如果出现了较多的<code class="highlighter-rouge">Sending to client</code>状态的线程，那么要么是客户端网络情况较差，要么是客户端在处理结果时过慢，此时需要优化客户端代码。</p>

<p><code class="highlighter-rouge">Sending to client</code>状态需要和<code class="highlighter-rouge">Sending data</code>状态区分开来，前者表示正在等待客户端接收结果，而后者则表示事务正在执行(不一定在发送数据，也可能在等待锁)。</p>

<h3 id="3-客户端不接收mysql的发送数据会发生什么">3. 客户端不接收MySQL的发送数据会发生什么?</h3>

<h4 id="31-innodb的一致性非锁定读">3.1 InnoDB的一致性非锁定读</h4>

<p>在InnoDB存储引擎中，每条UPDATE语句都会默认的在该TABLE上添加一个意向写锁(IX Lock)，并且在要修改的数据行上添加X Lock，防止其它线程对其同时更新。而在这个过程中，普通的数据读取操作依然能够进行，并不会等待X Lock的释放，极大的提升了数据库的并发读取能力，该读取方式称为一致性非锁定读，由undo段实现。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/MySQL-Send-Buffer/undo-read.png" alt="" /></p>

<p>在undo段中，同一行数据可能因为事务并发的执行而导致出现多个版本的快照，在一致性非锁定读中，只需要选择其中一个快照数据进行读取即可。在RC隔离级别，总是读取最新版本的快照数据，而在RR隔离级别下，总是读取事务开始时的行数据版本。</p>

<h4 id="32-sending-to-client导致undo段迅速膨胀">3.2 <code class="highlighter-rouge">Sending to client</code>导致undo段迅速膨胀</h4>

<p>当服务端出现大量的线程处于<code class="highlighter-rouge">Sending to client</code>状态时，所执行的查询语句未完成，那么会导致长事务的产生。而如果此时数据更新较为频繁时，将会导致undo段空间迅速膨胀，因为长事务的进行导致undo页无法被回收。</p>

<p>最常见的例子就是使用<code class="highlighter-rouge">mysqldump</code>对数据进行热备时，备份存储节点的磁盘已满，导致<code class="highlighter-rouge">mysqldump</code>无法向备份文件中写入数据。数据由客户端的接收缓冲区开始堆积，到服务端的发送缓冲区，再到<code class="highlighter-rouge">net_buffer</code>，最终可能会导致undo段的数据堆积，使得MySQL服务出现大面积的异常。</p>

<h3 id="4-小结">4. 小结</h3>

<p>综上，客户端如果在处理MySQL发送的大量数据时，应该尽可能地将其暂存在本地的某个缓冲区中，而后应用程序想怎么处理、以何种速度处理都没问题，避免让MySQL产生过多的长事务。</p>

	  ]]></description>
	</item>

	<item>
	  <title>TCP有限状态机</title>
	  <link>//TCP-Finite-State-Machine</link>
	  <author></author>
	  <pubDate>2020-06-09T18:06:25+00:00</pubDate>
	  <guid>//TCP-Finite-State-Machine</guid>
	  <description><![CDATA[
	     <p>相较于Linux进程状态的变迁，TCP的状态变迁则会复杂许多，当然这与TCP本身的实现有关。当线上的Web服务或者是基于TCP连接的服务出现了时断时续的网络状况时，往往需要通过<code class="highlighter-rouge">tcpdump</code>以及TCP连接的状态进行问题定位。同时，这一复杂的有限状态机设计也能够为业务的设计提供指导性的帮助。</p>

<!---more--->

<h3 id="1-tcp连接的建立">1. TCP连接的建立</h3>

<p>TCP连接本质上是两个进程的某些属性的状态值，在TCP连接的建立和断开过程中，实际是状态的变更。连接的建立需要经过三次握手，确认连接的双方能够正确应答，同时进行<code class="highlighter-rouge">MSS</code>、<code class="highlighter-rouge">Win</code>等信息的交换。</p>

<p>TCP协议是可靠传输协议，所以存在TCP序列号以及确认机制。序列号是指当前传输方向上数据报第一个字节的逻辑偏移，由于TCP连接是双向的，所以连接的双方都会有各自的序列号，记为Sequence Number，简写为Seq。</p>

<p>确认机制则由位于TCP报文段中大小为1bit的ACK确认位以及确认序号实现。当一方收到了Seq为$s$、Len为$l$的报文后，需要向对方确认已经收到了该报文。确认的方式是设置ACK确认位，并且将确认序号设置为$s+l$，表示下一次想要接收的数据字节序列号。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/TCP-Status/TCP-build.png" alt="" /></p>

<p>如上图所示，TCP连接的建立需要进行三次握手，其中的细节不再赘述。当客户端使用SYN发起连接时，其状态将会由<code class="highlighter-rouge">CLOSED</code>变迁为<code class="highlighter-rouge">SYN_SENT</code>，表示进程主动地打开了一个连接，并等待对端回应以此完成连接的建立。</p>

<p>当服务端收到来自客户端带有SYN控制位的数据包时，将回复带有SYN以及ACK控制位的数据包，并将状态置为<code class="highlighter-rouge">SYN_RECV</code>，等待对端发送的ACK数据包以建立连接。</p>

<p>客户端收到服务端的报文以后，将连接状态改变为<code class="highlighter-rouge"> ESTABLISHED</code>，表示与对端TCP节点间的连接建立完成，可以正式地传输数据了。同样地，服务端收到对端的ACK确认包以后，也会将状态改变为<code class="highlighter-rouge">ESTABLISHED</code>，两者的连接正式建立。</p>

<p>在连接建立时，只有在确认对方能够正确应答(SYN发送且收到ACK应答)时才会进入<code class="highlighter-rouge">ESTABLISHED</code>状态。</p>

<h3 id="2-tcp连接的拆除">2. TCP连接的拆除</h3>

<p>TCP连接的建立相对来说比较简单，其状态变迁也相对较少，而连接的拆除则远比连接的建立复杂的多。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/TCP-Status/TCP-disconnect.png" alt="" /></p>

<p>发起连接断开的一段称为主动断开方，那么另一端则称为被动断开方。主动断开方执行<code class="highlighter-rouge">close()</code>系统调用，断开TCP连接，此时主动方将发送设置了FIN控制位的报文，并进入<code class="highlighter-rouge">FIN_WAIT_1</code>阶段，等待对方对该FIN包的应答。</p>

<p>当被动断开方收到FIN包以后，立即回送该FIN的确认包，并进入到<code class="highlighter-rouge">CLOSE_WAIT</code>阶段，<strong>主要的工作就是等待上层应用主动调用<code class="highlighter-rouge">close</code>方法关闭连接</strong>，在该阶段中上层应用任何的<code class="highlighter-rouge">read()</code>系统调用都将返回0，表示文件结尾。当应用层调用了<code class="highlighter-rouge">close()</code>系统调用之后，被动断开方将发送FIN结束包。</p>

<p>主动断开方收到FIN包以后，同样地回送ACK确认报文，并进入<code class="highlighter-rouge">TIME_WAIT</code>阶段，此时将固定的等待2倍MSL时间，MSL为报文的最大生存时间，Linux中默认的MSL时间为60S，那么主动断开方将等待120S后彻底关闭TCP连接。</p>

<p>被动断开方在收到ACK确认包以后，释放内核资源，完全关闭TCP连接。</p>

<h4 id="21-close_wait">2.1 CLOSE_WAIT</h4>

<p><code class="highlighter-rouge">CLOSE_WAIT</code>状态只有在被动断开方才会出现，其过程的长短并不由内核控制，必须等待上层应用程序主动调用<code class="highlighter-rouge">close()</code>系统调用，才会从此状态变迁为<code class="highlighter-rouge">LAST_ACK</code>状态。所以，由于此阶段需要应用程序的主动参与，该阶段也是最容易出现问题的阶段。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/TCP-Status/CLOSE_WAIT.png" alt="" /></p>

<p>当服务器出现了大量的、长时间的<code class="highlighter-rouge">CLOSE_WAIT</code>状态的连接，就需要判断是否是应用程序存在BUG，导致TCP连接未主动地关闭。或者是锁争抢过于激烈，又或是CPU资源不足导致应用程序没有额外的CPU对连接进行处理。</p>

<h4 id="22-time_wait">2.2 TIME_WAIT</h4>

<p><code class="highlighter-rouge">TIME_WAIT</code>阶段往往会被开发者所误解当做是优化的对象，因为该阶段的超时时间为2倍的MSL，开发人员认为该值过大，通常会将其减少至15S或者更短。但是，<code class="highlighter-rouge">TIME_WAIT</code>阶段的存在主要目的在于实现连接的可靠终止，以及让原有报文段在网络中过期失效，不会发送给新的连接。</p>

<h5 id="221-连接的可靠终止">2.2.1 连接的可靠终止</h5>

<p>在TCP四次挥手的过程中，首次发送FIN报文和最后一次发送ACK报文的都是主动断开方，被动断开方被”夹在中间”。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Network/TCP-Status/NOT-TIME-WAIT.png" alt="" /></p>

<p>如上图所示，假设没有<code class="highlighter-rouge">TIME_WAIT</code>阶段，并且主动断开方的最后一个ACK在网络中丢失。被动断开方迟迟等不到自己FIN包的ACK，当达到最大超时时间时将重传FIN包(此时无法触发快速重传)。但是，由于此时主动断开方的状态已经是<code class="highlighter-rouge">CLOSED</code>，即当前连接并不存在，则会返回一个RST，而该RST则会被视为错误。</p>

<h5 id="222-确保老的重复的报文在网络中过期失效">2.2.2 确保老的重复的报文在网络中过期失效</h5>

<p>TCP的重传算法可能会导致生成重复的报文，并且根据路由的不同选择，这些重复的报文可能会在连接终止之后到达。</p>

<p>假设主动断开方在发送最后一个ACK包以后立即进入<code class="highlighter-rouge">CLOSED</code>状态，并且在该段又新建了一个与之前一样的连接(IP地址和端口号相同)，那么此连接就是原来连接的化身。在这种情况下，TCP必须确保上一次连接中老的重复报文不会在新的连接中被当成合法数据接收。当有TCP结点处于<code class="highlighter-rouge">TIME_WAIT</code>状态时是无法通过该结点创建新的连接的，这样就阻止了新连接的建立。</p>

<p>当一条连接处于<code class="highlighter-rouge">TIME_WAIT</code>阶段时，其向内核申请的端口号并不会得到释放。如果系统中同时存在大量的处于<code class="highlighter-rouge">TIME_WAIT</code>阶段的连接的话，可能无法再建立新的连接: 端口号资源不够。所以某些并发量较高的应用程序会选择缩短<code class="highlighter-rouge">TIME_WAIT</code>的时间，已获得更高的并发量。</p>

<p>但是，当系统因为<code class="highlighter-rouge">TIME_WAIT</code>而无法建立新的连接时，表示当前节点的资源已经吃紧，最好的办法是增加机器，而不是缩短<code class="highlighter-rouge">TIME_WAIT</code>的时间。</p>

<h3 id="3-使用netstat查看套接字状态">3. 使用netstat查看套接字状态</h3>

<p><code class="highlighter-rouge">netstat</code>可以显示出系统中Internet和UNIX域套接字的状态，当服务器出现网络问题时，可首先用此命令获取基本情况。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span>netstat 
Active Internet connections <span class="o">(</span>w/o servers<span class="o">)</span>
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 localhost:33406         localhost:7890          TIME_WAIT  
tcp        0      0 Zero:56626              183.61.83.4:https       ESTABLISHED
tcp        0      0 localhost:33528         localhost:7890          ESTABLISHED
tcp        0      0 Zero:54438              119.147.134.30:https    TIME_WAIT  
tcp        0      0 Zero:32856              220.181.107.131:https   ESTABLISHED
tcp        0      1 Zero:60558              media-router-fp1.:https LAST_ACK
</code></pre></div></div>

<ul>
  <li>proto: 表示套接字所使用的协议，例如tcp、udp和unix。</li>
  <li>Recv-Q: 表示套接字接收缓冲区中还未被本地应用读取的字节数。对于UDP套接字
来说，该字段不只包含数据，还包含UDP首部及其他元数据所占的字节。</li>
  <li>Send-Q: 表示套接字发送缓冲区中排队等待发送的字节数。</li>
  <li>Local Address: 本地套接字所绑定的地址，格式为IP+端口号。</li>
  <li>Foreign Address: 对端套接字所绑定的地址。</li>
  <li>State: 套接字所处的状态。</li>
</ul>

<p>通常来说我们并不关心UNIX域套接字的相关信息，所以可以使用<code class="highlighter-rouge">--tcp</code>进行过滤，得到的结果仅包含TCP套接字的相关信息。还有一些其他有用的选项:</p>

<table>
  <thead>
    <tr>
      <th>选项</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-a</td>
      <td>显示所有套接字的信息，保证正在监听(LISTEN)的套接字</td>
    </tr>
    <tr>
      <td>-c</td>
      <td>每隔一秒钟刷新显示套接字信息</td>
    </tr>
    <tr>
      <td>-l</td>
      <td>仅显示正在监听的套接字信息</td>
    </tr>
    <tr>
      <td>-p</td>
      <td>显示进程 ID 号以及套接字所归属的程序名称</td>
    </tr>
    <tr>
      <td>–tcp</td>
      <td>显示 Internet域TCP(流)套接字的信息</td>
    </tr>
    <tr>
      <td>–udp</td>
      <td>显示 Internet域UDP(数据报)套接字的信息</td>
    </tr>
    <tr>
      <td>–unix</td>
      <td>显示 UNIX 域套接字的信息</td>
    </tr>
  </tbody>
</table>


	  ]]></description>
	</item>

	<item>
	  <title>InnoDB独特的LRU</title>
	  <link>//InnoDB-LRU</link>
	  <author></author>
	  <pubDate>2020-06-09T18:06:25+00:00</pubDate>
	  <guid>//InnoDB-LRU</guid>
	  <description><![CDATA[
	     <p>由于硬盘和内存的造价差异，一台主机实例的硬盘容量通常会远超于内存容量。对于数据库等应用而言，为了保证更快的查询效率，通常会将使用过的数据放在内存中进行加速读取。LRU算法经常用于数据的置换，但InnoDB的LRU却更加独特。</p>

<!---more--->

<h3 id="1-总览">1. 总览</h3>

<p>InnoDB存储引擎是基于硬盘存储的，并且以页(page)的方式对数据记录进行管理。由于硬盘和CPU之间数据处理速度存在巨大差异，所以必须要使用内存来弥补两者之间的速度鸿沟。</p>

<p>正如同操作系统在读取硬盘文件时会将其纳入内核缓冲区一样，InnoDB存储引擎也会为硬盘中的数据和索引建立位于用户空间的内存缓冲池。当数据库从硬盘读取数据时，首先将其放置于位于内存的缓冲池中，下一次读取相同的数据时，首先判断是否位于缓冲池中。若在，则直接返回，若不在，再从硬盘中进行读取。</p>

<p>当修改数据页时，首先修改位于缓冲池中的数据页，InnoDB会寻找合适的时机将此修改持久化至硬盘中，该合适的时机通常由Checkpoint技术决定。</p>

<p>在Linux操作系统中，位于内核的内核缓冲区就是为了提高系统的I/O效率而产生的，那么为什么InnoDB还要建立自己的缓冲区? 内核缓冲区的终端为硬盘，需要处理诸如页对齐、数据边界等和硬盘硬件相关的事宜，而InnoDB缓冲区则主要服务于应用，并不关心硬件细节，并且可由应用程序控制。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/InnoDB-Buffer/InnoDB-Buffer-Pool.png" alt="" /></p>

<p>如上图所示，InnoDB缓冲池主要由数据页和索引页构成，两者占据了缓冲区的绝大部分空间。除此之外，undo页、插入缓冲以及自适应哈希索引等内容也位于缓冲池中。</p>

<h3 id="2-数据页与索引页的lru">2. 数据页与索引页的LRU</h3>

<p>数据页和索引页的目的在于缓存一部分的表数据和索引数据，其数据总量通常会超过缓冲池大小，所以缓冲池中应只缓冲那些经常使用的热点数据。InnoDB内存管理使用的是最近最少使用(Least Recently Used, LRU)算法。来淘汰最久未使用的数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/InnoDB-Buffer/normal-LRU.png" alt="" /></p>

<p>在一般的LRU算法中，当链表中的某一个数据被读取时，将会将其放置于队首。当新增数据且链表已达最大数量时，将链表尾部的数据移除，并将新增的数据置于链表首部。</p>

<p>但是，InnoDB并没有采用传统的LRU算法，而是对其进行了一些更能够适应自身行为的改进: 最近访问到的数据并不直接放到LRU列表的首部，而是放到LRU列表的midpoiont位置。在默认配置下，midpoint位于LRU列表的5/8处。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/MySQL/InnoDB-Buffer/midpoint.png" alt="" /></p>

<p>如上图所示，在midpoint之前的列表称之为new列表，或者使用Java中的GC术语: 新生代，在midpoint之后的列表称之为old列表，或者说，老年代。</p>

<p>当new列表中的数据被访问时，直接将其放置于LRU列表的首部。当出现新的页面进入LRU时，将其放置于midpoint位置，<strong>此时该数据页将会位于old列表</strong>。</p>

<p>当old列表中的数据被访问时，需要进行判断。如果当前页在old列表中存在时间超过了1秒，则将其移到列表首部。若存在时间小于1秒，则位置保持不变。该判断时间由<code class="highlighter-rouge">innodb_old_blocks_time</code>决定，默认为1000毫秒，即1秒。</p>

<p>另外一点需要注意的是，InnoDB管理数据的最小单位是页(page)，而不是数据库中的某一行。即如果两条记录处于同一页，在两次间隔时间超过<code class="highlighter-rouge">innodb_old_blocks_time</code>的不同行记录的访问也会将该页置于LRU的首部。</p>

<p>InnoDB如此设计的原因在于若使用朴素的LRU算法实现的，某些索引或者表扫描操作可能会将所有的索引页和数据页置换出去，而这些数据通常只是一次性使用的，热点数据被刷出之后，会严重的影响MySQL的性能。当采用midpoint实现后，至少能够保证5/8的数据都是热点数据，即使出现了大范围的表扫描和索引扫描。</p>

<p>让我们来具体分析下对大表进行顺序扫描的过程:</p>

<ol>
  <li>当扫描开始时，InnoDB会一次性地取出16KB的一页数据，将其置于LRU 5/8的位置。</li>
  <li>由于是顺序扫描，那么同一页将会被访问多次，但是访问的间隔一定不会超过默认的<code class="highlighter-rouge">innodb_old_blocks_time</code>，即1秒。所以该页并不会被置于LRU列表的首部，也就不会将真正的热点数据置换而出。</li>
  <li>后续的数据扫描将会在下一页进行，重复上述过程。</li>
</ol>

<p>通过执行<code class="highlighter-rouge">show engine innodb status\G;</code>可以查看InnoDB缓冲池的各种指标，包括当前缓冲池的大小。此外还有一个非常重要的性能指标: 内存命中率。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; show engine innodb status<span class="se">\G</span><span class="p">;</span>
Buffer pool hit rate 976 / 1000, young-making rate 0 / 1000 not 0 / 1000
</code></pre></div></div>

<p>其中Buffer pool hit rate即为缓冲池内存命中率，在一个线上服务中，如果要保证响应时间的话，命中率应不低于95%。 如果某台MySQL实例的hit rate低于此值的话，需要查看设置的缓冲池总大小，以及是否进行了频繁的大范围数据扫描导致LRU列表被污染。</p>

<p>除了增加缓冲池的大小来提高效率以外，当遇到持续的热点问题时，即预估将来的热点数据不止63%，也可以调整midpoint的值来减少热点数据被刷出的概率:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># innodb_old_blocks_pct默认值为37%, 即5/8</span>
mysql&gt; <span class="nb">set </span>global innodb_old_blocks_pct <span class="o">=</span> 20<span class="p">;</span>
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL主从复制</title>
	  <link>//MySQL-Replication</link>
	  <author></author>
	  <pubDate>2020-06-04T07:06:25+00:00</pubDate>
	  <guid>//MySQL-Replication</guid>
	  <description><![CDATA[
	     <p>MySQL的异步复制算的上是一种典型的单领导者复制模式，就复制本身而已并无特殊之处。但是复制的细节，例如binlog的格式选取，从节点如何在保证数据准确的情况下进行并行复制，MySQL的实现方案总是能令人眼前一亮。</p>

<!---more--->

<h3 id="1-binlog">1. binlog</h3>

<p>在经典的复制模型下，主节点和从节点的数据复制都是通过日志的传输进行的。例如Redis主从复制，复制的是<code class="highlighter-rouge">appendonly.aof</code>文件中的逻辑操作记录。又如Raft一致性算法，复制的是作为”日志项”的数据记录，<code class="highlighter-rouge">LogEntry</code>。而在MySQL中，则是使用binlog作为主节点和从节点的数据复制依据。</p>

<p>实际上，如果观察大多数数据库应用的话，会发现它们都会有逻辑日志这一概念，其中记录了对数据的逻辑增删改。一方面用于数据库在宕机时的数据恢复(Redis、MySQL)，另一方面则用于主从复制之中。</p>

<h4 id="11-binlog记录了哪些内容">1.1 binlog记录了哪些内容?</h4>

<p>有非常多的方式来查看binlog中的逻辑日志，一种是在MySQL-Client中查看，另一种则是直接查看位于硬盘中的binlog文件。前者其实也是读取位于硬盘中的binlog文件，只不过会对文件内容进行解析，并增加binlog内容的可读性。而后者则能够获取到更多的信息。</p>

<ul>
  <li>MySQL-Client</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">binary</span> <span class="n">logs</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">binlog</span> <span class="n">events</span> <span class="k">in</span> <span class="s1">'mysql-bin.000193'</span><span class="p">;</span>
</code></pre></div></div>

<p>所得到的结果如下所示:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/show-events.png" alt="" /></p>

<p>其中<code class="highlighter-rouge">Pos</code>表示该逻辑日志的起始位置，<code class="highlighter-rouge">End_log_pos</code>表示该逻辑日志的结束位置。<code class="highlighter-rouge">Event_type</code>表示事件名称，<code class="highlighter-rouge">Server_id</code>则是由用户配置的当前MySQL实例的集群ID，<code class="highlighter-rouge">Info</code>中记录了较为简短的逻辑事件。在起始位置为219的地方，实际上执行了一条<code class="highlighter-rouge">insert</code>语句，但是<code class="highlighter-rouge">Info</code>列中并没有给出详细信息。</p>

<ul>
  <li>mysqlbinlog</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span>mysqlbinlog <span class="nt">-vv</span> mysql-bin.000193
</code></pre></div></div>

<p>得到的输出结果如下:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span>
<span class="cm">/*!*/</span><span class="p">;</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">302</span>
<span class="o">#</span> <span class="err">中间省去一些注释内容</span>
<span class="cm">/*!*/</span><span class="p">;</span>

<span class="o">###</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="nv">`Mario`</span><span class="p">.</span><span class="nv">`hugo`</span>
<span class="o">###</span> <span class="k">SET</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">1</span><span class="o">=</span><span class="mi">7</span> <span class="cm">/* INT meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">2</span><span class="o">=</span><span class="s1">'2020-06-02 14:32:02'</span> <span class="cm">/* DATETIME(0) meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">3</span><span class="o">=</span><span class="s1">'2020-06-02 14:54:07'</span> <span class="cm">/* DATETIME(0) meta=0 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">4</span><span class="o">=</span><span class="s1">'nami'</span> <span class="cm">/* VARSTRING(256) meta=256 nullable=0 is_null=0 */</span>
<span class="o">###</span>   <span class="o">@</span><span class="mi">5</span><span class="o">=</span><span class="s1">'16399553366'</span> <span class="cm">/* VARSTRING(44) meta=44 nullable=0 is_null=0 */</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">428</span>
<span class="o">#</span><span class="mi">200602</span> <span class="mi">14</span><span class="p">:</span><span class="mi">54</span><span class="p">:</span><span class="mi">07</span> <span class="n">server</span> <span class="n">id</span> <span class="mi">1</span>  <span class="n">end_log_pos</span> <span class="mi">459</span> <span class="n">CRC32</span> <span class="mi">0</span><span class="n">x27a642a3</span> 	<span class="n">Xid</span> <span class="o">=</span> <span class="mi">146</span>
<span class="k">COMMIT</span><span class="cm">/*!*/</span><span class="p">;</span>
<span class="o">#</span> <span class="k">at</span> <span class="mi">459</span>
</code></pre></div></div>

<p>其输出内容要比<code class="highlighter-rouge">show binlog events</code>更加完整，除了事务的起始位置和结束位置以外，还包括事务的执行时间，以及完整的数据记录、相关字段的注释。所以，当需要查看binlog的详细内容时，尽量使用<code class="highlighter-rouge">mysqlbinlog</code>命令行工具。</p>

<h4 id="12-binlog日志格式">1.2 binlog日志格式</h4>

<p>MySQL一共提供了3种binlog日志格式，分别是<code class="highlighter-rouge">STATEMENT</code>，<code class="highlighter-rouge">ROW</code>以及<code class="highlighter-rouge">MIXED</code>。</p>

<ul>
  <li>查看当前binlog_format格式</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="nv">"binlog_format"</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>在线修改binlog_format格式</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="k">global</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="k">STATEMENT</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="k">global</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="k">ROW</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">set</span> <span class="k">global</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="n">MIXED</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">STATEMENT</code>日志格式仅记录用户所执行的SQL语句，用户执行什么，binlog就记录什么，属于最节省硬盘空间的一种日志格式。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/STATEMENT.png" alt="" /></p>

<p>但是，无论是出于数据恢复的考虑，还是出于主从复制的目的，都不应该将binlog格式设置为<code class="highlighter-rouge">STATEMENT</code>。其原因在于<code class="highlighter-rouge">STATEMENT</code>格式的日志依赖于执行SQL时的上下文，例如日期函数，<code class="highlighter-rouge">rand</code>函数，不同的执行环境下得到的结果可能并不相同，从而导致主从的数据不一致。而对于数据恢复而言，当然是数据越详细越完整更好。</p>

<p><code class="highlighter-rouge">ROW</code>日志格式将记录完整的数据变更记录，每一条<code class="highlighter-rouge">insert</code>语句都会记录每个字段的插入值，对于<code class="highlighter-rouge">update</code>语句，则会记录数据更新前和更新后的完整数据(<code class="highlighter-rouge">binlog_row_image</code>值为<code class="highlighter-rouge">FULL</code>)。其缺点就是占用硬盘空间较多，假设一条<code class="highlighter-rouge">update</code>语句更新了10万条数据，那么在<code class="highlighter-rouge">ROW</code>格式的binlog中则同样会记录10万条数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/ROW.png" alt="" /></p>

<p><code class="highlighter-rouge">MIXED</code>日志格式结合了<code class="highlighter-rouge">STATEMENT</code>和<code class="highlighter-rouge">ROW</code>日志格式，当MySQL认为当前SQL语句不会引起歧义，即不会导致主从不一致时，将使用<code class="highlighter-rouge">STATEMENT</code>格式记录，反之使用<code class="highlighter-rouge">ROW</code>格式进行记录。节省了一部分的硬盘使用空间，同时又能够保证数据在主从之间的一致性。</p>

<p>在实际应用中，应将binlog日志格式最低设置为<code class="highlighter-rouge">MIXED</code>，如果磁盘空间确实比较紧张的话。否则，就应该将binlog日志格式设置为<code class="highlighter-rouge">ROW</code>，该格式对于数据的误删操作恢复有非常大的帮助。</p>

<h4 id="13-binlog_row_image">1.3 binlog_row_image</h4>

<p>当<code class="highlighter-rouge">binlog_format</code>的值为<code class="highlighter-rouge">ROW</code>时，还有一个控制binlog日志记录的参数: <code class="highlighter-rouge">binlog_row_image</code>。该参数同样有3个可选项: <code class="highlighter-rouge">FULL</code>，<code class="highlighter-rouge">MINIMAL</code>以及<code class="highlighter-rouge">NOBLOB</code>。该参数控制了<code class="highlighter-rouge">ROW</code>格式的binlog日志在写入数据时是否写入完整数据。</p>

<p><code class="highlighter-rouge">FULL</code>将会记录数据修改前后的完整字段，包括未被修改的字段:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/FULL.png" alt="" /></p>

<p><code class="highlighter-rouge">MINIMAL</code>则采用最小记录原则，仅记录修改行的关键定位信息(例如主键或者唯一键)，以及最终被修改的字段的修改值，而不会记录那些没有被修改的字段:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/MINIMAL.png" alt="" /></p>

<p><code class="highlighter-rouge">NOBLOB</code>和<code class="highlighter-rouge">FULL</code>非常类似，会记录完整的字段修改前后数据，只不过不会记录未被修改的、且字段类型为BLOG或TEXT的数据，实际应用较少。</p>

<p>在主从复制中，如果主库网络带宽或者从库网络带宽无法立即升级，并且同步的日志量较大时，可临时的将<code class="highlighter-rouge">binlog_row_image</code>参数由<code class="highlighter-rouge">FULL</code>更改为<code class="highlighter-rouge">MINIMAL</code>，减少一部分的网络带宽使用。</p>

<h3 id="2-异步复制模型">2. 异步复制模型</h3>

<p>对于异步复制模型而言，从原理上来说，只需要将逻辑日志不断地发送给所有的从节点，让从节点重新执行逻辑日志的内容即可，也不需要关心从节点是否接收成功并且执行成功。</p>

<p>MySQL的异步复制模型也确实如此。主节点开启<code class="highlighter-rouge">binlog dump</code>线程，用于锁定地读取binlog内容，并通过TCP长连接发送给从节点。而对于从节点来说，将会开启一个<code class="highlighter-rouge">slave I/O</code>线程，用于和主节点建立TCP连接，以及接收主节点发送的binlog逻辑日志，并将接收到的数据写入自身的中继日志(relay log)文件中。另外的一个线程，即<code class="highlighter-rouge">slave SQL</code>线程，将不断地读取中继日志数据，并执行其中的逻辑SQL语句。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/master-slave.png" alt="" /></p>

<h4 id="21-为什么需要relay-log中继日志">2.1 为什么需要relay log(中继日志)?</h4>

<p>从节点在接收到主节点发送的binlog日志之后，并没有直接执行，而是存储在relay log中，由另外一个线程读取该文件的数据并执行。那么MySQL为什么要使用这种会降低复制效率的设计?</p>

<p>个人认为原因有两点，一方面relay log可以作为日志同步的缓冲区。主节点发送日志的速度可能要大于从节点执行日志的速度，此时就需要一个缓冲区来弥补两者之间的速度差，避免主节点发送的binlog被阻塞在socket缓冲区中。</p>

<p>另外一个作用就是利于故障时的问题排查。relay log的结构与binlog非常相似，通过在从节点持久化一份主节点发送的日志，那么在出现故障时，可查看该文件的内容来大致地判断是主节点出了问题，还是从节点出了问题。</p>

<p>这种数据冗余的设计在业务系统设计中其实也非常实用，相较于直接执行外部发送的数据，采用”生产者-消费者”模型将会有更好的健壮性: 在微服务中，”数据同步”是一件极易出错，且令人无比蛋疼的苦差事。当保留源数据，并在源数据的基础之上开展业务的话，能避免许多麻烦。</p>

<h3 id="3-并行复制">3. 并行复制</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/master-slave-load.png" alt="" /></p>

<p>在主节点中，由于存在各种各样的<code class="highlighter-rouge">Lock</code>， 例如共享锁，排它锁，意向锁等等，使得事务可以并发执行，而无需担心数据不一致的问题。但是，在从节点如果想要并发执行binlog中的内容，并不是一件容易的事情，其原因在于事务和事务之间并不是完全独立存在的，而是存在依赖性。</p>

<p>如上图所示，从节点Execute中继日志的内容将会成为主从复制最后的延迟点，同时，也可能是最大的延迟点: 因为<code class="highlighter-rouge">binlog dump</code>线程以及<code class="highlighter-rouge">slave I/O</code>线程均是对文件的顺序读取和写入，而<code class="highlighter-rouge">slave SQL</code>线程在执行语句时，则没有那么简单。</p>

<h4 id="31-并行复制所面对的问题">3.1 并行复制所面对的问题</h4>

<p>假设现在有3个事务并发执行，且修改的是同一行数据，并且事务提交的顺序为<code class="highlighter-rouge">TRX-1</code>，<code class="highlighter-rouge">TRX-2</code>，<code class="highlighter-rouge">TRX-3</code>，则数据的新旧程度为: <code class="highlighter-rouge">TRX-3</code> &gt; <code class="highlighter-rouge">TRX-2</code> &gt; <code class="highlighter-rouge">TRX-1</code>。</p>

<p>当从节点SQL执行线程读取中继日志时，并不知道这3个事务是修改的同一条数据，如果只是简单地将这3个事务分配给3个Worker执行的话，完全有可能发生旧数据覆盖新数据的情况，即<code class="highlighter-rouge">TRX-1</code>最后被执行，<code class="highlighter-rouge">TRX-3</code>的最新更新将会丢失，导致从节点和主节点的数据不一致。</p>

<h4 id="32-基于table的并行复制">3.2 基于table的并行复制</h4>

<p>如果两个事务是对不同的表进行操作，那么这两个事务即可并行执行。处理方式也非常简单，对表名称进行哈希，并对结果进行worker数量的取模，将该事务分发至对应的worker即可。</p>

<p>但是，如果事务同时对多张表进行了修改的话，上述模型就会出现问题: 该事务应该分配给哪个worker? 所以，还需要记录每个线程中有哪些事务正在执行或者排队，操作的是哪些表。对于线程私有变量，可以使用<code class="highlighter-rouge">ThreadLocal</code>来实现，外部也可方便的获取线程中的私有内容。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/parallel-with-table.png" alt="" /></p>

<p>如上图所示，Assigner线程读取relay log中的内容，并对数据进行解析，决定将该事物分配给哪个worker执行。worker线程则是事务的执行线程，并且使用哈希表记录下当前线程队列中有多少个事务正在修改哪些表。其中key为表名称，value为队列中有多少事务修改该表。</p>

<p>当Assigner读取到只修改table-1的事务时，遍历所有worker的哈希表，判断是否有其它worker正在执行关于table-1的事务，发现只有worker-1存在，那么将会直接将其分发至worker-1线程，并将事务追加至该worker的队列中，以此保证对同一个表的操作串行执行。</p>

<p>当Assigner读取到同时修改table-1和table-3的事务时，首先根据解析规则获取到这两个表应该被分配的worker，然后取出两个队列中正在对table-1和table-3所修改的事务数量。发现worker-1存在对table-1的事务，而worker-2对table-3的修改事务数量为0，那么Assigner将会将该事务分配给worker-1。</p>

<p>当Assigner读取到同时修改table-1和table-4的事务时，发现worker-1和worker-2都存在对两个表的修改，那么Assigner将会等待，等待worker-1对table-1的修改事务数量为0，或者是worker-2对table-4的修改事务数量为0。</p>

<p>在大多数情况下基于表的并行复制策略能够快速地执行，但是，如果遇到热点表的话，该热点表仍然是串行复制，同样会出现效率问题。</p>

<h4 id="33-基于行的并行复制">3.3 基于行的并行复制</h4>

<p>既然基于表的并行复制会有热点表的问题，那么基于行的并行复制总没有热点表的问题了吧? 并且同一条数据的修改频率并不会特别高。基于行的并行复制虽然能够有着更快的执行效率，但是同样地带来的更多的内存开销和CPU计算开销。</p>

<p>在基于行的并行复制中，至少需要记录下所有正在被修改或者是已经在队列中的行数据，那么显而易见的，worker线程中的哈希表将会有存在大量的数据。所以综合来看，基于行的并行复制并不是一个好的选择，甚至可以说是一个比较差的选择。</p>

<p>但是，MySQL针对基于行的复制进行了优化，将判断两个事务是否存在”冲突”(即是否更新了同一行)由从节点转移至主节点。MySQL会记录下更新的每一行的哈希值，组成一个集合。为了能够唯一标识同一行，哈希值通常由”库名+表名+唯一索引名+唯一索引值”计算得到，而唯一索引通常是主键。</p>

<p>如果两个事务没有同时更新同一条数据，那么两个事务的集合就不存在交集，它们是可以并行执行的。并且该哈希值集合是在主节点写入binlog时即计算好的，不需要从节点再次解析binlog event，节省了从节点的一部分计算资源。</p>

<h4 id="34-基于group-commit的并行复制">3.4 基于Group Commit的并行复制</h4>

<p>InnoDB存储引擎是通过redo log + binlog来实现事务的原子性以及持久性的，为了保证数据的一致性，两个日志的数据写入通过”两阶段提交”完成，并且使用组提交(Group Commit)来提高事务的并发效率。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/LSN-Commit.png" alt="" /></p>

<p>当未使用组提交时，当<code class="highlighter-rouge">trx:1</code>提交，仅将该事务的数据持久化至redo log以及binlog中，当有两万个事务并发执行时，将需要执行四万次<code class="highlighter-rouge">fsync</code>系统调用。</p>

<p>当使用组提交时，当<code class="highlighter-rouge">trx:1</code>提交，redo log buffer中可能存在多个事务的物理页修改，那么此时<code class="highlighter-rouge">trx:1</code>将会作为Leader，将当前最大的LSN redo log持久化至磁盘，以减少<code class="highlighter-rouge">fsync</code>的系统调用次数。并且，为了尽可能多地在一次写入中写入更多的数据，InnoDB还会推迟redo log的<code class="highlighter-rouge">fsync</code>过程。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/delay-fsync.png" alt="" /></p>

<p>更具体的上下文请参考文章: <a href="https://smartkeyerror.com/InnoDB-AD">InnoDB如何保证事务的原子性与持久性</a></p>

<p><strong>假设多个事务能够同时进入prepare阶段，那么这些事务一定能够并行执行。</strong> 接下来分析一下这句话的正确性:</p>

<ol>
  <li>事务A和事务B并发执行，准备修改同一条数据。由于X Lock的存在，当一个事务修改数据时，另一个事务将会被阻塞，等待前一个事务<strong>提交</strong>。</li>
  <li>假设事务A首先获得了X Lock，成功修改了数据并提交了事务。而此时，事务B仍然处于运行中，在获取到数据的X Lock之后才开始执行自己的修改。</li>
</ol>

<p>所以，<strong>只要是能够同时进入prepare的阶段，事务一定是经过了锁冲突的检验，一定能够在从库并行执行</strong>。</p>

<p>如此一来，当redo log在使用最大的LSN持久化至磁盘时，使用一个<code class="highlighter-rouge">commit_id</code>对该事务进行标记。下次的redo log持久化将<code class="highlighter-rouge">commit_id</code>自增。从库在并行执行binlog event是，只要是相同的<code class="highlighter-rouge">commit_id</code>，就使其并发执行。</p>

<h4 id="35-mysql提供的并行复制配置项">3.5 MySQL提供的并行复制配置项</h4>

<p>MySQL一共提供了三种并行复制策略，由参数<code class="highlighter-rouge">binlog_transaction_dependency_tracking</code>控制(MySQL版本大于5.7.22)。</p>

<ul>
  <li>COMMIT_ORDER: 利用Group Commit机制进行并行执行。</li>
  <li>WRITESET: 基于行的并行执行。</li>
  <li>WRITESET_SESSION: 建立在WRITESET策略之上，只不过多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li>
</ul>

<p>其中COMMIT_ORDER为默认策略，当使用该策略时，可以调整<code class="highlighter-rouge">binlog_group_commit_sync_delay</code>以及<code class="highlighter-rouge">binlog_group_commit_sync_no_delay_count</code>来使得主节点更慢的提交，使从节点更快的执行事务。</p>

<p>当主节点事务执行的并发度较高时，可以选择COMMIT_ORDER策略。当主节点事务执行并发度并不高，并且趋近于单线程或者双线程时，可选择WRITESET策略。</p>

<h3 id="4-主从延迟来源">4. 主从延迟来源</h3>

<h4 id="41-从节点硬件资源不足">4.1 从节点硬件资源不足</h4>

<p>有时候我们会认为从库只负责读请求，而不处理客户端的写请求，所以从库的内存、硬盘以及CPU都可以使用较低配置。但事实上，从库需要处理的数据写入并不会比主库要少，同时还要处理比主库更多的读请求。因此，从库的硬件资源应该至少和主库相同，甚至可以高于从库。</p>

<p>通过<code class="highlighter-rouge">top</code>或者是<code class="highlighter-rouge">htop</code>可以很清晰的得到从节点的内存以及CPU使用率，使用<code class="highlighter-rouge">iostat</code>查看从节点的磁盘I/O活动情况。<code class="highlighter-rouge">iostat</code>有几个非常关键的指标:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smartkeyerror@Zero:~<span class="nv">$ </span>iostat <span class="nt">-m</span>
Linux 4.15.0-101-generic <span class="o">(</span>Zero<span class="o">)</span>         2020年06月04日  _x86_64_        <span class="o">(</span>8 CPU<span class="o">)</span>

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           4.93    0.01    2.58    0.59    0.00   91.88
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">%iowait</code>表示CPU等待输入输出完成时间的百分比，<code class="highlighter-rouge">%idle</code>表示CPU空闲百分比。如果<code class="highlighter-rouge">%iowait</code>的值较高，说明硬盘存在I/O瓶颈; 如果<code class="highlighter-rouge">%idle</code>持续较低，说明系统的CPU处理能力较弱，此时应处理CPU资源。</p>

<h4 id="42-主节点大事务与从节点长事务">4.2 主节点大事务与从节点长事务</h4>

<p>大事务是指更新了较多数据行的事务，当从节点重放大事务的binlog event时，不管是使用<code class="highlighter-rouge">COMMIT_ORDER</code>还是<code class="highlighter-rouge">WRITESET</code>并行复制策略，后续操作均需要等待该事务的执行，事务执行所需要的执行时间越久，主从延迟就会越高。所以，尽量地将大事务拆分成多个小事务执行。</p>

<p>从节点长事务同样也可能导致主从延迟的产生。例如，当从库开启了一个长事务:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">hugo</span> <span class="k">WHERE</span> <span class="n">username</span> <span class="o">=</span> <span class="nv">"smart"</span><span class="p">;</span>
</code></pre></div></div>

<p>执行完<code class="highlighter-rouge">SELECT</code>语句之后因为种种原因长时间未提交事务，那么此时若主库对该表进行了DDL操作，即使<code class="highlighter-rouge">hugo</code>表只有几行数据，也会长时间的阻塞: 因为此时DDL操作无法获取到<code class="highlighter-rouge">hugo</code>表的意向排它锁(IX)。</p>

<p>如果主表的DDL操作在白天进行，并且恰好存在对该表的某一个长事务的话，即使不是高峰期也会带来非常大的主从延迟。</p>

<h4 id="43-从节点未开启并行复制">4.3 从节点未开启并行复制</h4>

<p>从节点的并行执行worker数量由<code class="highlighter-rouge">slave_parallel_workers</code>参数决定，最大值为1024，通常将其设置为CPU核心数的一半。</p>

	  ]]></description>
	</item>

	<item>
	  <title>InnoDB如何保证事务的原子性与持久性</title>
	  <link>//InnoDB-AD</link>
	  <author></author>
	  <pubDate>2020-05-28T18:06:25+00:00</pubDate>
	  <guid>//InnoDB-AD</guid>
	  <description><![CDATA[
	     <p>在InnoDB存储引擎中，一个事务的执行将涉及到3个日志的数据写入: redo log，undo log以及binlog。其中redo log以及binlog主要实现事务的原子性和持久性，而undo log主要用于实现事务的隔离性。</p>

<!---more--->

<h3 id="1-redo-log">1. redo log</h3>

<p>redo log又称之为重做日志，主要记录了事务对数据页(Page)的物理修改。redo log由两部分组成: 一是位于内存的redo log buffer，用于对redo log进行缓冲，目的在于提升性能。另一部分则位于硬盘中，用于对redo log的持久化。</p>

<h4 id="11-redo-log-buffer">1.1 redo log buffer</h4>

<p>redo log buffer用于优化redo log的写入性能，默认大小为16MB，最大大小为4GB。当一个事务对数据页进行修改时，首先将修改内容放置于缓冲中，而后再对其进行持久化。</p>

<h4 id="12-redo-log">1.2 redo log</h4>

<p>默认情况下，redo log由两个文件构成，<code class="highlighter-rouge">ib_logfile0</code>以及<code class="highlighter-rouge">ib_logfile1</code>。redo log的大小由配置文件决定，在5.7版本中，默认大小为48MB。由于其大小固定，所以数据在写入该日志文件时，将使用循环写入的方式: 首先从头开始写，写到末尾，然后再从头开始写，后面写入的内容会覆盖最初的内容，所以称之为循环写入。</p>

<p>redo log的文件大小设置和MySQL的负载相关，通常来说redo log应该能容纳至少一个小时的数据修改，一般<code class="highlighter-rouge">innodb_log_file_size</code>设置为1GB，<code class="highlighter-rouge">innodb_log_files_in_group</code>设置为4，总计4GB的redo log容量。重做日志大小如果设置的过大，宕机恢复时所花的时间也会越多，所以并不是越大越好。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/redo-log.png" alt="" /></p>

<p>redo log buffer中的数据将会在以下时机持久化至位于磁盘的redo log中:</p>

<ul>
  <li>事务提交</li>
  <li>当redo log buffer有一半的空间已经被使用时</li>
  <li>InnoDB后台线程每秒将数据持久化至硬盘</li>
</ul>

<p>所以，需要明确的是，当某个事务未提交(commit)时，该事务对物理数据页的修改也可能会持久化至redo log文件中。</p>

<h4 id="13-lsn">1.3 LSN</h4>

<p>在redo log中，还有一个非常重要的属性: LSN，Log Sequence Number，即日志序列号。接下来我们将会看到，LSN在数据恢复以及Group Commit中起到了决定性的作用。</p>

<p>在InnoDB存储引擎中，LSN占用8个字节，且单调递增。LSN所表示的含义包括redo log的总量，checkpoint的位置以及数据页的版本。</p>

<p>假设当前redo log的LSN为1000，事务T1写入了200字节的redo log，那么LSN将递增至1200。若事务T2写入了500字节的redo log，那么LSN又将变成1700。所以通过查看LSN的大小即可知道redo log的总量，单位为字节。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; show engine innodb status<span class="se">\G</span><span class="p">;</span>
<span class="nt">---</span>
LOG
<span class="nt">---</span>
Log sequence number 20598039739
Log flushed up to   20598039739
Pages flushed up to 20598039739
Last checkpoint at  20598039730
0 pending log flushes, 0 pending chkp writes
10 log i/o<span class="s1">'s done, 0.00 log i/o'</span>s/second
</code></pre></div></div>

<p>如上所示，Log sequence number表示当前的LSN，Log flushed up to表示已经刷新到redo log文件的LSN。</p>

<h3 id="2-binlog">2. binlog</h3>

<p>binlog为MySQL层面的逻辑日志，用于记录对哪一行数据进行了哪些修改，不管使用何种存储引擎，都会有binlog的记录。redo log则是InnoDB存储引擎所特有的日志记录，并且其中记录的是对物理数据页的修改。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/logical-binlog.png" alt="" /></p>

<p>关于binlog的更多内容将在后续的MySQL主从复制中描述。</p>

<h3 id="3-事务执行过程">3. 事务执行过程</h3>

<p>InnoDB存储引擎在提交事务时，为了保证原子性和持久性，将会采用”两阶段”提交的方式写入redo log和binlog。</p>

<h4 id="31-一阶段">3.1 一阶段</h4>

<p>首先，在MySQL中所有执行的SQL语句都会有一个全局递增且循环使用的query_id。当用户开启事务并执行语句后，MySQL将会把第一个语句的query_id分配给该事务，作为Xid的值。</p>

<p>当用户执行<code class="highlighter-rouge">COMMIT</code>提交事务时，将redo log buffer的内容调用<code class="highlighter-rouge">write()</code>系统调用写入内核缓冲区，并调用<code class="highlighter-rouge">fsync()</code>系统调用确保数据写入至硬盘(至少是硬盘的缓冲区)，更新状态为prepare。</p>

<h4 id="32-二阶段">3.2 二阶段</h4>

<p>将产生的binlog调用<code class="highlighter-rouge">write()</code>系统调用写入内核缓冲区，并调用<code class="highlighter-rouge">fsync()</code>系统调用将数据持久化至硬盘，写入成功后事务即可被提交，并更新状态为commit。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/2PC.png" alt="" /></p>

<p>当数据成功地写入到binlog以后，即可返回给用户事务提交成功。由于数据写入<code class="highlighter-rouge">.ibd</code>文件需要随机读写，所以将会由其它线程异步写入，以提高事务执行的效率。</p>

<p>现在来看两阶段提交在数据库Crash的情况:</p>

<ul>
  <li>binlog有记录，但redo log状态为prepare: 此时表示在写入binlog数据库崩溃，需要根据binlog进行数据恢复</li>
  <li>binlog有记录，redo log状态为commit: 事务正常提交，无需恢复</li>
  <li>binlog无记录，redo log状态为prepare: 事务执行一半时崩溃，无需恢复</li>
  <li>binlog无记录，redo log状态为commit: 在binlog持久化时崩溃，事务直接回滚</li>
</ul>

<p>可以看到，通过上述的两阶段提交方式能够保证不会产生脏事务，并且已成功提交的事务也能够在MySQL崩溃后重启恢复。</p>

<p>当redo log和binlog均正确的写入数据以后，就可以返回<code class="highlighter-rouge">OK</code>给用户了。至于何时将用户的修改持久化至<code class="highlighter-rouge">.ibd</code>文件中，由MySQL后台线程决定。</p>

<p>基于redo log和binlog的WAL(Write-Ahead Log)机制可以保证数据的原子性以及持久性，并且由于日志是顺序读写，所以事务的执行速度会快很多。</p>

<h3 id="4-group-commit">4. Group Commit</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/2PC.png" alt="" /></p>

<p>从上图模型可以看到，每一个事务的提交，都会伴随着两次<code class="highlighter-rouge">write()</code>以及<code class="highlighter-rouge">fsync()</code>系统调用。对于<code class="highlighter-rouge">Write()</code>调用来说，仅仅只是将用户缓冲区的内容写入至内核缓冲区中，虽然会有用户态与内核态的切换，但是仍然要比<code class="highlighter-rouge">fsync()</code>要快。</p>

<p>如果采用上述模型实现事务的话，如果有两万个并发事务执行，那么磁盘的IO负载将会达到四万，并且事务的执行效率将会非常之差。</p>

<p>为了解决事务执行效率问题，MySQL引入了组提交(Group Commit)技术: 在事务提交时，尽可能多地向文件中写入数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/LSN-Commit.png" alt="" /></p>

<p>如上图所示，共有3个事务并行执行，其中trx:1事务准备提交。按照之前的模型，将trx:1的redo log写入至磁盘中，并将binlog写入至磁盘中。</p>

<p>而在Group Commit中，当trx:1准备提交时，将会刷新最大的LSN之前未刷新的所有redo log。在该示例中，trx:1准备刷新时，则会将LSN为1600之前的所有redo log一齐刷新至磁盘。原来需要6次系统调用，现在只需要2次。</p>

<p>为了能够让redo log在每次写入时尽可能多的写入，MySQL将redo log调用<code class="highlighter-rouge">fsync()</code>的时机延迟，延迟至binlog调用<code class="highlighter-rouge">write()</code>之后:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/delay-fsync.png" alt="" /></p>

<p>这样一来，binlog也能够组提交了，能够有效地减少IOPS的消耗。</p>

<p>MySQL额外的提供了两个延迟参数来提高binlog的组提交效率:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 表示延迟多少微秒后才调用binlog的fsync()</span>
binlog_group_commit_sync_delay

<span class="c"># 表示累积了多少个binlog才调用binlog的fsync()</span>
binlog_group_commit_sync_no_delay_count
</code></pre></div></div>

<p>这两个参数为”或”关系，即只要满足一个条件，就会调用<code class="highlighter-rouge">fsync()</code>。当磁盘IO出现性能瓶颈时，可根据实际负载来设置该值，从而降低磁盘IO负载，代价是会增加事务的响应时间。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Linux主机通过Windows虚拟机转发Easyconnect内网请求</title>
	  <link>//Linux-Use-EasyConnect</link>
	  <author></author>
	  <pubDate>2020-02-27T12:06:25+00:00</pubDate>
	  <guid>//Linux-Use-EasyConnect</guid>
	  <description><![CDATA[
	     <p>世界上有个恶心的公司叫Sangfor，开发出了恶心的工具EasyConnect，本来这东西都是给在校的学生用的，好不好用都无所谓。但是很多公司也开始使用这个来访问内网，并且还不支持Linux(反正到目前Ubuntu下的64bit版本连接就没成功过)，这就很令人讨厌了。回想起Ubuntu下使用Wine安装微信的种种难受，决定还是使用Windows虚拟机开启EasyConnect，并把部分的Linux流量打进虚拟机。</p>

<!---more--->

<h4 id="1-虚拟机配置">1. 虚拟机配置</h4>
<p>虚拟机需要两块网卡，其中一块必须是Host-only类型的，用来和Linux主机通信，这块儿网卡是内网流量的入口，所以必须配置。另一块可以是NAT，也可以是Bridge，随个人喜好。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/VMware-Network-Config.png" alt="" /></p>

<h4 id="2-windows虚拟机网络配置">2. Windows虚拟机网络配置</h4>

<p>进到Windows虚拟机以后，打开网络适配器设置，这时候可以看到两张网卡: Ethernet0和Ethernet1，找到Host-only那张网卡，并修改其名称为<code class="highlighter-rouge">Host</code>，起一个有意义的名称对后面的操作非常有帮助。如果不确定哪张网卡是Host-only的话，可以对比网卡的MAC地址和虚拟机网络配置中的MAC地址。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/Ethernet.png" alt="" /></p>

<p>开启EasyConnect，并建立与内网的连接，此时会多出一张名为”以太网”的网卡，这张网卡的IP地址子网掩码什么的都可以不用管，就是张工具卡。设置该网络的共享属性，和前面建立的Host-only网卡建立共享。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/share-with-host-only.png" alt="" /></p>

<p>设置完成以后会发现Host-only那张网卡的IP地址被强制更改成了192.168.137.1，改了就改了吧，也不是不能用。</p>

<p>并关闭Windows的公用网络防火墙，不然数据包会被防火墙拦截。</p>

<h4 id="3-设置linux路由规则">3. 设置Linux路由规则</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>ip a add 192.168.137.2/24 dev vmnet1
<span class="nb">sudo </span>ip r add 10.0.0.0/8 via 192.168.137.1
</code></pre></div></div>

<p>给vmnet1，也就是Host-only网卡添加一个和192.168.137.2相同IP地址段的IP地址，使Linux能够建立正常的路由转发规则，否则Linux主机根本就不知道192.168.137.1这个IP地址是谁的。然后将所有的内网(10.0.0.0/8)请求都通过192.168.137.1走Windows的内网网络。</p>

<h4 id="4-windows安装ccproxy">4. Windows安装CCProxy</h4>

<p>对于某些需要域名解析的HTTP请求，又不想用dnsmasq去自己解析DNS，就可以直接用该工具进行转发，下载、安装和使用傻瓜式操作，完美，非常适合我这种智商不高的人。</p>

<p>安装完成以后设置下本机局域网IP地址，选择NAT或者是Bridge的那张网卡即可:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/CCProxy.png" alt="" /></p>

<p>由于我的Chrome用了SwitchOmega，并不想牺牲某些便利，所以使用Firefox进行代理设置，内网的HTTP请求以后就用Firefox发送，流量使用分明，代理配置也尽量分开。</p>

<p>Firefox中输入<code class="highlighter-rouge">about:preferences</code>，拉到最底下，选择Network Settings，就可以进行代理设置了。</p>

<p>CCProxy的HTTP协议默认端口为808，IP地址则是NAT或者Bridge网卡的IP地址，进行配置即可:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/Firefox-Config.png" alt="" /></p>

<p>需要注意的是FTP端口为2121，SOCKS端口为1080，因为我不需要这两个协议，所以并没有配置。</p>

<p>完)</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL-InnoDB中的锁</title>
	  <link>//MySQL-InnoDB-Lock</link>
	  <author></author>
	  <pubDate>2020-01-31T10:06:25+00:00</pubDate>
	  <guid>//MySQL-InnoDB-Lock</guid>
	  <description><![CDATA[
	     <p>锁在InnoDB存储引擎中的使用远比我们想象中的更加频繁，及时是一条最为简单的<code class="highlighter-rouge">update set</code>语句，其中也涉及到了各种锁的使用。包括常说的一致性锁定读，解决幻读等场景中，同样包含了锁的大量使用。</p>

<!---more--->

<h4 id="1-latch和lock">1. Latch和Lock</h4>

<p>在InnoDB存储引擎中，Latch(门闩)是用来保证并发线程操作临界资源的正确性，保证某些操作的原子性。通常又分为Mutex(互斥量)和RWLock(读写锁)，例如Python中<code class="highlighter-rouge">threading.Lock</code>，Java中<code class="highlighter-rouge">synchronized</code>，Golang中的<code class="highlighter-rouge">sync.Mutex</code>，Latch通常应用于操作缓冲池中的LRU列表元素(添加、删除以及移动)，部分场景下的<code class="highlighter-rouge">AUTO_INCREMENT</code>实现。用户通常不会直接地与Latch打交道，并且没有死锁检测。</p>

<p>Lock作用于事务之中，用来锁定表、页、行，锁的添加与释放通常会在事务的起始和结束时进行。数据库中的幻读问题解决就是通过Lock实现的，而非Latch。并且Lock存在死锁检测机制，当发生死锁时，会在某些情况下告知用户，例如在使用一致性锁定读(SELECT…FOR UPDATE)时产生的死锁，会直接抛出1213的Deadlock异常。</p>

<p>尽管Latch与Lock操作的对象均为数据，但是Latch更为底层，操作的对象更加细小。Lock的对象相对于Latch而言，则更加”粗放”，例如表、页数据，此外最重要的是Lock的作用域为事务，Latch则不是。</p>

<h4 id="2-innodb存储引擎中的lock">2. InnoDB存储引擎中的Lock</h4>

<p>为了方便叙述，下面均使用锁来指代InnoDB中的Lock(仍然要说明，Lock以及Latch都可以称为锁，这里只是为了方便叙述)。</p>

<p>InnoDB引擎支持行锁以及表锁，既可以锁定某一行，同时也可以锁定一整张表，先从行级锁说起。</p>

<p>InnoDB引擎实现了两种标准的行级锁:</p>
<ul>
  <li>共享行级锁(S Lock, Share Lock)</li>
  <li>排他行级锁(X Lock, Exclusive Lock)</li>
</ul>

<p>可以认为S Lock和X Lock分别表示读锁和写锁，如同RWLock一样。S Lock允许并发地读取数据，X Lock既限制并发地读取，同时也限制并发地修改。所以说，当某一行数据中存在S锁时，只能再次添加S锁，若想要添加X锁，则需要等待S锁的释放。行级锁X以及S Lock的兼容性如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">-</th>
      <th style="text-align: center">X</th>
      <th style="text-align: center">S</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">X</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">S</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
  </tbody>
</table>

<p>同时，InnoDB支持表级锁，为了支持表级锁与行级锁这两个不同粒度的锁，InnoDB支持一种额外的上锁方式，称之为意向锁(Intention Lock)。</p>

<p>为了更好的理解意向锁，首先假设没有意向锁，只有表锁和行锁。当事务A在更新某一条数据时，会在该数据行上添加X锁。此时另外事务B申请整个表的写锁，如果事务B申请成功，那么它就能修改表中任意一行数据，这与事务持有的X锁冲突。</p>

<p>如果数据库想要避免该冲突，那么需要让事务B阻塞，直到事务A提交释放X锁。转而需要判断事务B阻塞的条件: ①当前表是否被其它事务添加表锁 ②判断表中是否存在行锁。这两个条件判断均可以在表层面实现，而无需遍历所有数据，只需要定义好数据结构即可。一个最简单的实现就是为表锁和行锁添加两个标识位，该标识位在添加和释放锁时进行原子更新，例如:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table_s_lock <span class="o">=</span> <span class="nb">false
</span>table_x_lock <span class="o">=</span> <span class="nb">false
</span>row_s_lock <span class="o">=</span> <span class="nb">true
</span>row_x_lock <span class="o">=</span> <span class="nb">true</span>
</code></pre></div></div>

<p>当某一行添加X锁时，将<code class="highlighter-rouge">row_x_lock</code>置为true，若其余事务想要添加表级别的X锁，则必须等待<code class="highlighter-rouge">row_x_lock</code>更新为false。反之若事务已经添加了表级别的X锁，将<code class="highlighter-rouge">table_x_lock</code>置为true，事务B若想在某一行添加X锁，则需要等待<code class="highlighter-rouge">table_s_lock</code>以及<code class="highlighter-rouge">table_x_lock</code>均更新为false。</p>

<p>虽然上面的标识位能够解决问题，但仍然有些奇怪，奇怪的点在于标识位的判断粒度不同。我们更加希望表级锁与表级锁进行兼容性判断，行级锁与行级锁进行兼容性判断，而不是表级锁与行级锁进行兼容性判断。由此，就有了意向锁的诞生。</p>

<p>意向锁(Intention Lock)将锁定的对象分为多个粒度，当想要对细粒度的数据进行加锁时，那么首先需要对粗粒度的对象添加意向锁。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/intention-Lock.png" alt="" /></p>

<p>例如，若需要对页上的记录R添加X锁，则需要分别对数据库、表、页添加意向锁IX，添加成功后才会对记录R添加X锁，若其中任何一部分导致等待，那么该操作需要等待粗粒度上锁环节的完成。现在来看在有了意向锁之后InnoDB存储引擎如何支持多粒度的锁。</p>

<p>意向锁同样分为两种: 共享和排他</p>

<ul>
  <li>意向共享锁(IS, Intention Share Lock)</li>
  <li>意向排他锁(IX, Intention Exclusive Lock)</li>
</ul>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/intention-lock-example.png" alt="" /></p>

<p>如上图所示，事务A为了给记录R添加X锁(排他锁)，则需要依次对数据库、表、页添加意向排他锁(IX)，假设添加均成功，最终记录R添加了X锁。此时事务B想要向表A中添加表级别的排他锁，由于表A中存在IX锁，与表级别的X锁并不兼容，故事务B等待，等待表A中IX锁的释放。可以看到，在有了意向锁之后，锁的兼容性比较将处理同粒度水平，而不是跨粒度进行比较。这让我想起了一个段子:</p>

<blockquote>
  <p>不要跟傻逼争论，他会把你拉到他的水平上，然后用他丰富的经验打败你</p>
</blockquote>

<p>InnoDB存储引擎中意向锁和表级锁的兼容性如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">-</th>
      <th style="text-align: center">IX</th>
      <th style="text-align: center">IS</th>
      <th style="text-align: center">X(表级别)</th>
      <th style="text-align: center">S(表级别)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">IX</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">IS</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">X(表级别)</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">S(表级别)</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
  </tbody>
</table>

<p>在MySQL 5.5以上、5.7.14以下的版本中，用户可以通过<code class="highlighter-rouge">INFORMATION_SCHEMA</code>下的<code class="highlighter-rouge">INNODB_TRX</code>、<code class="highlighter-rouge">INNODB_LOCKS</code>以及<code class="highlighter-rouge">INNODB_LOCK_WAITS</code>这三张表简单地监控并分析可能存在的锁问题。</p>

<p>在MySQL 8.0版本中，则需要使用<code class="highlighter-rouge">performance_schema</code>下的<code class="highlighter-rouge">data_locks</code>以及<code class="highlighter-rouge">data_lock_waits</code>获取相关的锁以及锁等待信息。</p>

<p>而MySQL版本在5.7.14到8.0之间的用户，只能通过其它手段间接的获取上述信息。</p>

<h5 id="21-创建通用例程">2.1 创建通用例程</h5>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`user`</span> <span class="p">(</span>
  <span class="nv">`id`</span> <span class="n">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="nv">`nickname`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`password`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`user_id`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`mobile`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`mobile_area`</span> <span class="n">smallint</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">comment</span> <span class="nv">"手机号码区域"</span><span class="p">,</span>
  <span class="nv">`gender`</span> <span class="n">tinyint</span> <span class="k">DEFAULT</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nv">`avatar`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`account_id`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`created_at`</span> <span class="n">datetime</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="nv">`updated_at`</span> <span class="n">datetime</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="k">ON</span> <span class="k">UPDATE</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="nv">`deleted_at`</span> <span class="n">datetime</span><span class="p">,</span>
  <span class="nv">`status`</span> <span class="n">tinyint</span> <span class="k">DEFAULT</span> <span class="mi">1</span> <span class="k">comment</span> <span class="nv">"用户状态"</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`user_id`</span> <span class="p">(</span><span class="nv">`user_id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`mobile`</span> <span class="p">(</span><span class="nv">`mobile`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`account_id`</span> <span class="p">(</span><span class="nv">`account_id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`created_at`</span> <span class="p">(</span><span class="nv">`created_at`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`updated_at`</span> <span class="p">(</span><span class="nv">`updated_at`</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="p">(</span><span class="nv">`user_id`</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="p">(</span><span class="nv">`account_id`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">1</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span> <span class="k">COLLATE</span><span class="o">=</span><span class="n">utf8mb4_general_ci</span><span class="p">;</span>
</code></pre></div></div>

<p>这是一张非常普通但又普遍的用户信息表，其中包含了唯一主键，唯一辅助索引以及普通辅助索引。</p>

<h5 id="22-innodb_trx">2.2 INNODB_TRX</h5>
<p><code class="highlighter-rouge">INNODB_TRX</code>表中主要记录了当前正在执行的事务信息，包括只读事务。首先来看字段和字段所表示的含义:</p>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TRX_ID</td>
      <td>InnoDB存储引擎内部的唯一事务ID</td>
    </tr>
    <tr>
      <td>TRX_WEIGHT</td>
      <td>事务权重(与事务修改的行数和锁定的行数有关)，当两个事务执行发生死锁时，InnoDB会选择权重较低的事务进行回滚</td>
    </tr>
    <tr>
      <td>TRX_STATE</td>
      <td>当前的事务执行状态，包括RUNNING, LOCK WAIT, ROLLING BACK, 以及COMMITTING，LOCK WAIT表示当前事务正等待某个锁的释放</td>
    </tr>
    <tr>
      <td>TRX_STARTED</td>
      <td>事务开始时间，格式如2000-01-01 14:01:08</td>
    </tr>
    <tr>
      <td>TRX_REQUESTED_LOCK_ID</td>
      <td>当前事务所等待的锁ID，该字段只有在状态为LOCK WAIT才有值，否则为NULL。可与<code class="highlighter-rouge">INNODB_LOCKS</code>通过LOCK_ID字段进行关联查询，获取更为详细的锁信息。</td>
    </tr>
    <tr>
      <td>TRX_WAIT_STARTED</td>
      <td>当前事务等待锁的起始时间，在状态为LOCK WAIT时才有值，否则为NULL。</td>
    </tr>
    <tr>
      <td>TRX_QUERY</td>
      <td>当前事务<strong>正在</strong>执行的SQL语句(不是事务所有的执行语句)</td>
    </tr>
    <tr>
      <td>TRX_OPERATION_STATE</td>
      <td>事务的当前操作状态，包括PREPARING, UPDATING, DELETING, COMMITTING以及NULL，该字段在绝大部分情况下均为NULL，捕捉某一事务的瞬间执行状态还是比较困难的(除非是大事务)</td>
    </tr>
    <tr>
      <td>TRX_TABLES_IN_USE</td>
      <td>正在执行的SQL语句所操作的表数量，是一个动态变化值，通常很难观测</td>
    </tr>
    <tr>
      <td>TRX_TABLES_LOCKED</td>
      <td>当前事务在各个表中添加行锁的表数量</td>
    </tr>
    <tr>
      <td>TRX_LOCK_STRUCTS</td>
      <td>当前事务持有的锁数量</td>
    </tr>
    <tr>
      <td>TRX_LOCK_MEMORY_BYTES</td>
      <td>当前事务中锁结构的内存总占用</td>
    </tr>
    <tr>
      <td>TRX_ROWS_LOCKED</td>
      <td>当前事务锁住的近似数据总行数</td>
    </tr>
    <tr>
      <td>TRX_ROWS_MODIFIED</td>
      <td>当前事务插入、修改的总行数</td>
    </tr>
    <tr>
      <td>TRX_CONCURRENCY_TICKETS</td>
      <td>表示当前事务在换出之前所能做的工作之和</td>
    </tr>
    <tr>
      <td>TRX_ISOLATION_LEVEL</td>
      <td>当前事务隔离级别，包括READ UNCIMMITTED、READ COMMITTED、READ REPEATABLE以及SERIALIZABLE</td>
    </tr>
    <tr>
      <td>TRX_UNIQUE_CHECKS</td>
      <td>当前事务是否开启唯一性检查</td>
    </tr>
    <tr>
      <td>TRX_FOREIGN_KEY_CHECKS</td>
      <td>当前事务是否开启外键检查</td>
    </tr>
    <tr>
      <td>TRX_LAST_FOREIGN_KEY_ERROR</td>
      <td>当前事务执行时最后发生的外键错误</td>
    </tr>
    <tr>
      <td>TRX_ADAPTIVE_HASH_LATCHED</td>
      <td>当前事务是否锁定了自适应哈希索引</td>
    </tr>
  </tbody>
</table>

<p>在这20多个字段中，较为重要的包括事务ID，事务执行状态，事务等待锁的起始时间，事务锁定的近似总行数。</p>

<h5 id="23-innodb_locks">2.3 INNODB_LOCKS</h5>

<p><code class="highlighter-rouge">INNODB_LOCKS</code>表中记录了当前所有未释放的锁，包括行锁、页锁以及表锁，当某个事务发生严重的锁等待时，通常会在该表中查找蛛丝马迹，确定问题的根源。</p>

<p>但是，<code class="highlighter-rouge">INNODB_LOCKS</code>和<code class="highlighter-rouge">INNODB_LOCK_WAITS</code>这两张表在5.7.14以上版本中被废弃不用，在8.0版本中使用<code class="highlighter-rouge">data_locks</code>以及<code class="highlighter-rouge">data_lock_waits</code>进行代替，故以下内容均采用MySQL 8.0版本进行描述。</p>

<h5 id="24-data_locks">2.4 data_locks</h5>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ENGINE</td>
      <td>申请或持有锁的存储引擎类型</td>
    </tr>
    <tr>
      <td>ENGINE_LOCK_ID</td>
      <td>存储引擎内部的锁ID，该值会发生动态变化，外部系统不应该依赖该值</td>
    </tr>
    <tr>
      <td>ENGINE_TRANSACTION_ID</td>
      <td>持有锁的事务ID，与INNODB_TRX中的TRX_ID对应</td>
    </tr>
    <tr>
      <td>THREAD_ID</td>
      <td>持有锁的线程ID</td>
    </tr>
    <tr>
      <td>EVENT_ID</td>
      <td>事件ID，该字段将于下方进行详细描述</td>
    </tr>
    <tr>
      <td>OBJECT_SCHEMA</td>
      <td>锁所在的schema(database)</td>
    </tr>
    <tr>
      <td>OBJECT_NAME</td>
      <td>锁所在的表名称</td>
    </tr>
    <tr>
      <td>PARTITION_NAME</td>
      <td>锁所在分片名称</td>
    </tr>
    <tr>
      <td>SUBPARTITION_NAME</td>
      <td>锁所在的子分片名称</td>
    </tr>
    <tr>
      <td>INDEX_NAME</td>
      <td>被添加锁的索引名称</td>
    </tr>
    <tr>
      <td>OBJECT_INSTANCE_BEGIN</td>
      <td>锁的内存空间起始地址</td>
    </tr>
    <tr>
      <td>LOCK_TYPE</td>
      <td>锁类型，包含TABLE和RECORD</td>
    </tr>
    <tr>
      <td>LOCK_MODE</td>
      <td>锁的模式，包括S,X,IS,IX,AUTO_INC以及UNKNOWN</td>
    </tr>
    <tr>
      <td>LOCK_STATUS</td>
      <td>锁的状态，InnoDB引擎中包括GRANTED(已添加)和WAITING(等待中)</td>
    </tr>
    <tr>
      <td>LOCK_DATA</td>
      <td>锁覆盖的范围，该字段将于下方详细描述</td>
    </tr>
  </tbody>
</table>

<p>以一个具体的例子为例:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Mario</span><span class="p">.</span><span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
               <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140374385659344</span><span class="p">:</span><span class="mi">1453</span><span class="p">:</span><span class="mi">140374295256456</span>
<span class="n">ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">632837</span>
            <span class="n">THREAD_ID</span><span class="p">:</span> <span class="mi">56</span>
             <span class="n">EVENT_ID</span><span class="p">:</span> <span class="mi">28</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
       <span class="n">PARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
    <span class="n">SUBPARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">NULL</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140374295256456</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="k">TABLE</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">IX</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="k">NULL</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
               <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140374385659344</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140374295253576</span>
<span class="n">ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">632837</span>
            <span class="n">THREAD_ID</span><span class="p">:</span> <span class="mi">56</span>
             <span class="n">EVENT_ID</span><span class="p">:</span> <span class="mi">28</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
       <span class="n">PARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
    <span class="n">SUBPARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140374295253576</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p>当我们使用<code class="highlighter-rouge">FOR UPDATE</code>一致性锁定读向id为1的行添加一个写锁时，可以看到<code class="highlighter-rouge">data_locks</code>中生成了两条记录。从<code class="highlighter-rouge">LOCK_TYPE</code>以及<code class="highlighter-rouge">LOCK_MODE</code>来看，第一条为表级别意向排他锁(IX)，第二条为行记录排他锁(X)。注意到X锁后面还有一个说明: <code class="highlighter-rouge">REC_NOT_GAP</code>，表示排他非间隙行锁，这是行锁的一种实现，将在后面小节中描述。</p>

<p><code class="highlighter-rouge">LOCK_DATA</code>在IX项中为NULL，这是因为在InnoDB存储引擎中，该字段只会在<code class="highlighter-rouge">LOCK_TYPE</code>为<code class="highlighter-rouge">RECORD</code>时才有实际值，对于<code class="highlighter-rouge">TABLE</code>类型的锁而言，该值为NULL。<code class="highlighter-rouge">LOCK_DATA</code>根据不同的加锁方式会有不同具体值。当我们使用主键ID(primary key)进行加锁时，<code class="highlighter-rouge">LOCK_DATA</code>仅包含聚簇索引行记录，此时<code class="highlighter-rouge">LOCK_DATA</code>的值通常为主键ID。当我们使用辅助索引对记录加锁时，锁住的范围则会包括辅助索引+聚簇索引，所以此时<code class="highlighter-rouge">data_locks</code>会生成3条记录(表级别意向锁+索引记录锁+聚簇索引记录锁)，此时<code class="highlighter-rouge">LOCK_DATA</code>的值为”辅助索引字段值+主键ID”</p>

<p>例如:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Mario</span><span class="p">.</span><span class="k">user</span> <span class="k">where</span> <span class="n">user_id</span> <span class="o">=</span> <span class="nv">"168236477"</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
          <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">NULL</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="k">TABLE</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">IX</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="k">NULL</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">user_id_2</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="cm">/* LOCK_DATA为FieldValue+记录对应的主键ID。由于user_id为unique，故此处仅一条记录 */</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="s1">'168236477'</span><span class="p">,</span> <span class="mi">3</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">3</span>
</code></pre></div></div>

<h5 id="25-data_lock_waits">2.5 data_lock_waits</h5>

<p><code class="highlighter-rouge">data_lock_waits</code>相比于<code class="highlighter-rouge">INNODB_TRX</code>以及<code class="highlighter-rouge">data_locks</code>而言则要更复杂一些，该表实际上是一个ManyToMany的关系表，记录了<code class="highlighter-rouge">data_locks</code>中锁之间的等待以及依赖关系，同时也记录了锁所对应的事务/会话信息。</p>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ENGINE</td>
      <td>存储引擎类型</td>
    </tr>
    <tr>
      <td>REQUESTING_ENGINE_LOCK_ID</td>
      <td>存储引擎内锁ID，对应于data_locks表中的ENGINE_LOCK_ID</td>
    </tr>
    <tr>
      <td>REQUESTING_ENGINE_TRANSACTION_ID</td>
      <td>存储引擎内事务ID</td>
    </tr>
    <tr>
      <td>REQUESTING_THREAD_ID</td>
      <td>线程ID</td>
    </tr>
    <tr>
      <td>REQUESTING_EVENT_ID</td>
      <td>事件ID</td>
    </tr>
    <tr>
      <td>REQUESTING_OBJECT_INSTANCE_BEGIN</td>
      <td>锁的内存空间起始地址</td>
    </tr>
    <tr>
      <td>BLOCKING_ENGINE_LOCK_ID</td>
      <td>等待释放的锁ID</td>
    </tr>
    <tr>
      <td>BLOCKING_ENGINE_TRANSACTION_ID</td>
      <td>等待结束的事务ID</td>
    </tr>
    <tr>
      <td>BLOCKING_THREAD_ID</td>
      <td>等待结束的线程ID</td>
    </tr>
    <tr>
      <td>BLOCKING_EVENT_ID</td>
      <td>等待结束的事件ID</td>
    </tr>
    <tr>
      <td>BLOCKING_OBJECT_INSTANCE_BEGIN</td>
      <td>等待结束的锁的内存空间起始地址</td>
    </tr>
  </tbody>
</table>

<p>例如:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_lock_waits</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
                          <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">REQUESTING_ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140678484647376</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140678365511992</span>
<span class="n">REQUESTING_ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">635403</span>
            <span class="n">REQUESTING_THREAD_ID</span><span class="p">:</span> <span class="mi">48</span>
             <span class="n">REQUESTING_EVENT_ID</span><span class="p">:</span> <span class="mi">15</span>
<span class="n">REQUESTING_OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365511992</span>
         <span class="n">BLOCKING_ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140678484646504</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140678365506120</span>
  <span class="cm">/*等待ID为635400的事务释放锁*/</span>
  <span class="n">BLOCKING_ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">635400</span>
              <span class="n">BLOCKING_THREAD_ID</span><span class="p">:</span> <span class="mi">47</span>
               <span class="n">BLOCKING_EVENT_ID</span><span class="p">:</span> <span class="mi">12</span>
  <span class="n">BLOCKING_OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/data_lock_waits.png" alt="" /></p>

<h4 id="3-innodb存储引擎行锁算法">3. InnoDB存储引擎行锁算法</h4>

<p>InnoDB存储引擎存在3种行锁算法，分别为:</p>

<ul>
  <li>Record Lock: 单个行记录上的锁</li>
  <li>Gap Lock: 间隙锁，锁定一个范围，单不包含记录本身</li>
  <li>Next-Key Lock: Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身</li>
</ul>

<p>Record Lock表示单个行记录上的锁，这非常好理解，例如我们<code class="highlighter-rouge">update</code>一条或多条数据时，事务会为这一条或者多条数据均添加X锁。当使用主键ID进行更新时，记录仅包含聚簇索引行记录。当使用辅助索引进行更新时，将会锁住聚簇索引记录+辅助索引记录。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="k">user</span> <span class="k">set</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="cm">/* 省略部分非关键信息 */</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">commit</span><span class="p">;</span>
</code></pre></div></div>

<p>当使用主键ID进行一致性锁定读时，<code class="highlighter-rouge">data_locks</code>生成两条锁记录，一条为table IX，另一条为行记录的X锁，注意<code class="highlighter-rouge">LOCK_MODE</code>后面的附加声明: REC_NOT_GAP，表示当前锁的算法仅为行记录锁，非间隙锁。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="k">user</span> <span class="k">set</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">where</span> <span class="n">user_id</span> <span class="o">=</span> <span class="nv">"174269548"</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">user_id_2</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="s1">'174269548'</span><span class="p">,</span> <span class="mi">1</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506464</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p>而使用辅助索引进行一致性锁定读时，除了table IX以及聚簇索引的X锁以外，还会有额外的辅助索引X锁，<code class="highlighter-rouge">LOCK_MODE</code>同样备注了非间隙锁的标识。</p>

<p>间隙锁的存在主要是为了解决幻读问题，幻读是指当某事务读取一定范围内的数据时，其余事务在该范围内插入了一条或多条数据，或者删除了一条或多条数据，导致前一个事务读取的数据条数发生改变，如同出现幻觉，所以称为幻读。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="n">supremum</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">record</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">3</span>
</code></pre></div></div>

<p>当我们对某一个范围使用一致性锁定读时，就可以看到间隙锁的产生。<code class="highlighter-rouge">LOCK_MODE</code>仅为X时，就表示当前锁添加了间隙锁。并且在<code class="highlighter-rouge">LOCK_DATA</code>有supremum pseudo-record的解释说明，该说明表示MySQL决定锁定最大间隙范围。在本例中，为id大于2的所有数据，故另一个事务执行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">insert</span> <span class="k">into</span> <span class="k">user</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">nickname</span><span class="p">,</span> <span class="n">password</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">mobile_area</span><span class="p">,</span> <span class="n">gender</span><span class="p">,</span> <span class="n">avatar</span><span class="p">,</span> <span class="n">account_id</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="nv">"jojo"</span><span class="p">,</span> <span class="nv">"passwd"</span><span class="p">,</span> <span class="nv">"147523659"</span><span class="p">,</span> <span class="nv">"13555555555"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">"https://jojo.com"</span><span class="p">,</span> <span class="nv">"1753681429"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>将会被阻塞，直至前一个事务释放间隙锁或者当前事务锁等待超时。</p>

<p>在理解了间隙锁以后，Next-Key Lock就很容易理解了，锁定一个记录+一个范围。上面例子均有一个特点，就是不管是主键ID，还是user_id，它们都具有unique约束，而对于非唯一的辅助索引而言，即使是精确查询并加锁，也会添加Gap Lock，此时就是Next-Key Lock。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">updated_at</span> <span class="o">=</span> <span class="nv">"2020-01-23 21:32:52"</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="cm">/*此时DB中仅存在一条数据更新时间为"2020-01-23 21:32:52"*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">updated_at</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="n">supremum</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">record</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">updated_at</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">0</span><span class="n">x99A56F5834</span><span class="p">,</span> <span class="mi">1</span>
<span class="o">***************************</span> <span class="mi">4</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">updated_at</code>字段仅添加了普通索引，并且值为”2020-01-23 21:32:52”的记录主键ID为1，从<code class="highlighter-rouge">data_locks</code>的最后一条记录也可以看出。在该表的第二行和第三行中分别添加了间隙锁，第三行的<code class="highlighter-rouge">LOCK_DATA</code>字段值为16进制数+主键ID。</p>

<p>此外，<strong>需要尤为注意的是，<code class="highlighter-rouge">READ COMMITTED</code>事务隔离级别下，将不会有间隙锁的添加</strong>。在文章<a href="https://smartkeyerror.com/django-concurrent-data-process">Django处理数据并发问题</a>中描述了使用Django默认的<code class="highlighter-rouge">READ COMMITTED</code>事务隔离级别所带来的问题。</p>

<h4 id="4-自增长与锁">4. 自增长与锁</h4>

<p>自增长在数据库中是非常常见的属性，MySQL提供<code class="highlighter-rouge">AUTO_INCREMENT</code>属性使得列可具备自增长的功能。在InnoDB存储引擎内存结构中，对每个含有自增长值的表都有一个自增长计数器。</p>

<p>最初自增长是采用特殊的表锁实现，称为AUTO_INC Locking，为了提高插入的性能，锁并不是在事务结束时才释放，而是在完成对自增长值插入的SQL语句后立即释放。虽然AUTO_INC Locking从一定程度上提高了并发插入的效率，但是仍存在性能问题: 事务必须等待前一个事务插入语句的结束。所以，后续就有了轻量级的互斥量自增长实现。</p>

<p>互斥量的实现就是文章最开头所说的Latch，由硬件协助实现。该实现方式只有在确定所插入的行数时才会使用，否则，将仍然使用AUTO_INC Locking。</p>

<h4 id="5-metadata-lock">5. Metadata Lock</h4>

<p>Metadata Lock，又称为MDL，相较于行锁和表锁，其范围更广，对象包括数据库、表、行以及触发器和外键等，与InnoDB其它锁一样，在事务开始时获取，事务结束时释放，其设计目的在于保证在事务执行过程中表的结构不会被修改。</p>

<p>通常来讲，只有在修改表结构的时候我们才会直接地与MDL打交道，例如向某张表添加一列，或者删除某一列。在DML执行非常频繁的应用中，当我们执行ALTER TABLE table ADD column时，很有可能出现整个MySQL挂掉的情况，其原因就在于表结构修改语句获取MDL时阻塞，导致后续对该表的查询、修改和删除等语句阻塞。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/MDL.png" alt="" /></p>

<p>session A与session B会向表user添加只读MDL，而session C想要申请可写的MDL，由于前面两个事务均为提交，故只能阻塞。此时由于session C写锁的申请，导致session D以及后续的所有DML操作均会被阻塞，简单来说，此时表user不可读写。</p>

<p>如果user表中的读写非常频繁，将会导致大量的查询或更新语句阻塞，且状态均为<code class="highlighter-rouge">waiting for metadata lock</code>。此时若客户端存在超时重试机制，那么会导致大量新的会话建立，最后达到MySQL线程数量的限制，导致整个DB不可用。</p>

<p>在MySQL 5.6版本以上支持Online DDL，其过程如下:</p>
<ul>
  <li>ALTER TABLE table ADD column语句获取MDL写锁</li>
  <li>获取成功后，将其降级为MDL读锁</li>
  <li>执行真正的DDL操作，如添加、删除列，期间可以执行DML语句</li>
  <li>升级MDL读锁为写锁</li>
  <li>释放MDL写锁，整个DDL过程结束</li>
</ul>

<p>真正导致数据库不可读写的步骤为1、4，第3步为实际运行时间最长的步骤，不会影响表的读写操作，只要内存和磁盘容量足够，数据量再多也灭有关系。所以，DDL的关键影响因素不在于数据量，而是在于数据读写的QPS。这也是为什么表结构修改操作要放到月黑风高的凌晨进行操作的原因: 那时候访问量最少，而不是数据量最少。</p>

<p>在更改表结构时造成大面积读写操作阻塞的另一个原因就是长事务，即长时间运行的事务。即使QPS非常小，但是系统中存在长事务，同样会造成DDL语句获取写锁阻塞，从而阻塞后续的读写语句。</p>

<h4 id="6-reference">6. Reference</h4>

<ul>
  <li>https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_latch</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-trx-table.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/data-locks-table.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/data-lock-waits-table.html</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Golang中的interface</title>
	  <link>//Golang-interface</link>
	  <author></author>
	  <pubDate>2019-12-25T08:25:25+00:00</pubDate>
	  <guid>//Golang-interface</guid>
	  <description><![CDATA[
	     <p>Golang除了方便使用的协程以外，最令我感到惊讶的就是<code class="highlighter-rouge">interface</code>，接口。在其它语言中，接口承担的主要作用为解耦和协议，但是在Golang中，<code class="highlighter-rouge">interface</code>还作为一种”通用”类型广泛使用于标准库和第三方库中。</p>

<!---more--->

<h3 id="1-面向接口编程">1. 面向接口编程</h3>

<p>面向接口编程的核心就在于将接口和实现分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口编程而非面向实现编程，不依赖不稳定的实现细节，当实现发生变化时，上游系统可不做或者只需进行少量的修改，从而降低耦合性，提高拓展性。 换句话说，面向接口编程是一种可随时拔插替换的编程方法。</p>

<h4 id="11-接口的含义">1.1 接口的含义</h4>

<p>不管是在Java语言还是在Go语言中，接口本身的定义均只包含方法，并不包含具体的实现。换句话说，接口实际上是定义了一组行为，但是没有定义这些行为到底该怎么进行。</p>

<p>接口描述了”如果你是…则必须能…“的分类思想，如果你是动物，那么必须能呼吸，移动和进食。如果你是植物，那么你必须能进行光合作用。但是，具体的动物如何呼吸(鱼用腮呼吸，狮子用肺呼吸)，如何移动(鸟既能飞又能跑，狮子不能飞)，是由实现了动物这个接口的具体动物所决定的。</p>

<p>接口将一类事物的行为提炼并抽象出来，从而达到简化事物复杂度的目的，以便相关的研究人员更关注于他们想要关注的，而忽略其它的细节。</p>

<h4 id="12-依赖反转原则">1.2 依赖反转原则</h4>

<p>在SOLID原则中，依赖反转原则对于增强系统的可拓展性、降低代码的耦合性至关重要。依赖反转原则描述了这样一个概念:</p>

<blockquote>
  <p>高层次模块不应依赖于低层次模块的具体实现细节，两者都应该依赖于抽象</p>
</blockquote>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Go/interface/DIP.png" alt="" /></p>

<p>依赖反转原则简单来说就是额外地增加了一层抽象(接口)，该模块抽象了模块A所依赖的所有行为。而模块B则实现该抽象(接口)，并在运行时通过依赖注入的方式注入进模块A。如此一来，将来若想要替换掉模块B，只需要重新实现该接口，并在少量的代码中进行改动即可。</p>

<h4 id="13-接口的实际意义">1.3 接口的实际意义</h4>

<p>接口的实际意义其实就是一个标准，或者说一种协议。例如SSD的M.2接口，不管是三星的970 evo plus，还是海盗船的MP 510，在内部硬件的实现细节上虽然存在差异，但是它们都能够在支持M.2的主板上正常运行。这其实就是标准化的意义: 兼容性和可交换性。</p>

<p>从抽象代码上来看，接口就是一种约束，用于约束对象的行为，使得对象标准化。</p>

<h3 id="2-实现接口">2. 实现接口</h3>

<p>不同于Java语言中使用<code class="highlighter-rouge">implements</code>关键字实现接口，Golang中的某一个类型实现接口是隐式的: 只要类型实现了接口中的全部方法，就认为该类型实现了该接口。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">LogData</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">LogStorage</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Insert</span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="n">LogData</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">MongoStorage</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">m</span><span class="x"> </span><span class="o">*</span><span class="n">MongoStorage</span><span class="p">)</span><span class="n">Insert</span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="n">LogData</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="c">/*...*/</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<h4 id="21-接口和指针">2.1 接口和指针</h4>

<p>当接口和指针在一起使用时，往往会产生一些令人迷惑的问题。方式的接收者有值接收者和指针接收者，那么也就会有两种实现接口的方式，而这两种实现方法在使用过程中需要特别小心。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">LogData</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">LogStorage</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Insert</span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="n">LogData</span><span class="p">)</span><span class="x">
    </span><span class="n">InsertMany</span><span class="p">(</span><span class="n">dataSlice</span><span class="x"> </span><span class="p">[]</span><span class="n">LogData</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">MongoStorage</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{}</span><span class="x">

</span><span class="c">/* 指针接收者 */</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">m</span><span class="x"> </span><span class="o">*</span><span class="n">MongoStorage</span><span class="p">)</span><span class="n">Insert</span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="n">LogData</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="c">/*...*/</span><span class="p">}</span><span class="x">

</span><span class="c">/* 值接收者 */</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">m</span><span class="x"> </span><span class="n">MongoStorage</span><span class="p">)</span><span class="n">InsertMany</span><span class="p">(</span><span class="n">dataSlice</span><span class="x"> </span><span class="p">[]</span><span class="n">LogData</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="c">/*...*/</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>在示例中，<code class="highlighter-rouge">MongoStorage</code>这一具体的实现存在一个指针接收者方法，一个值接收者方法。当尝试使用结构体初始化变量时，将无法通过编译:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">m</span><span class="x"> </span><span class="n">LogStorage</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">MongoStorage</span><span class="p">{}</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="o">./</span><span class="n">mian</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">31</span><span class="o">:</span><span class="m">6</span><span class="o">:</span><span class="x"> </span><span class="n">cannot</span><span class="x"> </span><span class="n">use</span><span class="x"> </span><span class="n">MongoStorage</span><span class="x"> </span><span class="n">literal</span><span class="x"> </span><span class="p">(</span><span class="k">type</span><span class="x"> </span><span class="n">MongoStorage</span><span class="p">)</span><span class="x"> </span><span class="n">as</span><span class="x"> </span><span class="k">type</span><span class="x"> </span><span class="n">LogStorage</span><span class="x"> </span><span class="n">in</span><span class="x"> </span><span class="n">assignment</span><span class="o">:</span><span class="x">
	</span><span class="n">MongoStorage</span><span class="x"> </span><span class="n">does</span><span class="x"> </span><span class="n">not</span><span class="x"> </span><span class="n">implement</span><span class="x"> </span><span class="n">LogStorage</span><span class="x"> </span><span class="p">(</span><span class="n">Insert</span><span class="x"> </span><span class="n">method</span><span class="x"> </span><span class="n">has</span><span class="x"> </span><span class="n">pointer</span><span class="x"> </span><span class="n">receiver</span><span class="p">)</span><span class="x">
</span></code></pre></div></div>

<p>原因在于尽管<code class="highlighter-rouge">InsertMany</code>方法使用了值接收者实现，但是<code class="highlighter-rouge">Insert</code>方法却使用了指针接收者实现。由于Go方法调用按值传递，通过对指针的解引用可以获取到该指针指向的值，但是却无法获取到某一个变量的指针，因为在内存中可能存在多个指向该变量的指针。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">m</span><span class="x"> </span><span class="n">LogStorage</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">MongoStorage</span><span class="p">{}</span><span class="x">
    </span><span class="n">m</span><span class="o">.</span><span class="n">InsertMany</span><span class="p">([]</span><span class="n">LogData</span><span class="p">{})</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>当执行<code class="highlighter-rouge">m.InsertMany()</code>语句时，Go会将指向<code class="highlighter-rouge">MongoStorage{}</code>结构体的指针进行解引用，取出结构体<code class="highlighter-rouge">MongoStorage{}</code>并进行方法调用。</p>

<p>在实际应用中，为了节省实参的拷贝开销，通常都会使用指针接收者来实现接口中的方法。那么在定义变量时，需要指针变量。</p>

<h3 id="3-接口的值">3. 接口的值</h3>

<p>Go语言中接口的定义形式为:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">interfaceName</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">functionName</span><span class="p">(</span><span class="n">p</span><span class="x"> </span><span class="n">Type</span><span class="p">)</span><span class="x"> </span><span class="n">returnType</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>从接口定义中可以看到，<code class="highlighter-rouge">interface</code>是一个类型，那么既然是一个类型，就应该有值。接口的值由两部分组成: 接口的动态类型和该类型的值，前者称为动态类型，后者称为动态值。Go接口的动态类型和Java的RTTI一样，在运行时确定某个接口的具体类型。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">w</span><span class="x"> </span><span class="n">io</span><span class="o">.</span><span class="n">Writer</span><span class="x">                  </span><span class="c">// ①</span><span class="x">
</span><span class="n">w</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">os</span><span class="o">.</span><span class="n">Stdout</span><span class="x">                    </span><span class="c">// ②</span><span class="x">
</span><span class="n">w</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"Hello World~"</span><span class="p">))</span><span class="x">  </span><span class="c">// ③</span><span class="x">
</span></code></pre></div></div>

<p>①: 声明了变量<code class="highlighter-rouge">w</code>，且其类型为<code class="highlighter-rouge">io.Writer</code>，由于<code class="highlighter-rouge">io.Writer</code>是一个接口定义，并且Golang会在变量被定义时即对变量进行初始化，那么变量<code class="highlighter-rouge">w</code>也会被初始化。<strong>接口的零值就是将其动态类型和动态值均设置为nil</strong>。</p>

<p>②: 将<code class="highlighter-rouge">os.Stdout</code>这一具体类型赋值给了<code class="highlighter-rouge">w</code>，相当于将一个具体类型隐式转换成了接口类型。那么此时，<code class="highlighter-rouge">w</code>就有了动态类型和动态值。其动态类型为<code class="highlighter-rouge">*os.File</code>，其动态值为<code class="highlighter-rouge">*os.file</code>。</p>

<p>③: 调用该接口值的<code class="highlighter-rouge">Write</code>方法，实际上调用的是<code class="highlighter-rouge">(*os.File).Write</code>方法。在调用方法时，仍然需要使用动态分发的手段来获取到方法地址。</p>

<h4 id="31-go接口的实现">3.1 Go接口的实现</h4>

<p>在Golang中，接口的实现其实有两种，一种是拥有方法的接口，另一种则是不拥有方法的接口，后者通常表示为<code class="highlighter-rouge">interface{}</code>，将在文章的后续进行描述。</p>

<p>由用户自定义的、带有方法的接口通过<code class="highlighter-rouge">iface</code>结构体实现，位于源码<code class="highlighter-rouge">/src/runtime/runtime2.go</code>中:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">iface</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">tab</span><span class="x">  </span><span class="o">*</span><span class="n">itab</span><span class="x">
    </span><span class="n">data</span><span class="x"> </span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>其中<code class="highlighter-rouge">*itab</code>表示接口的动态类型，<code class="highlighter-rouge">unsafe.Pointer</code>则指向接口的动态值。<strong>对于一个接口变量而言，只要其动态类型的值不为nil，接口值就不为nil</strong></p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/Go/interface/interface-value.png" alt="" /></p>

<h3 id="4-interface">4. interface{}</h3>

<p><code class="highlighter-rouge">interface{}</code>表示不包含任何方法的接口，而Golang中不管是基本数据类型，还是复合数据类型，还是用户自定的类型，都至少包含零个方法。换句话说，所有的类型都实现了<code class="highlighter-rouge">interface{}</code>。</p>

<p>首先查看下<code class="highlighter-rouge">fmt.Println</code>函数的定义:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="x"> </span><span class="o">...</span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">(</span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">Fprintln</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stdout</span><span class="p">,</span><span class="x"> </span><span class="n">a</span><span class="o">...</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p><code class="highlighter-rouge">Println</code>方法接收任意多个<code class="highlighter-rouge">interface{}</code>类型的参数，这也是为什么<code class="highlighter-rouge">Println</code>方法能够接收任意类型的原因: <strong>所有传入的参数均进行了隐式转换，转换成了<code class="highlighter-rouge">interface{}</code>类型</strong>。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"123"</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">"name"</span><span class="o">:</span><span class="x"> </span><span class="s">"SmartKeyerror"</span><span class="p">})</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"foo"</span><span class="p">,</span><span class="x"> </span><span class="s">"bar"</span><span class="p">})</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>但是，需要特别注意的是: <code class="highlighter-rouge">interface{}</code>并不代表任意类型，它只是一种特殊的类型。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">v</span><span class="x"> </span><span class="p">[]</span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="c">/*...*/</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Bar</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"foo"</span><span class="p">,</span><span class="x"> </span><span class="s">"bar"</span><span class="p">})</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>上述代码将在编译期抛出异常:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./mian.go:35:14: cannot use <span class="o">[]</span>string literal <span class="o">(</span><span class="nb">type</span> <span class="o">[]</span>string<span class="o">)</span> as <span class="nb">type</span> <span class="o">[]</span>interface <span class="o">{}</span> <span class="k">in </span>argument to Bar
</code></pre></div></div>

<p><code class="highlighter-rouge">[]interface{}</code>和<code class="highlighter-rouge">[]string</code>是完全不同的类型，<code class="highlighter-rouge">interface{}</code>占用固定的内存空间，而<code class="highlighter-rouge">[]Type</code>则不能确定占用内存空间大小，它们自然不是同一种类型。</p>

<h4 id="41-interface的实现">4.1 interface{}的实现</h4>

<p>和带有方法的接口一样，<code class="highlighter-rouge">interface{}</code>的定义也在<code class="highlighter-rouge">/src/runtime/runtime2.go</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">eface</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">_type</span><span class="x"> </span><span class="o">*</span><span class="n">_type</span><span class="x">
    </span><span class="n">data</span><span class="x">  </span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>其中<code class="highlighter-rouge">_type</code>为Go语言类型的运行时表示，包括了一些元信息，包括大小、哈希值等等，而<code class="highlighter-rouge">data</code>用于保存实际运行时的数据，是一个指向原始数据的指针。<code class="highlighter-rouge">eface</code>和<code class="highlighter-rouge">iface</code>差别并不大，均包括运行时的动态值和动态类型。</p>

<h3 id="5-类型断言与类型分支">5. 类型断言与类型分支</h3>

<h4 id="51-类型断言">5.1 类型断言</h4>

<p>和Python中的<code class="highlighter-rouge">isinstance</code>、<code class="highlighter-rouge">issubclass</code>类似，Golang提供了类型断言来判断某个变量是否为某一种类型，其格式为<code class="highlighter-rouge">x.(T)</code>。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">w</span><span class="x"> </span><span class="n">io</span><span class="o">.</span><span class="n">Writer</span><span class="x">
    </span><span class="n">w</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">os</span><span class="o">.</span><span class="n">Stdout</span><span class="x">
    
    </span><span class="k">if</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">);</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="p">{</span><span class="x">
	    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Assert Right"</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
	    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Assert Wrong"</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>若<code class="highlighter-rouge">T</code>为具体类型，那么类型断言会检查x的动态类型是否为<code class="highlighter-rouge">T</code>。若断言成功，结果即为<code class="highlighter-rouge">x</code>的动态值，类型当然就是<code class="highlighter-rouge">T</code>。</p>

<p>若<code class="highlighter-rouge">T</code>为接口类型，那么类型断言会检查<code class="highlighter-rouge">x</code>的动态类型是否满足<code class="highlighter-rouge">T</code>。若断言成功，结果仍为接口值，不过此时的类型为接口类型<code class="highlighter-rouge">T</code>。</p>

<h4 id="52-类型分支">5.2 类型分支</h4>

<p>当某个函数接收<code class="highlighter-rouge">interface{}</code>类型参数时，需要在函数内部来确定其动态类型，此时可使用<code class="highlighter-rouge">x.(type)</code>类型分支。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">foo</span><span class="p">(</span><span class="n">v</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">switch</span><span class="x"> </span><span class="n">v</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">case</span><span class="x"> </span><span class="kt">int</span><span class="o">:</span><span class="x">
	    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"v is int"</span><span class="p">)</span><span class="x">
    </span><span class="k">case</span><span class="x"> </span><span class="kt">string</span><span class="o">:</span><span class="x">
	    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"v is string"</span><span class="p">)</span><span class="x">
    </span><span class="k">default</span><span class="o">:</span><span class="x">
	    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"unknown type"</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">foo</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="x">
    </span><span class="n">foo</span><span class="p">(</span><span class="s">"10"</span><span class="p">)</span><span class="x">
    </span><span class="n">foo</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"smart"</span><span class="p">})</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>Linux操作系统-文件I/O</title>
	  <link>//Linux-IO</link>
	  <author></author>
	  <pubDate>2019-12-17T09:39:25+00:00</pubDate>
	  <guid>//Linux-IO</guid>
	  <description><![CDATA[
	     <p>在操作系统中， 最为复杂同时也最为重要的功能就是文件I/O。 一台PC可以不连接互联网， 但是一定需要程序的载入、文件的打开， 而这些操作与I/O均密不可分。 包括软件开发中， 数据库与I/O的关系密切相关， 有时衡量一个DB的效率， 其实就是在衡量其I/O效率。 理解文件I/O， 就是在理解我们常用应用软件， 如MySQL、Redis、Nginx、ES、Prometheus等的核心。</p>

<!---more--->

<h4 id="1-处于内核态的系统调用">1. 处于内核态的系统调用</h4>

<p>操作系统的本质就是帮助用户更加高效的管理硬件， 向上提供统一的接口， 向下兼容不同的硬件， 使得用户并不需要关心硬件， 如硬盘的细节， 只需要关心操作系统为我们提供的抽象: 文件系统。 然而引入操作系统的代价就是用户对硬件的所有操作， 例如打开一个文件， 运行一个程序， 均需经由操作系统来完成， 如此以来， 就有了系统调用。</p>

<p>系统调用存在的原因就在于操作系统不允许用户直接访问硬件， 如果用户有此需求， 则需将想要访问的地址与内容告诉操作系统， 由操作系统进行硬件的访问， 最后由操作系统将结果返回给用户。</p>

<p>操作系统也是软件， 也是由一行行的代码所组成， 所以必定运行在内存中， 只不过操作系统所运行的内存受到保护， 用户无法直接对其进行操作而已。 当用户想要打开一个文件时， 将文件路径告知操作系统， 此时操作系统将会接管CPU的执行， 并将CPU的某标识位标记为内核态， 执行一系列的I/O操作， 取出结果并将结果发送给用户内存空间后， 再将CPU的执行权交给用户。 从本质上来看， 系统调用其实就是一次进程切换， 只不过所花费的时间要比普通的进程间切换大得多而已。</p>

<p>接下来将会看到， 为了”对抗”系统调用所带来的巨大代价， 先贤们实现了各种各样增加I/O效率的方式。 但是， 没有哪一种方式能够”一招吃遍天下鲜”， 不同的应用场景会有不同的最佳解决方式。</p>

<h4 id="2-linux通用io模型">2. Linux通用I/O模型</h4>

<p>Linux为系统用户提供了一些通用的IO函数， 包括<code class="highlighter-rouge">open</code>、<code class="highlighter-rouge">read</code>、<code class="highlighter-rouge">write</code>等方法， 当用户每次调用这些方法时， 都将产生一次系统调用， 此时程序运行由用户态切换至内核态， 内核做完自己应该完成的事情之后， 将结果保存至用户指定的位置中， 并再由内核态切换至用户态， 使用户继续执行下面的代码。</p>

<p><code class="highlighter-rouge">open</code>方法既能打开一个已经存在的文件， 也能创建并打开一个新的文件。 其原型如下:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="p">...</span><span class="cm">/* mode_t mode */</span><span class="p">)</span>
</code></pre></div></div>

<p>具体的方法使用请参见Linux manual page。 <code class="highlighter-rouge">open</code>方法在成功时将返回该文件的文件描述符， 用于在后续函数调用中指代该文件， 该文件描述符在进程中唯一， 即使打开的是同一个文件， 两者的文件描述符也不相同。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"hole.txt"</span><span class="p">,</span> <span class="n">O_WDONLY</span><span class="p">);</span>   <span class="c1">// 3
</span>    <span class="kt">int</span> <span class="n">fd2</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"hole.txt"</span><span class="p">,</span> <span class="n">O_WDONLY</span><span class="p">);</span>  <span class="c1">// 4
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于用户自定义的文件， 文件描述符通常都是从3开始， 0、1、2这三个描述符分别代表标准输入、标准输出以及标准错误， 定义于<code class="highlighter-rouge">unistd.h</code>头文件中。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Standard file descriptors.  */</span>
<span class="cp">#define	STDIN_FILENO	0	</span><span class="cm">/* Standard input.  */</span><span class="cp">
#define	STDOUT_FILENO	1	</span><span class="cm">/* Standard output.  */</span><span class="cp">
#define	STDERR_FILENO	2	</span><span class="cm">/* Standard error output.  */</span><span class="cp">
</span></code></pre></div></div>

<p><code class="highlighter-rouge">read</code>系统调用此报告文件描述符fd所指代的打开文件中读取数据， 其定义为:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;unistd.h&gt;
</span>
<span class="kt">ssize_t</span> <span class="n">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div></div>

<p>count参数指定最多能读取的字节数， buffer参数提供用来存放数据的内存缓冲区地址(由用户所提供)， 缓冲区至少应有count字节。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX_READ 20
</span><span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAX_READ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

<span class="kt">ssize_t</span> <span class="n">num_read</span><span class="p">;</span>
<span class="n">num_read</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">MAX_READ</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">num_read</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="n">buffer</span><span class="p">[</span><span class="n">num_read</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"The input data was: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</code></pre></div></div>

<p>从标准输入中读取数据和从文件中读取数据会有些许差异， 因为在默认情况下， 从终端读取字符会在遇到换行符(\n)时<code class="highlighter-rouge">read</code>调用就会结束， 而对于普通文件， 则不会这样。</p>

<p>现在来进一步地了解<code class="highlighter-rouge">read</code>系统调用背后所发生的事情。 当程序调用<code class="highlighter-rouge">read</code>方法时， 产生系统调用， 则当前程序执行的状态由用户态切换至内核态， 操作系统将所需要的文件内容读取至内核某缓冲区中。 同时， 由于I/O是一个相对来说代价较大的操作， 为了减少读取磁盘的数据， 操作系统还会额外的读取更多的内容进入内核缓冲区， 下次读取这些内容时， 直接从缓冲区中读取， 不再从磁盘中读取， 从而提升整体效率。 数据进入内核缓冲区后， 内核需要将数据复制到用户缓冲区中， 也就是<code class="highlighter-rouge">read</code>方法所传递的<code class="highlighter-rouge">void *buffer</code>中。 传输完毕后由内核态切换至用户态， <code class="highlighter-rouge">read</code>系统调用完成。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/Linux%20Read.png" alt="" /></p>

<p>在执行<code class="highlighter-rouge">read</code>系统调用时， 总计发生了2次用户态切换， 额外的一次数据复制(kernel to User)。 并且， kernel buffer中保存了多于用户当前所需的数据， 用于加快下一次的<code class="highlighter-rouge">read</code>调用。</p>

<p><code class="highlighter-rouge">write</code>系统调用将数据写入一个打开的文件中， 当调用成功时， 返回实际写入文件的字节数。 与<code class="highlighter-rouge">read</code>系统调用相同， <code class="highlighter-rouge">write</code>调用在返回成功时， 仅是将数据写入到内核缓冲区中， 再由内核寻找适当的时机将该部分数据真正地写入到磁盘中。</p>

<p>采用这一设计可以有效的减少内核必须执行的磁盘传输次数， 因为可能调用10次<code class="highlighter-rouge">write</code>系统调用， 内核仅进行一次磁盘写入， 不仅减少了单个<code class="highlighter-rouge">write</code>系统调用所需时间， 并且提高了操作系统整体的运作效率。</p>

<p>这一机制所带来的唯一问题就是由于数据在某一时刻仅暂存于内核缓冲区中， 当系统发生断电或者是意外宕机时， 该部分数据就会丢失。 对于数据库等对数据要求非常严格的系统， 这种数据丢失是无法接受的。 所以， 内核额外的提供了<code class="highlighter-rouge">fsync</code>等强制刷新数据至磁盘的系统调用。</p>

<p><code class="highlighter-rouge">fsync</code>系统调用将使缓冲区数据和与打开文件描述符fd相关的所有元数据都刷新到磁盘上， 调用<code class="highlighter-rouge">fsync</code>会强制使文件处于Synchronized I/O file integrity completion状态。 所以， 当程序想要确保数据完全写入磁盘时， 可在<code class="highlighter-rouge">write</code>调用后执行<code class="highlighter-rouge">fsync</code>调用， 进行强制刷盘。</p>

<h4 id="3-c标准io函数库">3. C标准I/O函数库</h4>

<p>上面所提到的<code class="highlighter-rouge">open</code>， <code class="highlighter-rouge">read</code>等系统调用均有Linux/Unix系统所提供， 如Windows等操作系统并不支持此类调用。 为了解决不同操作系统底层提供的通用I/O函数不同的问题， ANSI C制定了一系列的标准I/O函数， 其目的就是为了解决代码的可移植性问题以及屏蔽I/O细节(缓冲区大小的选择， 文件锁实现等)。</p>

<p>标准I/O函数库中最常用的方法为<code class="highlighter-rouge">fopen</code>， <code class="highlighter-rouge">fgets</code>,  <code class="highlighter-rouge">fputs</code>以及<code class="highlighter-rouge">printf</code>， <code class="highlighter-rouge">fprintf</code>。 <code class="highlighter-rouge">fopen</code>和<code class="highlighter-rouge">open</code>的作用类似， 以某种模式(只读、只写等)打开一个文件， 唯一不同的是<code class="highlighter-rouge">open</code>返回<code class="highlighter-rouge">int</code>类型的文件描述符， 而<code class="highlighter-rouge">fopen</code>返回<code class="highlighter-rouge">FILE</code>类型的指针。</p>

<p>为了更好的理解<code class="highlighter-rouge">FILE</code>文件对象， 首先需要了解C标准I/O库的过程。 C标准I/O库的底层实现， 同样是基于Linux提供的通用I/O函数， 只不过标准库对其进行了封装而已。</p>

<p>C标准库除了帮助用户处理平台可移植性问题以外， 还会帮助用户减少系统调用的次数， 但是会额外的增加数据在内存间的复制次数。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/C%20Standard%20Libary.png" alt="" /></p>

<p>如上图所示，与Linux通用I/O相比， C标准I/O库自身也维护一个类似于内核缓冲的缓冲池， 内核缓冲区的数据并不会直接被复制到用户缓冲区中， 而是复制到标准库缓冲区中。 并且， 所复制的字节数也远大于用户所需要的字节数(count)， 当下次进行内容读取时， 直接从标准缓冲区中读取， 而不需要进行系统调用从内核缓冲区中读取。</p>

<p>该方式从整体上减少了系统调用的次数， 额外的增加了一次用户空间的数据复制， 由于标准I/O函数对系统调用进行了二次封装， 所以解决了可移植性问题。</p>

<p><code class="highlighter-rouge">fputc</code>以及<code class="highlighter-rouge">fputs</code>分别向所关联的文件流中写入单个字符或者是一串字符。 由于标准IO缓冲区的存在， 调用该方法时仅是将数据写入到C标准IO缓冲区中， 而后C标准库根据相应的条件决定何时执行<code class="highlighter-rouge">write</code>系统调用， 将数据写入内核缓冲区。 此后， 内核将决定在适当的时机将数据真正地写入磁盘。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/fputc.png" alt="" /></p>

<h5 id="31-c标准io缓冲">3.1 C标准I/O缓冲</h5>

<p>标准IO库提供了3种类型的缓冲: 全缓冲、行缓冲以及不带缓冲。</p>

<p>在全缓冲类型下， C函数库只有在完全填满标准IO缓冲区后才进行实际的IO操作， 磁盘文件通常是全缓冲的。 也就是说， 当程序使用<code class="highlighter-rouge">fopen</code>打开一个磁盘文件并调用<code class="highlighter-rouge">fputs</code>进行数据写入时， 数据可能仅写入了标准IO缓冲区中。 在随后的<code class="highlighter-rouge">fputs</code>调用中， 若C标准IO函数发现缓冲区已满， 则进行一次系统调用， 将数据写入至内核缓冲区中。</p>

<p>在行缓冲区类型下， 在输入和输出中遇到换行符(\n)时， 标准IO库执行实际的IO操作。 当一个流涉及到终端时(如标准输出)， 通常时行缓冲的， 例如<code class="highlighter-rouge">printf</code>函数。</p>

<p>不带缓冲则表示只要向标准缓冲区中写入数据， 标准库就会立即进行系统调用， 将数据写入内核缓冲。 标准错误通常是不带缓冲的， 原因在于期望能够尽快的看到错误的产生。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;
#include&lt;fcntl.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"This is printf out | "</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"This is a error output | "</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"BiuBiu</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello Aean: "</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">"I would have written you a short letter. | "</span><span class="p">;</span>
    <span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">43</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>编译并运行上述代码， 将会得到:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is a error output | This is <span class="nb">printf </span>out | BiuBiu
I would have written you a short letter. | Hello Aean:
</code></pre></div></div>

<p>当标准IO函数与系统调用混合使用时， 将会看到与代码期望完全不同的结果。 尽管<code class="highlighter-rouge">printf</code>函数在<code class="highlighter-rouge">fprintf</code>之前执行， 但由于<code class="highlighter-rouge">printf</code>为行缓冲， 而标准错误为不带缓冲， 所以标准错误信息将在标准输出信息打印之前打印。 <code class="highlighter-rouge">write</code>函数为系统调用， 输出的时机要优先于不带换行符的标准输出。</p>

<p>标准IO函数库同时也提供了<code class="highlighter-rouge">fflush</code>函数， 用于将标准缓冲区的数据强制刷新至内核， 如果我们在<code class="highlighter-rouge">printf</code>函数调用后调用<code class="highlighter-rouge">fflush</code>， 则会在标准错误输出之前看到输出。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"This is printf out | "</span><span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"This is a error output | "</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其结果为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is <span class="nb">printf </span>out | This is a error output
</code></pre></div></div>

<p>使用过Docker部署Python项目的小伙伴儿可能对环境变量<code class="highlighter-rouge">PYTHONUNBUFFERED</code>感到很熟悉， 官方文档解释如下:</p>

<blockquote>
  <p>Force stdin, stdout and stderr to be totally unbuffered. On systems where it matters, also put stdin, stdout and stderr in binary mode.</p>
</blockquote>

<p>简单来说， 在Docker中使用该变量， 能够更快的使日志输出， 并且在容器crash的情况下， 也能看到必要的日志信息。</p>

<p>更详细的解释:</p>

<blockquote>
  <p>Setting PYTHONUNBUFFERED=TRUE or PYTHONUNBUFFERED=1 (they are equivalent) allows for log messages to be immediately dumped to the stream instead of being buffered. This is useful for receiving timely log messages and avoiding situations where the application crashes without emitting a relevant message due to the message being “stuck” in a buffer.
As for performance, there can be some (minor) loss that comes with using unbuffered I/O. To mitigate this, I would recommend limiting the number of log messages. If it is a significant concern, one can always leave buffered I/O on and manually flush the buffer when necessary.</p>
</blockquote>

<p>有关Linux通用IO以及C标准IO库的缓冲区， 可用下图清晰总结。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/IO%20buffer.png" alt="" /></p>

<p>原图来源于Linux/Unix系统编程手册， P200。</p>

<h4 id="4-内存映射io">4. 内存映射I/O</h4>

<p>现代操作系统大多数均采用分段+分页的方式来管理内存空间， 其目的就在于使得每一个进程的地址空间独立， 并且使系统能够运行超过其内存空间总数的各种进程。</p>

<p>分页内存管理的基本思想就是映射， 思想和哈希表基本类似: 将一个大范围的空间映射至一个小范围空间内。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/virtaul%20memory.png" alt="" /></p>

<p>当程序想要访问的虚拟地址没有在页表项建立映射时， 系统将发起一个”缺页异常”， 由操作系统建立页表项并建立虚拟地址页与物理地址页的映射关系。 如此一来， 能够使得不常用的数据或者是内存片段被细粒度地换置至磁盘中， 内存中保留常用的数据。</p>

<p><code class="highlighter-rouge">mmap</code>方法的原理与虚拟内存映射基本相同， 将进程的一部分地址空间与磁盘文件建立映射关系， 将文件当做是内存中的一个数组使用， 减少<code class="highlighter-rouge">read</code>, <code class="highlighter-rouge">write</code>以及<code class="highlighter-rouge">lseek</code>的调用。</p>

<p>需要注意的是， 内存映射一个文件并不会导致整个文件被读取到内存中， 就如同虚拟内存空间不会都在物理地址空间一样， 而是仅仅为需要的文件数据保留映射关系。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">mmap</span>

<span class="k">def</span> <span class="nf">memory_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="n">mmap</span><span class="o">.</span><span class="n">ACCESS_WRITE</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDWR</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mmap</span><span class="o">.</span><span class="n">mmap</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="n">access</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">memory_map</span><span class="p">(</span><span class="s">'hello.txt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">15</span><span class="p">])</span>
</code></pre></div></div>

<p>此外，使用内存映射I/O的读写并不一定会比C标准I/O库或者是Linux通用I/O更加高效， 其原因在于虽然<code class="highlighter-rouge">mmap</code>减少了用户态的切换以及减少了数据的复制， 但是增加了处理缺页错误、建立页表项的时间， 并且各个平台对于<code class="highlighter-rouge">mmap</code>的实现也各有不同， 其优点就在于更加简洁的随机读取以及数据写入。</p>

<h4 id="5-异步io">5. 异步I/O</h4>

<p>异步I/O的实现通常会有两种: 当文件可读/可写时， 内核向进程发送一个信号， 或者是内核调用进程提供的回调函数。 在Linux下， AIO有2种实现: 基于线程模拟异步I/O的glibc AIO， 以及由内核实现的Kernel AIO。</p>

<p>对于glibc AIO而言， 是在用户空间使用多线程来模拟实现的， 并不能真正的称之为异步I/O， 但是能够在任意的文件系统、任意的操作系统上运行。</p>

<p>而Kernel AIO采用信号通知的方式实现异步I/O， 只能在Linux操作系统上运行， 基本没有可移植性。 此外， 一个最重要的问题就是Kernel AIO要求用户必须使用<code class="highlighter-rouge">O_DIRECT</code>模式打开文件， 即绕过内核高速缓冲区， 直接将数据传递至文件或者是磁盘设备， 这种方式又称为直接I/O(direct I/O)。</p>

<p>对于大多数应用而言， 使用直接I/O可能会大大的降低性能， 并且会有诸多不便之处。 其原因在于内核针对缓冲区高速缓存做了不少优化， 包括按顺序读取， 在成簇磁盘块上执行I/O， 允许访问同一文件的多个进程共享内核缓冲区。 并且， 直接I/O由于直接将数据传输至磁盘， 所以必须遵守磁盘的一些限制， 包括但不限于: 用于传递数据的缓冲区其内存边界必须对齐为块大小的整数倍， 待传输的数据长度必须是块大小的整数倍…</p>

<p>正是因为诸多限制， 不管是glibc AIO， 还是Kernel AIO， 在绝大部分的应用中都未曾使用， 看起来AIO就是专门为数据库应用所提供的实现。</p>

<h4 id="6-zero-copysendfile">6. Zero Copy(sendfile)</h4>

<p><code class="highlighter-rouge">sendfile</code>系统调用用于在两个文件描述符之间传输数据， 在Linux Kernel 2.6.33以前， <code class="highlighter-rouge">sendfile</code>只能将数据从一个具体的文件发送到一个<code class="highlighter-rouge">socket</code>中。 而在此版本之后， <code class="highlighter-rouge">sendfile</code>的接收方可以是任意的文件， 但是输入端只能是存在于虚拟内存空间的文件描述符， <code class="highlighter-rouge">socket</code>则不在此列。</p>

<p>方法原型为:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;sys/sendfile.h&gt;
</span>
<span class="kt">ssize_t</span> <span class="n">sendfile</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__out_fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__in_fd</span><span class="p">,</span> <span class="kt">off_t</span> <span class="o">*</span><span class="n">__offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">__count</span><span class="p">);</span>
</code></pre></div></div>

<p>一个简单的文件复制示例:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;fcntl.h&gt;
#include&lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/sendfile.h&gt;
</span>
<span class="kt">int</span> <span class="nf">get_file_size</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">stat</span> <span class="n">statbuf</span><span class="p">;</span>
    <span class="n">stat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statbuf</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">statbuf</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 省去错误判断
</span>    <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"foo.txt"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"bar.txt"</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">foo_size</span> <span class="o">=</span> <span class="n">get_file_size</span><span class="p">(</span><span class="s">"foo.txt"</span><span class="p">);</span>
    <span class="n">sendfile</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="n">foo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">foo_size</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外需要注意的是， <code class="highlighter-rouge">sendfile</code>在文件之间传输数据时， 并不支持<code class="highlighter-rouge">O_APPEND</code> flags， 只能覆盖写入。</p>

<p><code class="highlighter-rouge">sendfile</code>系统调用完全在内核空间进行， 数据不会从内核空间拷贝至用户空间， 并且能够得到DMA的硬件支持， 因而速度很快。</p>

<h4 id="7-总结">7. 总结</h4>

<p>对于非数据库类型的应用而言， 文件I/O的可选范围并不广， 即与其花费大量时间调试异步I/O， 不如直接选择C标准库I/O， 因为同时监听成百上千的文件读写并不常见。 对于频繁随机读取和写入的文件而言， 可以使用内存映射I/O来减少<code class="highlighter-rouge">lseek</code>的调用， 而<code class="highlighter-rouge">sendfile</code>系统调用更多地应用于文件至socket的数据传输。</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL中的悲观锁与常见的死锁场景</title>
	  <link>//MySQL-Pessimistic-Lock</link>
	  <author></author>
	  <pubDate>2019-09-18T21:39:25+00:00</pubDate>
	  <guid>//MySQL-Pessimistic-Lock</guid>
	  <description><![CDATA[
	     <p>在MySQL中， 锁机制是并发条件下保护数据一致性与稳定性的一个非常重要的机制， 并且事务的实现也依赖于于锁机制。 其锁定的数据不单包括数据行记录， 同时也包括缓冲池中的LRU列表数据、日志数据等。 悲观锁(FOR UPDATE)则是日常开发中使用最多的一种锁， 但是， 由于事务隔离级别的多样性导致了悲观锁在使用时常常会有不同的表现， 死锁在程序员稍不注意时就会发生。</p>

<!---more--->

<h4 id="1-悲观锁概述">1. 悲观锁概述</h4>
<p>在通用的程序设计语言中， 锁通常是基于某一个对象， 或者是一组对象而言。 在Python、Java和Golang中， 分别提供了<code class="highlighter-rouge">threading.Lock</code>、<code class="highlighter-rouge">synchronized</code>以及<code class="highlighter-rouge">sync.Mutex</code>互斥所机制。 而数据库要更为特殊一些， 其原因就在于我们所管理的不是一个个的对象， 而是一行行的数据。</p>

<p>InnoDB存储引擎支持的最小锁粒度为行锁， 可以通过在事务中执行<code class="highlighter-rouge">SELECT .. FOR UPDATE</code>为某一行或者是多行数据添加互斥锁。 锁的生命周期完全由InnoDB管理， 当事务成功提交或者是失败回滚时， 互斥锁则自动释放。</p>

<p>需要注意的一点是， 互斥锁必须在事务中执行才会生效。 当<code class="highlighter-rouge">autocommit</code>为<code class="highlighter-rouge">ON</code>时， 需要显示的使用<code class="highlighter-rouge">BEGIN</code>开启事务， 而后对数据添加互斥锁。</p>

<p>在程序设计语言中， 锁的目的是串行化修改、删除操作， InnoDB中的互斥锁有着同样的目的。 但是， 由于事务隔离级别的分类， 使得互斥锁的行为变得复杂许多。 其中最让人感到迷惑的就是为了解决幻读问题所添加的<code class="highlighter-rouge">GAP Lock</code>。</p>

<h4 id="2-事务隔离级别概述">2. 事务隔离级别概述</h4>

<p>不同的事务隔离级别， 悲观锁会产生不同的行为。 所以， 理解事务隔离级别是理解悲观锁的第一步。</p>

<p>InnoDB事务隔离级别从低到高依次为未提交读(READ UNCOMMITED)， 提交读(READ COMMITED)， 可重复读(READ REPEATABLE)以及串行化(SERIALIZABLE)。</p>

<p>未提交读指的是事务B可以读取到事务A未提交的数据， 此时若事务A回滚， 那么事务B读到的就是错误数据， 也称为脏数据。 该读取行为有时也会被称为脏读， 因为未提交读会导致脏读的问题， 从而导致数据混乱， 所以该事务隔离级别基本不会被使用。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/read-uncommitted-with-dirty-data.png" alt="" /></p>

<p>提交读是指在执行事务B时， 可以读取到事务A提交到的数据， 未提交的数据不可读取。 提交读解决了脏读的问题， 读取到的数据一定是已经持久化至磁盘的数据， 但是会出现同一条SQL语句在执行时出现不一致的情况。 例如事务A、B先后开始执行， 事务A首先读取row-1的内容， 而此时事务B对row-1的内容修改并提交， 此时事务A再次读取row-1数据， 发现其已经发生改变， 而该变化并不是事务A自身进行的。 这种情况又称为不可重复读。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/Read-Committed.png" alt="" /></p>

<p>可重复读， 顾名思义， 解决了提交读的不可重复读问题， 使得事务在读取同一行数据时， 结果并不会因为其它事务的执行而发生改变， 数据发生的修改行为在整个事务内是可以自恰的。 但是并没有解决幻读的问题， 幻读是指其余事务在某一个区间内插入数据， 而非修改数据， 此时事务也会读取到这部分插入的数据。 InnoDB借助MVCC(多版本并发控制)以及锁机制来解决幻读问题。</p>

<p>MVCC即在数据中添加版本号， 数据插入时会有初始版本号， 在修改、删除时更新版本号。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/Repeatable-Read.png" alt="" /></p>

<p>串行化指事务串行化执行， 自然就不会有出现上述出现的脏读、不可重复读以及幻读了。 一个很重要的事实是， 串行化的事务隔离级别执行效率并不会比可重复读事务隔离级别差很多。 同样的， 提交读执行效率也不会比可重复读执行效率高多少， 所以在优化数据库时， 事务隔离级别不应该是效率优化目标， 而是业务优化目标。</p>

<h4 id="3-mysql中的锁">3. MySQL中的锁</h4>

<p>使用<code class="highlighter-rouge">FOR UPDATE</code>对某一行或者是多行数据添加的锁， 其实是由MySQL更细粒度的锁组合而成的， 不同的事务隔离级别有不同的组合方式。</p>

<p>在InnoDB存储引擎中， 存在3种行锁的算法， 其分别为:</p>
<ul>
  <li>Record Lock: 单个行记录上的锁，聚集索引及辅助索引均会添加锁。</li>
  <li>Gap Lock: 间隙锁， 锁定一个范围， 但不包含行记录本身。</li>
  <li>Next-Key Lock: Record Lock + Gap Lock，锁定行记录本身并且锁定一个范围。</li>
</ul>

<p>下面用一个实际的例子来解释Record Lock以及Gap Lock。 首先表结构定义如下:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">lock_test</span> <span class="p">(</span>
  <span class="n">id</span> <span class="n">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="n">a</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">latin1</span><span class="p">;</span>

<span class="c1">-- 插入部分测试数据</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"1"</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"3"</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"5"</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"8"</span><span class="p">);</span>
</code></pre></div></div>

<p>接着执行下面的语句:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “5” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“4”); <br /> 阻塞，等待会话A事务的提交</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">COMMIT;</td>
      <td style="text-align: left">Query OK, 1 row affected (6.87 sec)</td>
    </tr>
  </tbody>
</table>

<p>尽管列<code class="highlighter-rouge">a</code>添加了辅助索引， 但是在对该列使用<code class="highlighter-rouge">FOR UPDATE</code>添加悲观锁时， 仍然会出现其它列被锁定的现象。 这是因为<code class="highlighter-rouge">a = "5"</code>该行数据不仅被添加了Record Lock， 并且也添加了Gap Lock， 其目的就是为了解决幻读问题， 前提是当前事务隔离级别为REPEATABLE READ。</p>

<p>在列<code class="highlighter-rouge">a</code>的辅助索引中， 值”5”之前的值为”3”， 故存在(3, 5)这个间隙， 所以在插入值”4”时， InnoDB为了杜绝幻读现象的发生， 使得只有在会话A事务提交时才允许插入操作的进行。 另外一点需要注意的是， 当查询的索引具有唯一属性时， InnoDB存储引擎会对Next-Key Lock进行优化， 将其降级为Record Lock， 即仅锁住索引本身， 而不锁定一个范围。</p>

<blockquote>
  <p>For a unique index with a unique search condition, InnoDB locks only the index record found, not the gap before it.</p>
</blockquote>

<h4 id="4-锁与事务之间的关联">4. 锁与事务之间的关联</h4>

<p>前面提到了Gap Lock的存在主要是为了解决幻读问题的发生， 而在READ COMMITTED事务隔离级别中， 只解决了脏读问题， 所以说， 在该事务隔离级别下， <code class="highlighter-rouge">FOR UPDATE</code>仅会添加Record Lock， 并不会添加Gap Lock。</p>

<blockquote>
  <p>For locking reads (SELECT with FOR UPDATE or FOR SHARE), UPDATE statements, and DELETE statements, InnoDB locks only index records, not the gaps before them.</p>
</blockquote>

<blockquote>
  <p>Because gap locking is disabled, phantom problems may occur, as other sessions can insert new rows into the gaps</p>
</blockquote>

<p>此外， 如果用户通过索引查询一个值， 并在其之上添加排它锁， 当查询的值不存在时， READ COMMITTED与REPEATABLE READ两个事务隔离级别所产生的行为同样存在差异， 一个最直观的差异就是REPEATABLE READ在并发条件下会产生死锁， 而READ COMMITTED则不会。</p>

<p>READ COMMITTED事务隔离级别:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “100” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “100” FOR UPDATE; <br /> 不会被阻塞</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“100”); <br /> 不会被阻塞</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">6</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“100”); <br /> 不会被阻塞</td>
    </tr>
    <tr>
      <td style="text-align: left">7</td>
      <td style="text-align: left">COMMIT;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">8</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">COMMIT;</td>
    </tr>
  </tbody>
</table>

<p>所以说， 当事务隔离级别为READ COMMITTED时， 无法使用Next-Key Lock来帮助我们实现类似于<code class="highlighter-rouge">update_or_create</code>或者是<code class="highlighter-rouge">get_or_create</code>等方法， 因为在并发条件下会造成重复数据创建， 除非表中存在唯一索引。 这也是Django框架官网中所提到的Multiply records问题。 感兴趣的小伙伴可访问官网获取更多详细内容:</p>

<blockquote>
  <p>https://docs.djangoproject.com/en/2.2/ref/models/querysets/#get-or-create</p>
</blockquote>

<p>REPEATABLE READ事务隔离级别:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE; <br /> 不会被阻塞</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“200”); <br /> 阻塞, 等待事务B的结束</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">6</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“200”); <br /> ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction，死锁发生</td>
    </tr>
  </tbody>
</table>

<p>当在REPEATABLE READ事务隔离级别级别下实现<code class="highlighter-rouge">get_or_create</code>方法时，会产生死锁问题， 原因就在于锁定的记录并不存在， 多个事务可同时对其添加悲观锁， 但是插入语句的执行位置是不确定的， 所以就会有死锁问题的出现。解决此类问题的一个方法就是使用指数退避方式的重试。</p>

<h4 id="5-死锁">5. 死锁</h4>

<p>通常来讲， 如果我们的SQL执行计划较为简单， 几乎所有的执行均为单条语句执行时， 死锁基本与我们无关。 但是当执行计划稍加复杂， 事务执行的语句较多时， 就会出现死锁问题。 一个最经典的死锁场景即为AB-BA死锁。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “400” FOR UPDATE;</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “400” FOR UPDATE<br /> 阻塞, 等待事务B的结束</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">6</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE; <br /> ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction，死锁发生</td>
    </tr>
  </tbody>
</table>

<p>当MySQL检测到死锁时， 会根据其事务权重选择性的回滚其中一个事务。 但是， 权重的判定完全由MySQL决定， 业务系统无法人为的干预， 如果某一个事务在业务系统中非常重要， 但是MySQL却回滚了该事务， 而业务系统仅捕捉了该异常并向外扩散的话， 并不是我们期望的结果。 所以， 在绝大多数场景下， 指数退避的重试策略要更好一些。 或者对于关键性的业务逻辑， 使用Redis等消息队列进行串行化操作。</p>

<p>另外一个死锁场景则是上一小节中我们所见到的并发执行<code class="highlighter-rouge">if not exist then create</code>模式所带来的死锁问题， 该模式在业务场景下其实非常常见。</p>

<h4 id="reference">Reference</h4>
<ul>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html</li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
