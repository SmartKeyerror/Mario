<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>smartkeyerror.com/</title>
   
   <link>https://smartkeyerror.com</link>
   <description>Keep coding, Keep curiosity</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>InnoDB如何保证事务的原子性与持久性</title>
	  <link>//InnoDB-AD</link>
	  <author></author>
	  <pubDate>2020-05-28T18:06:25+00:00</pubDate>
	  <guid>//InnoDB-AD</guid>
	  <description><![CDATA[
	     <p>在InnoDB存储引擎中，一个事务的执行将涉及到3个日志的数据写入: redo log，undo log以及binlog。其中redo log以及binlog主要实现事务的原子性和持久性，而undo log主要用于实现事务的隔离性。</p>

<!---more--->

<h3 id="1-redo-log">1. redo log</h3>

<p>redo log又称之为重做日志，主要记录了事务对数据页(Page)的物理修改。redo log由两部分组成: 一是位于内存的redo log buffer，用于对redo log进行缓冲，目的在于提升性能。另一部分则位于硬盘中，用于对redo log的持久化。</p>

<h4 id="11-redo-log-buffer">1.1 redo log buffer</h4>

<p>redo log buffer用于优化redo log的写入性能，默认大小为16MB，最大大小为4GB。当一个事务对数据页进行修改时，首先将修改内容放置于缓冲中，而后再对其进行持久化。</p>

<h4 id="12-redo-log">1.2 redo log</h4>

<p>默认情况下，redo log由两个文件构成，<code class="highlighter-rouge">ib_logfile0</code>以及<code class="highlighter-rouge">ib_logfile1</code>。redo log的大小由配置文件决定，在5.7版本中，默认大小为48MB。由于其大小固定，所以数据在写入该日志文件时，将使用循环写入的方式: 首先从头开始写，写到末尾，然后再从头开始写，后面写入的内容会覆盖最初的内容，所以称之为循环写入。</p>

<p>redo log的文件大小设置和MySQL的负载相关，通常来说redo log应该能容纳至少一个小时的数据修改，一般<code class="highlighter-rouge">innodb_log_file_size</code>设置为1GB，<code class="highlighter-rouge">innodb_log_files_in_group</code>设置为4，总计4GB的redo log容量。重做日志大小如果设置的过大，宕机恢复时所花的时间也会越多，所以并不是越大越好。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/redo-log.png" alt="" /></p>

<p>redo log buffer中的数据将会在以下时机持久化至位于磁盘的redo log中:</p>

<ul>
  <li>事务提交</li>
  <li>当redo log buffer有一半的空间已经被使用时</li>
  <li>InnoDB后台线程每秒将数据持久化至硬盘</li>
</ul>

<p>所以，需要明确的是，当某个事务未提交(commit)时，该事务对物理数据页的修改也可能会持久化至redo log文件中。</p>

<h4 id="13-lsn">1.3 LSN</h4>

<p>在redo log中，还有一个非常重要的属性: LSN，Log Sequence Number，即日志序列号。接下来我们将会看到，LSN在数据恢复以及Group Commit中起到了决定性的作用。</p>

<p>在InnoDB存储引擎中，LSN占用8个字节，且单调递增。LSN所表示的含义包括redo log的总量，checkpoint的位置以及数据页的版本。</p>

<p>假设当前redo log的LSN为1000，事务T1写入了200字节的redo log，那么LSN将递增至1200。若事务T2写入了500字节的redo log，那么LSN又将变成1700。所以通过查看LSN的大小即可知道redo log的总量，单位为字节。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; show engine innodb status<span class="se">\G</span><span class="p">;</span>
<span class="nt">---</span>
LOG
<span class="nt">---</span>
Log sequence number 20598039739
Log flushed up to   20598039739
Pages flushed up to 20598039739
Last checkpoint at  20598039730
0 pending log flushes, 0 pending chkp writes
10 log i/o<span class="s1">'s done, 0.00 log i/o'</span>s/second
</code></pre></div></div>

<p>如上所示，Log sequence number表示当前的LSN，Log flushed up to表示已经刷新到redo log文件的LSN。</p>

<h3 id="2-binlog">2. binlog</h3>

<p>binlog为MySQL层面的逻辑日志，用于记录对哪一行数据进行了哪些修改，不管使用何种存储引擎，都会有binlog的记录。redo log则是InnoDB存储引擎所特有的日志记录，并且其中记录的是对物理数据页的修改。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/logical-binlog.png" alt="" /></p>

<p>关于binlog的更多内容将在后续的MySQL主从复制中描述。</p>

<h3 id="3-事务执行过程">3. 事务执行过程</h3>

<p>InnoDB存储引擎在提交事务时，为了保证原子性和持久性，将会采用”两阶段”提交的方式写入redo log和binlog。</p>

<h4 id="31-一阶段">3.1 一阶段</h4>

<p>首先，在MySQL中所有执行的SQL语句都会有一个全局递增且循环使用的query_id。当用户开启事务并执行语句后，MySQL将会把第一个语句的query_id分配给该事务，作为Xid的值。</p>

<p>当用户执行<code class="highlighter-rouge">COMMIT</code>提交事务时，将redo log buffer的内容调用<code class="highlighter-rouge">write()</code>系统调用写入内核缓冲区，并调用<code class="highlighter-rouge">fsync()</code>系统调用确保数据写入至硬盘(至少是硬盘的缓冲区)，更新状态为prepare。</p>

<h4 id="32-二阶段">3.2 二阶段</h4>

<p>将产生的binlog调用<code class="highlighter-rouge">write()</code>系统调用写入内核缓冲区，并调用<code class="highlighter-rouge">fsync()</code>系统调用将数据持久化至硬盘，写入成功后事务即可被提交，并更新状态为commit。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/2PC.png" alt="" /></p>

<p>当数据成功地写入到binlog以后，即可返回给用户事务提交成功。由于数据写入<code class="highlighter-rouge">.ibd</code>文件需要随机读写，所以将会由其它线程异步写入，以提高事务执行的效率。</p>

<p>现在来看两阶段提交在数据库Crash的情况:</p>

<ul>
  <li>binlog有记录，但redo log状态为prepare: 此时表示在写入binlog数据库崩溃，需要根据binlog进行数据恢复</li>
  <li>binlog有记录，redo log状态为commit: 事务正常提交，无需恢复</li>
  <li>binlog无记录，redo log状态为prepare: 事务执行一半时崩溃，无需恢复</li>
  <li>binlog无记录，redo log状态为commit: 在binlog持久化时崩溃，事务直接回滚</li>
</ul>

<p>可以看到，通过上述的两阶段提交方式能够保证不会产生脏事务，并且已成功提交的事务也能够在MySQL崩溃后重启恢复。</p>

<p>当redo log和binlog均正确的写入数据以后，就可以返回<code class="highlighter-rouge">OK</code>给用户了。至于何时将用户的修改持久化至<code class="highlighter-rouge">.ibd</code>文件中，由MySQL后台线程决定。</p>

<p>基于redo log和binlog的WAL(Write-Ahead Log)机制可以保证数据的原子性以及持久性，并且由于日志是顺序读写，所以事务的执行速度会快很多。</p>

<h3 id="4-group-commit">4. Group Commit</h3>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/2PC.png" alt="" /></p>

<p>从上图模型可以看到，每一个事务的提交，都会伴随着两次<code class="highlighter-rouge">write()</code>以及<code class="highlighter-rouge">fsync()</code>系统调用。对于<code class="highlighter-rouge">Write()</code>调用来说，仅仅只是将用户缓冲区的内容写入至内核缓冲区中，虽然会有用户态与内核态的切换，但是仍然要比<code class="highlighter-rouge">fsync()</code>要快。</p>

<p>如果采用上述模型实现事务的话，如果有两万个并发事务执行，那么磁盘的IO负载将会达到四万，并且事务的执行效率将会非常之差。</p>

<p>为了解决事务执行效率问题，MySQL引入了组提交(Group Commit)技术: 在事务提交时，尽可能多地向文件中写入数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/LSN-Commit.png" alt="" /></p>

<p>如上图所示，共有3个事务并行执行，其中trx:1事务准备提交。按照之前的模型，将trx:1的redo log写入至磁盘中，并将binlog写入至磁盘中。</p>

<p>而在Group Commit中，当trx:1准备提交时，将会刷新最大的LSN之前未刷新的所有redo log。在该示例中，trx:1准备刷新时，则会将LSN为1600之前的所有redo log一齐刷新至磁盘。原来需要6次系统调用，现在只需要2次。</p>

<p>为了能够让redo log在每次写入时尽可能多的写入，MySQL将redo log调用<code class="highlighter-rouge">fsync()</code>的时机延迟，延迟至binlog调用<code class="highlighter-rouge">write()</code>之后:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/ZeroMind/DistributedSystem/MySQL-Replication/delay-fsync.png" alt="" /></p>

<p>这样一来，binlog也能够组提交了，能够有效地减少IOPS的消耗。</p>

<p>MySQL额外的提供了两个延迟参数来提高binlog的组提交效率:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 表示延迟多少微秒后才调用binlog的fsync()</span>
binlog_group_commit_sync_delay

<span class="c"># 表示累积了多少个binlog才调用binlog的fsync()</span>
binlog_group_commit_sync_no_delay_count
</code></pre></div></div>

<p>这两个参数为”或”关系，即只要满足一个条件，就会调用<code class="highlighter-rouge">fsync()</code>。当磁盘IO出现性能瓶颈时，可根据实际负载来设置该值，从而降低磁盘IO负载，代价是会增加事务的响应时间。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Linux主机通过Windows虚拟机转发Easyconnect内网请求</title>
	  <link>//Linux-Use-EasyConnect</link>
	  <author></author>
	  <pubDate>2020-02-27T12:06:25+00:00</pubDate>
	  <guid>//Linux-Use-EasyConnect</guid>
	  <description><![CDATA[
	     <p>世界上有个恶心的公司叫Sangfor，开发出了恶心的工具EasyConnect，本来这东西都是给在校的学生用的，好不好用都无所谓。但是很多公司也开始使用这个来访问内网，并且还不支持Linux(反正到目前Ubuntu下的64bit版本连接就没成功过)，这就很令人讨厌了。回想起Ubuntu下使用Wine安装微信的种种难受，决定还是使用Windows虚拟机开启EasyConnect，并把部分的Linux流量打进虚拟机。</p>

<!---more--->

<h4 id="1-虚拟机配置">1. 虚拟机配置</h4>
<p>虚拟机需要两块网卡，其中一块必须是Host-only类型的，用来和Linux主机通信，这块儿网卡是内网流量的入口，所以必须配置。另一块可以是NAT，也可以是Bridge，随个人喜好。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/VMware-Network-Config.png" alt="" /></p>

<h4 id="2-windows虚拟机网络配置">2. Windows虚拟机网络配置</h4>

<p>进到Windows虚拟机以后，打开网络适配器设置，这时候可以看到两张网卡: Ethernet0和Ethernet1，找到Host-only那张网卡，并修改其名称为<code class="highlighter-rouge">Host</code>，起一个有意义的名称对后面的操作非常有帮助。如果不确定哪张网卡是Host-only的话，可以对比网卡的MAC地址和虚拟机网络配置中的MAC地址。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/Ethernet.png" alt="" /></p>

<p>开启EasyConnect，并建立与内网的连接，此时会多出一张名为”以太网”的网卡，这张网卡的IP地址子网掩码什么的都可以不用管，就是张工具卡。设置该网络的共享属性，和前面建立的Host-only网卡建立共享。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/share-with-host-only.png" alt="" /></p>

<p>设置完成以后会发现Host-only那张网卡的IP地址被强制更改成了192.168.137.1，改了就改了吧，也不是不能用。</p>

<p>并关闭Windows的公用网络防火墙，不然数据包会被防火墙拦截。</p>

<h4 id="3-设置linux路由规则">3. 设置Linux路由规则</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>ip a add 192.168.137.2/24 dev vmnet1
<span class="nb">sudo </span>ip r add 10.0.0.0/8 via 192.168.137.1
</code></pre></div></div>

<p>给vmnet1，也就是Host-only网卡添加一个和192.168.137.2相同IP地址段的IP地址，使Linux能够建立正常的路由转发规则，否则Linux主机根本就不知道192.168.137.1这个IP地址是谁的。然后将所有的内网(10.0.0.0/8)请求都通过192.168.137.1走Windows的内网网络。</p>

<h4 id="4-windows安装ccproxy">4. Windows安装CCProxy</h4>

<p>对于某些需要域名解析的HTTP请求，又不想用dnsmasq去自己解析DNS，就可以直接用该工具进行转发，下载、安装和使用傻瓜式操作，完美，非常适合我这种智商不高的人。</p>

<p>安装完成以后设置下本机局域网IP地址，选择NAT或者是Bridge的那张网卡即可:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/CCProxy.png" alt="" /></p>

<p>由于我的Chrome用了SwitchOmega，并不想牺牲某些便利，所以使用Firefox进行代理设置，内网的HTTP请求以后就用Firefox发送，流量使用分明，代理配置也尽量分开。</p>

<p>Firefox中输入<code class="highlighter-rouge">about:preferences</code>，拉到最底下，选择Network Settings，就可以进行代理设置了。</p>

<p>CCProxy的HTTP协议默认端口为808，IP地址则是NAT或者Bridge网卡的IP地址，进行配置即可:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/tool/proxy/Firefox-Config.png" alt="" /></p>

<p>需要注意的是FTP端口为2121，SOCKS端口为1080，因为我不需要这两个协议，所以并没有配置。</p>

<p>完)</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL-InnoDB中的锁</title>
	  <link>//MySQL-InnoDB-Lock</link>
	  <author></author>
	  <pubDate>2020-01-31T10:06:25+00:00</pubDate>
	  <guid>//MySQL-InnoDB-Lock</guid>
	  <description><![CDATA[
	     <p>锁在InnoDB存储引擎中的使用远比我们想象中的更加频繁，及时是一条最为简单的<code class="highlighter-rouge">update set</code>语句，其中也涉及到了各种锁的使用。包括常说的一致性锁定读，解决幻读等场景中，同样包含了锁的大量使用。</p>

<!---more--->

<h4 id="1-latch和lock">1. Latch和Lock</h4>

<p>在InnoDB存储引擎中，Latch(门闩)是用来保证并发线程操作临界资源的正确性，保证某些操作的原子性。通常又分为Mutex(互斥量)和RWLock(读写锁)，例如Python中<code class="highlighter-rouge">threading.Lock</code>，Java中<code class="highlighter-rouge">synchronized</code>，Golang中的<code class="highlighter-rouge">sync.Mutex</code>，Latch通常应用于操作缓冲池中的LRU列表元素(添加、删除以及移动)，部分场景下的<code class="highlighter-rouge">AUTO_INCREMENT</code>实现。用户通常不会直接地与Latch打交道，并且没有死锁检测。</p>

<p>Lock作用于事务之中，用来锁定表、页、行，锁的添加与释放通常会在事务的起始和结束时进行。数据库中的幻读问题解决就是通过Lock实现的，而非Latch。并且Lock存在死锁检测机制，当发生死锁时，会在某些情况下告知用户，例如在使用一致性锁定读(SELECT…FOR UPDATE)时产生的死锁，会直接抛出1213的Deadlock异常。</p>

<p>尽管Latch与Lock操作的对象均为数据，但是Latch更为底层，操作的对象更加细小。Lock的对象相对于Latch而言，则更加”粗放”，例如表、页数据，此外最重要的是Lock的作用域为事务，Latch则不是。</p>

<h4 id="2-innodb存储引擎中的lock">2. InnoDB存储引擎中的Lock</h4>

<p>为了方便叙述，下面均使用锁来指代InnoDB中的Lock(仍然要说明，Lock以及Latch都可以称为锁，这里只是为了方便叙述)。</p>

<p>InnoDB引擎支持行锁以及表锁，既可以锁定某一行，同时也可以锁定一整张表，先从行级锁说起。</p>

<p>InnoDB引擎实现了两种标准的行级锁:</p>
<ul>
  <li>共享行级锁(S Lock, Share Lock)</li>
  <li>排他行级锁(X Lock, Exclusive Lock)</li>
</ul>

<p>可以认为S Lock和X Lock分别表示读锁和写锁，如同RWLock一样。S Lock允许并发地读取数据，X Lock既限制并发地读取，同时也限制并发地修改。所以说，当某一行数据中存在S锁时，只能再次添加S锁，若想要添加X锁，则需要等待S锁的释放。行级锁X以及S Lock的兼容性如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">-</th>
      <th style="text-align: center">X</th>
      <th style="text-align: center">S</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">X</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">S</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
  </tbody>
</table>

<p>同时，InnoDB支持表级锁，为了支持表级锁与行级锁这两个不同粒度的锁，InnoDB支持一种额外的上锁方式，称之为意向锁(Intention Lock)。</p>

<p>为了更好的理解意向锁，首先假设没有意向锁，只有表锁和行锁。当事务A在更新某一条数据时，会在该数据行上添加X锁。此时另外事务B申请整个表的写锁，如果事务B申请成功，那么它就能修改表中任意一行数据，这与事务持有的X锁冲突。</p>

<p>如果数据库想要避免该冲突，那么需要让事务B阻塞，直到事务A提交释放X锁。转而需要判断事务B阻塞的条件: ①当前表是否被其它事务添加表锁 ②判断表中是否存在行锁。这两个条件判断均可以在表层面实现，而无需遍历所有数据，只需要定义好数据结构即可。一个最简单的实现就是为表锁和行锁添加两个标识位，该标识位在添加和释放锁时进行原子更新，例如:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table_s_lock <span class="o">=</span> <span class="nb">false
</span>table_x_lock <span class="o">=</span> <span class="nb">false
</span>row_s_lock <span class="o">=</span> <span class="nb">true
</span>row_x_lock <span class="o">=</span> <span class="nb">true</span>
</code></pre></div></div>

<p>当某一行添加X锁时，将<code class="highlighter-rouge">row_x_lock</code>置为true，若其余事务想要添加表级别的X锁，则必须等待<code class="highlighter-rouge">row_x_lock</code>更新为false。反之若事务已经添加了表级别的X锁，将<code class="highlighter-rouge">table_x_lock</code>置为true，事务B若想在某一行添加X锁，则需要等待<code class="highlighter-rouge">table_s_lock</code>以及<code class="highlighter-rouge">table_x_lock</code>均更新为false。</p>

<p>虽然上面的标识位能够解决问题，但仍然有些奇怪，奇怪的点在于标识位的判断粒度不同。我们更加希望表级锁与表级锁进行兼容性判断，行级锁与行级锁进行兼容性判断，而不是表级锁与行级锁进行兼容性判断。由此，就有了意向锁的诞生。</p>

<p>意向锁(Intention Lock)将锁定的对象分为多个粒度，当想要对细粒度的数据进行加锁时，那么首先需要对粗粒度的对象添加意向锁。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/intention-Lock.png" alt="" /></p>

<p>例如，若需要对页上的记录R添加X锁，则需要分别对数据库、表、页添加意向锁IX，添加成功后才会对记录R添加X锁，若其中任何一部分导致等待，那么该操作需要等待粗粒度上锁环节的完成。现在来看在有了意向锁之后InnoDB存储引擎如何支持多粒度的锁。</p>

<p>意向锁同样分为两种: 共享和排他</p>

<ul>
  <li>意向共享锁(IS, Intention Share Lock)</li>
  <li>意向排他锁(IX, Intention Exclusive Lock)</li>
</ul>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/intention-lock-example.png" alt="" /></p>

<p>如上图所示，事务A为了给记录R添加X锁(排他锁)，则需要依次对数据库、表、页添加意向排他锁(IX)，假设添加均成功，最终记录R添加了X锁。此时事务B想要向表A中添加表级别的排他锁，由于表A中存在IX锁，与表级别的X锁并不兼容，故事务B等待，等待表A中IX锁的释放。可以看到，在有了意向锁之后，锁的兼容性比较将处理同粒度水平，而不是跨粒度进行比较。这让我想起了一个段子:</p>

<blockquote>
  <p>不要跟傻逼争论，他会把你拉到他的水平上，然后用他丰富的经验打败你</p>
</blockquote>

<p>InnoDB存储引擎中意向锁和表级锁的兼容性如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">-</th>
      <th style="text-align: center">IX</th>
      <th style="text-align: center">IS</th>
      <th style="text-align: center">X(表级别)</th>
      <th style="text-align: center">S(表级别)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">IX</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">IS</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">X(表级别)</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">不兼容</td>
    </tr>
    <tr>
      <td style="text-align: center">S(表级别)</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
      <td style="text-align: center">不兼容</td>
      <td style="text-align: center">兼容</td>
    </tr>
  </tbody>
</table>

<p>在MySQL 5.5以上、5.7.14以下的版本中，用户可以通过<code class="highlighter-rouge">INFORMATION_SCHEMA</code>下的<code class="highlighter-rouge">INNODB_TRX</code>、<code class="highlighter-rouge">INNODB_LOCKS</code>以及<code class="highlighter-rouge">INNODB_LOCK_WAITS</code>这三张表简单地监控并分析可能存在的锁问题。</p>

<p>在MySQL 8.0版本中，则需要使用<code class="highlighter-rouge">performance_schema</code>下的<code class="highlighter-rouge">data_locks</code>以及<code class="highlighter-rouge">data_lock_waits</code>获取相关的锁以及锁等待信息。</p>

<p>而MySQL版本在5.7.14到8.0之间的用户，只能通过其它手段间接的获取上述信息。</p>

<h5 id="21-创建通用例程">2.1 创建通用例程</h5>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`user`</span> <span class="p">(</span>
  <span class="nv">`id`</span> <span class="n">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="nv">`nickname`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`password`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`user_id`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`mobile`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`mobile_area`</span> <span class="n">smallint</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">comment</span> <span class="nv">"手机号码区域"</span><span class="p">,</span>
  <span class="nv">`gender`</span> <span class="n">tinyint</span> <span class="k">DEFAULT</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nv">`avatar`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`account_id`</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`created_at`</span> <span class="n">datetime</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="nv">`updated_at`</span> <span class="n">datetime</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="k">ON</span> <span class="k">UPDATE</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span>
  <span class="nv">`deleted_at`</span> <span class="n">datetime</span><span class="p">,</span>
  <span class="nv">`status`</span> <span class="n">tinyint</span> <span class="k">DEFAULT</span> <span class="mi">1</span> <span class="k">comment</span> <span class="nv">"用户状态"</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`user_id`</span> <span class="p">(</span><span class="nv">`user_id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`mobile`</span> <span class="p">(</span><span class="nv">`mobile`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`account_id`</span> <span class="p">(</span><span class="nv">`account_id`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`created_at`</span> <span class="p">(</span><span class="nv">`created_at`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="nv">`updated_at`</span> <span class="p">(</span><span class="nv">`updated_at`</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="p">(</span><span class="nv">`user_id`</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="p">(</span><span class="nv">`account_id`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">1</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span> <span class="k">COLLATE</span><span class="o">=</span><span class="n">utf8mb4_general_ci</span><span class="p">;</span>
</code></pre></div></div>

<p>这是一张非常普通但又普遍的用户信息表，其中包含了唯一主键，唯一辅助索引以及普通辅助索引。</p>

<h5 id="22-innodb_trx">2.2 INNODB_TRX</h5>
<p><code class="highlighter-rouge">INNODB_TRX</code>表中主要记录了当前正在执行的事务信息，包括只读事务。首先来看字段和字段所表示的含义:</p>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TRX_ID</td>
      <td>InnoDB存储引擎内部的唯一事务ID</td>
    </tr>
    <tr>
      <td>TRX_WEIGHT</td>
      <td>事务权重(与事务修改的行数和锁定的行数有关)，当两个事务执行发生死锁时，InnoDB会选择权重较低的事务进行回滚</td>
    </tr>
    <tr>
      <td>TRX_STATE</td>
      <td>当前的事务执行状态，包括RUNNING, LOCK WAIT, ROLLING BACK, 以及COMMITTING，LOCK WAIT表示当前事务正等待某个锁的释放</td>
    </tr>
    <tr>
      <td>TRX_STARTED</td>
      <td>事务开始时间，格式如2000-01-01 14:01:08</td>
    </tr>
    <tr>
      <td>TRX_REQUESTED_LOCK_ID</td>
      <td>当前事务所等待的锁ID，该字段只有在状态为LOCK WAIT才有值，否则为NULL。可与<code class="highlighter-rouge">INNODB_LOCKS</code>通过LOCK_ID字段进行关联查询，获取更为详细的锁信息。</td>
    </tr>
    <tr>
      <td>TRX_WAIT_STARTED</td>
      <td>当前事务等待锁的起始时间，在状态为LOCK WAIT时才有值，否则为NULL。</td>
    </tr>
    <tr>
      <td>TRX_QUERY</td>
      <td>当前事务<strong>正在</strong>执行的SQL语句(不是事务所有的执行语句)</td>
    </tr>
    <tr>
      <td>TRX_OPERATION_STATE</td>
      <td>事务的当前操作状态，包括PREPARING, UPDATING, DELETING, COMMITTING以及NULL，该字段在绝大部分情况下均为NULL，捕捉某一事务的瞬间执行状态还是比较困难的(除非是大事务)</td>
    </tr>
    <tr>
      <td>TRX_TABLES_IN_USE</td>
      <td>正在执行的SQL语句所操作的表数量，是一个动态变化值，通常很难观测</td>
    </tr>
    <tr>
      <td>TRX_TABLES_LOCKED</td>
      <td>当前事务在各个表中添加行锁的表数量</td>
    </tr>
    <tr>
      <td>TRX_LOCK_STRUCTS</td>
      <td>当前事务持有的锁数量</td>
    </tr>
    <tr>
      <td>TRX_LOCK_MEMORY_BYTES</td>
      <td>当前事务中锁结构的内存总占用</td>
    </tr>
    <tr>
      <td>TRX_ROWS_LOCKED</td>
      <td>当前事务锁住的近似数据总行数</td>
    </tr>
    <tr>
      <td>TRX_ROWS_MODIFIED</td>
      <td>当前事务插入、修改的总行数</td>
    </tr>
    <tr>
      <td>TRX_CONCURRENCY_TICKETS</td>
      <td>表示当前事务在换出之前所能做的工作之和</td>
    </tr>
    <tr>
      <td>TRX_ISOLATION_LEVEL</td>
      <td>当前事务隔离级别，包括READ UNCIMMITTED、READ COMMITTED、READ REPEATABLE以及SERIALIZABLE</td>
    </tr>
    <tr>
      <td>TRX_UNIQUE_CHECKS</td>
      <td>当前事务是否开启唯一性检查</td>
    </tr>
    <tr>
      <td>TRX_FOREIGN_KEY_CHECKS</td>
      <td>当前事务是否开启外键检查</td>
    </tr>
    <tr>
      <td>TRX_LAST_FOREIGN_KEY_ERROR</td>
      <td>当前事务执行时最后发生的外键错误</td>
    </tr>
    <tr>
      <td>TRX_ADAPTIVE_HASH_LATCHED</td>
      <td>当前事务是否锁定了自适应哈希索引</td>
    </tr>
  </tbody>
</table>

<p>在这20多个字段中，较为重要的包括事务ID，事务执行状态，事务等待锁的起始时间，事务锁定的近似总行数。</p>

<h5 id="23-innodb_locks">2.3 INNODB_LOCKS</h5>

<p><code class="highlighter-rouge">INNODB_LOCKS</code>表中记录了当前所有未释放的锁，包括行锁、页锁以及表锁，当某个事务发生严重的锁等待时，通常会在该表中查找蛛丝马迹，确定问题的根源。</p>

<p>但是，<code class="highlighter-rouge">INNODB_LOCKS</code>和<code class="highlighter-rouge">INNODB_LOCK_WAITS</code>这两张表在5.7.14以上版本中被废弃不用，在8.0版本中使用<code class="highlighter-rouge">data_locks</code>以及<code class="highlighter-rouge">data_lock_waits</code>进行代替，故以下内容均采用MySQL 8.0版本进行描述。</p>

<h5 id="24-data_locks">2.4 data_locks</h5>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ENGINE</td>
      <td>申请或持有锁的存储引擎类型</td>
    </tr>
    <tr>
      <td>ENGINE_LOCK_ID</td>
      <td>存储引擎内部的锁ID，该值会发生动态变化，外部系统不应该依赖该值</td>
    </tr>
    <tr>
      <td>ENGINE_TRANSACTION_ID</td>
      <td>持有锁的事务ID，与INNODB_TRX中的TRX_ID对应</td>
    </tr>
    <tr>
      <td>THREAD_ID</td>
      <td>持有锁的线程ID</td>
    </tr>
    <tr>
      <td>EVENT_ID</td>
      <td>事件ID，该字段将于下方进行详细描述</td>
    </tr>
    <tr>
      <td>OBJECT_SCHEMA</td>
      <td>锁所在的schema(database)</td>
    </tr>
    <tr>
      <td>OBJECT_NAME</td>
      <td>锁所在的表名称</td>
    </tr>
    <tr>
      <td>PARTITION_NAME</td>
      <td>锁所在分片名称</td>
    </tr>
    <tr>
      <td>SUBPARTITION_NAME</td>
      <td>锁所在的子分片名称</td>
    </tr>
    <tr>
      <td>INDEX_NAME</td>
      <td>被添加锁的索引名称</td>
    </tr>
    <tr>
      <td>OBJECT_INSTANCE_BEGIN</td>
      <td>锁的内存空间起始地址</td>
    </tr>
    <tr>
      <td>LOCK_TYPE</td>
      <td>锁类型，包含TABLE和RECORD</td>
    </tr>
    <tr>
      <td>LOCK_MODE</td>
      <td>锁的模式，包括S,X,IS,IX,AUTO_INC以及UNKNOWN</td>
    </tr>
    <tr>
      <td>LOCK_STATUS</td>
      <td>锁的状态，InnoDB引擎中包括GRANTED(已添加)和WAITING(等待中)</td>
    </tr>
    <tr>
      <td>LOCK_DATA</td>
      <td>锁覆盖的范围，该字段将于下方详细描述</td>
    </tr>
  </tbody>
</table>

<p>以一个具体的例子为例:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Mario</span><span class="p">.</span><span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
               <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140374385659344</span><span class="p">:</span><span class="mi">1453</span><span class="p">:</span><span class="mi">140374295256456</span>
<span class="n">ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">632837</span>
            <span class="n">THREAD_ID</span><span class="p">:</span> <span class="mi">56</span>
             <span class="n">EVENT_ID</span><span class="p">:</span> <span class="mi">28</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
       <span class="n">PARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
    <span class="n">SUBPARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">NULL</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140374295256456</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="k">TABLE</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">IX</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="k">NULL</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
               <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140374385659344</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140374295253576</span>
<span class="n">ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">632837</span>
            <span class="n">THREAD_ID</span><span class="p">:</span> <span class="mi">56</span>
             <span class="n">EVENT_ID</span><span class="p">:</span> <span class="mi">28</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
       <span class="n">PARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
    <span class="n">SUBPARTITION_NAME</span><span class="p">:</span> <span class="k">NULL</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140374295253576</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p>当我们使用<code class="highlighter-rouge">FOR UPDATE</code>一致性锁定读向id为1的行添加一个写锁时，可以看到<code class="highlighter-rouge">data_locks</code>中生成了两条记录。从<code class="highlighter-rouge">LOCK_TYPE</code>以及<code class="highlighter-rouge">LOCK_MODE</code>来看，第一条为表级别意向排他锁(IX)，第二条为行记录排他锁(X)。注意到X锁后面还有一个说明: <code class="highlighter-rouge">REC_NOT_GAP</code>，表示排他非间隙行锁，这是行锁的一种实现，将在后面小节中描述。</p>

<p><code class="highlighter-rouge">LOCK_DATA</code>在IX项中为NULL，这是因为在InnoDB存储引擎中，该字段只会在<code class="highlighter-rouge">LOCK_TYPE</code>为<code class="highlighter-rouge">RECORD</code>时才有实际值，对于<code class="highlighter-rouge">TABLE</code>类型的锁而言，该值为NULL。<code class="highlighter-rouge">LOCK_DATA</code>根据不同的加锁方式会有不同具体值。当我们使用主键ID(primary key)进行加锁时，<code class="highlighter-rouge">LOCK_DATA</code>仅包含聚簇索引行记录，此时<code class="highlighter-rouge">LOCK_DATA</code>的值通常为主键ID。当我们使用辅助索引对记录加锁时，锁住的范围则会包括辅助索引+聚簇索引，所以此时<code class="highlighter-rouge">data_locks</code>会生成3条记录(表级别意向锁+索引记录锁+聚簇索引记录锁)，此时<code class="highlighter-rouge">LOCK_DATA</code>的值为”辅助索引字段值+主键ID”</p>

<p>例如:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Mario</span><span class="p">.</span><span class="k">user</span> <span class="k">where</span> <span class="n">user_id</span> <span class="o">=</span> <span class="nv">"168236477"</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
          <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">NULL</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="k">TABLE</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">IX</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="k">NULL</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">user_id_2</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="cm">/* LOCK_DATA为FieldValue+记录对应的主键ID。由于user_id为unique，故此处仅一条记录 */</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="s1">'168236477'</span><span class="p">,</span> <span class="mi">3</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">3</span>
</code></pre></div></div>

<h5 id="25-data_lock_waits">2.5 data_lock_waits</h5>

<p><code class="highlighter-rouge">data_lock_waits</code>相比于<code class="highlighter-rouge">INNODB_TRX</code>以及<code class="highlighter-rouge">data_locks</code>而言则要更复杂一些，该表实际上是一个ManyToMany的关系表，记录了<code class="highlighter-rouge">data_locks</code>中锁之间的等待以及依赖关系，同时也记录了锁所对应的事务/会话信息。</p>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>字段含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ENGINE</td>
      <td>存储引擎类型</td>
    </tr>
    <tr>
      <td>REQUESTING_ENGINE_LOCK_ID</td>
      <td>存储引擎内锁ID，对应于data_locks表中的ENGINE_LOCK_ID</td>
    </tr>
    <tr>
      <td>REQUESTING_ENGINE_TRANSACTION_ID</td>
      <td>存储引擎内事务ID</td>
    </tr>
    <tr>
      <td>REQUESTING_THREAD_ID</td>
      <td>线程ID</td>
    </tr>
    <tr>
      <td>REQUESTING_EVENT_ID</td>
      <td>事件ID</td>
    </tr>
    <tr>
      <td>REQUESTING_OBJECT_INSTANCE_BEGIN</td>
      <td>锁的内存空间起始地址</td>
    </tr>
    <tr>
      <td>BLOCKING_ENGINE_LOCK_ID</td>
      <td>等待释放的锁ID</td>
    </tr>
    <tr>
      <td>BLOCKING_ENGINE_TRANSACTION_ID</td>
      <td>等待结束的事务ID</td>
    </tr>
    <tr>
      <td>BLOCKING_THREAD_ID</td>
      <td>等待结束的线程ID</td>
    </tr>
    <tr>
      <td>BLOCKING_EVENT_ID</td>
      <td>等待结束的事件ID</td>
    </tr>
    <tr>
      <td>BLOCKING_OBJECT_INSTANCE_BEGIN</td>
      <td>等待结束的锁的内存空间起始地址</td>
    </tr>
  </tbody>
</table>

<p>例如:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_lock_waits</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
                          <span class="n">ENGINE</span><span class="p">:</span> <span class="n">INNODB</span>
       <span class="n">REQUESTING_ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140678484647376</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140678365511992</span>
<span class="n">REQUESTING_ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">635403</span>
            <span class="n">REQUESTING_THREAD_ID</span><span class="p">:</span> <span class="mi">48</span>
             <span class="n">REQUESTING_EVENT_ID</span><span class="p">:</span> <span class="mi">15</span>
<span class="n">REQUESTING_OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365511992</span>
         <span class="n">BLOCKING_ENGINE_LOCK_ID</span><span class="p">:</span> <span class="mi">140678484646504</span><span class="p">:</span><span class="mi">532</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">140678365506120</span>
  <span class="cm">/*等待ID为635400的事务释放锁*/</span>
  <span class="n">BLOCKING_ENGINE_TRANSACTION_ID</span><span class="p">:</span> <span class="mi">635400</span>
              <span class="n">BLOCKING_THREAD_ID</span><span class="p">:</span> <span class="mi">47</span>
               <span class="n">BLOCKING_EVENT_ID</span><span class="p">:</span> <span class="mi">12</span>
  <span class="n">BLOCKING_OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/data_lock_waits.png" alt="" /></p>

<h4 id="3-innodb存储引擎行锁算法">3. InnoDB存储引擎行锁算法</h4>

<p>InnoDB存储引擎存在3种行锁算法，分别为:</p>

<ul>
  <li>Record Lock: 单个行记录上的锁</li>
  <li>Gap Lock: 间隙锁，锁定一个范围，单不包含记录本身</li>
  <li>Next-Key Lock: Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身</li>
</ul>

<p>Record Lock表示单个行记录上的锁，这非常好理解，例如我们<code class="highlighter-rouge">update</code>一条或多条数据时，事务会为这一条或者多条数据均添加X锁。当使用主键ID进行更新时，记录仅包含聚簇索引行记录。当使用辅助索引进行更新时，将会锁住聚簇索引记录+辅助索引记录。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="k">user</span> <span class="k">set</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="cm">/* 省略部分非关键信息 */</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">commit</span><span class="p">;</span>
</code></pre></div></div>

<p>当使用主键ID进行一致性锁定读时，<code class="highlighter-rouge">data_locks</code>生成两条锁记录，一条为table IX，另一条为行记录的X锁，注意<code class="highlighter-rouge">LOCK_MODE</code>后面的附加声明: REC_NOT_GAP，表示当前锁的算法仅为行记录锁，非间隙锁。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="k">user</span> <span class="k">set</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">where</span> <span class="n">user_id</span> <span class="o">=</span> <span class="nv">"174269548"</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">user_id_2</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="s1">'174269548'</span><span class="p">,</span> <span class="mi">1</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506464</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p>而使用辅助索引进行一致性锁定读时，除了table IX以及聚簇索引的X锁以外，还会有额外的辅助索引X锁，<code class="highlighter-rouge">LOCK_MODE</code>同样备注了非间隙锁的标识。</p>

<p>间隙锁的存在主要是为了解决幻读问题，幻读是指当某事务读取一定范围内的数据时，其余事务在该范围内插入了一条或多条数据，或者删除了一条或多条数据，导致前一个事务读取的数据条数发生改变，如同出现幻觉，所以称为幻读。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="n">supremum</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">record</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
        <span class="n">OBJECT_SCHEMA</span><span class="p">:</span> <span class="n">Mario</span>
          <span class="n">OBJECT_NAME</span><span class="p">:</span> <span class="k">user</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
<span class="n">OBJECT_INSTANCE_BEGIN</span><span class="p">:</span> <span class="mi">140678365506120</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">3</span>
</code></pre></div></div>

<p>当我们对某一个范围使用一致性锁定读时，就可以看到间隙锁的产生。<code class="highlighter-rouge">LOCK_MODE</code>仅为X时，就表示当前锁添加了间隙锁。并且在<code class="highlighter-rouge">LOCK_DATA</code>有supremum pseudo-record的解释说明，该说明表示MySQL决定锁定最大间隙范围。在本例中，为id大于2的所有数据，故另一个事务执行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">insert</span> <span class="k">into</span> <span class="k">user</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">nickname</span><span class="p">,</span> <span class="n">password</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">mobile_area</span><span class="p">,</span> <span class="n">gender</span><span class="p">,</span> <span class="n">avatar</span><span class="p">,</span> <span class="n">account_id</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="nv">"jojo"</span><span class="p">,</span> <span class="nv">"passwd"</span><span class="p">,</span> <span class="nv">"147523659"</span><span class="p">,</span> <span class="nv">"13555555555"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">"https://jojo.com"</span><span class="p">,</span> <span class="nv">"1753681429"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>将会被阻塞，直至前一个事务释放间隙锁或者当前事务锁等待超时。</p>

<p>在理解了间隙锁以后，Next-Key Lock就很容易理解了，锁定一个记录+一个范围。上面例子均有一个特点，就是不管是主键ID，还是user_id，它们都具有unique约束，而对于非唯一的辅助索引而言，即使是精确查询并加锁，也会添加Gap Lock，此时就是Next-Key Lock。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">begin</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">updated_at</span> <span class="o">=</span> <span class="nv">"2020-01-23 21:32:52"</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
<span class="cm">/*此时DB中仅存在一条数据更新时间为"2020-01-23 21:32:52"*/</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="err">\</span><span class="k">G</span><span class="p">;</span>
<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
<span class="cm">/* ...................表级别的意向排他锁，此处省略.............. */</span>
<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">updated_at</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="n">supremum</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">record</span>
<span class="o">***************************</span> <span class="mi">3</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="n">updated_at</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">0</span><span class="n">x99A56F5834</span><span class="p">,</span> <span class="mi">1</span>
<span class="o">***************************</span> <span class="mi">4</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
           <span class="n">INDEX_NAME</span><span class="p">:</span> <span class="k">PRIMARY</span>
            <span class="n">LOCK_TYPE</span><span class="p">:</span> <span class="n">RECORD</span>
            <span class="n">LOCK_MODE</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span><span class="n">REC_NOT_GAP</span>
          <span class="n">LOCK_STATUS</span><span class="p">:</span> <span class="k">GRANTED</span>
            <span class="n">LOCK_DATA</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">updated_at</code>字段仅添加了普通索引，并且值为”2020-01-23 21:32:52”的记录主键ID为1，从<code class="highlighter-rouge">data_locks</code>的最后一条记录也可以看出。在该表的第二行和第三行中分别添加了间隙锁，第三行的<code class="highlighter-rouge">LOCK_DATA</code>字段值为16进制数+主键ID。</p>

<p>此外，<strong>需要尤为注意的是，<code class="highlighter-rouge">READ COMMITTED</code>事务隔离级别下，将不会有间隙锁的添加</strong>。在文章<a href="https://smartkeyerror.com/django-concurrent-data-process">Django处理数据并发问题</a>中描述了使用Django默认的<code class="highlighter-rouge">READ COMMITTED</code>事务隔离级别所带来的问题。</p>

<h4 id="4-自增长与锁">4. 自增长与锁</h4>

<p>自增长在数据库中是非常常见的属性，MySQL提供<code class="highlighter-rouge">AUTO_INCREMENT</code>属性使得列可具备自增长的功能。在InnoDB存储引擎内存结构中，对每个含有自增长值的表都有一个自增长计数器。</p>

<p>最初自增长是采用特殊的表锁实现，称为AUTO_INC Locking，为了提高插入的性能，锁并不是在事务结束时才释放，而是在完成对自增长值插入的SQL语句后立即释放。虽然AUTO_INC Locking从一定程度上提高了并发插入的效率，但是仍存在性能问题: 事务必须等待前一个事务插入语句的结束。所以，后续就有了轻量级的互斥量自增长实现。</p>

<p>互斥量的实现就是文章最开头所说的Latch，由硬件协助实现。该实现方式只有在确定所插入的行数时才会使用，否则，将仍然使用AUTO_INC Locking。</p>

<h4 id="5-metadata-lock">5. Metadata Lock</h4>

<p>Metadata Lock，又称为MDL，相较于行锁和表锁，其范围更广，对象包括数据库、表、行以及触发器和外键等，与InnoDB其它锁一样，在事务开始时获取，事务结束时释放，其设计目的在于保证在事务执行过程中表的结构不会被修改。</p>

<p>通常来讲，只有在修改表结构的时候我们才会直接地与MDL打交道，例如向某张表添加一列，或者删除某一列。在DML执行非常频繁的应用中，当我们执行ALTER TABLE table ADD column时，很有可能出现整个MySQL挂掉的情况，其原因就在于表结构修改语句获取MDL时阻塞，导致后续对该表的查询、修改和删除等语句阻塞。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/MDL.png" alt="" /></p>

<p>session A与session B会向表user添加只读MDL，而session C想要申请可写的MDL，由于前面两个事务均为提交，故只能阻塞。此时由于session C写锁的申请，导致session D以及后续的所有DML操作均会被阻塞，简单来说，此时表user不可读写。</p>

<p>如果user表中的读写非常频繁，将会导致大量的查询或更新语句阻塞，且状态均为<code class="highlighter-rouge">waiting for metadata lock</code>。此时若客户端存在超时重试机制，那么会导致大量新的会话建立，最后达到MySQL线程数量的限制，导致整个DB不可用。</p>

<p>在MySQL 5.6版本以上支持Online DDL，其过程如下:</p>
<ul>
  <li>ALTER TABLE table ADD column语句获取MDL写锁</li>
  <li>获取成功后，将其降级为MDL读锁</li>
  <li>执行真正的DDL操作，如添加、删除列，期间可以执行DML语句</li>
  <li>升级MDL读锁为写锁</li>
  <li>释放MDL写锁，整个DDL过程结束</li>
</ul>

<p>真正导致数据库不可读写的步骤为1、4，第3步为实际运行时间最长的步骤，不会影响表的读写操作，只要内存和磁盘容量足够，数据量再多也灭有关系。所以，DDL的关键影响因素不在于数据量，而是在于数据读写的QPS。这也是为什么表结构修改操作要放到月黑风高的凌晨进行操作的原因: 那时候访问量最少，而不是数据量最少。</p>

<p>在更改表结构时造成大面积读写操作阻塞的另一个原因就是长事务，即长时间运行的事务。即使QPS非常小，但是系统中存在长事务，同样会造成DDL语句获取写锁阻塞，从而阻塞后续的读写语句。</p>

<h4 id="6-reference">6. Reference</h4>

<ul>
  <li>https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_latch</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-trx-table.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/data-locks-table.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/data-lock-waits-table.html</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Golang中的interface</title>
	  <link>//Golang-interface</link>
	  <author></author>
	  <pubDate>2019-12-25T08:25:25+00:00</pubDate>
	  <guid>//Golang-interface</guid>
	  <description><![CDATA[
	     <p>Golang除了方便使用的协程以外，最令我感到惊讶的就是<code class="highlighter-rouge">interface</code>，接口。在其它语言中，接口承担的主要作用为解耦和协议，但是在Golang中，<code class="highlighter-rouge">interface</code>还作为一种”通用”类型广泛使用于标准库和第三方库中。</p>

<!---more--->

<h4 id="1-面向接口编程">1. 面向接口编程</h4>

<p>面向接口编程的核心就在于将接口和实现分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口编程而非面向实现编程，不依赖不稳定的实现细节，当实现发生变化时，上游系统可不做或者只需进行少量的修改，从而降低耦合性，提高拓展性。 换句话说，面向接口编程是一种可随时拔插替换的编程方法。</p>

<p>以图片存储服务为例，图片经过一系列的处理之后上传至阿里云OSS中保存。 以Java代码为例，为了代码复用，将其封装成一个类对外使用:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AliyunOssImageStore</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createBucketIfNotExist</span><span class="o">(</span><span class="n">string</span> <span class="n">bucketName</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="c1">// OSS通过bucket来划分整块OSS存储空间</span>
        <span class="c1">// 当所需要的bucket不存在时，进行创建，创建失败则抛出异常</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="n">String</span> <span class="nf">generateAccessToken</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 通过appKey以及appSecret生成access_token, 内部方法</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">uploadToOss</span><span class="o">(</span><span class="n">Image</span> <span class="n">image</span><span class="o">,</span> <span class="n">string</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 将图片上传至oss，返回图片URL地址</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 使用</span>
<span class="kd">class</span> <span class="nc">OssProcess</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">bucketName</span> <span class="o">=</span> <span class="s">"user_thumbnail_image"</span><span class="o">;</span>
        <span class="n">AliyunOssImageStore</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AliyunOssImageStore</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">createBucketIfNotExist</span><span class="o">(</span><span class="n">bucketName</span><span class="o">);</span>
        <span class="n">Image</span> <span class="n">image</span> <span class="o">=</span> <span class="o">...</span> <span class="c1">// 生成图片</span>
        <span class="n">store</span><span class="o">.</span><span class="na">uploadToOss</span><span class="o">(</span><span class="n">image</span><span class="o">,</span> <span class="n">bucketName</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">AliyunOssImageStore</code>就是一个具体的实现类，实现了将图片上传至阿里云OSS的功能，在绝大多数时候，代码都能完好的工作。现在由于采购部门不满阿里云的价格，想要更换图片存储供应商，比如七牛。现在开发人员需要添加<code class="highlighter-rouge">QiniuImageStore</code>，并替换掉原有的实现方式，如此一来，必将会涉及到大面积的代码改动，包括业务代码以及重新编写测试用例。</p>

<p>更换一个OSS服务就需要大面积的更改业务代码，违反了开放-封闭原则，从而引入了额外的工作量以及风险，上游系统直接依赖具体的实现是不妥当的，因为具体的实现很有可能发生变化，一旦发生变化，波及的范围可能是整个系统。</p>

<p>解决该问题的一种方式是添加代理类，即在业务代码和具体实现之间额外添加一层抽象，或者说函数，假设叫<code class="highlighter-rouge">imageStoreProxy</code>。业务代码调用<code class="highlighter-rouge">imageStoreProxy</code>方法，而该方法调用具体的OSS实现，当OSS实现发生变动时，只需修改<code class="highlighter-rouge">imageStoreProxy</code>一处即可。但是这么做的后果就是降低了系统的灵活性并增加了系统的复杂度，<code class="highlighter-rouge">imageStoreProxy</code>需要满足上游系统所有的需求，该方法到后期将会变得非常臃肿而难以维护，最可能出现的情况就是该方法存在乱七八糟的<code class="highlighter-rouge">if-else</code>。</p>

<p>一个更好的方式就是使用接口，上游系统依赖接口，具体实现根据接口定义的方法进行实现，并在运行时选择具体的实现。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ImageStore</span> <span class="o">{</span>
    <span class="n">String</span> <span class="nf">upload</span><span class="o">(</span><span class="n">Image</span> <span class="n">image</span><span class="o">,</span> <span class="n">String</span> <span class="n">bucket</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AliyunOssImageStore</span> <span class="kd">implements</span> <span class="n">ImageStore</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">upload</span><span class="o">(</span><span class="n">Image</span> <span class="n">image</span><span class="o">,</span> <span class="n">String</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 阿里云OSS的具体实现</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">QiniuImageStore</span> <span class="kd">implements</span> <span class="n">ImageStore</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">upload</span><span class="o">(</span><span class="n">Image</span> <span class="n">image</span><span class="o">,</span> <span class="n">String</span> <span class="n">bucket</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 七牛云的具体实现</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 使用</span>
<span class="kd">class</span> <span class="nc">OssProcess</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ImageStore</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AliyunOssImageStore</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">upload</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span> <span class="c1">// 使用阿里云OSS</span>
        
        <span class="n">ImageStore</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QiniuImageStore</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">upload</span><span class="o">(</span><span class="cm">/*省略参数*/</span><span class="o">);</span> <span class="c1">// 使用七牛云</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>合理的使用接口可以完全屏蔽具体的实现细节，当具体实现发生变化时，上游系统只需改动少量的代码即可适应该变化。 例如底层数据存储，MySQL与MongoDB在实现上完全不同，数据的CRUD有着非常大的区别，但是通过定义合理的接口，再根据接口封装MySQL与MongoDB的具体实现，上游系统则可以完全忽略其细节的区别，只关注自身的业务逻辑，从而实现耦合的解除。</p>

<p>常见ORM就是做的，例如Python中的<code class="highlighter-rouge">SQLAlchemy</code>，只需在配置文件或者是定义文件中进行少量的修改，即可实现底层数据存储应用的替换。</p>

<h4 id="2-作为接口定义的interface">2. 作为接口定义的interface</h4>

<p>Golang中的<code class="highlighter-rouge">interface</code>承担的主要作用之一就是解耦与多态，与Java中的接口没有什么区别，只是在语法格式上不同而已。Golang中的接口实现不需要显式地使用<code class="highlighter-rouge">implements</code>关键字，某个类型只需要实现了接口中的所有方法，就说该类型实现了该接口。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">OperationLog</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Timestamp</span><span class="x"> </span><span class="kt">int32</span><span class="x">    </span><span class="c">// 时间戳</span><span class="x">
	</span><span class="n">Operation</span><span class="x"> </span><span class="kt">string</span><span class="x">   </span><span class="c">// 操作类型, create/update/delete</span><span class="x">
	</span><span class="c">// Other need fields</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">OperationLogService</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">InsertOne</span><span class="p">(</span><span class="n">log</span><span class="x"> </span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x">      </span><span class="c">// 单个日志记录</span><span class="x">
	</span><span class="n">InsertMany</span><span class="p">(</span><span class="n">logs</span><span class="x"> </span><span class="p">[]</span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x">  </span><span class="c">// 批量日志记录</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">ElasticLogService</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">EsClient</span><span class="x"> </span><span class="o">*</span><span class="n">ElasticClient</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">svc</span><span class="x"> </span><span class="o">*</span><span class="n">ElasticLogService</span><span class="p">)</span><span class="x"> </span><span class="n">InsertOne</span><span class="p">(</span><span class="n">log</span><span class="x"> </span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">svc</span><span class="o">.</span><span class="n">EsClient</span><span class="o">.</span><span class="n">PostOne</span><span class="p">(</span><span class="c">/*参数省略*/</span><span class="p">)</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">svc</span><span class="x"> </span><span class="o">*</span><span class="n">ElasticLogService</span><span class="p">)</span><span class="x"> </span><span class="n">InsertMany</span><span class="p">(</span><span class="n">logs</span><span class="x"> </span><span class="p">[]</span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">svc</span><span class="o">.</span><span class="n">EsClient</span><span class="o">.</span><span class="n">PostMany</span><span class="p">(</span><span class="c">/*参数省略*/</span><span class="p">)</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">MySQLLogService</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Db</span><span class="x"> </span><span class="o">*</span><span class="n">MySQLClient</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">svc</span><span class="x"> </span><span class="o">*</span><span class="n">MySQLLogService</span><span class="p">)</span><span class="x"> </span><span class="n">InsertOne</span><span class="p">(</span><span class="n">log</span><span class="x"> </span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">svc</span><span class="o">.</span><span class="n">Db</span><span class="o">.</span><span class="n">InsertToLogTable</span><span class="p">(</span><span class="c">/*参数省略*/</span><span class="p">)</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">svc</span><span class="x"> </span><span class="o">*</span><span class="n">MySQLLogService</span><span class="p">)</span><span class="x"> </span><span class="n">InsertMany</span><span class="p">(</span><span class="n">logs</span><span class="x"> </span><span class="p">[]</span><span class="o">*</span><span class="n">OperationLog</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">svc</span><span class="o">.</span><span class="n">Db</span><span class="o">.</span><span class="n">InsertManyToLogTable</span><span class="p">(</span><span class="c">/*参数省略*/</span><span class="p">)</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">var</span><span class="x"> </span><span class="n">logService</span><span class="x"> </span><span class="n">OperationLogService</span><span class="x">
	</span><span class="c">// 使用MySQL作为data storage</span><span class="x">
	</span><span class="n">logService</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">ElasticLogService</span><span class="p">{</span><span class="c">/*...*/</span><span class="p">}</span><span class="x">
	</span><span class="n">logService</span><span class="o">.</span><span class="n">InsertOne</span><span class="p">(</span><span class="c">/*...*/</span><span class="p">)</span><span class="x">

	</span><span class="c">// 使用ES作为data storage</span><span class="x">
	</span><span class="n">logService</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">MySQLLogService</span><span class="p">{</span><span class="c">/*...*/</span><span class="p">}</span><span class="x">
	</span><span class="n">logService</span><span class="o">.</span><span class="n">InsertOne</span><span class="p">(</span><span class="c">/*...*/</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>这是一个简单的操作日志服务demo，可以看到，操作日志具体的实现有Elasticsearch以及MySQL两种方式，而这两种DB对数据的CURD有着非常大的差异，前者使用http API，而后者则采用SQL语句。由于系统本身的复杂性既需要存储容量大、支持全局搜索但数据易失的ES，又需要存储容量有限、不支持全局搜索但数据持久化要求程度高的MySQL。</p>

<p>在有了接口对相关方法进行强约束以后，<code class="highlighter-rouge">ElasticLogService</code>以及<code class="highlighter-rouge">MySQLLogService</code>可以无差别的对外提供服务，需要切换服务时，只需进行非常小的改动即可满足需求。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/golang/interface/log_service.png" alt="" /></p>

<h4 id="3-作为类型的interface">3. 作为类型的interface</h4>

<p>当使用</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">MyInterface</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{}</span><span class="x">
</span></code></pre></div></div>

<p>时，我们定义了一个接口，当接口中不存在任何方法时，称之为empty interface，通常写做<code class="highlighter-rouge">interface{}</code>。由于Golang并没有显式的<code class="highlighter-rouge">implements</code>关键字，而所有的类型至少包含零个个方法，所以Golang中所有的类型都隐式地实现了<code class="highlighter-rouge">interface{}</code>，也就意味着，当我们定义如下方法时:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">DoSomething</span><span class="p">(</span><span class="n">v</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>函数将能够接收任意的数据类型，不管是<code class="highlighter-rouge">int</code>还是<code class="highlighter-rouge">int64</code>，或者是自定义的结构体。以內建函数<code class="highlighter-rouge">Printf</code>为例，其原型为:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">Printf</span><span class="p">(</span><span class="n">format</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">a</span><span class="x"> </span><span class="o">...</span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">(</span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>其中的<code class="highlighter-rouge">a</code>即为任意类型的任意数量的参数，如</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"human eat %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">food</span><span class="p">)</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"The T-shirt price is %.2f, %s"</span><span class="p">,</span><span class="x"> </span><span class="m">9.15</span><span class="p">,</span><span class="x"> </span><span class="s">"nine fifteen"</span><span class="p">)</span><span class="x">
</span></code></pre></div></div>

<p>回到<code class="highlighter-rouge">DoSomething</code>方法，在函数内部，<code class="highlighter-rouge">v</code>的类型是什么?假如传入的参数类型为<code class="highlighter-rouge">int</code>，<code class="highlighter-rouge">v</code>的类型是否就是<code class="highlighter-rouge">int</code>?答案是<code class="highlighter-rouge">interface{}</code>，不管传入的参数是什么类型，Go都会在必要时对其进行类型转换，转换成<code class="highlighter-rouge">interface{}</code>类型，而<code class="highlighter-rouge">interface{}</code>类型，是有值的。</p>

<p>接口的值分为两部分，一个指向底层方法表的指针，和指向保存着具体值的指针。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">MyInterface</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">PrintSelf</span><span class="p">()</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">MyInt</span><span class="x"> </span><span class="kt">int</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">this</span><span class="x"> </span><span class="n">MyInt</span><span class="p">)</span><span class="x"> </span><span class="n">PrintSelf</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"The value is: %d"</span><span class="p">,</span><span class="x"> </span><span class="n">this</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">s</span><span class="x"> </span><span class="n">MyInterface</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>此时<code class="highlighter-rouge">s</code>无具体的类型，也无具体的值，两个指针均指向nil:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/golang/interface/nil-interface.png" alt="" /></p>

<p>当执行:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">MyInt</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="x">
</span><span class="n">s</span><span class="o">.</span><span class="n">PrintSelf</span><span class="p">()</span><span class="x">
</span></code></pre></div></div>

<p>时, <code class="highlighter-rouge">s</code>拥了的具体的类型和确切的值:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/golang/interface/not%20nil%20interface.png" alt="" /></p>

<p>虽然<code class="highlighter-rouge">interface{}</code>作为参数时可以接收任何类型的参数，但是并不代表参数的类型是任意类型，变量在运行时的某一时刻，永远有一个具体的类型。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">DoSomething</span><span class="p">(</span><span class="n">v</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>在<code class="highlighter-rouge">DoSomething</code>方法内部，如果想要获取变量<code class="highlighter-rouge">v</code>的类型，可以使用类型分支(<code class="highlighter-rouge">switch-case</code>)来进行类型检查，也可以使用反射直接获取变量类型:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">DoSomething</span><span class="p">(</span><span class="n">v</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="c">// 使用类型分支</span><span class="x">
	</span><span class="k">switch</span><span class="x"> </span><span class="n">v</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">case</span><span class="x"> </span><span class="no">nil</span><span class="o">:</span><span class="x">
		</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"nil"</span><span class="p">)</span><span class="x">
	</span><span class="k">case</span><span class="x"> </span><span class="kt">string</span><span class="o">:</span><span class="x">
		</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"string"</span><span class="p">)</span><span class="x">
	</span><span class="k">case</span><span class="x"> </span><span class="kt">int</span><span class="o">:</span><span class="x">
		</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"int"</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	
	</span><span class="c">// 使用反射</span><span class="x">
	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"v'type is: %T</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">v</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<h4 id="4-作为契约协议的interface">4. 作为契约(协议)的interface</h4>

<p>Golang语言本身并不支持泛型，尽管函数参数可以使用<code class="highlighter-rouge">interface{}</code>来接收任意类型的变量，但是对于<code class="highlighter-rouge">slice</code>而言，我们无法定义一个<code class="highlighter-rouge">[]interface{}</code>来接收任意类型的<code class="highlighter-rouge">[]T</code>，原因在于<code class="highlighter-rouge">T</code>和<code class="highlighter-rouge">interface{}</code>在存储空间中有着截然不同的表现形式。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">PrintSlice</span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="p">[]</span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">v</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">s</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">var</span><span class="x"> </span><span class="n">s</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="m">10</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">s</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="x"> </span><span class="n">i</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="n">PrintSlice</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>在编译时期就会抛出异常:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cannot use s <span class="o">(</span><span class="nb">type</span> <span class="o">[]</span>int<span class="o">)</span> as <span class="nb">type</span> <span class="o">[]</span>interface <span class="o">{}</span> <span class="k">in </span>argument to PrintSlice
</code></pre></div></div>

<p>尽然可以通过代码将<code class="highlighter-rouge">[]T</code>转换成<code class="highlighter-rouge">[]interface{}</code>，但是会带来一些效率上的损耗，并且很丑陋。解决此类问题的通用方法就是使用<code class="highlighter-rouge">interface</code>，如<code class="highlighter-rouge">sort.Interface</code>。</p>

<p>sort包提供了针对任意类型序列根据任意排序函数原地排序的功能，使用<code class="highlighter-rouge">sort.Interface</code>接口来指定通用排序算法和每个具体类型之间的协议。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">Interface</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Len</span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="x">            </span><span class="c">// 获取集合中元素个数的方法</span><span class="x">
	</span><span class="n">Less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">bool</span><span class="x">  </span><span class="c">// 排序的依据</span><span class="x">
	</span><span class="n">Swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x">       </span><span class="c">// 如何在集合中交换两个元素</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>简单地来说，只要类型实现了<code class="highlighter-rouge">sort.Interface</code>接口，就可以使用Golang内部提供的排序算法(根据元素排布动态地选择排序方式)，而无需自行实现。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">Employee</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">Name</span><span class="x"> </span><span class="kt">string</span><span class="x">
	</span><span class="n">Salary</span><span class="x"> </span><span class="kt">int</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">Employees</span><span class="x"> </span><span class="p">[]</span><span class="n">Employee</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">em</span><span class="x"> </span><span class="n">Employees</span><span class="p">)</span><span class="x"> </span><span class="n">Len</span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">em</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">em</span><span class="x"> </span><span class="n">Employees</span><span class="p">)</span><span class="x"> </span><span class="n">Less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">bool</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Salary</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">Salary</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">em</span><span class="x"> </span><span class="n">Employees</span><span class="p">)</span><span class="x"> </span><span class="n">Swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">em</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="x"> </span><span class="n">em</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">employees</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">Employees</span><span class="p">{</span><span class="x">
		</span><span class="n">Employee</span><span class="p">{</span><span class="s">"smart"</span><span class="p">,</span><span class="x"> </span><span class="m">5000</span><span class="p">},</span><span class="x">
		</span><span class="n">Employee</span><span class="p">{</span><span class="s">"Aelam"</span><span class="p">,</span><span class="x"> </span><span class="m">4500</span><span class="p">},</span><span class="x">
		</span><span class="n">Employee</span><span class="p">{</span><span class="s">"Lin"</span><span class="p">,</span><span class="x"> </span><span class="m">8500</span><span class="p">},</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="n">sort</span><span class="o">.</span><span class="n">Sort</span><span class="p">(</span><span class="n">employees</span><span class="p">)</span><span class="x">
	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">employees</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p><code class="highlighter-rouge">sort.Sort</code>接收一个<code class="highlighter-rouge">sort.Interface</code>类型参数，而<code class="highlighter-rouge">Employees</code>实现了该接口，故在<code class="highlighter-rouge">sort.Sort</code>内部，可以完全不用管<code class="highlighter-rouge">Employees</code>的具体类型是什么，只需调用接口中定义好的方法，是接口和实现类型之间的契约。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Linux操作系统-文件I/O</title>
	  <link>//Linux-IO</link>
	  <author></author>
	  <pubDate>2019-12-17T09:39:25+00:00</pubDate>
	  <guid>//Linux-IO</guid>
	  <description><![CDATA[
	     <p>在操作系统中， 最为复杂同时也最为重要的功能就是文件I/O。 一台PC可以不连接互联网， 但是一定需要程序的载入、文件的打开， 而这些操作与I/O均密不可分。 包括软件开发中， 数据库与I/O的关系密切相关， 有时衡量一个DB的效率， 其实就是在衡量其I/O效率。 理解文件I/O， 就是在理解我们常用应用软件， 如MySQL、Redis、Nginx、ES、Prometheus等的核心。</p>

<!---more--->

<h4 id="1-处于内核态的系统调用">1. 处于内核态的系统调用</h4>

<p>操作系统的本质就是帮助用户更加高效的管理硬件， 向上提供统一的接口， 向下兼容不同的硬件， 使得用户并不需要关心硬件， 如硬盘的细节， 只需要关心操作系统为我们提供的抽象: 文件系统。 然而引入操作系统的代价就是用户对硬件的所有操作， 例如打开一个文件， 运行一个程序， 均需经由操作系统来完成， 如此以来， 就有了系统调用。</p>

<p>系统调用存在的原因就在于操作系统不允许用户直接访问硬件， 如果用户有此需求， 则需将想要访问的地址与内容告诉操作系统， 由操作系统进行硬件的访问， 最后由操作系统将结果返回给用户。</p>

<p>操作系统也是软件， 也是由一行行的代码所组成， 所以必定运行在内存中， 只不过操作系统所运行的内存受到保护， 用户无法直接对其进行操作而已。 当用户想要打开一个文件时， 将文件路径告知操作系统， 此时操作系统将会接管CPU的执行， 并将CPU的某标识位标记为内核态， 执行一系列的I/O操作， 取出结果并将结果发送给用户内存空间后， 再将CPU的执行权交给用户。 从本质上来看， 系统调用其实就是一次进程切换， 只不过所花费的时间要比普通的进程间切换大得多而已。</p>

<p>接下来将会看到， 为了”对抗”系统调用所带来的巨大代价， 先贤们实现了各种各样增加I/O效率的方式。 但是， 没有哪一种方式能够”一招吃遍天下鲜”， 不同的应用场景会有不同的最佳解决方式。</p>

<h4 id="2-linux通用io模型">2. Linux通用I/O模型</h4>

<p>Linux为系统用户提供了一些通用的IO函数， 包括<code class="highlighter-rouge">open</code>、<code class="highlighter-rouge">read</code>、<code class="highlighter-rouge">write</code>等方法， 当用户每次调用这些方法时， 都将产生一次系统调用， 此时程序运行由用户态切换至内核态， 内核做完自己应该完成的事情之后， 将结果保存至用户指定的位置中， 并再由内核态切换至用户态， 使用户继续执行下面的代码。</p>

<p><code class="highlighter-rouge">open</code>方法既能打开一个已经存在的文件， 也能创建并打开一个新的文件。 其原型如下:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="p">...</span><span class="cm">/* mode_t mode */</span><span class="p">)</span>
</code></pre></div></div>

<p>具体的方法使用请参见Linux manual page。 <code class="highlighter-rouge">open</code>方法在成功时将返回该文件的文件描述符， 用于在后续函数调用中指代该文件， 该文件描述符在进程中唯一， 即使打开的是同一个文件， 两者的文件描述符也不相同。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"hole.txt"</span><span class="p">,</span> <span class="n">O_WDONLY</span><span class="p">);</span>   <span class="c1">// 3
</span>    <span class="kt">int</span> <span class="n">fd2</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"hole.txt"</span><span class="p">,</span> <span class="n">O_WDONLY</span><span class="p">);</span>  <span class="c1">// 4
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于用户自定义的文件， 文件描述符通常都是从3开始， 0、1、2这三个描述符分别代表标准输入、标准输出以及标准错误， 定义于<code class="highlighter-rouge">unistd.h</code>头文件中。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Standard file descriptors.  */</span>
<span class="cp">#define	STDIN_FILENO	0	</span><span class="cm">/* Standard input.  */</span><span class="cp">
#define	STDOUT_FILENO	1	</span><span class="cm">/* Standard output.  */</span><span class="cp">
#define	STDERR_FILENO	2	</span><span class="cm">/* Standard error output.  */</span><span class="cp">
</span></code></pre></div></div>

<p><code class="highlighter-rouge">read</code>系统调用此报告文件描述符fd所指代的打开文件中读取数据， 其定义为:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;unistd.h&gt;
</span>
<span class="kt">ssize_t</span> <span class="n">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div></div>

<p>count参数指定最多能读取的字节数， buffer参数提供用来存放数据的内存缓冲区地址(由用户所提供)， 缓冲区至少应有count字节。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX_READ 20
</span><span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAX_READ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

<span class="kt">ssize_t</span> <span class="n">num_read</span><span class="p">;</span>
<span class="n">num_read</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">MAX_READ</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">num_read</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="n">buffer</span><span class="p">[</span><span class="n">num_read</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"The input data was: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</code></pre></div></div>

<p>从标准输入中读取数据和从文件中读取数据会有些许差异， 因为在默认情况下， 从终端读取字符会在遇到换行符(\n)时<code class="highlighter-rouge">read</code>调用就会结束， 而对于普通文件， 则不会这样。</p>

<p>现在来进一步地了解<code class="highlighter-rouge">read</code>系统调用背后所发生的事情。 当程序调用<code class="highlighter-rouge">read</code>方法时， 产生系统调用， 则当前程序执行的状态由用户态切换至内核态， 操作系统将所需要的文件内容读取至内核某缓冲区中。 同时， 由于I/O是一个相对来说代价较大的操作， 为了减少读取磁盘的数据， 操作系统还会额外的读取更多的内容进入内核缓冲区， 下次读取这些内容时， 直接从缓冲区中读取， 不再从磁盘中读取， 从而提升整体效率。 数据进入内核缓冲区后， 内核需要将数据复制到用户缓冲区中， 也就是<code class="highlighter-rouge">read</code>方法所传递的<code class="highlighter-rouge">void *buffer</code>中。 传输完毕后由内核态切换至用户态， <code class="highlighter-rouge">read</code>系统调用完成。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/Linux%20Read.png" alt="" /></p>

<p>在执行<code class="highlighter-rouge">read</code>系统调用时， 总计发生了2次用户态切换， 额外的一次数据复制(kernel to User)。 并且， kernel buffer中保存了多于用户当前所需的数据， 用于加快下一次的<code class="highlighter-rouge">read</code>调用。</p>

<p><code class="highlighter-rouge">write</code>系统调用将数据写入一个打开的文件中， 当调用成功时， 返回实际写入文件的字节数。 与<code class="highlighter-rouge">read</code>系统调用相同， <code class="highlighter-rouge">write</code>调用在返回成功时， 仅是将数据写入到内核缓冲区中， 再由内核寻找适当的时机将该部分数据真正地写入到磁盘中。</p>

<p>采用这一设计可以有效的减少内核必须执行的磁盘传输次数， 因为可能调用10次<code class="highlighter-rouge">write</code>系统调用， 内核仅进行一次磁盘写入， 不仅减少了单个<code class="highlighter-rouge">write</code>系统调用所需时间， 并且提高了操作系统整体的运作效率。</p>

<p>这一机制所带来的唯一问题就是由于数据在某一时刻仅暂存于内核缓冲区中， 当系统发生断电或者是意外宕机时， 该部分数据就会丢失。 对于数据库等对数据要求非常严格的系统， 这种数据丢失是无法接受的。 所以， 内核额外的提供了<code class="highlighter-rouge">fsync</code>等强制刷新数据至磁盘的系统调用。</p>

<p><code class="highlighter-rouge">fsync</code>系统调用将使缓冲区数据和与打开文件描述符fd相关的所有元数据都刷新到磁盘上， 调用<code class="highlighter-rouge">fsync</code>会强制使文件处于Synchronized I/O file integrity completion状态。 所以， 当程序想要确保数据完全写入磁盘时， 可在<code class="highlighter-rouge">write</code>调用后执行<code class="highlighter-rouge">fsync</code>调用， 进行强制刷盘。</p>

<h4 id="3-c标准io函数库">3. C标准I/O函数库</h4>

<p>上面所提到的<code class="highlighter-rouge">open</code>， <code class="highlighter-rouge">read</code>等系统调用均有Linux/Unix系统所提供， 如Windows等操作系统并不支持此类调用。 为了解决不同操作系统底层提供的通用I/O函数不同的问题， ANSI C制定了一系列的标准I/O函数， 其目的就是为了解决代码的可移植性问题以及屏蔽I/O细节(缓冲区大小的选择， 文件锁实现等)。</p>

<p>标准I/O函数库中最常用的方法为<code class="highlighter-rouge">fopen</code>， <code class="highlighter-rouge">fgets</code>,  <code class="highlighter-rouge">fputs</code>以及<code class="highlighter-rouge">printf</code>， <code class="highlighter-rouge">fprintf</code>。 <code class="highlighter-rouge">fopen</code>和<code class="highlighter-rouge">open</code>的作用类似， 以某种模式(只读、只写等)打开一个文件， 唯一不同的是<code class="highlighter-rouge">open</code>返回<code class="highlighter-rouge">int</code>类型的文件描述符， 而<code class="highlighter-rouge">fopen</code>返回<code class="highlighter-rouge">FILE</code>类型的指针。</p>

<p>为了更好的理解<code class="highlighter-rouge">FILE</code>文件对象， 首先需要了解C标准I/O库的过程。 C标准I/O库的底层实现， 同样是基于Linux提供的通用I/O函数， 只不过标准库对其进行了封装而已。</p>

<p>C标准库除了帮助用户处理平台可移植性问题以外， 还会帮助用户减少系统调用的次数， 但是会额外的增加数据在内存间的复制次数。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/C%20Standard%20Libary.png" alt="" /></p>

<p>如上图所示，与Linux通用I/O相比， C标准I/O库自身也维护一个类似于内核缓冲的缓冲池， 内核缓冲区的数据并不会直接被复制到用户缓冲区中， 而是复制到标准库缓冲区中。 并且， 所复制的字节数也远大于用户所需要的字节数(count)， 当下次进行内容读取时， 直接从标准缓冲区中读取， 而不需要进行系统调用从内核缓冲区中读取。</p>

<p>该方式从整体上减少了系统调用的次数， 额外的增加了一次用户空间的数据复制， 由于标准I/O函数对系统调用进行了二次封装， 所以解决了可移植性问题。</p>

<p><code class="highlighter-rouge">fputc</code>以及<code class="highlighter-rouge">fputs</code>分别向所关联的文件流中写入单个字符或者是一串字符。 由于标准IO缓冲区的存在， 调用该方法时仅是将数据写入到C标准IO缓冲区中， 而后C标准库根据相应的条件决定何时执行<code class="highlighter-rouge">write</code>系统调用， 将数据写入内核缓冲区。 此后， 内核将决定在适当的时机将数据真正地写入磁盘。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/fputc.png" alt="" /></p>

<h5 id="31-c标准io缓冲">3.1 C标准I/O缓冲</h5>

<p>标准IO库提供了3种类型的缓冲: 全缓冲、行缓冲以及不带缓冲。</p>

<p>在全缓冲类型下， C函数库只有在完全填满标准IO缓冲区后才进行实际的IO操作， 磁盘文件通常是全缓冲的。 也就是说， 当程序使用<code class="highlighter-rouge">fopen</code>打开一个磁盘文件并调用<code class="highlighter-rouge">fputs</code>进行数据写入时， 数据可能仅写入了标准IO缓冲区中。 在随后的<code class="highlighter-rouge">fputs</code>调用中， 若C标准IO函数发现缓冲区已满， 则进行一次系统调用， 将数据写入至内核缓冲区中。</p>

<p>在行缓冲区类型下， 在输入和输出中遇到换行符(\n)时， 标准IO库执行实际的IO操作。 当一个流涉及到终端时(如标准输出)， 通常时行缓冲的， 例如<code class="highlighter-rouge">printf</code>函数。</p>

<p>不带缓冲则表示只要向标准缓冲区中写入数据， 标准库就会立即进行系统调用， 将数据写入内核缓冲。 标准错误通常是不带缓冲的， 原因在于期望能够尽快的看到错误的产生。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;
#include&lt;fcntl.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"This is printf out | "</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"This is a error output | "</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"BiuBiu</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello Aean: "</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">"I would have written you a short letter. | "</span><span class="p">;</span>
    <span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">43</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>编译并运行上述代码， 将会得到:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is a error output | This is <span class="nb">printf </span>out | BiuBiu
I would have written you a short letter. | Hello Aean:
</code></pre></div></div>

<p>当标准IO函数与系统调用混合使用时， 将会看到与代码期望完全不同的结果。 尽管<code class="highlighter-rouge">printf</code>函数在<code class="highlighter-rouge">fprintf</code>之前执行， 但由于<code class="highlighter-rouge">printf</code>为行缓冲， 而标准错误为不带缓冲， 所以标准错误信息将在标准输出信息打印之前打印。 <code class="highlighter-rouge">write</code>函数为系统调用， 输出的时机要优先于不带换行符的标准输出。</p>

<p>标准IO函数库同时也提供了<code class="highlighter-rouge">fflush</code>函数， 用于将标准缓冲区的数据强制刷新至内核， 如果我们在<code class="highlighter-rouge">printf</code>函数调用后调用<code class="highlighter-rouge">fflush</code>， 则会在标准错误输出之前看到输出。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"This is printf out | "</span><span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"This is a error output | "</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其结果为:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is <span class="nb">printf </span>out | This is a error output
</code></pre></div></div>

<p>使用过Docker部署Python项目的小伙伴儿可能对环境变量<code class="highlighter-rouge">PYTHONUNBUFFERED</code>感到很熟悉， 官方文档解释如下:</p>

<blockquote>
  <p>Force stdin, stdout and stderr to be totally unbuffered. On systems where it matters, also put stdin, stdout and stderr in binary mode.</p>
</blockquote>

<p>简单来说， 在Docker中使用该变量， 能够更快的使日志输出， 并且在容器crash的情况下， 也能看到必要的日志信息。</p>

<p>更详细的解释:</p>

<blockquote>
  <p>Setting PYTHONUNBUFFERED=TRUE or PYTHONUNBUFFERED=1 (they are equivalent) allows for log messages to be immediately dumped to the stream instead of being buffered. This is useful for receiving timely log messages and avoiding situations where the application crashes without emitting a relevant message due to the message being “stuck” in a buffer.
As for performance, there can be some (minor) loss that comes with using unbuffered I/O. To mitigate this, I would recommend limiting the number of log messages. If it is a significant concern, one can always leave buffered I/O on and manually flush the buffer when necessary.</p>
</blockquote>

<p>有关Linux通用IO以及C标准IO库的缓冲区， 可用下图清晰总结。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/IO%20buffer.png" alt="" /></p>

<p>原图来源于Linux/Unix系统编程手册， P200。</p>

<h4 id="4-内存映射io">4. 内存映射I/O</h4>

<p>现代操作系统大多数均采用分段+分页的方式来管理内存空间， 其目的就在于使得每一个进程的地址空间独立， 并且使系统能够运行超过其内存空间总数的各种进程。</p>

<p>分页内存管理的基本思想就是映射， 思想和哈希表基本类似: 将一个大范围的空间映射至一个小范围空间内。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/Linux/IO/virtaul%20memory.png" alt="" /></p>

<p>当程序想要访问的虚拟地址没有在页表项建立映射时， 系统将发起一个”缺页异常”， 由操作系统建立页表项并建立虚拟地址页与物理地址页的映射关系。 如此一来， 能够使得不常用的数据或者是内存片段被细粒度地换置至磁盘中， 内存中保留常用的数据。</p>

<p><code class="highlighter-rouge">mmap</code>方法的原理与虚拟内存映射基本相同， 将进程的一部分地址空间与磁盘文件建立映射关系， 将文件当做是内存中的一个数组使用， 减少<code class="highlighter-rouge">read</code>, <code class="highlighter-rouge">write</code>以及<code class="highlighter-rouge">lseek</code>的调用。</p>

<p>需要注意的是， 内存映射一个文件并不会导致整个文件被读取到内存中， 就如同虚拟内存空间不会都在物理地址空间一样， 而是仅仅为需要的文件数据保留映射关系。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">mmap</span>

<span class="k">def</span> <span class="nf">memory_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="n">mmap</span><span class="o">.</span><span class="n">ACCESS_WRITE</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDWR</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mmap</span><span class="o">.</span><span class="n">mmap</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="n">access</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">memory_map</span><span class="p">(</span><span class="s">'hello.txt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">15</span><span class="p">])</span>
</code></pre></div></div>

<p>此外，使用内存映射I/O的读写并不一定会比C标准I/O库或者是Linux通用I/O更加高效， 其原因在于虽然<code class="highlighter-rouge">mmap</code>减少了用户态的切换以及减少了数据的复制， 但是增加了处理缺页错误、建立页表项的时间， 并且各个平台对于<code class="highlighter-rouge">mmap</code>的实现也各有不同， 其优点就在于更加简洁的随机读取以及数据写入。</p>

<h4 id="5-异步io">5. 异步I/O</h4>

<p>异步I/O的实现通常会有两种: 当文件可读/可写时， 内核向进程发送一个信号， 或者是内核调用进程提供的回调函数。 在Linux下， AIO有2种实现: 基于线程模拟异步I/O的glibc AIO， 以及由内核实现的Kernel AIO。</p>

<p>对于glibc AIO而言， 是在用户空间使用多线程来模拟实现的， 并不能真正的称之为异步I/O， 但是能够在任意的文件系统、任意的操作系统上运行。</p>

<p>而Kernel AIO采用信号通知的方式实现异步I/O， 只能在Linux操作系统上运行， 基本没有可移植性。 此外， 一个最重要的问题就是Kernel AIO要求用户必须使用<code class="highlighter-rouge">O_DIRECT</code>模式打开文件， 即绕过内核高速缓冲区， 直接将数据传递至文件或者是磁盘设备， 这种方式又称为直接I/O(direct I/O)。</p>

<p>对于大多数应用而言， 使用直接I/O可能会大大的降低性能， 并且会有诸多不便之处。 其原因在于内核针对缓冲区高速缓存做了不少优化， 包括按顺序读取， 在成簇磁盘块上执行I/O， 允许访问同一文件的多个进程共享内核缓冲区。 并且， 直接I/O由于直接将数据传输至磁盘， 所以必须遵守磁盘的一些限制， 包括但不限于: 用于传递数据的缓冲区其内存边界必须对齐为块大小的整数倍， 待传输的数据长度必须是块大小的整数倍…</p>

<p>正是因为诸多限制， 不管是glibc AIO， 还是Kernel AIO， 在绝大部分的应用中都未曾使用， 看起来AIO就是专门为数据库应用所提供的实现。</p>

<h4 id="6-zero-copysendfile">6. Zero Copy(sendfile)</h4>

<p><code class="highlighter-rouge">sendfile</code>系统调用用于在两个文件描述符之间传输数据， 在Linux Kernel 2.6.33以前， <code class="highlighter-rouge">sendfile</code>只能将数据从一个具体的文件发送到一个<code class="highlighter-rouge">socket</code>中。 而在此版本之后， <code class="highlighter-rouge">sendfile</code>的接收方可以是任意的文件， 但是输入端只能是存在于虚拟内存空间的文件描述符， <code class="highlighter-rouge">socket</code>则不在此列。</p>

<p>方法原型为:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;sys/sendfile.h&gt;
</span>
<span class="kt">ssize_t</span> <span class="n">sendfile</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__out_fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__in_fd</span><span class="p">,</span> <span class="kt">off_t</span> <span class="o">*</span><span class="n">__offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">__count</span><span class="p">);</span>
</code></pre></div></div>

<p>一个简单的文件复制示例:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;fcntl.h&gt;
#include&lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/sendfile.h&gt;
</span>
<span class="kt">int</span> <span class="nf">get_file_size</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">stat</span> <span class="n">statbuf</span><span class="p">;</span>
    <span class="n">stat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statbuf</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">statbuf</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 省去错误判断
</span>    <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"foo.txt"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"bar.txt"</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">foo_size</span> <span class="o">=</span> <span class="n">get_file_size</span><span class="p">(</span><span class="s">"foo.txt"</span><span class="p">);</span>
    <span class="n">sendfile</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="n">foo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">foo_size</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外需要注意的是， <code class="highlighter-rouge">sendfile</code>在文件之间传输数据时， 并不支持<code class="highlighter-rouge">O_APPEND</code> flags， 只能覆盖写入。</p>

<p><code class="highlighter-rouge">sendfile</code>系统调用完全在内核空间进行， 数据不会从内核空间拷贝至用户空间， 并且能够得到DMA的硬件支持， 因而速度很快。</p>

<h4 id="7-总结">7. 总结</h4>

<p>对于非数据库类型的应用而言， 文件I/O的可选范围并不广， 即与其花费大量时间调试异步I/O， 不如直接选择C标准库I/O， 因为同时监听成百上千的文件读写并不常见。 对于频繁随机读取和写入的文件而言， 可以使用内存映射I/O来减少<code class="highlighter-rouge">lseek</code>的调用， 而<code class="highlighter-rouge">sendfile</code>系统调用更多地应用于文件至socket的数据传输。</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL中的悲观锁与常见的死锁场景</title>
	  <link>//MySQL-Pessimistic-Lock</link>
	  <author></author>
	  <pubDate>2019-09-18T21:39:25+00:00</pubDate>
	  <guid>//MySQL-Pessimistic-Lock</guid>
	  <description><![CDATA[
	     <p>在MySQL中， 锁机制是并发条件下保护数据一致性与稳定性的一个非常重要的机制， 并且事务的实现也依赖于于锁机制。 其锁定的数据不单包括数据行记录， 同时也包括缓冲池中的LRU列表数据、日志数据等。 悲观锁(FOR UPDATE)则是日常开发中使用最多的一种锁， 但是， 由于事务隔离级别的多样性导致了悲观锁在使用时常常会有不同的表现， 死锁在程序员稍不注意时就会发生。</p>

<!---more--->

<h4 id="1-悲观锁概述">1. 悲观锁概述</h4>
<p>在通用的程序设计语言中， 锁通常是基于某一个对象， 或者是一组对象而言。 在Python、Java和Golang中， 分别提供了<code class="highlighter-rouge">threading.Lock</code>、<code class="highlighter-rouge">synchronized</code>以及<code class="highlighter-rouge">sync.Mutex</code>互斥所机制。 而数据库要更为特殊一些， 其原因就在于我们所管理的不是一个个的对象， 而是一行行的数据。</p>

<p>InnoDB存储引擎支持的最小锁粒度为行锁， 可以通过在事务中执行<code class="highlighter-rouge">SELECT .. FOR UPDATE</code>为某一行或者是多行数据添加互斥锁。 锁的生命周期完全由InnoDB管理， 当事务成功提交或者是失败回滚时， 互斥锁则自动释放。</p>

<p>需要注意的一点是， 互斥锁必须在事务中执行才会生效。 当<code class="highlighter-rouge">autocommit</code>为<code class="highlighter-rouge">ON</code>时， 需要显示的使用<code class="highlighter-rouge">BEGIN</code>开启事务， 而后对数据添加互斥锁。</p>

<p>在程序设计语言中， 锁的目的是串行化修改、删除操作， InnoDB中的互斥锁有着同样的目的。 但是， 由于事务隔离级别的分类， 使得互斥锁的行为变得复杂许多。 其中最让人感到迷惑的就是为了解决幻读问题所添加的<code class="highlighter-rouge">GAP Lock</code>。</p>

<h4 id="2-事务隔离级别概述">2. 事务隔离级别概述</h4>

<p>不同的事务隔离级别， 悲观锁会产生不同的行为。 所以， 理解事务隔离级别是理解悲观锁的第一步。</p>

<p>InnoDB事务隔离级别从低到高依次为未提交读(READ UNCOMMITED)， 提交读(READ COMMITED)， 可重复读(READ REPEATABLE)以及串行化(SERIALIZABLE)。</p>

<p>未提交读指的是事务B可以读取到事务A未提交的数据， 此时若事务A回滚， 那么事务B读到的就是错误数据， 也称为脏数据。 该读取行为有时也会被称为脏读， 因为未提交读会导致脏读的问题， 从而导致数据混乱， 所以该事务隔离级别基本不会被使用。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/read-uncommitted-with-dirty-data.png" alt="" /></p>

<p>提交读是指在执行事务B时， 可以读取到事务A提交到的数据， 未提交的数据不可读取。 提交读解决了脏读的问题， 读取到的数据一定是已经持久化至磁盘的数据， 但是会出现同一条SQL语句在执行时出现不一致的情况。 例如事务A、B先后开始执行， 事务A首先读取row-1的内容， 而此时事务B对row-1的内容修改并提交， 此时事务A再次读取row-1数据， 发现其已经发生改变， 而该变化并不是事务A自身进行的。 这种情况又称为不可重复读。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/Read-Committed.png" alt="" /></p>

<p>可重复读， 顾名思义， 解决了提交读的不可重复读问题， 使得事务在读取同一行数据时， 结果并不会因为其它事务的执行而发生改变， 数据发生的修改行为在整个事务内是可以自恰的。 但是并没有解决幻读的问题， 幻读是指其余事务在某一个区间内插入数据， 而非修改数据， 此时事务也会读取到这部分插入的数据。 InnoDB借助MVCC(多版本并发控制)以及锁机制来解决幻读问题。</p>

<p>MVCC即在数据中添加版本号， 数据插入时会有初始版本号， 在修改、删除时更新版本号。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/lock/Repeatable-Read.png" alt="" /></p>

<p>串行化指事务串行化执行， 自然就不会有出现上述出现的脏读、不可重复读以及幻读了。 一个很重要的事实是， 串行化的事务隔离级别执行效率并不会比可重复读事务隔离级别差很多。 同样的， 提交读执行效率也不会比可重复读执行效率高多少， 所以在优化数据库时， 事务隔离级别不应该是效率优化目标， 而是业务优化目标。</p>

<h4 id="3-mysql中的锁">3. MySQL中的锁</h4>

<p>使用<code class="highlighter-rouge">FOR UPDATE</code>对某一行或者是多行数据添加的锁， 其实是由MySQL更细粒度的锁组合而成的， 不同的事务隔离级别有不同的组合方式。</p>

<p>在InnoDB存储引擎中， 存在3种行锁的算法， 其分别为:</p>
<ul>
  <li>Record Lock: 单个行记录上的锁，聚集索引及辅助索引均会添加锁。</li>
  <li>Gap Lock: 间隙锁， 锁定一个范围， 但不包含行记录本身。</li>
  <li>Next-Key Lock: Record Lock + Gap Lock，锁定行记录本身并且锁定一个范围。</li>
</ul>

<p>下面用一个实际的例子来解释Record Lock以及Gap Lock。 首先表结构定义如下:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">lock_test</span> <span class="p">(</span>
  <span class="n">id</span> <span class="n">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="n">a</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">latin1</span><span class="p">;</span>

<span class="c1">-- 插入部分测试数据</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"1"</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"3"</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"5"</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">lock_test</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nv">"8"</span><span class="p">);</span>
</code></pre></div></div>

<p>接着执行下面的语句:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “5” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“4”); <br /> 阻塞，等待会话A事务的提交</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">COMMIT;</td>
      <td style="text-align: left">Query OK, 1 row affected (6.87 sec)</td>
    </tr>
  </tbody>
</table>

<p>尽管列<code class="highlighter-rouge">a</code>添加了辅助索引， 但是在对该列使用<code class="highlighter-rouge">FOR UPDATE</code>添加悲观锁时， 仍然会出现其它列被锁定的现象。 这是因为<code class="highlighter-rouge">a = "5"</code>该行数据不仅被添加了Record Lock， 并且也添加了Gap Lock， 其目的就是为了解决幻读问题， 前提是当前事务隔离级别为REPEATABLE READ。</p>

<p>在列<code class="highlighter-rouge">a</code>的辅助索引中， 值”5”之前的值为”3”， 故存在(3, 5)这个间隙， 所以在插入值”4”时， InnoDB为了杜绝幻读现象的发生， 使得只有在会话A事务提交时才允许插入操作的进行。 另外一点需要注意的是， 当查询的索引具有唯一属性时， InnoDB存储引擎会对Next-Key Lock进行优化， 将其降级为Record Lock， 即仅锁住索引本身， 而不锁定一个范围。</p>

<blockquote>
  <p>For a unique index with a unique search condition, InnoDB locks only the index record found, not the gap before it.</p>
</blockquote>

<h4 id="4-锁与事务之间的关联">4. 锁与事务之间的关联</h4>

<p>前面提到了Gap Lock的存在主要是为了解决幻读问题的发生， 而在READ COMMITTED事务隔离级别中， 只解决了脏读问题， 所以说， 在该事务隔离级别下， <code class="highlighter-rouge">FOR UPDATE</code>仅会添加Record Lock， 并不会添加Gap Lock。</p>

<blockquote>
  <p>For locking reads (SELECT with FOR UPDATE or FOR SHARE), UPDATE statements, and DELETE statements, InnoDB locks only index records, not the gaps before them.</p>
</blockquote>

<blockquote>
  <p>Because gap locking is disabled, phantom problems may occur, as other sessions can insert new rows into the gaps</p>
</blockquote>

<p>此外， 如果用户通过索引查询一个值， 并在其之上添加排它锁， 当查询的值不存在时， READ COMMITTED与REPEATABLE READ两个事务隔离级别所产生的行为同样存在差异， 一个最直观的差异就是REPEATABLE READ在并发条件下会产生死锁， 而READ COMMITTED则不会。</p>

<p>READ COMMITTED事务隔离级别:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “100” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “100” FOR UPDATE; <br /> 不会被阻塞</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“100”); <br /> 不会被阻塞</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">6</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“100”); <br /> 不会被阻塞</td>
    </tr>
    <tr>
      <td style="text-align: left">7</td>
      <td style="text-align: left">COMMIT;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">8</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">COMMIT;</td>
    </tr>
  </tbody>
</table>

<p>所以说， 当事务隔离级别为READ COMMITTED时， 无法使用Next-Key Lock来帮助我们实现类似于<code class="highlighter-rouge">update_or_create</code>或者是<code class="highlighter-rouge">get_or_create</code>等方法， 因为在并发条件下会造成重复数据创建， 除非表中存在唯一索引。 这也是Django框架官网中所提到的Multiply records问题。 感兴趣的小伙伴可访问官网获取更多详细内容:</p>

<blockquote>
  <p>https://docs.djangoproject.com/en/2.2/ref/models/querysets/#get-or-create</p>
</blockquote>

<p>REPEATABLE READ事务隔离级别:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE; <br /> 不会被阻塞</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“200”); <br /> 阻塞, 等待事务B的结束</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">6</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">INSERT INTO lock_test (a) VALUES (“200”); <br /> ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction，死锁发生</td>
    </tr>
  </tbody>
</table>

<p>当在REPEATABLE READ事务隔离级别级别下实现<code class="highlighter-rouge">get_or_create</code>方法时，会产生死锁问题， 原因就在于锁定的记录并不存在， 多个事务可同时对其添加悲观锁， 但是插入语句的执行位置是不确定的， 所以就会有死锁问题的出现。解决此类问题的一个方法就是使用指数退避方式的重试。</p>

<h4 id="5-死锁">5. 死锁</h4>

<p>通常来讲， 如果我们的SQL执行计划较为简单， 几乎所有的执行均为单条语句执行时， 死锁基本与我们无关。 但是当执行计划稍加复杂， 事务执行的语句较多时， 就会出现死锁问题。 一个最经典的死锁场景即为AB-BA死锁。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">时间</th>
      <th style="text-align: left">会话A</th>
      <th style="text-align: left">会话B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">BEGIN;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE;</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">BEGIN;</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “400” FOR UPDATE;</td>
    </tr>
    <tr>
      <td style="text-align: left">5</td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “400” FOR UPDATE<br /> 阻塞, 等待事务B的结束</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">6</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">SELECT * FROM lock_test <br /> WHERE a = “200” FOR UPDATE; <br /> ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction，死锁发生</td>
    </tr>
  </tbody>
</table>

<p>当MySQL检测到死锁时， 会根据其事务权重选择性的回滚其中一个事务。 但是， 权重的判定完全由MySQL决定， 业务系统无法人为的干预， 如果某一个事务在业务系统中非常重要， 但是MySQL却回滚了该事务， 而业务系统仅捕捉了该异常并向外扩散的话， 并不是我们期望的结果。 所以， 在绝大多数场景下， 指数退避的重试策略要更好一些。 或者对于关键性的业务逻辑， 使用Redis等消息队列进行串行化操作。</p>

<p>另外一个死锁场景则是上一小节中我们所见到的并发执行<code class="highlighter-rouge">if not exist then create</code>模式所带来的死锁问题， 该模式在业务场景下其实非常常见。</p>

<h4 id="reference">Reference</h4>
<ul>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html</li>
  <li>https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL中的联合索引与覆盖索引</title>
	  <link>//MySQL-union-index-and-cover-index</link>
	  <author></author>
	  <pubDate>2019-09-01T21:39:25+00:00</pubDate>
	  <guid>//MySQL-union-index-and-cover-index</guid>
	  <description><![CDATA[
	     <p>在上一篇文章中， 通过解析InnoDB存储引擎的<code class="highlighter-rouge">.ibd</code>数据存储文件得到了数据与索引的真实组织方式: 数据通过聚集索引在逻辑上连续存放， 二级索引保存数据主键ID(Row ID)， 多棵B+Tree组合起来提供高效的索引数据查询。 除辅助索引(二级索引)外， 联合索引与覆盖索引在日常中也会经常用到。</p>

<!---more--->

<h4 id="1-联合索引">1. 联合索引</h4>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">union_test</span> <span class="p">(</span>
	<span class="n">id</span> <span class="n">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
	<span class="n">user_id</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	<span class="n">order_id</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	<span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
	<span class="k">KEY</span> <span class="n">ix_union_order_id_user_id</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">union_test</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"0000"</span><span class="p">,</span> <span class="nv">"A0000"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">union_test</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"0000"</span><span class="p">,</span> <span class="nv">"A0001"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">union_test</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"0001"</span><span class="p">,</span> <span class="nv">"A0003"</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div>

<p>在创建表结构以及插入部分测试数据之后， 我们依然使用<code class="highlighter-rouge">hexdump -C</code>来对<code class="highlighter-rouge">.ibd</code>文件进行分析， 从最基本的数据存储结构中更能够发现联合索引的存储特点。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00010070  73 75 70 72 65 6d 75 6d  03 04 00 00 10 00 36 30  |supremum......60|
00010080  30 35 38 41 31 34 80 00  00 01 03 04 07 00 18 05  |058A14..........|
00010090  e2 30 30 33 36 41 32 30  80 00 00 02 03 04 08 00  |.0036A20........|
000100a0  20 00 fb 30 30 34 33 41  31 33 80 00 00 03 03 04  | ..0043A13......|
000100b0  00 00 28 01 67 30 30 35  39 41 32 31 80 00 00 04  |..<span class="o">(</span>.g0059A21....|
000100c0  03 04 08 00 30 02 65 30  30 34 39 41 38 39 80 00  |....0.e0049A89..|
000100d0  00 05 03 04 00 00 38 01  1f 30 30 35 31 41 35 34  |......8..0051A54|
000100e0  80 00 00 06 02 04 06 00  40 05 76 30 30 32 33 41  |........@.v0023A|
000100f0  36 80 00 00 07 03 04 00  00 48 02 0c 30 30 30 31  |6........H..0001|
00010100  41 35 30 80 00 00 08 03  04 00 00 50 06 19 30 30  |A50........P..00|
00010110  31 35 41 39 31 80 00 00  09 03 04 00 00 58 ff 83  |15A91........X..|
00010120  30 30 34 32 41 37 32 80  00 00 0a 03 04 00 00 60  |0042A72........<span class="sb">`</span>|
00010130  01 56 30 30 33 38 41 39  35 80 00 00 0b 03 04 00  |.V0038A95.......|
00010140  00 68 03 4f 30 30 32 39  41 39 37 80 00 00 0c 03  |.h.O0029A97.....|
00010150  04 05 00 70 05 41 30 30  35 37 41 31 31 80 00 00  |...p.A0057A11...|
00010160  0d 03 04 00 00 78 02 c0  30 30 31 39 41 35 32 80  |.....x..0019A52.|
</code></pre></div></div>

<p>直接截取部分的联合索引内容进行分析， 索引数据从<code class="highlighter-rouge">00010078</code>开始:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span> <span class="mi">04</span>  <span class="cm">/* 倒序索引长度列表 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">36</span>
<span class="mi">30</span> <span class="mi">30</span> <span class="mi">35</span> <span class="mi">38</span>  <span class="cm">/* 列1索引数据 */</span>
<span class="mi">41</span> <span class="mi">31</span> <span class="mi">34</span>  <span class="cm">/* 列2索引数据 */</span>
<span class="mi">80</span> <span class="mi">00</span>  <span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 主键id */</span>
</code></pre></div></div>

<p>可以看到， 联合索引的物理存储方式与单一索引的最大区别就是索引数据不是分开存储的。 所以， 联合索引要比两个或多个单独的索引占用更少的磁盘空间。</p>

<p>事实上， 联合索引与单列索引在组织形式上没什么区别， 都是一棵B+Tree。 只不过联合索引的键值数量不是1， 而是大于等于2。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/union-index.png" alt="" /></p>

<p>如上图所示， 联合索引的第1列数据将严格按照B+Tree的字典序进行排序， 第2列数据则在第一列数据有序的基础上进行排序。 可以认为， 联合索引的B+Tree结构就是对一个多维数组进行排序， 以Python为例:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 假设有如下数据</span>
<span class="n">unsorted_list</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>

<span class="n">res</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">unsorted_list</span><span class="p">)</span>
<span class="c"># Out: [(1, 2), (1, 3), (2, 4), (2, 5), (4, 1), (4, 2)]</span>
</code></pre></div></div>

<p>假设现在有两列数据a, b组合成为了联合索引， 那么当a列相同时， b列数据一定是有序存放的， 也就是说当执行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">a</span> <span class="o">=</span> <span class="n">XX</span> <span class="k">AND</span> <span class="n">b</span> <span class="o">=</span> <span class="n">XX</span><span class="p">;</span>
</code></pre></div></div>

<p>其效率要高于a, b两个单独的索引列查询， 原因就在于其索引数据保存在同一棵B+Tree中， 使用更少的逻辑I/O就能将数据取出。</p>

<p>在单独查询列a时， 依然可以使用联合索引进行查询， 但是在单独查询b列时， 则不可以使用联合索引。 因为b列数据并不是有序存放的。</p>

<p>如上例所示， b列的数据为<code class="highlighter-rouge">[2, 3, 2, 4, 1, 2]</code>， 完全无序， 故使用:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">b</span> <span class="o">=</span> <span class="n">XX</span><span class="p">;</span>
</code></pre></div></div>

<p>进行查询时将无法使用联合索引。 联合索引除了能加速查询以外， 还有另外一个好处， 就是加速<code class="highlighter-rouge">ORDER BY</code>的查询。</p>

<p>这也很好理解， 因为在建立了联合索引以后， 第2列数据， 甚至是第n列数据， 将会有序的组成B+Tree， 如此一来就省去了排序的的时间。</p>

<p>假设现在有4列数据a, b, c, d组成的联合索引(a, b, c, d)， 那么B+Tree的结构为a有序排列， b在a相同的情况下有序排列， c在b相同的情况下有序排列， d在c相同的情况下有序排列。 在查询时， 只要查询条件包含a字段， 均可以使用索引进行查询。</p>

<h4 id="2-覆盖索引cover-index">2. 覆盖索引(Cover Index)</h4>
<p>现在我们已经知道了InnoDB的物理存储方式是一个聚集索引+多个辅助索引组成， 辅助索引包含单列索引以及上面提到的联合索引。 在使用索引进行数据查询时， 首先在辅助索引树中找到该条数据对应的主键id(Row ID)， 而后根据主键id在聚集索引树中进行查询， 粗略的认为就是2次逻辑I/O。</p>

<p>覆盖索引的本质就是不使用聚集索引， 只使用辅助索引就能够将所需要的数据查询出来， 最典型的例子就是<code class="highlighter-rouge">count(*)</code>。</p>

<p>当某张表内存在二级索引时， <code class="highlighter-rouge">count(*)</code>将直接统计二级索引的数量并返回。 由于二级索引的B+Tree要比聚集索引更加的矮胖， 每页能够容纳更多的索引数据行， 所以其效率要高于扫描聚集索引。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">count_test</span> <span class="p">(</span>
	<span class="n">id</span> <span class="n">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
	<span class="n">user_id</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	<span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
	<span class="k">KEY</span> <span class="n">ix_user_id</span> <span class="p">(</span><span class="n">user_id</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/count-with-cover-index.png" alt="" /></p>

<p>如果表内有多个二级索引， 则<code class="highlighter-rouge">count(*)</code>将会选择长度最短的二级索引。 索引长度越短， 每页就能够容纳更多的数据， 就会有更少的逻辑I/O， 因此效率也就越高。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">count_test</span> <span class="k">ADD</span> <span class="n">order_id</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">count_test</span> <span class="k">ADD</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">order_id</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/count-with-shorter-cover-index.png" alt="" /></p>

<p>覆盖索引严格意义上来讲是MySQL的查询优化器所做的优化， 并不是物理上存在的索引。 但是， 借助于覆盖索引的特点， 我们可以有目的的对某些查询进行优化。</p>

<h4 id="3-小结">3. 小结</h4>
<p>联合索引是优化多字段查询以及需要对某个字段进行排序的一种手段， 而覆盖索引则是MySQL查询优化器的一种优化策略， 并不能称为真正意义上的索引。</p>

	  ]]></description>
	</item>

	<item>
	  <title>MySQL物理存储方式</title>
	  <link>//MySQL-physical-structure</link>
	  <author></author>
	  <pubDate>2019-08-15T21:39:25+00:00</pubDate>
	  <guid>//MySQL-physical-structure</guid>
	  <description><![CDATA[
	     <p>MySQL是基于磁盘进行数据存储的关系型数据库， 所有的数据、索引等数据均以磁盘文件的方式存储， 在有需要时载入内存读取。 为了加快数据查询的效率， 通常会在一些字段上添加索引， 但是许多文档都会告诉我们， 不要添加太多的索引， 索引不要太长， 使用数字或者空字符串来代替NULL值， 为什么会有这些建议? 这些建议又是否正确?  答案都能够从MySQL数据的物理存储方式中找到。</p>

<!---more--->

<h4 id="1-innodb文件格式">1. InnoDB文件格式</h4>
<p>由于InnoDB是MySQL使用最为广泛的存储引擎， 所以本篇博文基于InnoDB存储引擎来讨论其数据存储方式。</p>

<p>当我们创建一个table时， InnoDB会创建三个文件。 一个是表结构定义文件， 另一个为数据实际存储文件， 并且所有的索引也将存放在这个文件中。 最后一个文件保存该table所制定的字符集。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/innodb-table-structure.png" alt="" /></p>

<h4 id="2-innodb行记录格式">2. InnoDB行记录格式</h4>
<p>当我们使用SQL查询一条或者是多条数据时， 数据将会以一行一行的方式返回， 而实际上数据在文件中也的确是使用行记录的方式进行存储的。</p>

<p>不同的InnoDB引擎版本可能有着不同的行记录格式来存放数据， 可以说， 行记录格式的变更将会直接影响到InnoDB的查询以及DML效率。 在MySQL 5.7版本中， 如果对某个table执行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SHOW</span> <span class="k">TABLE</span> <span class="n">STATUS</span> <span class="k">LIKE</span> <span class="nv">"table_name"</span> <span class="err">\</span><span class="k">G</span><span class="p">;</span>
</code></pre></div></div>

<p>将会得到该table的一系列信息， 在这里， 我们只需要知道<code class="highlighter-rouge">Row_format</code>的值即可， 5.7将会返回<code class="highlighter-rouge">Dynamic</code>。</p>

<p>在官网上给出了不同格式的行记录格式之间的差别， 详细内容见官方文档:</p>

<blockquote>
  <p>https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html</p>
</blockquote>

<p>在这里我们只需要知道<code class="highlighter-rouge">Dynamic</code>行记录格式在存储可变字符(Varchar)时， 与<code class="highlighter-rouge">Compact</code>行记录格式有着同样的表现即可。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/Compact-row-format.png" alt="" /></p>

<p>Compact行记录格式将以上图的方式保存在文件中， 需要注意的是， 如果一个table中没有任何的varchar类型， 那么变长字段长度列表将为空。</p>

<p>Compact行记录格式的首部是一个非NULL变长字段长度列表， 并且是按照列的顺序逆序放置的， 其长度表现为:</p>
<ul>
  <li>若列的长度小于255字节， 用1字节表示</li>
  <li>若列的长度大于255字节， 用2字节表示</li>
</ul>

<p>变长字段的长度最大不会超过2字节， 这是因为MySQL中VARCAHR类型的最大长度限制为65535。 变长字段之后的第二个部分为NULL标识位， 该位指示了该行数据中是否存在NULL值， 有则用1表示， 本质上是一个bitmap。</p>

<p>下面用一个实际的例子来具体分析Compact行记录格式的实际存储。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 创建database</span>
<span class="k">CREATE</span> <span class="k">SCHEMA</span> <span class="nv">`coco`</span> <span class="k">DEFAULT</span> <span class="n">CHARACTER</span> <span class="k">SET</span> <span class="n">latin1</span> <span class="p">;</span>

<span class="c1">-- 创建table</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">one</span> <span class="p">(</span>
    <span class="n">id</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">nickname</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="p">(</span><span class="n">nickname</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>

<span class="c1">-- 插入代表性数据</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"a"</span><span class="p">,</span> <span class="nv">"AAA"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"b"</span><span class="p">,</span> <span class="nv">"BBB"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"c"</span><span class="p">,</span> <span class="k">NULL</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"d"</span><span class="p">,</span> <span class="nv">"DDD"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"e"</span><span class="p">,</span> <span class="nv">""</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">one</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"f"</span><span class="p">,</span> <span class="nv">"FFF"</span><span class="p">);</span>
</code></pre></div></div>

<p>而后在<code class="highlighter-rouge">/var/lib/mysql/coco</code>中即可找到该表的<code class="highlighter-rouge">.ibd</code>文件了， 使用<code class="highlighter-rouge">hexdump -C one.ibd</code>对其进行16进制的数据解析并查看。 由于数据太长， 所以仅截取部分数据:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000c070  73 75 70 72 65 6d 75 6d  03 01 00 00 00 10 00 1d  |supremum........|
0000c080  80 00 00 01 00 00 00 08  d1 29 bd 00 00 01 35 01  |.........<span class="o">)</span>....5.|
0000c090  10 61 41 41 41 03 01 00  00 00 18 00 1c 80 00 00  |.aAAA...........|
0000c0a0  02 00 00 00 08 d1 29 bd  00 00 01 35 01 1d 62 42  |......<span class="o">)</span>....5..bB|
0000c0b0  42 42 01 02 00 00 20 00  1a 80 00 00 03 00 00 00  |BB.... .........|
0000c0c0  08 d1 29 bd 00 00 01 35  01 2a 63 03 01 00 00 00  |..<span class="o">)</span>....5.<span class="k">*</span>c.....|
0000c0d0  28 00 1d 80 00 00 04 00  00 00 08 d1 29 bd 00 00  |<span class="o">(</span>...........<span class="o">)</span>...|
0000c0e0  01 35 01 37 64 44 44 44  00 01 00 00 00 30 00 1a  |.5.7dDDD.....0..|
0000c0f0  80 00 00 05 00 00 00 08  d1 29 bd 00 00 01 35 01  |.........<span class="o">)</span>....5.|
0000c100  44 65 03 01 00 00 00 38  ff 66 80 00 00 06 00 00  |De.....8.f......|
0000c110  00 08 d1 29 bd 00 00 01  35 01 51 66 46 46 46 00  |...<span class="o">)</span>....5.QfFFF.|
</code></pre></div></div>

<p>实际存储数据从<code class="highlighter-rouge">0000c078</code>开始， 使用Compact行记录格式对其进行整理:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span> <span class="mi">01</span> <span class="cm">/* 变长字段长度列表, 逆序, 第一行varchar数据为('a', 'AAA') */</span>
<span class="mi">00</span> <span class="cm">/* NULL标识位, 该值表示该行未有NULL值的列 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">1</span><span class="n">d</span> <span class="cm">/* 记录头(Record Header)信息, 固定长度为5字节 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="cm">/* Row ID, 这里即为该行数据的主键值(paimary key)，长度为4 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">08</span> <span class="n">d1</span> <span class="mi">29</span> <span class="cm">/* Transaction ID, 即事务ID, 默认为6字节 */</span>
<span class="n">bd</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">35</span> <span class="mi">01</span> <span class="mi">10</span> <span class="cm">/* 回滚指针, 默认为7字节 */</span>
<span class="mi">61</span> <span class="cm">/* 列1数据'a' */</span>
<span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span> <span class="cm">/* 列2数据'AAA' */</span>
</code></pre></div></div>

<p>第2行数据与第1行数据大同小异， 值得关注的是包含有NULL值以及空值的行， 即第3行和第5行， 首先来看第3行数据:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">01</span> <span class="cm">/* 由于该行中只有一列数据类型为varchar，并且非NULL, 所以列表长度为1 */</span>
<span class="mi">02</span> <span class="cm">/* 02转换为2进制结果为10, 表示第二列数据为NULL(注意是逆序) */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">20</span> <span class="mi">00</span> <span class="mi">1</span><span class="n">a</span> <span class="cm">/* 记录头(Record Header)信息, 固定长度为5字节 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">03</span> <span class="cm">/* 第3行数据的主键id */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">08</span> <span class="n">d1</span> <span class="mi">29</span>  <span class="cm">/* Transaction ID, 即事务ID, 默认为6字节 */</span>
<span class="n">bd</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">35</span>  <span class="mi">01</span> <span class="mi">2</span><span class="n">a</span> <span class="cm">/* 回滚指针, 默认为7字节 */</span>
<span class="mi">63</span> <span class="cm">/* 列1数据'c' */</span>
</code></pre></div></div>

<p>可以非常明显的看到， NULL值并没有在文件中进行存储， 而是仅使用NULL标识位来标记某一列是否为NULL。 所以说， NULL值不会占据任何的物理存储空间， 相反， varchar类型的NULL值还会少占用变长字段长度列表空间。</p>

<p>再来看空字符串所在的第5行数据:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 表示第2列的varchar长度为0 */</span>
<span class="mi">00</span>  <span class="cm">/* 该行没有NULL值的列 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">30</span> <span class="mi">00</span> <span class="mi">1</span><span class="n">a</span>  <span class="cm">/* 记录头(Record Header)信息, 固定长度为5字节 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">05</span>  <span class="cm">/* 第5行数据的主键id */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">08</span> <span class="n">d1</span> <span class="mi">29</span>  <span class="cm">/* Transaction ID, 即事务ID, 默认为6字节 */</span>
<span class="n">bd</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">35</span> <span class="mi">01</span> <span class="mi">44</span>   <span class="cm">/* 回滚指针, 默认为7字节 */</span>
<span class="mi">65</span>  <span class="cm">/* 列1数据'e' */</span>
</code></pre></div></div>

<p>可以看到， 空字符串和NULL值一样， 也不占用任何的磁盘存储空间。 只不过与NULL值不同的是， 在首部的变长字符长度列表中仍然占据存储空间， 但是值为0。</p>

<h4 id="3-数据的聚集索引组织方式">3. 数据的聚集索引组织方式</h4>
<p>有些人将聚集索引(Cluster Index)理解成为主键， 或者是主键索引， 这是不准确的。 聚集索引并不是一种索引结构， 而是一种数据的组织方式， 用唯一且不为空的主键来对所有的数据进行组织。 主键， 是最为常见的聚集索引对外表现的形式。</p>

<p>聚集索引最大的特点就在于数据在逻辑上是一定是连续的， 但是在物理是并不一定连续。 比如我们常见的自增主键， 当我们对查询语句不做任何处理时， 默认就是按照主键的递增顺序返回的。</p>

<p>而辅助索引， 或者是二级索引， 是由程序员人为的在某些列上所添加的索引。 辅助索引所代表的数据在逻辑上不一定连续， 物理存储上也不一定连续。</p>

<p>MySQL使用B+Tree来组织数据和索引(关于B+Tree的详细内容， 可见下方传送门)， 在非叶子节点中保存着索引和指针， 在叶子节点保存着数据。 情况又分两种:</p>
<ul>
  <li>聚集索引的叶子节点保存着实际的数据，即一行完整的数据</li>
  <li>辅助索引的叶子节点保存着该行数据的主键ID</li>
</ul>

<p><a href="https://smartkeyerror.com/%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-04-B-Tree%E4%B8%8EB-Tree.html">那些有趣的数据结构与算法(04)–B-Tree与B+Tree</a></p>

<p>也就是说， 假设聚集索引和辅助索引的B+Tree树高均为3的话， 使用主键查询需要3次逻辑I/O。 而使用辅助索引则需要6次逻辑I/O才能找到该行数据。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/Cluster-Index.png" alt="" /></p>

<p>还记得在上面的Compact行记录格式中的行记录头， 也就是Record Header信息吗?  Record Header的最后两个字节表示下一行数据的偏移量， 其实这个就是B+Tree中的指针。 例如第一行的起始位置为c078， Record Header最后两个字节为001d， 加起来等于c095， 刚好是第二行的起始位置。</p>

<p>在上面的例子中， 我们创建了这样的一张表:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">one</span> <span class="p">(</span>
    <span class="n">id</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">nickname</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="p">(</span><span class="n">nickname</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">nickname</code>字段被我们添加了辅助索引， 同样地， 可以使用<code class="highlighter-rouge">.ibd</code>文件来具体对其结构进行分析。 使用<code class="highlighter-rouge">hexdump -C one.ibd</code>解析文件并找到辅助索引开始的地方:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00010060</span>  <span class="mi">02</span> <span class="mi">00</span> <span class="mi">37</span> <span class="mi">69</span> <span class="mi">6</span><span class="n">e</span> <span class="mi">66</span> <span class="mi">69</span> <span class="mi">6</span><span class="n">d</span>  <span class="mi">75</span> <span class="mi">6</span><span class="n">d</span> <span class="mi">00</span> <span class="mi">07</span> <span class="mi">00</span> <span class="mi">0</span><span class="n">b</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="o">|</span><span class="p">..</span><span class="mi">7</span><span class="n">infimum</span><span class="p">......</span><span class="o">|</span>
<span class="mi">00010070</span>  <span class="mi">73</span> <span class="mi">75</span> <span class="mi">70</span> <span class="mi">72</span> <span class="mi">65</span> <span class="mi">6</span><span class="n">d</span> <span class="mi">75</span> <span class="mi">6</span><span class="n">d</span>  <span class="mi">03</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">0</span><span class="n">e</span> <span class="mi">41</span>  <span class="o">|</span><span class="n">supremum</span><span class="p">.......</span><span class="n">A</span><span class="o">|</span>
<span class="mi">00010080</span>  <span class="mi">41</span> <span class="mi">41</span> <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">03</span> <span class="mi">00</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">18</span> <span class="mi">00</span> <span class="mi">18</span> <span class="mi">42</span> <span class="mi">42</span> <span class="mi">42</span>  <span class="o">|</span><span class="n">AA</span><span class="p">...........</span><span class="n">BBB</span><span class="o">|</span>
<span class="mi">00010090</span>  <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">02</span> <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">20</span>  <span class="mi">00</span> <span class="mi">19</span> <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">03</span> <span class="mi">03</span> <span class="mi">00</span>  <span class="o">|</span><span class="p">.......</span> <span class="p">........</span><span class="o">|</span>
<span class="mi">000100</span><span class="n">a0</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">28</span> <span class="mi">00</span> <span class="mi">19</span> <span class="mi">44</span> <span class="mi">44</span> <span class="mi">44</span>  <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">04</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="o">|</span><span class="p">..(..</span><span class="n">DDD</span><span class="p">........</span><span class="o">|</span>
<span class="mi">000100</span><span class="n">b0</span>  <span class="mi">30</span> <span class="n">ff</span> <span class="n">cc</span> <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">05</span> <span class="mi">03</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">38</span> <span class="n">ff</span> <span class="n">b2</span> <span class="mi">46</span> <span class="mi">46</span>  <span class="o">|</span><span class="mi">0</span><span class="p">..........</span><span class="mi">8</span><span class="p">..</span><span class="n">FF</span><span class="o">|</span>
<span class="mi">000100</span><span class="n">c0</span>  <span class="mi">46</span> <span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">06</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="o">|</span><span class="n">F</span><span class="p">...............</span><span class="o">|</span>
<span class="mi">000100</span><span class="n">d0</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="o">|</span><span class="p">................</span><span class="o">|</span>
</code></pre></div></div>

<p>索引数据从00010078的位置开始， 逐行进行分析即可:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span>  <span class="cm">/* 当前索引字段的长度 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">0</span><span class="n">e</span> <span class="cm">/* 不知道是啥 */</span>
<span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span>   <span class="cm">/* 索引值 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 指向的主键id */</span>
</code></pre></div></div>

<p>第2行与第1行基本类似， 现在来看看比较特殊的第3行与第5行。 第3行索引数据内容:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">01</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">20</span> <span class="mi">00</span> <span class="mi">19</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">03</span>  <span class="cm">/* 指向的主键id */</span>
</code></pre></div></div>

<p>当索引的内容为NULL值时， 辅助索引的文件格式也变得奇怪了起来， 和第一行完全不一样， 再来看看第5行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00</span>  <span class="cm">/* 当前索引字段的长度 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">30</span> <span class="n">ff</span> <span class="n">cc</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">05</span>  <span class="cm">/* 指向的主键id */</span>
</code></pre></div></div>

<p>和正常索引内容基本类似， 空字符串仍然没有表示， 仅使用了00表示该字段长度为0。</p>

<h4 id="4-辅助索引叶子节点存储方式">4. 辅助索引叶子节点存储方式</h4>
<p>在MySQL中， 数据管理的最小单元为页(page)， 而并非一行一行的数据。 数据保存在页中， 当我们使用主键查找一行数据时， 其实MySQL并不能直接返回这一行数据， 而是将该行所在的页载入内存， 然后在内存页中进行查找。</p>

<p>通常情况下页大小为16K， 在某些情况下可能会对页进行压缩， 使得页大小为8K或者是4K。 由于B+Tree的特点， 使得每一页内最少为2行数据， 再少就将退化成链表， 显然出于效率的考量不会让此种情况出现。 故而一行数据大小至多为16K， 通过该特性， 就可以研究二级索引的叶子节点是什么样子的了。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">two</span> <span class="p">(</span>
    <span class="n">id</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">nickname</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">8000</span><span class="p">),</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="p">(</span><span class="n">nickname</span><span class="p">(</span><span class="mi">2000</span><span class="p">))</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'A'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'C'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">,</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'E'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">'f'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'F'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">'g'</span><span class="p">,</span> <span class="k">NULL</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">'h'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'H'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">'i'</span><span class="p">,</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'G'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">two</span> <span class="k">SELECT</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">'i'</span><span class="p">,</span> <span class="nv">""</span><span class="p">;</span>
</code></pre></div></div>

<p>由于索引长度的限制， 这里仅取nickname的前2000个字符进行索引， 并插入一些具有代表性的数据。 同样使用<code class="highlighter-rouge">hexdump -C two.ibd</code>对索引结构进行分析:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00010070  73 75 70 72 65 6d 75 6d  d0 87 00 05 00 10 07 e6  |supremum........|
00010080  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|
<span class="k">*</span>
00010850  80 00 00 01 01 00 00 18  07 e6 80 00 00 02 d0 87  |................|
00010860  00 00 00 20 07 e6 43 43  43 43 43 43 43 43 43 43  |... ..CCCCCCCCCC|
00010870  43 43 43 43 43 43 43 43  43 43 43 43 43 43 43 43  |CCCCCCCCCCCCCCCC|
<span class="k">*</span>
00011030  43 43 43 43 43 43 80 00  00 03 01 00 00 28 0f c2  |CCCCCC.......<span class="o">(</span>..|
00011040  80 00 00 04 d0 87 00 00  00 30 07 dc 45 45 45 45  |.........0..EEEE|
00011050  45 45 45 45 45 45 45 45  45 45 45 45 45 45 45 45  |EEEEEEEEEEEEEEEE|
<span class="k">*</span>
00011810  45 45 45 45 45 45 45 45  45 45 45 45 80 00 00 05  |EEEEEEEEEEEE....|
00011820  d0 87 00 00 00 38 0f c2  46 46 46 46 46 46 46 46  |.....8..FFFFFFFF|
00011830  46 46 46 46 46 46 46 46  46 46 46 46 46 46 46 46  |FFFFFFFFFFFFFFFF|
<span class="k">*</span>
00011ff0  46 46 46 46 46 46 46 46  80 00 00 06 01 00 00 40  |FFFFFFFF.......@|
00012000  0f c3 80 00 00 07 d0 87  00 00 00 48 e0 62 48 48  |...........H.bHH|
00012010  48 48 48 48 48 48 48 48  48 48 48 48 48 48 48 48  |HHHHHHHHHHHHHHHH|
<span class="k">*</span>
000127d0  48 48 48 48 48 48 48 48  48 48 48 48 48 48 80 00  |HHHHHHHHHHHHHH..|
000127e0  00 08 d0 87 00 00 00 50  f8 24 47 47 47 47 47 47  |.......P.<span class="nv">$GGGGGG</span>|
000127f0  47 47 47 47 47 47 47 47  47 47 47 47 47 47 47 47  |GGGGGGGGGGGGGGGG|
<span class="k">*</span>
00012fb0  47 47 47 47 47 47 47 47  47 47 80 00 00 09 00 00  |GGGGGGGGGG......|
00012fc0  00 00 58 d0 bb 80 00 00  0a 00 00 00 00 00 00 00  |..X.............|
00012fd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</code></pre></div></div>

<p>从上表中可以看到， 索引数据起始点为00010078， 逐行进行分析可以发现， NULL值和空值的表现形式与上一小节分析的基本相同。</p>

<p>NULL值行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">01</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">18</span> <span class="mi">07</span> <span class="n">e6</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">02</span>  <span class="cm">/* 主键id */</span>

<span class="mi">01</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">28</span> <span class="mi">0</span><span class="n">f</span> <span class="n">c2</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">04</span>  <span class="cm">/* 主键id */</span>

<span class="mi">01</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">40</span> <span class="mi">0</span><span class="n">f</span> <span class="n">c3</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">07</span>  <span class="cm">/* 主键id */</span>
</code></pre></div></div>

<p>空字符串行:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">58</span> <span class="n">d0</span> <span class="n">bb</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">0</span><span class="n">a</span>  <span class="cm">/* 主键id */</span>
</code></pre></div></div>

<p>所以说， 分析到这里， 我们完全有理由说NULL值要比空值占用更少的物理存储空间， 包含索引存储空间。 但是， 这是在我们所定义表结构时允许字段值为NULL的前提下， 当我们显式的指定IS NOT NULL时， 情况又会不一样。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">three</span> <span class="p">(</span>
    <span class="n">id</span> <span class="n">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">name</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">nickname</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="p">(</span><span class="n">nickname</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">LATIN1</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"a"</span><span class="p">,</span> <span class="nv">"AAA"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"b"</span><span class="p">,</span> <span class="nv">""</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"c"</span><span class="p">,</span> <span class="nv">"CCC"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"d"</span><span class="p">,</span> <span class="nv">"DDD"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"e"</span><span class="p">,</span> <span class="nv">"EEE"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"f"</span><span class="p">,</span> <span class="nv">""</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">three</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nickname</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="nv">"g"</span><span class="p">,</span> <span class="nv">"GGG"</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">hexdump -C three.ibd</code>可得:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000c070  73 75 70 72 65 6d 75 6d  03 01 00 00 10 00 1c 80  |supremum........|
0000c080  00 00 01 00 00 00 08 dd  21 ba 00 00 01 2f 01 10  |........!..../..|
0000c090  61 41 41 41 00 01 00 00  18 00 19 80 00 00 02 00  |aAAA............|
0000c0a0  00 00 08 dd 22 bb 00 00  01 31 01 10 62 03 01 00  |....<span class="s2">"....1..b...|
0000c0b0  00 20 00 1c 80 00 00 03  00 00 00 08 dd 25 bd 00  |. ...........%..|
0000c0c0  00 01 35 01 10 63 43 43  43 03 01 00 00 28 00 1c  |..5..cCCC....(..|
0000c0d0  80 00 00 04 00 00 00 08  dd 28 bf 00 00 01 36 01  |.........(....6.|
0000c0e0  10 64 44 44 44 03 01 00  00 30 00 1c 80 00 00 05  |.dDDD....0......|
0000c0f0  00 00 00 08 dd 29 c0 00  00 01 37 01 10 65 45 45  |.....)....7..eEE|
0000c100  45 00 01 00 00 38 00 19  80 00 00 06 00 00 00 08  |E....8..........|
0000c110  dd 2a a1 00 00 01 12 01  10 66 03 01 00 00 40 ff  |.*.......f....@.|
0000c120  4f 80 00 00 07 00 00 00  08 dd 2b a2 00 00 01 15  |O.........+.....|
0000c130  01 10 67 47 47 47 00 00  00 00 00 00 00 00 00 00  |..gGGG..........|
</span></code></pre></div></div>

<p>数据从c078开始， 同样进行逐行分析:</p>

<p>第一行数据:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span> <span class="mi">01</span>  <span class="cm">/* 逆序可变字符长度列表 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">1</span><span class="k">c</span>  <span class="cm">/* 记录头信息(Record Header), c078+001c=c094 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 主键id */</span>
<span class="c1">-- Transaction ID + Roll Pointer</span>
<span class="mi">61</span>  <span class="cm">/* 列1数据 */</span>
<span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span>  <span class="cm">/* 列2数据 */</span>
</code></pre></div></div>

<p>第二行数据</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">00</span> <span class="mi">01</span>  <span class="cm">/* 逆序可变字符长度列表 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">18</span> <span class="mi">00</span> <span class="mi">19</span>  <span class="cm">/* 记录头信息(Record Header), c094+0019=c0ad */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">02</span>  <span class="cm">/* 主键id */</span>
<span class="c1">-- Transaction ID + Roll Pointer</span>
<span class="mi">62</span>  <span class="cm">/* 列1数据, 列2数据为空值, 故无记录 */</span>
</code></pre></div></div>

<p>第三行数据:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">03</span> <span class="mi">01</span>  <span class="cm">/* 逆序可变字符长度列表 */</span>
<span class="mi">00</span> <span class="mi">00</span> <span class="mi">20</span> <span class="mi">00</span> <span class="mi">1</span><span class="k">c</span>  <span class="cm">/* 记录头信息(Record Header), c0ad+001c=c0c9 */</span>
<span class="mi">80</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">03</span>  <span class="cm">/* 主键id */</span>
<span class="c1">-- Transaction ID + Roll Pointer</span>
<span class="mi">63</span>  <span class="cm">/* 列1数据 */</span>
<span class="mi">43</span> <span class="mi">43</span> <span class="mi">43</span>  <span class="cm">/* 列2数据 */</span>
</code></pre></div></div>

<p>可以看到， 将<strong>所有</strong>的列设置为NOT NULL之后， 存储内容少了一个NULL标识位， 此时该table的存储效率要高于最初的表结构。</p>

<p>所以说， 如果想要真正的节省表空间存储大小， 需要将<strong>所有</strong>的字段都设置为NOT NULL约束， 否则在存储时仍然需要NULL标识位来标记哪一列数据为非NULL， 即使所有的列都有数据。</p>

<p>最后， NULL真的比空字符串占用更少的空间吗? 答案是不一定。 如果在定义表结构时指定了NOT NULL， 那么数据中就不可能出现NULL值， 也就无从比起。 如果在定义表结构时没有指定NOT NULL， 那么NULL将会比空字符串占用更少的空间。</p>

<h4 id="5-总结">5. 总结</h4>
<p>经过对<code class="highlighter-rouge">.ibd</code>文件的分析， 想必对数据以及索引的组织方式有了一个更加清晰的了解， 并且也能够判断出各种各样优化建议到底是否正确了。</p>

<p>使用数字或者是空串来代替NULL值? 没有必要， 有时还会适得其反， 而且对于添加了二级索引的NULL值， 查询仍然会使用索引。 正确的做法就是在定义表结构的时候就将NULL值扼杀在摇篮里， 如此一来能够节省一部分的磁盘空间以及一定程度上的效率提升。</p>

<p>为什么索引不能太多? 因为每添加一个索引， <code class="highlighter-rouge">.ibd</code>文件中就需要多维护一个B+Tree索引树， 如果某一个table中存在10个索引， 那么就需要维护10棵B+Tree， 写入效率会降低， 并且会浪费磁盘空间。</p>

<p>B+Tree中的指针是用什么实现的? 使用文件偏移量实现， 指向下一行或者是下一个索引的起始位置。</p>

	  ]]></description>
	</item>

	<item>
	  <title>数据变更操作日志设计</title>
	  <link>//change-log-system-design</link>
	  <author></author>
	  <pubDate>2019-08-10T21:39:25+00:00</pubDate>
	  <guid>//change-log-system-design</guid>
	  <description><![CDATA[
	     <p>当系统的某些行为涉及到资金与资产的数据变更时，常常会为其增加操作日志， 便于后续的问题排查。 例如红包的使用明细， 银行转账的详细记录等等。 操作日志记录这个需求看起来很简单， 但是深挖下去， 依然能找到很有趣的东西。</p>

<!---more--->

<h4 id="1-需求">1. 需求</h4>
<p>既然是操作日志， 势必要记录<strong>谁对什么进行了怎样的操作</strong>， 抽象出来的字段就有<code class="highlighter-rouge">operator</code>(操作人)， <code class="highlighter-rouge">action</code>(创建、修改等行为)， <code class="highlighter-rouge">entry</code>(实体, 通常会用实体id来代替)。</p>

<p>MySQL-binlog的日志格式有<code class="highlighter-rouge">FULL</code>和<code class="highlighter-rouge">MINIMAL</code>两种， 前者记录了所有的字段， 后者只记录了更新的部分字段。 那么对于操作日志而言， 同样需要考虑是记录更新前后的所有数据字段， 还是只记录更新的字段。 操作日志的数据当然是越详细越好， 既然都要做这个需求了， 那就一步到位。</p>

<p>所以说， 本篇文章的日志格式即为数据库数据的增量版， 并且在原有数据字段上进行稍许拓展， 进行更加详细的记录。 也可以认为这就是记录了所有的数据版本库， 此时添加一个版本号即可。</p>

<h4 id="2-实现">2. 实现</h4>
<p>理论上来讲实现有两种， 一种是业务层面实现， 一种是使用日志解析工具来解析二进制日志， 但是该实现方式非常依赖具体的存储实现， 像MySQL和Oracle的解析策略是不一样的， 如果使用了MongoDB作为主库存储， 数据文件解析起来就更费劲了。</p>

<p>从项目维护的角度来看， 业务层实现在编码完成之后， 几乎不需要花太多的精力维护。 但是日志解析或者是数据文件解析工具， 却需要花大量的人力和时间来维护(看看<code class="highlighter-rouge">canal</code>)。</p>

<p>从易拓展的角度来看， 业务层的实现只需要稍加抽象， 就可以随意的更换或者添加数据存储源。 而日志分析的实现如果需要更换数据源的话， 迁移的工作量可能相当庞大。</p>

<p>从效率的角度来看， 业务层的实现效率确实会低于日志解析的实现。</p>

<p>综上考虑， 业务层实现是最佳的方式， 方便维护， 方便拓展， 在效率上虽然会对原有系统造成影响， 但是可以通过其它的方式进行补偿。</p>

<h4 id="3-实现细节">3. 实现细节</h4>

<p>在具体的实现之前， 首先来看一下常见Web请求的基本流程， 当然， 这里只针对创建、修改和删除操作:</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/operation-log/data-stream.png" alt="" /></p>

<p>当对创建请求进行操作日志记录时， 完全可以将经过表单验证以及逻辑处理后的数据直接写入到日志记录库， 并添加一些附属信息， 如操作人， 操作的动作(create)， 来源IP等等。</p>

<p>但是对于更新操作呢? 通常只会进行部分字段的更新， 而后直接使用</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">update</span> <span class="p">...</span> <span class="k">set</span> <span class="n">field</span> <span class="o">=</span> <span class="n">value</span> <span class="k">where</span> <span class="p">...;</span>
</code></pre></div></div>

<p>进行部分字段或者是批量更新。 但是为了记录更新后的完整数据， 那么就需要在更新后再将数据取出， 添加附属信息， 并插入日志记录库。 如此一来相比原来，多了一次查询操作。</p>

<p>如果不使用<code class="highlighter-rouge">update</code>语句， 使用<code class="highlighter-rouge">instance.save</code>方式呢? 即先将数据取出， 而后更新数据， 将更新的数据写回DB并插入操作日志。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/operation-log/get-and-update.png" alt="" /></p>

<p>在使用ORM的应用中， 这样的代码其实很常见， 一个最大的问题就是并发时的数据问题， 先更新的语句可能会覆盖掉另外一条后更新的语句， 导致数据混乱。</p>

<p>原因就在于取出数据-更新数据不是一个原子性的操作， 底层的数据库因为并发执行导致多条语句的执行顺序并不受程序控制。 所以我们要么寻找一种能够原子性执行的方式， 要么对数据添加行锁。 首先来看行锁的方式:</p>

<p>使用<code class="highlighter-rouge">select for update</code>对数据添加行锁， 在一个事务内， 只能由当前事务对其进行更新，  这样一来就不会有并发问题了。 但是这种方式相比于第一种方式， 额外的增加了行锁的持有时间， 在大量的并发更新时， 很有可能产生雪崩效应。</p>

<p>如果使用版本控制的乐观锁实现， 虽然也可以达到目的， 但是在大量并发的情况下可能会导致许多的更新都会失败， 而后全部进行重试流程， 导致恶性循环。</p>

<h4 id="4-事务隔离">4. 事务隔离</h4>

<p>在上面的讨论中， 不管是先更新， 还是先取出数据再更新， 都面临着同一个问题: 并发。 并发导致了SQL语句并不会向我们预期的那样执行， 前脚取出的数据可能后脚就被更新了。 所以我们需要一个机制来协助我们对抗并发， 事务。</p>

<p>单纯的事务仅具有原子性， 即要么全部成功， 要么全部失败的特性。 想要满足我们的需求还需要一定的事务隔离级别。</p>

<p><code class="highlighter-rouge">REPEATABLE READ</code>该事务隔离级别保证了在同一个事务内， 所读取到的数据不受其它事务语句的影响，  同样也是MySQL默认的事务隔离级别。</p>

<p>所以不管是先更新还是先取数据， 只要在同一个事务内执行， 就不会存在数据污染问题， 保证了数据的准确与完整性。</p>

<h4 id="5-aop的实现">5. AOP的实现</h4>
<p>面向切面编程更进一步地理解其实就是函数式编程， 纵观Spring Boot AOP以及Python中的装饰器， 都是函数的注册与调用， 只是语言间的具体实现不同而已。 Python存在<code class="highlighter-rouge">@</code>语法糖， 更加的灵活和方便。 而对于Golang和Java而言， 就需要自己进一步的进行函数封装和调用了。</p>

<p>包括像<code class="highlighter-rouge">hook</code>(钩子)一类的技术实现， 最终也是函数的注册与调用。 比如Django中的<code class="highlighter-rouge">singal</code>(信号量)， 虽然说是发布-订阅模式， 但是本质仍是函数的调用。 只不过没有把具体的逻辑写在一个地方， 而是使用某种其它方式进行解耦了而已。</p>

<p>所以， 写一个简单的AOP是一件非常easy的事情， 处理好异常和重试机制就好。</p>

<h4 id="6-日志存储源">6. 日志存储源</h4>

<p>一个系统中对数据处理优先程度是不同的， 类似于转账记录、红包使用记录等数据， 必须进行完备的数据持久化， 并且能够在灾难时进行迅速恢复。 此时可使用可靠性较强的关系型数据库， 如MySQL， PG等。</p>

<p>当数据的要求较低， 并且数量比较庞大时， 可采用Elasticsearch进行存储和查询。</p>

<p>那么业务层在具体实现时， 就需要能够支持多种日志存储源， 此时面向接口编程又是最佳的选择。</p>

<h4 id="7-持续优化">7. 持续优化</h4>

<p>前面提到了由于需要记录数据操作日志的原因， 需要在更新、删除等操作后多一次额外的数据查询， 并且需要将完整的日志数据持久化至日志存储源， 相当于多了两次网络传输。</p>

<p>如何将这两次网络传输所花费的时间降至最低， 是本小结要讨论的内容。</p>

<p>数据库数据组织形式分为聚集索引和非聚集索引， 聚集索引的组织方式使得B+Tree的叶子节点即数据， 而非聚集索引的叶子节点仍然是索引节点， 需要多一个I/O操作找到该索引节点的数据节点。 所以说， 使用主键查询是非常快的。</p>

<p>对于常见的更新操作， 通常不会使用主键来作为查找条件， 这是由业务系统所决定的。 所以说如果使用<code class="highlighter-rouge">更新-查询</code>的方式， 无法使用主键进行查询来提高系统效率。 相反， 使用<code class="highlighter-rouge">查询-更新</code>的方式却可以。 查询时使用非聚集索引进行查询， 而后使用主键来进行数据定位和更新。</p>

<p>日志持久化可使用消息队列完成， 重试机制可使用消息队列本身携带的重试实现， 或者是对其进行封装， 自行实现。</p>

<h4 id="8-批量更新问题">8. 批量更新问题</h4>
<p>如果需要更新的行数不止一条， 而是有很多条时又该如何处理? 取出数据后遍历更新并生成操作日志吗?</p>

<p>在业务端写SQL一个比较忌讳的事情就是在for循环中对数据库进行操作， 如此一来必定会有N次网络传输， 跑起来的效率令人发指。</p>

<p>可以采用<code class="highlighter-rouge">查询-业务端组装操作日志-更新</code>的方式完成， 伪代码如下:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 开启事务</span>
<span class="n">begin</span>

<span class="n">result_list</span> <span class="o">=</span> <span class="n">Model</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="c"># 生成批量日志</span>
<span class="n">log_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">result_list</span><span class="p">:</span>
    <span class="n">ins_dict</span> <span class="o">=</span> <span class="n">Serialize</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="c"># 填充ip, 操作人等信息</span>
    <span class="n">log_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ins_dict</span><span class="p">)</span>

<span class="c"># 对多条数据进行更新</span>
<span class="n">Model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="n">commit</span> <span class="ow">or</span> <span class="n">rollback</span>

<span class="c"># 事务成功提交后将日志提交至存储层</span>
</code></pre></div></div>

<h4 id="9-小结">9. 小结</h4>

<p>记录操作日志这个需求看起来很小， 但是仔细的审视每一个操作内的细节， 会发现这真是一个有趣的需求。 涉及了数据库事务， 事务隔离， 索引， NoSQL与搜索引擎， 消息队列， 等等技术细节。</p>

	  ]]></description>
	</item>

	<item>
	  <title>那些有趣的数据结构与算法(05)--限流</title>
	  <link>//limits</link>
	  <author></author>
	  <pubDate>2019-07-20T21:54:55+00:00</pubDate>
	  <guid>//limits</guid>
	  <description><![CDATA[
	     <p>有时候限流也可以称为防刷， 这两者的界定并不是很明显， 常用的限流算法包括固定窗口， 滑动窗口， 漏桶以及令牌桶算法， 它们都有各自的优势与最适合的使用场景， 算法不分好坏， 之分场景。</p>

<!---more--->

<h4 id="1-固定窗口">1. 固定窗口</h4>
<p>固定窗口属于最简单但是也最容易出现问题的限流策略， 假设某接口限制请求频率为<code class="highlighter-rouge">10000/minute</code>， 则统计一分钟内接口请求的总次数， 若次数大于10000， 则请求失败， 开始限流， 直到下一个一分钟开始。</p>

<p>使用Redis可以非常轻松的实现该功能:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 该功能可用Lua优化，详见Lua模块</span>
<span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span>
<span class="n">redis</span> <span class="o">=</span> <span class="n">Redis</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">6379</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">hit_user_access</span><span class="p">(</span><span class="n">api</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">redis_key</span> <span class="o">=</span> <span class="s">"restrict_access:"</span><span class="o">+</span><span class="n">api</span>
        <span class="n">access_number</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="n">redis_key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">access_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">redis</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">redis_key</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">access_number</span> <span class="o">&gt;</span> <span class="n">MAX_ACCESS_NUMBER</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c"># 日记记录</span>
        <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</code></pre></div></div>

<p>借助于Redis的expire-key功能来实现”当前一分钟”和”下一个一分钟”， 若键过期， 则重新进行计数， 表示下一个一分钟开始了。</p>

<p>固定窗口用来做小流量的防刷比较适合， 但是并不适合作为整体系统的限流。 其原因就在于在这一分钟内接收流量并不一定是平均的。 攻击方可以在每一个一分钟开始的前1秒或几秒中疯狂攻击接口， 使得接口的请求数量在一开始就达到上限， 这样一来后续的正常用户将无法访问。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/limit/fixed.png" alt="" /></p>

<p>但是在一些简单的场景下， 例如单个用户的验证码发送条数限制， 当天密码输入失败的最大次数等等， 使用Redis实现的固定窗口不失为一个最佳选择。</p>

<h4 id="2-滑动窗口">2. 滑动窗口</h4>
<p>固定窗口很像一步接着一步的走路， 两步之间没有间隙， 但是每一步之间不会重叠。 而滑动窗口则是”拖着脚”在走路， 下一步会部分的覆盖前一步所走过的路径。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/limit/moving-window.png" alt="" /></p>

<p>如上图所示， 窗口大小为60s， 每过一秒向前移动一小步， 60s过后将会移动一整个窗口， 此时就像固定窗口移动一样。</p>

<p>滑动窗口在限流上其实使用的不是很多， 原因就在于滑动窗口也无法处理1s内请求过载的问题，  但是在监控告警上却是不二之选。</p>

<p>滑动窗口的最大优势就在于”重叠”， 因为窗口在滑动过程中， 势必会跨越前一分钟和后一分钟， 使得控制更加精细。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/limit/moving-window-alert.png" alt="" /></p>

<p>在具体的实现上， 通常会使用计算的方式来模拟窗口的向右滑动， 也可以说是”薛定谔的滑动”。 这里不考虑限流的滑动窗口实现， 而是转而实现监控告警的功能。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">key</span> <span class="o">=</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="kd">local</span> <span class="n">now_timestamp</span> <span class="o">=</span> <span class="nb">tonumber</span><span class="p">(</span><span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="kd">local</span> <span class="n">window_size</span> <span class="o">=</span> <span class="nb">tonumber</span><span class="p">(</span><span class="n">ARGV</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="kd">local</span> <span class="n">limit</span> <span class="o">=</span> <span class="nb">tonumber</span><span class="p">(</span><span class="n">ARGV</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

<span class="kd">local</span> <span class="n">should_clear</span> <span class="o">=</span> <span class="n">now_timestamp</span> <span class="o">-</span> <span class="n">window_size</span>
<span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s2">"ZREMRANGEBYSCORE"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">should_clear</span><span class="p">)</span>

<span class="kd">local</span> <span class="n">amount</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s2">"ZCARD"</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="k">if</span> <span class="n">amount</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="k">then</span>
    <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s2">"ZADD"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">now_timestamp</span><span class="p">,</span> <span class="n">now_timestamp</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s2">"EXPIRE"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">window_size</span><span class="p">)</span>

<span class="k">return</span> <span class="n">amount</span> <span class="o">&lt;</span> <span class="n">limit</span>
</code></pre></div></div>

<p>在熔断器里面会有这样的技术细节: 5分钟内失败率达到某个阈值时进行熔断， 像这样的需求完全可以使用滑动窗口很好的实现， 不管是使用简单的单机实现， 还是使用Redis的分布式实现。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MovingWindow</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
        <span class="s">"""
        :param window: 窗口大小
        :param rate: 移动速率
        """</span>
        <span class="k">assert</span> <span class="n">window</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"window and rate should more than zero value"</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s">"window and rate should be a Integer"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">=</span> <span class="n">rate</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__window</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__last_moving</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="s">"""
        :param step: 窗口向右滑动的距离
        """</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__window</span><span class="p">[</span><span class="n">step</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">step</span>

    <span class="k">def</span> <span class="nf">__clock_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        计算窗口应当滑动的距离
        """</span>
        <span class="n">now</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
        <span class="n">expire</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__last_moving</span>
        <span class="n">step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">expire</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__shift</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__last_moving</span> <span class="o">=</span> <span class="n">now</span>

    <span class="k">def</span> <span class="nf">incr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c"># 首先将窗口滑动至正确位置</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__clock_shift</span><span class="p">()</span>
        <span class="c"># 将值添加至窗口最后一个元素上即可</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__window</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        :return: 返回当前窗口计数总数
        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__clock_shift</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__window</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__window</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">"window: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__window</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="3-令牌桶">3. 令牌桶</h4>
<p>令牌桶算法可能是生产用使用的较为广泛的限流算法， 一方面可以限制瞬时流量， 一方面也可以限制一段时间内的流量， 算是比较两全的算法。</p>

<p>令牌桶引入缓冲区， 按照一定的速率生成令牌， 并将其置于令牌桶中。 每一个请求首先尝试从令牌桶中获取令牌， 若无令牌可用， 则直接返回失败。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TokenBucket</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
        <span class="s">"""
        :param capacity: 桶的容量
        :param rate: 生成令牌的速率
        """</span>
        <span class="k">assert</span> <span class="n">capacity</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"capacity and rate should more than zero"</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s">"capacity and rate should be integer"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">=</span> <span class="n">rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__last_clock</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
        <span class="c"># 初始令牌数为0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__bucket</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">hit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># 非并发安全的实现</span>
        <span class="n">now</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__bucket</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">capacity</span><span class="p">,</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__last_clock</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bucket</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__bucket</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__last_clock</span> <span class="o">=</span> <span class="n">now</span>
            <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<h4 id="4-小结">4. 小结</h4>
<p>无论是最简单的固定窗口， 还是稍微复杂一些的滑动窗口与令牌桶， 都有其适用的场景。 比如固定窗口适合限制具体的接口某个ip的访问次数， 滑动窗口用于记录一段时间内错误次数， 令牌桶用于秒杀场景下的限流。 在一个系统中综合运用这三种算法完全有可能， 只不过可能会根据业务场景的不同而进行稍加变动而已。</p>


	  ]]></description>
	</item>


</channel>
</rss>
