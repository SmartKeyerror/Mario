<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>Python 虚拟机</title>
    <meta name="description" content="Keep coding, Keep curiosity" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />

    <!-- highlight.js -->
<!--    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">-->
<!--    <style>.hljs { background: none; }</style>-->

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="https://smartkeyerror.com//Python-Virtual-Machine" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/page2/" />

    <meta property="og:site_name" content="知其然, 知其所以然" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Python 虚拟机" />
    <meta property="og:description" content="Keep coding, Keep curiosity" />
    <meta property="og:url" content="https://smartkeyerror.com//Python-Virtual-Machine" />
    <meta property="og:image" content="/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Python 虚拟机" />
    <meta name="twitter:description" content="Keep coding, Keep curiosity" />
    <meta name="twitter:url" content="https://smartkeyerror.com//Python-Virtual-Machine" />
    <meta name="twitter:image:src" content="/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "知其然, 知其所以然",
    "name": "Python 虚拟机",
    "url": "https://smartkeyerror.com//Python-Virtual-Machine",
    "image": "/assets/images/cover1.jpg",
    "description": "Keep coding, Keep curiosity"
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="知其然, 知其所以然" href="/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/">Home</a></li>
        <li class="nav-archives " role="presentation"><a href="/archives">Archives</a></li>
        <li class="nav-about " role="presentation"><a href="/about">About</a></li>
    </ul>
<!--    <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>-->
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
            <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">Python 虚拟机</h1>
            <section class="post-meta">
            <!-- <a href='/'></a> -->

            
                
                    <a href='/author/smartkeyerror'>smartkeyerror</a>
                
            
            <time class="post-date" datetime="2020-08-18">18 Aug 2020</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/tag/Python'>Python</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <p>我们常说 Python 一是门解释型语言，只需要敲下 <code class="highlighter-rouge">python code.py</code> 就可以运行编写的代码，而无需使用类似于 <code class="highlighter-rouge">javac</code> 或者 <code class="highlighter-rouge">gcc</code> 进行编译。那么，Python 解释器是真的一行一行读取 Python 源代码而后执行吗? 实际上，Python 在执行程序时和 Java、C# 一样，都是先将源码进行编译生成字节码，然后由虚拟机进行执行，只不过 Python 解释器把这两步合二为一了而已。</p>

<!---more--->

<h3 id="1-python-程序执行过程">1. Python 程序执行过程</h3>

<p>事实上，Python 程序在执行过程中同样需要编译(Compile)，编译产生的结果称之为字节码，而后由 Python 虚拟机逐行地执行这些字节码。所以，Python 解释器由两部分组成: 编译器和虚拟机。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/Process.png" alt="" /></p>

<p>上图展示了 Python 程序的执行过程，以及C程序的编译、汇编与链接过程，从该图中可以非常明显地看出 Python 与 C 程序的执行区别。Python 如此设计的原因在于将程序的执行与底层硬件进一步地分离，无需担心程序的编译、汇编以及链接过程，使得 Python 程序相较于 C 程序而言更加易于移植。</p>

<p>这里再说一下 Python 和 Java 的区别。Java 在程序执行时必须使用 <code class="highlighter-rouge">javac</code> 对源代码进行编译，但是并不直接编译成机器语言，而是和 Python 一样，编译成字节码，而后由 JVM 进行执行。从这一点上来看，Python 和 Java 非常类似，只不过 Python 的编译过程由解释器完成，用户也可以手动的对 Python 源代码进行编译，生成 <code class="highlighter-rouge">.pyc</code> 文件，节省那么一丢丢的时间。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-m</span> compileall &lt;dir&gt;
</code></pre></div></div>

<p>通过运行上述命令可对 <code class="highlighter-rouge">&lt;dir&gt;</code> 目录下所有的Python文件进行编译，编译结果将会存放于该目录下的 <code class="highlighter-rouge">__pycache__</code> 的 <code class="highlighter-rouge">.pyc</code> 文件中。</p>

<h3 id="2-编译过程与字节码">2. 编译过程与字节码</h3>

<p>在Python的内建函数中，定义了 <code class="highlighter-rouge">compile</code> 以及 <code class="highlighter-rouge">exec</code> 两个方法，前者将源代码编译成为 Code Object 对象，Code Object 对象中即保存着源代码所对应的字节。而 <code class="highlighter-rouge">exec</code> 方法则是运行 Python 语句或者是由 <code class="highlighter-rouge">compile</code> 方法所返回的 Code Object。<code class="highlighter-rouge">exec</code> 方法可直接运行 Python 语句，其参数并一定需要是 Code Object。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> snippet <span class="o">=</span> <span class="s2">"for i in range(3): print(f'Output: {i}')"</span>

<span class="o">&gt;&gt;&gt;</span> result <span class="o">=</span> compile<span class="o">(</span>snippet, <span class="s2">""</span>, <span class="s2">"exec"</span><span class="o">)</span>

<span class="o">&gt;&gt;&gt;</span> result
&lt;code object &lt;module&gt; at 0x7f8e7e6471e0, file <span class="s2">""</span>, line 1&gt;

<span class="o">&gt;&gt;&gt;</span> <span class="nb">exec</span><span class="o">(</span>result<span class="o">)</span>
Output: 0
Output: 1
Output: 2
</code></pre></div></div>

<p>在上述代码中定义了一个非常简单的 Python 代码片段，其作用就是在标准输出中打印0，1，2这三个数而已。通过 <code class="highlighter-rouge">compile</code> 方法对该片段进行编译，得到 Code Object 对象，并将该对象交由 <code class="highlighter-rouge">exec</code> 函数执行。下面来具体看下返回的 Code Object 中到底包含了什么。</p>

<p>在源码 <code class="highlighter-rouge">cpython/Include/code.h</code> 中定义了 <code class="highlighter-rouge">PyCodeObject</code> 结构体，即 Code Object 对象:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Bytecode object */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>               <span class="cm">/* Python定长对象头 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_code</span><span class="p">;</span>          <span class="cm">/* 指令操作码，即字节码 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_consts</span><span class="p">;</span>        <span class="cm">/* 常量列表 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_names</span><span class="p">;</span>         <span class="cm">/* 名称列表(不一定是变量，也可能是函数名称、类名称等) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_filename</span><span class="p">;</span>      <span class="cm">/* 源码文件名称 */</span>
    
    <span class="p">...</span>                         <span class="cm">/* 省略若干字段 */</span>
<span class="p">}</span> <span class="n">PyCodeObject</span><span class="p">;</span>
</code></pre></div></div>

<p>字段 <code class="highlighter-rouge">co_code</code> 即为 Python 编译后字节码，其它字段在此处可暂时忽略。字节码的格式为人类不可阅读格式，其形式通常是这样的:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> result.co_code
b<span class="s1">'x\x1ee\x00d\x00\x83\x01D\x00]\x12Z\x01e\x02d\x01e\x01\x9b\x00\x9d\x02\x83\x01\x01\x00q\nW\x00d\x02S\x00'</span>
</code></pre></div></div>

<p>这个时候我们需要一个”反汇编器”来将字节码转换成人类可阅读的格式，”反汇编器”打引号的原因是在 Python 中并不能称为真正的反汇编器。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> import dis
<span class="o">&gt;&gt;&gt;</span> dis.dis<span class="o">(</span>result.co_code<span class="o">)</span>
          0 SETUP_LOOP              30 <span class="o">(</span>to 32<span class="o">)</span>
          2 LOAD_NAME                0 <span class="o">(</span>0<span class="o">)</span>
          4 LOAD_CONST               0 <span class="o">(</span>0<span class="o">)</span>
          6 CALL_FUNCTION            1
          8 GET_ITER
    <span class="o">&gt;&gt;</span>   10 FOR_ITER                18 <span class="o">(</span>to 30<span class="o">)</span>
         12 STORE_NAME               1 <span class="o">(</span>1<span class="o">)</span>
         14 LOAD_NAME                2 <span class="o">(</span>2<span class="o">)</span>
         16 LOAD_CONST               1 <span class="o">(</span>1<span class="o">)</span>
         18 LOAD_NAME                1 <span class="o">(</span>1<span class="o">)</span>
         20 FORMAT_VALUE             0
         22 BUILD_STRING             2
         24 CALL_FUNCTION            1
         26 POP_TOP
         28 JUMP_ABSOLUTE           10
    <span class="o">&gt;&gt;</span>   30 POP_BLOCK
    <span class="o">&gt;&gt;</span>   32 LOAD_CONST               2 <span class="o">(</span>2<span class="o">)</span>
         34 RETURN_VALUE
</code></pre></div></div>

<p><code class="highlighter-rouge">dis</code> 方法将返回字节码的助记符(mnemonics)，和汇编语言非常类似，从这些助记符的名称上我们就可以大概猜出解释器将要执行的动作，例如 <code class="highlighter-rouge">LOAD_NAME</code> 加载名称，<code class="highlighter-rouge">LOAD_CONST</code> 加载常量。所以，我们完全可以将这些助记符看作是汇编指令，而指令的操作数则在助记符后面描述。例如 <code class="highlighter-rouge">LOAD_NAME</code> 操作，其操作数的下标为0，而在源代码中使用过的名称保存在 <code class="highlighter-rouge">co_names</code> 字段中，所以 <code class="highlighter-rouge">LOAD_NAME  0</code> 即表示加载 <code class="highlighter-rouge">result.co_names[0]</code> :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> result.co_names[0]
<span class="s1">'range'</span>
</code></pre></div></div>

<p>又比如 <code class="highlighter-rouge">LOAD_CONST</code> 操作，其操作数的下标也为0，只不过这次操作数不再保存在 <code class="highlighter-rouge">co_names</code> ，而是 <code class="highlighter-rouge">co_consts</code> 中，所以 <code class="highlighter-rouge">LOAD_CONST  0</code> 则表示加载 <code class="highlighter-rouge">result.co_consts[0]</code> :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> result.co_consts[0]
3
</code></pre></div></div>

<p>由于 Code Object 对象保存了常量、变量、名称等一系列的上下文内容，所以可以直接对该对象进行反汇编操作:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> dis.dis<span class="o">(</span>result<span class="o">)</span>
  1           0 SETUP_LOOP              30 <span class="o">(</span>to 32<span class="o">)</span>
              2 LOAD_NAME                0 <span class="o">(</span>range<span class="o">)</span>
              4 LOAD_CONST               0 <span class="o">(</span>3<span class="o">)</span>
              ...
</code></pre></div></div>

<p>现在，我们可以对 Python 字节码做一下小结了。Python 在编译某段源码时，并不会直接返回字节码，而是返回一个 Code Object 对象，字节码则保存在该对象的 <code class="highlighter-rouge">co_code</code> 字段中。由于字节码是一个二进制字节序列，无法直接进行阅读，所以需要通过”反汇编器”(<code class="highlighter-rouge">dis</code> 模块)将字节码转换成人类可读的助记符。助记符的形式和汇编语言非常类似，均由操作指令+操作数所组成。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/compile.png" alt="" /></p>

<h3 id="3-命名空间与作用域">3. 命名空间与作用域</h3>

<p>Python 的命名空间与作用域经常被开发者所忽略，在未深入了解 Python 虚拟机之前，我个人也认为这些东西并不重要。但是，命名空间和变量作用域将会是 Python 虚拟机在执行过程中一个非常重要的一环。</p>

<p>命名空间实际上是名称到对象的一种映射，本质上就是一个键-值对，所以大部分的命名空间由 <code class="highlighter-rouge">dict</code> 实现。命名空间可以分为3类: 内置命名空间，全局命名空间与局部命名空间，在作用域存在嵌套的特殊情况下，可能还会有闭包命名空间。</p>

<h4 id="31-内置命名空间build-in">3.1 内置命名空间(Build-in)</h4>
<p>Python语言内置的名称，例如内置函数名(<code class="highlighter-rouge">len</code>, <code class="highlighter-rouge">dis</code>)，内置异常(<code class="highlighter-rouge">Exception</code>)等。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> import builtins
<span class="o">&gt;&gt;&gt;</span> builtins.__dict__
</code></pre></div></div>

<h4 id="32-全局命名空间global">3.2 全局命名空间(Global)</h4>

<p>全局命名空间以模块进行划分，每一个模块中都包含了 <code class="highlighter-rouge">dict</code> 对象，其中保存了模块中的变量名、类名、函数名等等。在字节码中，全局变量的导入使用 <code class="highlighter-rouge">LOAD_GLOBAL</code> 。</p>

<h4 id="33-局部命名空间local">3.3 局部命名空间(Local)</h4>

<p>局部命名空间可以简单的认为就是函数的命名空间，例如函数参数，在函数中定义的局部变量。</p>

<p>下面是关于局部命名空间和全局命名空间的一个非常典型的例子:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">number</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">number</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">foo</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnboundLocalError: <span class="nb">local </span>variable <span class="s1">'number'</span> referenced before assignment
</code></pre></div></div>

<p>在运行上述代码时将会抛出 <code class="highlighter-rouge">UnboundLocalError</code> 异常，这简直莫名其妙，在其它语言中，上述代码都能够正常运行，以 C 语言为例:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">number</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>  <span class="c1">// 正常运行并打印结果: 20
</span><span class="p">}</span>
</code></pre></div></div>

<p>但是在 Python 中却抛出了异常，这又是为什么? 官方在 <a href="https://docs.python.org/3.8/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python">Python FAQ</a> 给出了相关解释，原文如下:</p>

<blockquote>
  <p>In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a value anywhere within the function’s body, it’s assumed to be a local unless explicitly declared as global.</p>
</blockquote>

<p>简单来说，当我们在函数中引用一个变量时，Python 将隐式地默认该变量为全局变量。但是，一旦变量在没有<code class="highlighter-rouge">global</code>关键字修饰的情况下进行了赋值操作，Python 会将其作为局部变量处理。</p>

<p>而语句 <code class="highlighter-rouge">number += 10</code> 进行了赋值动作，此时 <code class="highlighter-rouge">number</code> 为局部变量，该函数中又没有声明该局部变量，故而抛出异常。Python 这么做的目的就是为了防止开发者者在某些函数中修改了全局变量而又不自知，通过显式地添加 <code class="highlighter-rouge">global</code> 关键字来确保开发者知道自己在做什么。这正如 Python 之禅所述的，Explicit is better than implicit。</p>

<p>首先先来看下正常的局部变量在字节码中是如何处理的:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dis</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 LOAD_CONST               1 <span class="o">(</span>10<span class="o">)</span>
2 STORE_FAST               0 <span class="o">(</span>number<span class="o">)</span>
4 LOAD_GLOBAL              0 <span class="o">(</span>print<span class="o">)</span>
6 LOAD_FAST                0 <span class="o">(</span>number<span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">STORE_FAST</code> 将当前变量压入到函数运行栈中，而 <code class="highlighter-rouge">LOAD_FAST</code> 则从函数运行栈取出该变量。<code class="highlighter-rouge">LOAD_FAST</code> 之前必须存在 <code class="highlighter-rouge">STORE_FAST</code>，否则在运行时将会抛出异常。对于最初的例子而言，在未添加 <code class="highlighter-rouge">global</code> 关键字的情况下，语句 <code class="highlighter-rouge">number += 10</code> 将会直接执行 <code class="highlighter-rouge">LOAD_FAST</code> 指令，而此时当前变量并未压入至当前函数运行栈。</p>

<h4 id="34-闭包命名空间enclosing">3.4 闭包命名空间(Enclosing)</h4>

<p>当出现嵌套函数定义时，或者作用域嵌套时，Python 将会把内层作用域所依赖的所有外层命名存储在一个特殊的命名空间中，也就是闭包命名空间。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">logging</span> <span class="k">as</span> <span class="n">logger</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s">"Execute func: {func.__name__}"</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">foo</code> 闭包函数中，参数 <code class="highlighter-rouge">func</code> 即属于闭包命名空间，内层函数 <code class="highlighter-rouge">wrapper</code> 在寻找变量时，若局部命名空间内无此变量，将会于闭包命名空间中进行查找。</p>

<p>如果在闭包函数中对外层函数的局部变量进行赋值会发生什么?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
        <span class="n">number</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">return</span> <span class="n">bar</span>
</code></pre></div></div>

<p>正如同在局部命名空间中提到的一样，当一个变量在函数中被赋值时，Python 默认将其作为<strong>全局变量</strong>，既不是局部变量，也不是这里提到的闭包空间变量。所以，当我们在实际运行 <code class="highlighter-rouge">bar</code> 方法时，同样会得到 <code class="highlighter-rouge">UnboundLocalError</code> 异常。在这里如果想要使用 <code class="highlighter-rouge">foo</code> 函数中的 <code class="highlighter-rouge">number</code> 变量的话，需要使用 <code class="highlighter-rouge">nonlocal</code> 关键字进行修饰，让 Python 去 <code class="highlighter-rouge">bar</code> 函数的最近外层，也就是 <code class="highlighter-rouge">foo</code> 寻找该变量的定义。</p>

<p>此外，闭包指函数，而不是类，所以在类的嵌套中，将不会存在闭包命名空间:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Reader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">4096</span>

    <span class="k">class</span> <span class="nc">ReaderInternal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span> <span class="o">=</span> <span class="n">BUFFER_SIZE</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="c"># ...</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">Reader</span><span class="o">.</span><span class="n">ReaderInternal</span><span class="p">()</span>
</code></pre></div></div>

<p>在执行 <code class="highlighter-rouge">Reader.ReaderInternal()</code> 语句时，将会抛出 <code class="highlighter-rouge">NameError</code> 的异常，表示 <code class="highlighter-rouge">BUFFER_SIZE</code> 未定义。</p>

<p>当语句需要查找变量 <code class="highlighter-rouge">X</code> 时，将会按照 Local -&gt; Enclosing -&gt; Global -&gt; Builtin 的顺序进行查找，俗称 LEGB 规则。</p>

<h3 id="4-python虚拟机的执行">4. Python虚拟机的执行</h3>

<h4 id="41-执行上下文栈帧">4.1 执行上下文——栈帧</h4>

<p>在 x86-64 CPU 中包含了16个64位的通用目的寄存器，这些寄存器用于存储数据或者是指针。在这16个通用目的寄存器中，有两个较为特殊的寄存器: %rsp 与 %rbp。%rsp 为栈指针寄存器，表示运行时栈的结束位置，可以简单地理解为栈顶。%rbp 为栈帧指针，用于标识当前栈帧的起始位置。</p>

<p>在 x86 体系结构中，函数调用是通过栈和栈帧实现的。当一个函数被调用时，首先做的事情就是将调用者栈帧指针入栈，以保留调用关系。其次将为调用的函数创建栈帧，栈帧中包含了函数的参数、创建的局部变量等信息。</p>

<p>回到Python虚拟机中，虚拟机在进行函数调用时，运行方式和x86没什么区别，都是由栈和栈帧所实现的。而栈帧则是由 <code class="highlighter-rouge">PyFrameObject</code> 表示，于源码 <code class="highlighter-rouge">cpython/Include/frameobject.h</code> 中定义。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_frame</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>           <span class="cm">/* Python固定长度对象头 */</span>
    <span class="k">struct</span> <span class="n">_frame</span> <span class="o">*</span><span class="n">f_back</span><span class="p">;</span>      <span class="cm">/* 指向上一个栈帧的指针 */</span>
    <span class="n">PyCodeObject</span> <span class="o">*</span><span class="n">f_code</span><span class="p">;</span>       <span class="cm">/* Code Object代码对象，其中包含了字节码 */</span>
    
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_builtins</span><span class="p">;</span>       <span class="cm">/* 内建命名空间字典(PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_globals</span><span class="p">;</span>        <span class="cm">/* 全局命名空间字典(PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_locals</span><span class="p">;</span>         <span class="cm">/* 局部命名空间表(通常是数组) */</span>

    <span class="kt">int</span> <span class="n">f_lasti</span><span class="p">;</span>                <span class="cm">/* 上一条指令编号 */</span>
    
    <span class="p">...</span>
<span class="p">}</span> <span class="n">PyFrameObject</span><span class="p">;</span>
</code></pre></div></div>

<p>可以看到，在一个栈帧中包含了Code Object代码对象，三个命名空间表，上一个栈帧指针等信息。可以说，<code class="highlighter-rouge">PyFrameObject</code> 对象包含了Python虚拟机执行所需的全部上下文。在 Python 源码层面，可以通过 <code class="highlighter-rouge">sys</code> 模块中的 <code class="highlighter-rouge">_getframe</code> 方法来获取当前函数运行时的栈帧，方法将返回 <code class="highlighter-rouge">FrameType</code> 类型，其实就是 <code class="highlighter-rouge">PyFrameObject</code> 简化后的 Python 结构。</p>

<p>下面通过一段简单的代码来具体看下 Python 运行时的栈帧结构:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">():</span>
    <span class="n">middle</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">middle</span><span class="p">():</span>
    <span class="n">finish</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">finish</span><span class="p">():</span>
    <span class="n">print_frame</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">print_frame</span><span class="p">():</span>
    <span class="n">current_frame</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">current_frame</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"func name: {current_frame.f_code.co_name}"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"*"</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="n">current_frame</span><span class="o">.</span><span class="n">f_back</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">first</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func name: print_frame
<span class="k">****************************************</span>
func name: finish
<span class="k">****************************************</span>
func name: middle
<span class="k">****************************************</span>
func name: first
<span class="k">****************************************</span>
func name: &lt;module&gt;
<span class="k">****************************************</span>
</code></pre></div></div>

<p>在 Python 开始执行该程序时，首先创建一个用于执行模块代码对象的栈帧对象，也就是 <code class="highlighter-rouge">module</code> 。随着一个一个的函数调用，不同的栈帧对象将会被创建，并且压入至运行栈中，而连接这些栈帧对象的纽带就是 <code class="highlighter-rouge">f_back</code> 指针。当栈顶的函数执行完毕开始返回时，将沿着 <code class="highlighter-rouge">f_back</code> 指针方向一直到当前调用链的起始位置。</p>

<p>结合前面提到的字节码和命名空间，我们可以用一张简图来描述。</p>

<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Python/Interpreter/PyFrameObject.png" alt="" /></p>

<h4 id="42-指令的执行">4.2 指令的执行</h4>

<p>指令执行的源码均位于 <code class="highlighter-rouge">cpython/Python/ceval.c</code> 中，入口函数有两个，一个是 <code class="highlighter-rouge">PyEval_EvalCode</code> ，另一个则是 <code class="highlighter-rouge">PyEval_EvalCodeEx</code> ，最终的实际调用函数为 <code class="highlighter-rouge">_PyEval_EvalCodeWithName</code>，所以我们只需要关注该函数即可。</p>

<p><code class="highlighter-rouge">_PyEval_EvalCodeWithName</code> 函数的主要作用为进行函数调用的例常检查，例如校验函数参数的个数、类型，校验关键字参数等。除此之外，该函数将会初始化栈帧对象并将其交给 <code class="highlighter-rouge">PyEval_EvalFrame</code> 函数进行处理，最终由 <code class="highlighter-rouge">_PyEval_EvalFrameDefault</code> 函数真正的运行指令。</p>

<p><code class="highlighter-rouge">_PyEval_EvalFrameDefault</code> 函数定义超过了3K行，绝大部分的逻辑其实都是 <code class="highlighter-rouge">switch-case</code> : 根据指令类型执行相应的逻辑。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">LOAD_CONST</span><span class="p">):</span> <span class="p">{</span>      <span class="cm">/* 加载常量 */</span>
            <span class="p">...</span>
        <span class="p">}</span>		
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">ROT_TWO</span><span class="p">):</span> <span class="p">{</span>         <span class="cm">/* 交换两个变量 */</span>
            <span class="p">...</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="n">TARGET</span><span class="p">(</span><span class="n">FORMAT_VALUE</span><span class="p">):{</span>     <span class="cm">/* 格式化字符串 */</span>
            <span class="p">...</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>可以看到 <code class="highlighter-rouge">TARGET()</code> 调用中的参数其实就是 <code class="highlighter-rouge">dis</code> 方法返回的助记符，当我们在分析助记符的具体实现逻辑时，可以在该文件中找到对应的 C 实现方法。</p>

<h4 id="43-gil-与字节码的执行">4.3 GIL 与字节码的执行</h4>

<p>对于 Python 中的容器，例如 dict，并没有实现像 Java 中的 <code class="highlighter-rouge">ConcurrentHashMap</code>，或者是 Golang 中的 <code class="highlighter-rouge">sync.Map</code>，这是因为 Python 中的容器(list, dict)本身就是并发安全的，但是在这些容器的源码中并没有发现定义 <code class="highlighter-rouge">mutex</code>，也就是说，Python 容器的并发安全并不是通过互斥锁实现的。</p>

<p>实际上，Python 容器的并发安全是通过 GIL 实现的，也就是被广大 Pythoner 口诛笔伐的全局解释器锁。某一个线程想要运行必须要首先获取全局锁，如此一来，在同一时刻只能有一个线程运行，无法充分利用多核的硬件资源。</p>

<p>Python 的线程调度非常类似于 CPU 的时间片实现，只不过并不是以时间为判断标准，而是以执行字节码的数量作为判断标准。当某一个线程执行了足够多的字节码条数时，当前线程将释放全局锁，唤醒其它线程进行执行。</p>

<p><strong>所以，得益于 GIL 的存在，Python 容器在进行诸如扩容、缩容操作时，完全不必担心并发问题，因为一条字节码的执行一定是原子性的。</strong></p>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
                    
                        <figure class="author-image">
                            <a class="img" href="/author/smartkeyerror" style="background-image: url(/assets/images/author.jpg)"><span class="hidden">smartkeyerror's Picture</span></a>
                        </figure>
                    

                    <section class="author">
                        <h4><a href="/author/smartkeyerror">smartkeyerror</a></h4>

                        
                            <p> 日拱一卒，功不唐捐</p>
                        
                        <div class="author-meta">
                            <span class="author-location icon-location"> China</span>
                            <span class="author-link icon-link"><a href="https://smartkeyerror.com"> https://smartkeyerror.com</a></span>
                        </div>
                    </section>

                    <!-- /author  -->

                    <section class="share">
                        <h4>Share this post</h4>
                        <a class="icon-twitter" href="http://twitter.com/share?text=Python 虚拟机&amp;url=https://smartkeyerror.comPython-Virtual-Machine"
                            onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                            <span class="hidden">Twitter</span>
                        </a>
                        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://smartkeyerror.comPython-Virtual-Machine"
                            onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                            <span class="hidden">Facebook</span>
                        </a>
                        <a class="icon-google-plus" href="https://plus.google.com/share?url=https://smartkeyerror.comPython-Virtual-Machine"
                           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                            <span class="hidden">Google+</span>
                        </a>
                    </section>
                
            

            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>

<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story no-cover" href="/Kubernetes-Informer">
            <section class="post">
                <h2>Kubernetes-Informer</h2>
                <p>Kubernetes 声明式API的核心就在于用户提交的YAML文件表示期望状态，Kubernetes 需要根据该期望状态与集群实际状态进行对比，并根据对比的结果作出相应的操作。期望状态由 APIServer 保存在 Etcd 中，Kubernetes 对资源进行调谐时，是否均需要通过 APIServer 查询 Etcd 来获取期望状态呢?

</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev no-cover" href="/VXLAN">
            <section class="post">
                <h2>VXLAN—构建Overlay容器网络</h2>
                <p>由于 VLAN 实现中的 VLAN ID 仅有12位，只能划分4096个虚拟局域网网段，对于云计算等领域而言，其用户远远不止4096个。并且，VLAN 依赖于交换机等物理设备的实现，一旦升级物理设备，集群网络可能需要重新配置。因此，基于上述的限制，VMware、Cisco 等大型网络企业推出了 VXLAN 解决方案。

</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/">知其然, 知其所以然</a> &copy; 2021</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/10.1.2/styles/monokai-sublime.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="https://cdn.bootcdn.net/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-150652886-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/assets/js/index.js"></script>

</body>
</html>
